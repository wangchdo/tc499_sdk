/**********************************************************************************************************************
 * \file AllowAccess.c
 * \copyright Copyright (C) Infineon Technologies AG 2023
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "Ifx_Types.h"
#include "IfxApApu.h"
#include "IfxCpu_cfg.h"
#include "IfxCpu_reg.h"
#include "IfxAdc_reg.h"
#include "IfxPpuc_reg.h"
#include "IfxGtm_cfg.h"
#include "IfxGtm_reg.h"
#include "IfxEgtm_cfg.h"
#include "IfxEgtm_reg.h"
#include "IfxQspi_cfg.h"
#include "IfxQspi_reg.h"
#include "IfxCan_cfg.h"
#include "IfxCan_reg.h"
#include "IfxAsclin_cfg.h"
#include "IfxAsclin_reg.h"
#include "IfxSent_cfg.h"
#include "IfxSent_reg.h"
#include "IfxGpt12_cfg.h"
#include "IfxGpt12_reg.h"
#include "IfxI2c_cfg.h"
#include "IfxI2c_reg.h"
#include "IfxClock_reg.h"
#include "IfxInt_reg.h"
#include "IfxPort_reg.h"
#include "IfxGeth_cfg.h"
#include "IfxGeth_reg.h"
#include "IfxPms_reg.h"
#include "IfxHsphy_reg.h"

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/

typedef struct
{
    void *module;
    void *startAddr;
    void *endAddr;
} AllowAccess_MemoryRegion;


#define ALLOWACCESS_MASTER_BITS       (0xFFFFFFFFFFFFFFFFULL)
#define ALLOWACCESS_VM_BITS           (uint8)(0xFF)
#define ALLOWACCESS_PRS_BITS          (uint8)(0xFF)

/*********************************************************************************************************************/
/*--------------------------------------------Private Variables/Constants--------------------------------------------*/
/*********************************************************************************************************************/
const IfxApApu_ApuConfig g_apuConfig=
{
   .wraTagId= (uint32)ALLOWACCESS_MASTER_BITS,
   .wrbTagId= (uint32)(ALLOWACCESS_MASTER_BITS >> 32),
   .rdaTagId= (uint32)ALLOWACCESS_MASTER_BITS,
   .rdbTagId= (uint32)(ALLOWACCESS_MASTER_BITS >> 32),
   .vmWrId= ALLOWACCESS_VM_BITS,
   .vmRdId= ALLOWACCESS_VM_BITS,
   .prsWrId= ALLOWACCESS_PRS_BITS,
   .prsRdId= ALLOWACCESS_PRS_BITS
};

const AllowAccess_MemoryRegion g_lmuRegions[]=
{
    {(void *)&MODULE_LMU0, (void *)0xB0300000, (void *)0xB037FFFF},    /**< LMU0 */
    {(void *)&MODULE_LMU1, (void *)0xB0380000, (void *)0xB03FFFFF},    /**< LMU1 */
    {(void *)&MODULE_LMU2, (void *)0xB0400000, (void *)0xB047FFFF},    /**< LMU2 */
    {(void *)&MODULE_LMU3, (void *)0xB0480000, (void *)0xB04FFFFF},    /**< LMU3 */
    {(void *)&MODULE_LMU4, (void *)0xB0500000, (void *)0xB057FFFF},    /**< LMU4 */
    {(void *)&MODULE_LMU5, (void *)0xB0580000, (void *)0xB05FFFFF},    /**< LMU0 */
    {(void *)&MODULE_LMU6, (void *)0xB0600000, (void *)0xB067FFFF},    /**< LMU0 */
    {(void *)&MODULE_LMU7, (void *)0xB0680000, (void *)0xB06FFFFF},    /**< LMU0 */
};

const AllowAccess_MemoryRegion g_dlmuRegions[]=
{
    {(void *)&MODULE_CPU0, (void *)0xB0000000, (void *)0xB007FFFF},    /**< DLMU0 */
    {(void *)&MODULE_CPU1, (void *)0xB0080000, (void *)0xB00FFFFF},    /**< DLMU1 */
    {(void *)&MODULE_CPU2, (void *)0xB0100000, (void *)0xB015FFFF},    /**< DLMU2 */
    {(void *)&MODULE_CPU3, (void *)0xB0160000, (void *)0xB019FFFF},    /**< DLMU3 */
    {(void *)&MODULE_CPU4, (void *)0xB01A0000, (void *)0xB01DFFFF},    /**< DLMU4 */
    {(void *)&MODULE_CPU5, (void *)0xB01E0000, (void *)0xB021FFFF},    /**< DLMU0 */
};

const AllowAccess_MemoryRegion g_dsprRegions[]=
{
    {(void *)&MODULE_CPU0, (void *)0x70000000, (void *)0x7003BFFF},    /**< DSPR0 */
    {(void *)&MODULE_CPU1, (void *)0x60000000, (void *)0x6003BFFF},    /**< DSPR1 */
    {(void *)&MODULE_CPU2, (void *)0x50000000, (void *)0x5003BFFF},    /**< DSPR2 */
    {(void *)&MODULE_CPU3, (void *)0x40000000, (void *)0x4001BFFF},    /**< DSPR3 */
    {(void *)&MODULE_CPU4, (void *)0x30000000, (void *)0x3001BFFF},    /**< DSPR4 */
    {(void *)&MODULE_CPU5, (void *)0x20000000, (void *)0x2001BFFF},    /**< DSPR5 */
};

const AllowAccess_MemoryRegion g_psprRegions[]=
{
    {(void *)&MODULE_CPU0, (void *)0x70100000, (void *)0x7010FFFF},    /**< PSPR0 */
    {(void *)&MODULE_CPU1, (void *)0x60100000, (void *)0x6010FFFF},    /**< PSPR1 */
    {(void *)&MODULE_CPU2, (void *)0x50100000, (void *)0x5010FFFF},    /**< PSPR2 */
    {(void *)&MODULE_CPU3, (void *)0x40100000, (void *)0x4010FFFF},    /**< PSPR3 */
    {(void *)&MODULE_CPU4, (void *)0x30100000, (void *)0x3010FFFF},    /**< PSPR4 */
    {(void *)&MODULE_CPU5, (void *)0x20100000, (void *)0x2010FFFF},    /**< PSPR5 */
};

static boolean accessGranted= FALSE;

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
static void allowAccessToLmus(void)
{
    uint8 region;
    IfxApApu_ApuMemoryConfig memConfig;
    memConfig.apuConfig= (IfxApApu_ApuConfig *)&g_apuConfig;
    for(region= 0; region < sizeof(g_lmuRegions)/sizeof(AllowAccess_MemoryRegion); region++)
    {
        memConfig.rgnlaVal= (uint32)g_lmuRegions[region].startAddr & 0xDFFFFFC0U;
        memConfig.rgnuaVal= (uint32)g_lmuRegions[region].endAddr & 0xDFFFFFC0U;

        IfxApApu_configMemoryAccess((Ifx_ACCEN_ACCEN *)&((Ifx_LMU*)g_lmuRegions[region].module)->ACCENCFG,
                &memConfig,
                (Ifx_PROT_PROT *)&((Ifx_LMU*)g_lmuRegions[region].module)->PROTRGN,
                0);
    }
}

static void allowAccessToDlmus(void)
{
    uint8 region;
    IfxApApu_ApuMemoryConfig memConfig;
    memConfig.apuConfig= (IfxApApu_ApuConfig *)&g_apuConfig;
    for(region= 0; region < sizeof(g_dlmuRegions)/sizeof(AllowAccess_MemoryRegion); region++)
    {
        memConfig.rgnlaVal= (uint32)g_dlmuRegions[region].startAddr & 0xDFFFFFC0U;
        memConfig.rgnuaVal= (uint32)g_dlmuRegions[region].endAddr & 0xDFFFFFC0U;

        IfxApApu_configMemoryAccess((Ifx_ACCEN_ACCEN *)&((Ifx_CPU*)g_dlmuRegions[region].module)->ACCENDLMUCFG,
                &memConfig,
                (Ifx_PROT_PROT *)&((Ifx_CPU*)g_dlmuRegions[region].module)->PROTDLMUSE,
                0);
    }
}


static void allowAccessToDsprs(void)
{
    uint8 region;
    IfxApApu_ApuMemoryConfig memConfig;
    memConfig.apuConfig= (IfxApApu_ApuConfig *)&g_apuConfig;
    for(region= 0; region < sizeof(g_dsprRegions)/sizeof(AllowAccess_MemoryRegion); region++)
    {
        memConfig.rgnlaVal= (uint32)g_dsprRegions[region].startAddr & 0xFFFFFFC0U;
        memConfig.rgnuaVal= (uint32)g_dsprRegions[region].endAddr & 0xFFFFFFC0U;

        IfxApApu_configMemoryAccess((Ifx_ACCEN_ACCEN *)&((Ifx_CPU*)g_dsprRegions[region].module)->ACCENSPRCFG,
                &memConfig,
                (Ifx_PROT_PROT *)&((Ifx_CPU*)g_dsprRegions[region].module)->PROTSPRSE,
                0);
    }
}

static void allowAccessToPsprs(void)
{
    uint8 region;
    IfxApApu_ApuMemoryConfig memConfig;
    memConfig.apuConfig= (IfxApApu_ApuConfig *)&g_apuConfig;
    for(region= 0; region < sizeof(g_psprRegions)/sizeof(AllowAccess_MemoryRegion); region++)
    {
        memConfig.rgnlaVal= (uint32)g_psprRegions[region].startAddr & 0xFFFFFFC0U;
        memConfig.rgnuaVal= (uint32)g_psprRegions[region].endAddr & 0xFFFFFFC0U;

        IfxApApu_configMemoryAccess((Ifx_ACCEN_ACCEN *)&((Ifx_CPU*)g_psprRegions[region].module)->ACCENSPRCFG,
                &memConfig,
                (Ifx_PROT_PROT *)&((Ifx_CPU*)g_psprRegions[region].module)->PROTSPRSE,
                1);
    }
}

static void allowAccessToCpus(void)
{
    uint32 index;

    for(index= 0; index < IFXCPU_NUM_MODULES; index++)
    {
        uint32 vm;
        Ifx_CPU *cpu= (Ifx_CPU *)(((uint32)&MODULE_CPU0) + index * ((uint32)&MODULE_CPU1 - (uint32)&MODULE_CPU0));
        IfxApApu_init((Ifx_ACCEN_ACCEN *)&cpu->ACCENSFRCFG,    (IfxApApu_ApuConfig *)&g_apuConfig);

        /*configure STM access*/
        for(vm= 0; vm < 8; vm++)
        {
            cpu->PROTSTMSE.B.SEL= vm;
            IfxApApu_init((Ifx_ACCEN_ACCEN *)&cpu->ACCENSTMCFG,    (IfxApApu_ApuConfig *)&g_apuConfig);
        }
    }
}

static void allowAccessToAdcs(void)
{
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&MODULE_ADC.ACCEN[0], (IfxApApu_ApuConfig *)&g_apuConfig);       /*The reset values of RESALLOC_XXX registers are 0, hence ACCEN0 controls all resources */
}

static void allowAccessToPpu(void)
{
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&MODULE_PPUC.SFR.ACCEN, (IfxApApu_ApuConfig *)&g_apuConfig);
}

static void allowAccessToGtms(void)
{
    uint8 cluster;
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&MODULE_GTM.CTRL.ACCEN, (IfxApApu_ApuConfig *)&g_apuConfig);

    for(cluster= 0; cluster < IFXGTM_NUM_CCM_OBJECTS; cluster++)
    {
        IfxApApu_init((Ifx_ACCEN_ACCEN *)&MODULE_GTM.CL[cluster].ACCEN, (IfxApApu_ApuConfig *)&g_apuConfig);
    }
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&MODULE_GTM.WRAP.ACCEN, (IfxApApu_ApuConfig *)&g_apuConfig);
}

static void allowAccessToEgtms(void)
{
    uint8 cluster;
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&MODULE_EGTM.CTRL.ACCEN, (IfxApApu_ApuConfig *)&g_apuConfig);
    for(cluster= 0; cluster < IFXEGTM_NUM_CCM_OBJECTS; cluster++)
    {
        IfxApApu_init((Ifx_ACCEN_ACCEN *)&MODULE_EGTM.CL[cluster].ACCEN, (IfxApApu_ApuConfig *)&g_apuConfig);
    }
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&MODULE_EGTM.WRAP.ACCEN, (IfxApApu_ApuConfig *)&g_apuConfig);
}

static void allowAccessToQspis(void)
{
    uint8 index;
    for(index= 0; index < IFXQSPI_NUM_MODULES; index++)
    {
        Ifx_QSPI *qspi= (Ifx_QSPI *)(((uint32)&MODULE_QSPI0) + index * ((uint32)&MODULE_QSPI1 - (uint32)&MODULE_QSPI0));
        IfxApApu_init((Ifx_ACCEN_ACCEN *)&qspi->ACCEN, (IfxApApu_ApuConfig *)&g_apuConfig);
    }
}

static void allowAccessToCans(void)
{
    uint8 index;
    for(index= 0; index < IFXCAN_NUM_MODULES; index++)
    {
        uint8 node;
        Ifx_CAN *can= (Ifx_CAN *)(((uint32)&MODULE_CAN0) + index * ((uint32)&MODULE_CAN1 - (uint32)&MODULE_CAN0));
        IfxApApu_init((Ifx_ACCEN_ACCEN *)&can->ACCEN, (IfxApApu_ApuConfig *)&g_apuConfig);
        for(node= 0; node < IFXCAN_NUM_NODES; node++)
        {
            IfxApApu_init((Ifx_ACCEN_ACCEN *)&can->N[node].ACCEN, (IfxApApu_ApuConfig *)&g_apuConfig);
        }
    }
}

static void allowAccessToAsclins(void)
{
    uint8 index;
    for(index= 0; index < 28; index++)
    {
        Ifx_ASCLIN *asclin= (Ifx_ASCLIN *)(((uint32)&MODULE_ASCLIN0) + index * ((uint32)&MODULE_ASCLIN1 - (uint32)&MODULE_ASCLIN0));
        IfxApApu_init((Ifx_ACCEN_ACCEN *)&asclin->ACCEN, (IfxApApu_ApuConfig *)&g_apuConfig);
    }
}

static void allowAccessToSents(void)
{
    uint8 index;
    for(index= 0; index < IFXSENT_NUM_MODULES; index++)
    {
        Ifx_SENT *sent= (Ifx_SENT *)(((uint32)&MODULE_SENT0) + index * ((uint32)&MODULE_SENT1 - (uint32)&MODULE_SENT0));
        IfxApApu_init((Ifx_ACCEN_ACCEN *)&sent->ACCEN, (IfxApApu_ApuConfig *)&g_apuConfig);
    }
}

static void allowAccessToGpt12(void)
{
    uint8 index;
    for(index= 0; index < IFXGPT12_NUM_MODULES; index++)
    {
        Ifx_GPT12 *gpt12= (Ifx_GPT12 *)(((uint32)&MODULE_GPT120) + index * ((uint32)&MODULE_GPT121 - (uint32)&MODULE_GPT120));
        IfxApApu_init((Ifx_ACCEN_ACCEN *)&gpt12->ACCEN, (IfxApApu_ApuConfig *)&g_apuConfig);
    }
}

static void allowAccessToI2cs(void)
{
    uint8 index;
    for(index= 0; index < IFXI2C_NUM_MODULES; index++)
    {
        Ifx_I2C *i2c= (Ifx_I2C *)(((uint32)&MODULE_I2C0) + index * ((uint32)&MODULE_I2C1 - (uint32)&MODULE_I2C0));
        IfxApApu_init((Ifx_ACCEN_ACCEN *)&i2c->ACCEN, (IfxApApu_ApuConfig *)&g_apuConfig);
    }
}

static void allowAccessToClock(void)
{
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&MODULE_CLOCK.ACCEN, (IfxApApu_ApuConfig *)&g_apuConfig);
}

static void allowAccessToInterrupts(void)
{
    uint8 tos;

    /* Allow Service Request register access register access for CPUx targeted SRNs (TOS=x) */
    for(tos= 0; tos < 10; tos++)
    {
        IfxApApu_init((Ifx_ACCEN_ACCEN *)&MODULE_INT.TOS[tos].ACCENSCTRL, (IfxApApu_ApuConfig *)&g_apuConfig);
        IfxApApu_init((Ifx_ACCEN_ACCEN *)&MODULE_INT.TOS[tos].ACCENSCFG, (IfxApApu_ApuConfig *)&g_apuConfig);
    }
}

static void allowAccessToPins(void)
{
    /* By default the access protection group selected is 0 (PADCFG.ACCEN.B.GRP= 0) for all ports*/
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&MODULE_P00.ACCGRP[0], (IfxApApu_ApuConfig *)&g_apuConfig);  //Configure the APU group 0
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&MODULE_P01.ACCGRP[0], (IfxApApu_ApuConfig *)&g_apuConfig);  //Configure the APU group 0
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&MODULE_P02.ACCGRP[0], (IfxApApu_ApuConfig *)&g_apuConfig);  //Configure the APU group 0
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&MODULE_P03.ACCGRP[0], (IfxApApu_ApuConfig *)&g_apuConfig);  //Configure the APU group 0
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&MODULE_P10.ACCGRP[0], (IfxApApu_ApuConfig *)&g_apuConfig);  //Configure the APU group 0
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&MODULE_P11.ACCGRP[0], (IfxApApu_ApuConfig *)&g_apuConfig);  //Configure the APU group 0
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&MODULE_P12.ACCGRP[0], (IfxApApu_ApuConfig *)&g_apuConfig);  //Configure the APU group 0
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&MODULE_P13.ACCGRP[0], (IfxApApu_ApuConfig *)&g_apuConfig);  //Configure the APU group 0
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&MODULE_P14.ACCGRP[0], (IfxApApu_ApuConfig *)&g_apuConfig);  //Configure the APU group 0
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&MODULE_P15.ACCGRP[0], (IfxApApu_ApuConfig *)&g_apuConfig);  //Configure the APU group 0
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&MODULE_P16.ACCGRP[0], (IfxApApu_ApuConfig *)&g_apuConfig);  //Configure the APU group 0
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&MODULE_P17.ACCGRP[0], (IfxApApu_ApuConfig *)&g_apuConfig);  //Configure the APU group 0
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&MODULE_P20.ACCGRP[0], (IfxApApu_ApuConfig *)&g_apuConfig);  //Configure the APU group 0
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&MODULE_P21.ACCGRP[0], (IfxApApu_ApuConfig *)&g_apuConfig);  //Configure the APU group 0
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&MODULE_P22.ACCGRP[0], (IfxApApu_ApuConfig *)&g_apuConfig);  //Configure the APU group 0
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&MODULE_P23.ACCGRP[0], (IfxApApu_ApuConfig *)&g_apuConfig);  //Configure the APU group 0
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&MODULE_P24.ACCGRP[0], (IfxApApu_ApuConfig *)&g_apuConfig);  //Configure the APU group 0
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&MODULE_P25.ACCGRP[0], (IfxApApu_ApuConfig *)&g_apuConfig);  //Configure the APU group 0
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&MODULE_P26.ACCGRP[0], (IfxApApu_ApuConfig *)&g_apuConfig);  //Configure the APU group 0
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&MODULE_P30.ACCGRP[0], (IfxApApu_ApuConfig *)&g_apuConfig);  //Configure the APU group 0
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&MODULE_P31.ACCGRP[0], (IfxApApu_ApuConfig *)&g_apuConfig);  //Configure the APU group 0
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&MODULE_P32.ACCGRP[0], (IfxApApu_ApuConfig *)&g_apuConfig);  //Configure the APU group 0
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&MODULE_P33.ACCGRP[0], (IfxApApu_ApuConfig *)&g_apuConfig);  //Configure the APU group 0
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&MODULE_P34.ACCGRP[0], (IfxApApu_ApuConfig *)&g_apuConfig);  //Configure the APU group 0
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&MODULE_P40.ACCGRP[0], (IfxApApu_ApuConfig *)&g_apuConfig);  //Configure the APU group 0
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&MODULE_P41.ACCGRP[0], (IfxApApu_ApuConfig *)&g_apuConfig);  //Configure the APU group 0A
}

static void allowAccessToGeth(void)
{
    int i;
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&MODULE_GETH0.ACCENGLOBAL, (IfxApApu_ApuConfig *)&g_apuConfig);

    for(i= 0; i < IFXGETH_NUM_TX_CHANNELS; i++)
    {
        IfxApApu_init((Ifx_ACCEN_ACCEN *)&MODULE_GETH0.ACCENCH[i], (IfxApApu_ApuConfig *)&g_apuConfig);
    }

    IfxApApu_init((Ifx_ACCEN_ACCEN *)&MODULE_GETH0.ACCENMAC[0], (IfxApApu_ApuConfig *)&g_apuConfig);
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&MODULE_GETH0.ACCENMAC[1], (IfxApApu_ApuConfig *)&g_apuConfig);
}

static void allowAccessToPms(void)
{
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&MODULE_PMS.ACCEN,     (IfxApApu_ApuConfig *)&g_apuConfig);
}

static void allowAccessToHsphy(void)
{
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&MODULE_HSPHY.ACCENGLB,     (IfxApApu_ApuConfig *)&g_apuConfig);
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&MODULE_HSPHY.ACCENCH[0],     (IfxApApu_ApuConfig *)&g_apuConfig);
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&MODULE_HSPHY.ACCENCH[1],     (IfxApApu_ApuConfig *)&g_apuConfig);
}

void allowAccess(void)
{
    allowAccessToLmus();
    allowAccessToDlmus();
    allowAccessToDsprs();
    allowAccessToPsprs();
    allowAccessToCpus();
    allowAccessToAdcs();
    allowAccessToPpu();
    allowAccessToGtms();
    allowAccessToEgtms();
    allowAccessToQspis();
    allowAccessToCans();
    allowAccessToAsclins();
    allowAccessToSents();
    allowAccessToGpt12();
    allowAccessToI2cs();
    allowAccessToClock();
    allowAccessToInterrupts();
    allowAccessToPins();
    allowAccessToGeth();
    allowAccessToPms();
    allowAccessToHsphy();
    accessGranted= TRUE;
}

boolean isAccessGranted(void)
{
    return accessGranted;
}
