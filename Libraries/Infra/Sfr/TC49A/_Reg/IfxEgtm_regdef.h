/**
 * \file IfxEgtm_regdef.h
 * \brief
 * \copyright Copyright (c) 2022 Infineon Technologies AG. All rights reserved.
 *
 *
 * Version: MC_ACE_A3G_HSI_EGTM/V0.1.1.3.16
 * Specification: latest @ 2022-03-03 instance sheet @ MC_A3G_TC49x : V9.1.7.1.0 
 * MAY BE CHANGED BY USER [yes/no]: No
 *
 *                                 IMPORTANT NOTICE
 *
 *
 * Use of this file is subject to the terms of use agreed between (i) you or 
 * the company in which ordinary course of business you are acting and (ii) 
 * Infineon Technologies AG or its licensees. If and as long as no such 
 * terms of use are agreed, use of this file is subject to following:


 * Boost Software License - Version 1.0 - August 17th, 2003

 * Permission is hereby granted, free of charge, to any person or 
 * organization obtaining a copy of the software and accompanying 
 * documentation covered by this license (the "Software") to use, reproduce,
 * display, distribute, execute, and transmit the Software, and to prepare
 * derivative works of the Software, and to permit third-parties to whom the 
 * Software is furnished to do so, all subject to the following:

 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE 
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * \defgroup IfxSfr_Egtm_Registers Egtm Registers
 * \ingroup IfxSfr
 * 
 * \defgroup IfxSfr_Egtm_Registers_Bitfields Bitfields
 * \ingroup IfxSfr_Egtm_Registers
 * 
 * \defgroup IfxSfr_Egtm_Registers_union Register unions
 * \ingroup IfxSfr_Egtm_Registers
 * 
 * \defgroup IfxSfr_Egtm_Registers_struct Memory map
 * \ingroup IfxSfr_Egtm_Registers
 */
#ifndef IFXEGTM_REGDEF_H
#define IFXEGTM_REGDEF_H 1
/******************************************************************************/
#include "Ifx_TypesReg.h"
/******************************************************************************/

/******************************************************************************/

/******************************************************************************/

/******************************************************************************/
#if defined (__TASKING__)
#pragma warning 586
#endif
/******************************************************************************/

/** \addtogroup IfxSfr_Egtm_Registers_Bitfields
 * \{  */
/** \brief PRS access enable register */
typedef struct _Ifx_EGTM_ACCEN_PRS_Bits
{
    __IO Ifx_UReg_32Bit RD00:1;            /**< \brief [0:0] Read access enable for PRS q (rw) */
    __IO Ifx_UReg_32Bit RD01:1;            /**< \brief [1:1] Read access enable for PRS q (rw) */
    __IO Ifx_UReg_32Bit RD02:1;            /**< \brief [2:2] Read access enable for PRS q (rw) */
    __IO Ifx_UReg_32Bit RD03:1;            /**< \brief [3:3] Read access enable for PRS q (rw) */
    __IO Ifx_UReg_32Bit RD04:1;            /**< \brief [4:4] Read access enable for PRS q (rw) */
    __IO Ifx_UReg_32Bit RD05:1;            /**< \brief [5:5] Read access enable for PRS q (rw) */
    __IO Ifx_UReg_32Bit RD06:1;            /**< \brief [6:6] Read access enable for PRS q (rw) */
    __IO Ifx_UReg_32Bit RD07:1;            /**< \brief [7:7] Read access enable for PRS q (rw) */
    __I  Ifx_UReg_32Bit :8;                /**< \brief [15:8] \internal Reserved */
    __IO Ifx_UReg_32Bit WR00:1;            /**< \brief [16:16] Write access enable for PRS q (rw) */
    __IO Ifx_UReg_32Bit WR01:1;            /**< \brief [17:17] Write access enable for PRS q (rw) */
    __IO Ifx_UReg_32Bit WR02:1;            /**< \brief [18:18] Write access enable for PRS q (rw) */
    __IO Ifx_UReg_32Bit WR03:1;            /**< \brief [19:19] Write access enable for PRS q (rw) */
    __IO Ifx_UReg_32Bit WR04:1;            /**< \brief [20:20] Write access enable for PRS q (rw) */
    __IO Ifx_UReg_32Bit WR05:1;            /**< \brief [21:21] Write access enable for PRS q (rw) */
    __IO Ifx_UReg_32Bit WR06:1;            /**< \brief [22:22] Write access enable for PRS q (rw) */
    __IO Ifx_UReg_32Bit WR07:1;            /**< \brief [23:23] Write access enable for PRS q (rw) */
    __I  Ifx_UReg_32Bit :8;                /**< \brief [31:24] \internal Reserved */
} Ifx_EGTM_ACCEN_PRS_Bits;

/** \brief Read access enable register A */
typedef struct _Ifx_EGTM_ACCEN_RDA_Bits
{
    __IO Ifx_UReg_32Bit EN00:1;            /**< \brief [0:0] Read access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN01:1;            /**< \brief [1:1] Read access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN02:1;            /**< \brief [2:2] Read access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN03:1;            /**< \brief [3:3] Read access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN04:1;            /**< \brief [4:4] Read access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN05:1;            /**< \brief [5:5] Read access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN06:1;            /**< \brief [6:6] Read access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN07:1;            /**< \brief [7:7] Read access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN08:1;            /**< \brief [8:8] Read access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN09:1;            /**< \brief [9:9] Read access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN10:1;            /**< \brief [10:10] Read access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN11:1;            /**< \brief [11:11] Read access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN12:1;            /**< \brief [12:12] Read access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN13:1;            /**< \brief [13:13] Read access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN14:1;            /**< \brief [14:14] Read access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN15:1;            /**< \brief [15:15] Read access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN16:1;            /**< \brief [16:16] Read access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN17:1;            /**< \brief [17:17] Read access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN18:1;            /**< \brief [18:18] Read access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN19:1;            /**< \brief [19:19] Read access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN20:1;            /**< \brief [20:20] Read access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN21:1;            /**< \brief [21:21] Read access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN22:1;            /**< \brief [22:22] Read access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN23:1;            /**< \brief [23:23] Read access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN24:1;            /**< \brief [24:24] Read access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN25:1;            /**< \brief [25:25] Read access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN26:1;            /**< \brief [26:26] Read access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN27:1;            /**< \brief [27:27] Read access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN28:1;            /**< \brief [28:28] Read access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN29:1;            /**< \brief [29:29] Read access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN30:1;            /**< \brief [30:30] Read access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN31:1;            /**< \brief [31:31] Read access enable for Master TAG ID q - ENq (rw) */
} Ifx_EGTM_ACCEN_RDA_Bits;

/** \brief Read access enable register B */
typedef struct _Ifx_EGTM_ACCEN_RDB_FPI_Bits
{
    __IO Ifx_UReg_32Bit EN32:1;            /**< \brief [0:0] Read access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN33:1;            /**< \brief [1:1] Read access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN34:1;            /**< \brief [2:2] Read access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN35:1;            /**< \brief [3:3] Read access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN36:1;            /**< \brief [4:4] Read access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN37:1;            /**< \brief [5:5] Read access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN38:1;            /**< \brief [6:6] Read access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN39:1;            /**< \brief [7:7] Read access enable for Master TAG ID q - ENq (rw) */
    __I  Ifx_UReg_32Bit :24;               /**< \brief [31:8] \internal Reserved */
} Ifx_EGTM_ACCEN_RDB_FPI_Bits;

/** \brief VM access enable register */
typedef struct _Ifx_EGTM_ACCEN_VM_Bits
{
    __IO Ifx_UReg_32Bit RD00:1;            /**< \brief [0:0] Read access enable for VM ID q (rw) */
    __IO Ifx_UReg_32Bit RD01:1;            /**< \brief [1:1] Read access enable for VM ID q (rw) */
    __IO Ifx_UReg_32Bit RD02:1;            /**< \brief [2:2] Read access enable for VM ID q (rw) */
    __IO Ifx_UReg_32Bit RD03:1;            /**< \brief [3:3] Read access enable for VM ID q (rw) */
    __IO Ifx_UReg_32Bit RD04:1;            /**< \brief [4:4] Read access enable for VM ID q (rw) */
    __IO Ifx_UReg_32Bit RD05:1;            /**< \brief [5:5] Read access enable for VM ID q (rw) */
    __IO Ifx_UReg_32Bit RD06:1;            /**< \brief [6:6] Read access enable for VM ID q (rw) */
    __IO Ifx_UReg_32Bit RD07:1;            /**< \brief [7:7] Read access enable for VM ID q (rw) */
    __I  Ifx_UReg_32Bit :8;                /**< \brief [15:8] \internal Reserved */
    __IO Ifx_UReg_32Bit WR00:1;            /**< \brief [16:16] Write access enable for VM ID q (rw) */
    __IO Ifx_UReg_32Bit WR01:1;            /**< \brief [17:17] Write access enable for VM ID q (rw) */
    __IO Ifx_UReg_32Bit WR02:1;            /**< \brief [18:18] Write access enable for VM ID q (rw) */
    __IO Ifx_UReg_32Bit WR03:1;            /**< \brief [19:19] Write access enable for VM ID q (rw) */
    __IO Ifx_UReg_32Bit WR04:1;            /**< \brief [20:20] Write access enable for VM ID q (rw) */
    __IO Ifx_UReg_32Bit WR05:1;            /**< \brief [21:21] Write access enable for VM ID q (rw) */
    __IO Ifx_UReg_32Bit WR06:1;            /**< \brief [22:22] Write access enable for VM ID q (rw) */
    __IO Ifx_UReg_32Bit WR07:1;            /**< \brief [23:23] Write access enable for VM ID q (rw) */
    __I  Ifx_UReg_32Bit :8;                /**< \brief [31:24] \internal Reserved */
} Ifx_EGTM_ACCEN_VM_Bits;

/** \brief Write access enable register A */
typedef struct _Ifx_EGTM_ACCEN_WRA_Bits
{
    __IO Ifx_UReg_32Bit EN00:1;            /**< \brief [0:0] Write access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN01:1;            /**< \brief [1:1] Write access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN02:1;            /**< \brief [2:2] Write access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN03:1;            /**< \brief [3:3] Write access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN04:1;            /**< \brief [4:4] Write access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN05:1;            /**< \brief [5:5] Write access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN06:1;            /**< \brief [6:6] Write access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN07:1;            /**< \brief [7:7] Write access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN08:1;            /**< \brief [8:8] Write access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN09:1;            /**< \brief [9:9] Write access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN10:1;            /**< \brief [10:10] Write access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN11:1;            /**< \brief [11:11] Write access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN12:1;            /**< \brief [12:12] Write access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN13:1;            /**< \brief [13:13] Write access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN14:1;            /**< \brief [14:14] Write access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN15:1;            /**< \brief [15:15] Write access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN16:1;            /**< \brief [16:16] Write access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN17:1;            /**< \brief [17:17] Write access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN18:1;            /**< \brief [18:18] Write access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN19:1;            /**< \brief [19:19] Write access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN20:1;            /**< \brief [20:20] Write access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN21:1;            /**< \brief [21:21] Write access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN22:1;            /**< \brief [22:22] Write access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN23:1;            /**< \brief [23:23] Write access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN24:1;            /**< \brief [24:24] Write access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN25:1;            /**< \brief [25:25] Write access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN26:1;            /**< \brief [26:26] Write access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN27:1;            /**< \brief [27:27] Write access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN28:1;            /**< \brief [28:28] Write access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN29:1;            /**< \brief [29:29] Write access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN30:1;            /**< \brief [30:30] Write access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN31:1;            /**< \brief [31:31] Write access enable for Master TAG ID q - ENq (rw) */
} Ifx_EGTM_ACCEN_WRA_Bits;

/** \brief Write access enable register B */
typedef struct _Ifx_EGTM_ACCEN_WRB_FPI_Bits
{
    __IO Ifx_UReg_32Bit EN32:1;            /**< \brief [0:0] Write access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN33:1;            /**< \brief [1:1] Write access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN34:1;            /**< \brief [2:2] Write access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN35:1;            /**< \brief [3:3] Write access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN36:1;            /**< \brief [4:4] Write access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN37:1;            /**< \brief [5:5] Write access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN38:1;            /**< \brief [6:6] Write access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN39:1;            /**< \brief [7:7] Write access enable for Master TAG ID q - ENq (rw) */
    __I  Ifx_UReg_32Bit :24;               /**< \brief [31:8] \internal Reserved */
} Ifx_EGTM_ACCEN_WRB_FPI_Bits;

/** \brief eGTM to ADC output selection register 0 */
typedef struct _Ifx_EGTM_ADC_OUT_Bits
{
    __IO Ifx_UReg_32Bit SEL0:5;            /**< \brief [4:0] eGTM to ADC trigger 0 output selection (rw) */
    __I  Ifx_UReg_32Bit :3;                /**< \brief [7:5] \internal Reserved */
    __IO Ifx_UReg_32Bit SEL1:5;            /**< \brief [12:8] eGTM to ADC trigger 1 output selection (rw) */
    __I  Ifx_UReg_32Bit :3;                /**< \brief [15:13] \internal Reserved */
    __IO Ifx_UReg_32Bit SEL2:5;            /**< \brief [20:16] eGTM to ADC trigger 2 output selection (rw) */
    __I  Ifx_UReg_32Bit :3;                /**< \brief [23:21] \internal Reserved */
    __IO Ifx_UReg_32Bit SEL3:5;            /**< \brief [28:24] eGTM to ADC trigger 3 output selection (rw) */
    __I  Ifx_UReg_32Bit :3;                /**< \brief [31:29] \internal Reserved */
} Ifx_EGTM_ADC_OUT_Bits;

/** \brief eGTM to ASCLIN0 output selection register */
typedef struct _Ifx_EGTM_ASCLIN_OUT_Bits
{
    __IO Ifx_UReg_32Bit SEL:5;             /**< \brief [4:0] eGTM to ASCLIN0 trigger output selection (rw) */
    __I  Ifx_UReg_32Bit :27;               /**< \brief [31:5] \internal Reserved */
} Ifx_EGTM_ASCLIN_OUT_Bits;

/** \brief eGTM to CAN0 output selection register 0 */
typedef struct _Ifx_EGTM_CAN_OUT_Bits
{
    __IO Ifx_UReg_32Bit SEL:4;             /**< \brief [3:0] eGTM to CAN0 trigger 0 output selection (rw) */
    __I  Ifx_UReg_32Bit :28;               /**< \brief [31:4] \internal Reserved */
} Ifx_EGTM_CAN_OUT_Bits;

/** \brief Clock control register */
typedef struct _Ifx_EGTM_CLC_Bits
{
    __IO Ifx_UReg_32Bit DISR:1;            /**< \brief [0:0] Module Disable Request Bit - DISR (rw) */
    __I  Ifx_UReg_32Bit DISS:1;            /**< \brief [1:1] Module Disable Status Bit - DISS (rh) */
    __I  Ifx_UReg_32Bit :1;                /**< \brief [2:2] \internal Reserved */
    __IO Ifx_UReg_32Bit EDIS:1;            /**< \brief [3:3] Sleep Mode Enable Control - EDIS (rw) */
    __I  Ifx_UReg_32Bit :28;               /**< \brief [31:4] \internal Reserved */
} Ifx_EGTM_CLC_Bits;

/** \brief BRIDGE_MODE */
typedef struct _Ifx_EGTM_CLS_AEI_BRIDGE_MODE_Bits
{
    __IO Ifx_Strict_32Bit BRG_MODE:1;      /**< \brief [0:0] Defines the operation mode for the AEI bridge (rw) */
    __IO Ifx_Strict_32Bit MSK_WR_RSP:1;    /**< \brief [1:1] Mask write response (rw) */
    __IO Ifx_Strict_32Bit BYPASS_SYNC:1;    /**< \brief [2:2] Bypass synchronizer flip-flops (rw) */
    __I  Ifx_Strict_32Bit :5;              /**< \brief [7:3] \internal Reserved */
    __I  Ifx_Strict_32Bit MODE_UP_PGR:1;    /**< \brief [8:8] Mode update in progress. (r) */
    __IO Ifx_Strict_32Bit BUFF_OVL:1;      /**< \brief [9:9] Buffer overflow register (rw1ch) */
    __I  Ifx_Strict_32Bit :2;              /**< \brief [11:10] \internal Reserved */
    __I  Ifx_Strict_32Bit SYNC_INPUT_REG:1;    /**< \brief [12:12] Additional pipelined stage in synchronous bridge mode (r) */
    __I  Ifx_Strict_32Bit :3;              /**< \brief [15:13] \internal Reserved */
    __IO Ifx_Strict_32Bit BRG_RST:1;       /**< \brief [16:16] Bridge software reset (rw) */
    __I  Ifx_Strict_32Bit :7;              /**< \brief [23:17] \internal Reserved */
    __I  Ifx_Strict_32Bit BUFF_DPT:8;      /**< \brief [31:24] Buffer depth of AEI bridge (r) */
} Ifx_EGTM_CLS_AEI_BRIDGE_MODE_Bits;

/** \brief BRIDGE_PTR1 */
typedef struct _Ifx_EGTM_CLS_AEI_BRIDGE_PTR1_Bits
{
    __I  Ifx_Strict_32Bit NEW_TRAN_PTR:5;    /**< \brief [4:0] New transaction pointer (rh) */
    __I  Ifx_Strict_32Bit FIRST_RSP_PTR:5;    /**< \brief [9:5] First response pointer (rh) */
    __I  Ifx_Strict_32Bit TRAN_IN_PGR:5;    /**< \brief [14:10] Transaction in progress pointer (acquire) (rh) */
    __I  Ifx_Strict_32Bit ABT_TRAN_PGR:5;    /**< \brief [19:15] Aborted transaction in progress pointer (rh) */
    __I  Ifx_Strict_32Bit FBC:6;           /**< \brief [25:20] Free buffer count (rh) */
    __I  Ifx_Strict_32Bit RSP_TRAN_RDY:6;    /**< \brief [31:26] Response transactions ready (rh) */
} Ifx_EGTM_CLS_AEI_BRIDGE_PTR1_Bits;

/** \brief BRIDGE_PTR2 */
typedef struct _Ifx_EGTM_CLS_AEI_BRIDGE_PTR2_Bits
{
    __I  Ifx_Strict_32Bit TRAN_IN_PGR2:5;    /**< \brief [4:0] Transaction in progress pointer (aquire2) (rh) */
    __I  Ifx_Strict_32Bit :27;             /**< \brief [31:5] \internal Reserved */
} Ifx_EGTM_CLS_AEI_BRIDGE_PTR2_Bits;

/** \brief GTM_AEI_ADDR_XPT */
typedef struct _Ifx_EGTM_CLS_ARCH_AEI_ADDR_XPT_Bits
{
    __I  Ifx_Strict_32Bit TO_ADDR:21;      /**< \brief [20:0] AEI timeout address (rh) */
    __I  Ifx_Strict_32Bit :3;              /**< \brief [23:21] \internal Reserved */
    __I  Ifx_Strict_32Bit TO_W1R0:1;       /**< \brief [24:24] AEI timeout Read/Write flag (rh) */
    __I  Ifx_Strict_32Bit :7;              /**< \brief [31:25] \internal Reserved */
} Ifx_EGTM_CLS_ARCH_AEI_ADDR_XPT_Bits;

/** \brief GTM_AEI_STA_XPT */
typedef struct _Ifx_EGTM_CLS_ARCH_AEI_STA_XPT_Bits
{
    __I  Ifx_Strict_32Bit ADDR:21;         /**< \brief [20:0] AEI exception address (rh) */
    __I  Ifx_Strict_32Bit :3;              /**< \brief [23:21] \internal Reserved */
    __I  Ifx_Strict_32Bit W1R0:1;          /**< \brief [24:24] AEI exception Read/Write flag (rh) */
    __I  Ifx_Strict_32Bit :7;              /**< \brief [31:25] \internal Reserved */
} Ifx_EGTM_CLS_ARCH_AEI_STA_XPT_Bits;

/** \brief eGTM configuration register */
typedef struct _Ifx_EGTM_CLS_ARCH_CFG_Bits
{
    __IO Ifx_Strict_32Bit SRC_IN_MUX:1;    /**< \brief [0:0] Input source selection for signal TIM[i]_AUX_IN ( input port AUX_IN at module TIM) (rw) */
    __I  Ifx_Strict_32Bit :31;             /**< \brief [31:1] \internal Reserved */
} Ifx_EGTM_CLS_ARCH_CFG_Bits;

/** \brief eGTM Cluster Clock Configuration */
typedef struct _Ifx_EGTM_CLS_ARCH_CLK_CFG_Bits
{
    __IO Ifx_Strict_32Bit CLS0_CLK_DIV:2;    /**< \brief [1:0] Cluster [j] Clock Divider (rwh) */
    __IO Ifx_Strict_32Bit CLS1_CLK_DIV:2;    /**< \brief [3:2] Cluster [j] Clock Divider (rwh) */
    __IO Ifx_Strict_32Bit CLS2_CLK_DIV:2;    /**< \brief [5:4] Cluster [j] Clock Divider (rwh) */
    __I  Ifx_Strict_32Bit :18;             /**< \brief [23:6] \internal Reserved */
    __I  Ifx_Strict_32Bit :8;              /**< \brief [31:24] \internal Reserved */
} Ifx_EGTM_CLS_ARCH_CLK_CFG_Bits;

/** \brief eGTM global control register */
typedef struct _Ifx_EGTM_CLS_ARCH_CTRL_Bits
{
    __IO Ifx_Strict_32Bit RF_PROT:1;       /**< \brief [0:0] RST and FORCINT protection (rw) */
    __IO Ifx_Strict_32Bit TO_MODE:2;       /**< \brief [2:1] AEI timeout mode (rw) */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [3:3] \internal Reserved */
    __IO Ifx_Strict_32Bit TO_VAL:8;        /**< \brief [11:4] AEI timeout value (rw) */
    __I  Ifx_Strict_32Bit :4;              /**< \brief [15:12] \internal Reserved */
    __I  Ifx_Strict_32Bit :16;             /**< \brief [31:16] \internal Reserved */
} Ifx_EGTM_CLS_ARCH_CTRL_Bits;

/** \brief eGTM error interrupt enable register */
typedef struct _Ifx_EGTM_CLS_ARCH_EIRQ_EN_Bits
{
    __IO Ifx_Strict_32Bit AEI_TO_XPT_EIRQ_EN:1;    /**< \brief [0:0] AEI_TO_XPT_EIRQ error interrupt enable (rw) */
    __IO Ifx_Strict_32Bit AEI_USP_ADDR_EIRQ_EN:1;    /**< \brief [1:1] AEI_USP_ADDR_EIRQ error interrupt enable (rw) */
    __IO Ifx_Strict_32Bit AEI_IM_ADDR_EIRQ_EN:1;    /**< \brief [2:2] AEI_IM_ADDR_EIRQ error interrupt enable (rw) */
    __IO Ifx_Strict_32Bit AEI_USP_BE_EIRQ_EN:1;    /**< \brief [3:3] AEI_USP_BE_EIRQ error interrupt enable (rw) */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [4:4] \internal Reserved */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [5:5] \internal Reserved */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [6:6] \internal Reserved */
    __IO Ifx_Strict_32Bit CLK_EN_ERR_EIRQ_EN:1;    /**< \brief [7:7] CLK_EN_ERR_EIRQ interrupt enable (rw) */
    __IO Ifx_Strict_32Bit CLK_PER_ERR_EIRQ_EN:1;    /**< \brief [8:8] CLK_PER_ERR_EIRQ interrupt enable (rw) */
    __I  Ifx_Strict_32Bit :23;             /**< \brief [31:9] \internal Reserved */
} Ifx_EGTM_CLS_ARCH_EIRQ_EN_Bits;

/** \brief eGTM interrupt enable register */
typedef struct _Ifx_EGTM_CLS_ARCH_IRQ_EN_Bits
{
    __IO Ifx_Strict_32Bit AEI_TO_XPT_IRQ_EN:1;    /**< \brief [0:0] AEI_TO_XPT_IRQ interrupt enable (rw) */
    __IO Ifx_Strict_32Bit AEI_USP_ADDR_IRQ_EN:1;    /**< \brief [1:1] AEI_USP_ADDR_IRQ interrupt enable (rw) */
    __IO Ifx_Strict_32Bit AEI_IM_ADDR_IRQ_EN:1;    /**< \brief [2:2] AEI_IM_ADDR_IRQ interrupt enable (rw) */
    __IO Ifx_Strict_32Bit AEI_USP_BE_IRQ_EN:1;    /**< \brief [3:3] AEI_USP_BE_IRQ interrupt enable (rw) */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [4:4] \internal Reserved */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [5:5] \internal Reserved */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [6:6] \internal Reserved */
    __IO Ifx_Strict_32Bit CLK_EN_ERR_IRQ_EN:1;    /**< \brief [7:7] CLK_EN_ERR_IRQ interrupt enable (rw) */
    __IO Ifx_Strict_32Bit CLK_PER_ERR_IRQ_EN:1;    /**< \brief [8:8] CLK_PER_ERR_IRQ interrupt enable (rw) */
    __I  Ifx_Strict_32Bit :23;             /**< \brief [31:9] \internal Reserved */
} Ifx_EGTM_CLS_ARCH_IRQ_EN_Bits;

/** \brief eGTM Software interrupt generation register */
typedef struct _Ifx_EGTM_CLS_ARCH_IRQ_FORCINT_Bits
{
    __IO Ifx_Strict_32Bit TRG_AEI_TO_XPT:1;    /**< \brief [0:0] Trigger the bit GTM_IRQ_NOTIFY.AEI_TO_XPT by software. (rw) */
    __IO Ifx_Strict_32Bit TRG_AEI_USP_ADDR:1;    /**< \brief [1:1] Trigger the bit GTM_IRQ_NOTIFY.AEI_USP_ADDR by software. (rw) */
    __IO Ifx_Strict_32Bit TRG_AEI_IM_ADDR:1;    /**< \brief [2:2] Trigger the bit GTM_IRQ_NOTIFY.AEI_IM_ADDR by software. (rw) */
    __IO Ifx_Strict_32Bit TRG_AEI_USP_BE:1;    /**< \brief [3:3] Trigger the bit GTM_IRQ_NOTIFY.AEI_USP_BE by software. (rw) */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [4:4] \internal Reserved */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [5:5] \internal Reserved */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [6:6] \internal Reserved */
    __IO Ifx_Strict_32Bit TRG_CLK_EN_ERR:1;    /**< \brief [7:7] Trigger the bit GTM_IRQ_NOTIFY.CLK_EN_ERR by software. (rw) */
    __IO Ifx_Strict_32Bit TRG_CLK_PER_ERR:1;    /**< \brief [8:8] Trigger the bit GTM_IRQ_NOTIFY.CLK_PER_ERR by software. (rw) */
    __I  Ifx_Strict_32Bit :23;             /**< \brief [31:9] \internal Reserved */
} Ifx_EGTM_CLS_ARCH_IRQ_FORCINT_Bits;

/** \brief eGTM top level interrupts mode selection */
typedef struct _Ifx_EGTM_CLS_ARCH_IRQ_MODE_Bits
{
    __IO Ifx_Strict_32Bit IRQ_MODE:2;      /**< \brief [1:0] Interrupt strategy mode selection for the AEI timeout and address monitoring interrupts. (rw) */
    __I  Ifx_Strict_32Bit :30;             /**< \brief [31:2] \internal Reserved */
} Ifx_EGTM_CLS_ARCH_IRQ_MODE_Bits;

/** \brief eGTM Interrupt notification register */
typedef struct _Ifx_EGTM_CLS_ARCH_IRQ_NOTIFY_Bits
{
    __IO Ifx_Strict_32Bit AEI_TO_XPT:1;    /**< \brief [0:0] AEI timeout exception occurred (rw1ch) */
    __IO Ifx_Strict_32Bit AEI_USP_ADDR:1;    /**< \brief [1:1] AEI unsupported address interrupt (rw1ch) */
    __IO Ifx_Strict_32Bit AEI_IM_ADDR:1;    /**< \brief [2:2] AEI illegal Module address interrupt (rw1ch) */
    __IO Ifx_Strict_32Bit AEI_USP_BE:1;    /**< \brief [3:3] AEI unsupported byte enable interrupt (rw1ch) */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [4:4] \internal Reserved */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [5:5] \internal Reserved */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [6:6] \internal Reserved */
    __IO Ifx_Strict_32Bit CLK_EN_ERR:1;    /**< \brief [7:7] Clock enable error interrupt (rw1ch) */
    __IO Ifx_Strict_32Bit CLK_PER_ERR:1;    /**< \brief [8:8] Clock period error interrupt (rw1ch) */
    __I  Ifx_Strict_32Bit :15;             /**< \brief [23:9] \internal Reserved */
    __I  Ifx_Strict_32Bit CLK_EN_ERR_STATE:2;    /**< \brief [25:24] Erroneous clock enable state (rh) */
    __I  Ifx_Strict_32Bit :2;              /**< \brief [27:26] \internal Reserved */
    __I  Ifx_Strict_32Bit CLK_EN_EXP_STATE:2;    /**< \brief [29:28] Expected clock enable state (rh) */
    __I  Ifx_Strict_32Bit :2;              /**< \brief [31:30] \internal Reserved */
} Ifx_EGTM_CLS_ARCH_IRQ_NOTIFY_Bits;

/** \brief eGTM version control register */
typedef struct _Ifx_EGTM_CLS_ARCH_REV_Bits
{
    __I  Ifx_Strict_32Bit REL_ITER:4;      /**< \brief [3:0] Delivery number (r) */
    __I  Ifx_Strict_32Bit REL_BASE:8;      /**< \brief [11:4] Release step (r) */
    __I  Ifx_Strict_32Bit :4;              /**< \brief [15:12] \internal Reserved */
    __I  Ifx_Strict_32Bit VENDOR_CODE:4;    /**< \brief [19:16] Device encoding digit 1 (r) */
    __I  Ifx_Strict_32Bit DEVICE_CODE:4;    /**< \brief [23:20] Device encoding digit 0 (r) */
    __I  Ifx_Strict_32Bit VER_MINOR:4;     /**< \brief [27:24] Minor version number (r) */
    __I  Ifx_Strict_32Bit VER_MAJOR:4;     /**< \brief [31:28] Major version number (r) */
} Ifx_EGTM_CLS_ARCH_REV_Bits;

/** \brief eGTM global reset register */
typedef struct _Ifx_EGTM_CLS_ARCH_RST_Bits
{
    __I  Ifx_Strict_32Bit :1;              /**< \brief [0:0] \internal Reserved */
    __I  Ifx_Strict_32Bit :26;             /**< \brief [26:1] \internal Reserved */
    __IO Ifx_Strict_32Bit BRIDGE_MODE_WRDIS:1;    /**< \brief [27:27] BRIDGE_MODE write disable (rwh) */
    __I  Ifx_Strict_32Bit :4;              /**< \brief [31:28] \internal Reserved */
} Ifx_EGTM_CLS_ARCH_RST_Bits;

/** \brief ATOM[i] AGC action time base register */
typedef struct _Ifx_EGTM_CLS_ATOM_AGC_ACT_TB_Bits
{
    __IO Ifx_Strict_32Bit ACT_TB:24;       /**< \brief [23:0] Specifies the signed compare value with selected signal CCM[i]_TBU_TS0/CCM[i]_TBU_TS1/CCM[i]_TBU_TS2. If selected CCM[i]_TBU_TS0/CCM[i]_TBU_TS1/CCM[i]_TBU_TS2 value is in the interval [ATOM[i]_AGC_ACT_TB.ACT_TB-007FFFFFh,ATOM[i]_AGC_ACT_TB.ACT_TB] the event is in the past and the trigger is generated immediately. Otherwise the event is in the future and the trigger is generated if selected CCM[i]_TBU_TS0/CCM[i]_TBU_TS1/CCM[i]_TBU_TS2 is equal to ATOM[i]_AGC_ACT_TB.ACT_TB. (rw) */
    __IO Ifx_Strict_32Bit TB_TRIG:1;       /**< \brief [24:24] Set trigger request (rwh) */
    __IO Ifx_Strict_32Bit TBU_SEL:2;       /**< \brief [26:25] Selection of time base used for comparison (rw) */
    __I  Ifx_Strict_32Bit :5;              /**< \brief [31:27] \internal Reserved */
} Ifx_EGTM_CLS_ATOM_AGC_ACT_TB_Bits;

/** \brief ATOM[i] AGC enable/disable control register */
typedef struct _Ifx_EGTM_CLS_ATOM_AGC_ENDIS_CTRL_Bits
{
    __IO Ifx_Strict_32Bit ENDIS_CTRL0:2;    /**< \brief [1:0] ATOM [i] channel [x] enable/disable control register. (rw) */
    __IO Ifx_Strict_32Bit ENDIS_CTRL1:2;    /**< \brief [3:2] ATOM [i] channel [x] enable/disable control register. (rw) */
    __IO Ifx_Strict_32Bit ENDIS_CTRL2:2;    /**< \brief [5:4] ATOM [i] channel [x] enable/disable control register. (rw) */
    __IO Ifx_Strict_32Bit ENDIS_CTRL3:2;    /**< \brief [7:6] ATOM [i] channel [x] enable/disable control register. (rw) */
    __IO Ifx_Strict_32Bit ENDIS_CTRL4:2;    /**< \brief [9:8] ATOM [i] channel [x] enable/disable control register. (rw) */
    __IO Ifx_Strict_32Bit ENDIS_CTRL5:2;    /**< \brief [11:10] ATOM [i] channel [x] enable/disable control register. (rw) */
    __IO Ifx_Strict_32Bit ENDIS_CTRL6:2;    /**< \brief [13:12] ATOM [i] channel [x] enable/disable control register. (rw) */
    __IO Ifx_Strict_32Bit ENDIS_CTRL7:2;    /**< \brief [15:14] ATOM [i] channel [x] enable/disable control register. (rw) */
    __I  Ifx_Strict_32Bit :16;             /**< \brief [31:16] \internal Reserved */
} Ifx_EGTM_CLS_ATOM_AGC_ENDIS_CTRL_Bits;

/** \brief ATOM[i] AGC enable/disable status register */
typedef struct _Ifx_EGTM_CLS_ATOM_AGC_ENDIS_STAT_Bits
{
    __IO Ifx_Strict_32Bit ENDIS_STAT0:2;    /**< \brief [1:0] ATOM [i] channel [k] enable/disable status register (rwh) */
    __IO Ifx_Strict_32Bit ENDIS_STAT1:2;    /**< \brief [3:2] ATOM [i] channel [k] enable/disable status register (rwh) */
    __IO Ifx_Strict_32Bit ENDIS_STAT2:2;    /**< \brief [5:4] ATOM [i] channel [k] enable/disable status register (rwh) */
    __IO Ifx_Strict_32Bit ENDIS_STAT3:2;    /**< \brief [7:6] ATOM [i] channel [k] enable/disable status register (rwh) */
    __IO Ifx_Strict_32Bit ENDIS_STAT4:2;    /**< \brief [9:8] ATOM [i] channel [k] enable/disable status register (rwh) */
    __IO Ifx_Strict_32Bit ENDIS_STAT5:2;    /**< \brief [11:10] ATOM [i] channel [k] enable/disable status register (rwh) */
    __IO Ifx_Strict_32Bit ENDIS_STAT6:2;    /**< \brief [13:12] ATOM [i] channel [k] enable/disable status register (rwh) */
    __IO Ifx_Strict_32Bit ENDIS_STAT7:2;    /**< \brief [15:14] ATOM [i] channel [k] enable/disable status register (rwh) */
    __I  Ifx_Strict_32Bit :16;             /**< \brief [31:16] \internal Reserved */
} Ifx_EGTM_CLS_ATOM_AGC_ENDIS_STAT_Bits;

/** \brief ATOM[i] AGC force update control register */
typedef struct _Ifx_EGTM_CLS_ATOM_AGC_FUPD_CTRL_Bits
{
    __IO Ifx_Strict_32Bit FUPD_CTRL0:2;    /**< \brief [1:0] Force update of ATOM channel [k] operation registers (rw) */
    __IO Ifx_Strict_32Bit FUPD_CTRL1:2;    /**< \brief [3:2] Force update of ATOM channel [k] operation registers (rw) */
    __IO Ifx_Strict_32Bit FUPD_CTRL2:2;    /**< \brief [5:4] Force update of ATOM channel [k] operation registers (rw) */
    __IO Ifx_Strict_32Bit FUPD_CTRL3:2;    /**< \brief [7:6] Force update of ATOM channel [k] operation registers (rw) */
    __IO Ifx_Strict_32Bit FUPD_CTRL4:2;    /**< \brief [9:8] Force update of ATOM channel [k] operation registers (rw) */
    __IO Ifx_Strict_32Bit FUPD_CTRL5:2;    /**< \brief [11:10] Force update of ATOM channel [k] operation registers (rw) */
    __IO Ifx_Strict_32Bit FUPD_CTRL6:2;    /**< \brief [13:12] Force update of ATOM channel [k] operation registers (rw) */
    __IO Ifx_Strict_32Bit FUPD_CTRL7:2;    /**< \brief [15:14] Force update of ATOM channel [k] operation registers (rw) */
    __IO Ifx_Strict_32Bit RSTCN0_CH0:2;    /**< \brief [17:16] Reset ATOM[i]_CH[k]_CN0 of channel [k] on force update event (rw) */
    __IO Ifx_Strict_32Bit RSTCN0_CH1:2;    /**< \brief [19:18] Reset ATOM[i]_CH[k]_CN0 of channel [k] on force update event (rw) */
    __IO Ifx_Strict_32Bit RSTCN0_CH2:2;    /**< \brief [21:20] Reset ATOM[i]_CH[k]_CN0 of channel [k] on force update event (rw) */
    __IO Ifx_Strict_32Bit RSTCN0_CH3:2;    /**< \brief [23:22] Reset ATOM[i]_CH[k]_CN0 of channel [k] on force update event (rw) */
    __IO Ifx_Strict_32Bit RSTCN0_CH4:2;    /**< \brief [25:24] Reset ATOM[i]_CH[k]_CN0 of channel [k] on force update event (rw) */
    __IO Ifx_Strict_32Bit RSTCN0_CH5:2;    /**< \brief [27:26] Reset ATOM[i]_CH[k]_CN0 of channel [k] on force update event (rw) */
    __IO Ifx_Strict_32Bit RSTCN0_CH6:2;    /**< \brief [29:28] Reset ATOM[i]_CH[k]_CN0 of channel [k] on force update event (rw) */
    __IO Ifx_Strict_32Bit RSTCN0_CH7:2;    /**< \brief [31:30] Reset ATOM[i]_CH[k]_CN0 of channel [k] on force update event (rw) */
} Ifx_EGTM_CLS_ATOM_AGC_FUPD_CTRL_Bits;

/** \brief ATOM[i] AGC global control register */
typedef struct _Ifx_EGTM_CLS_ATOM_AGC_GLB_CTRL_Bits
{
    __IO Ifx_Strict_32Bit HOST_TRIG:1;     /**< \brief [0:0] Trigger request signal (see AGC) to update the register ATOM[i]_AGC_ENDIS_STAT and ATOM[i]_AGC_OUTEN_STAT (rw) */
    __I  Ifx_Strict_32Bit :7;              /**< \brief [7:1] \internal Reserved */
    __IO Ifx_Strict_32Bit RST_CH0:1;       /**< \brief [8:8] Software reset of channel [k] (rw) */
    __IO Ifx_Strict_32Bit RST_CH1:1;       /**< \brief [9:9] Software reset of channel [k] (rw) */
    __IO Ifx_Strict_32Bit RST_CH2:1;       /**< \brief [10:10] Software reset of channel [k] (rw) */
    __IO Ifx_Strict_32Bit RST_CH3:1;       /**< \brief [11:11] Software reset of channel [k] (rw) */
    __IO Ifx_Strict_32Bit RST_CH4:1;       /**< \brief [12:12] Software reset of channel [k] (rw) */
    __IO Ifx_Strict_32Bit RST_CH5:1;       /**< \brief [13:13] Software reset of channel [k] (rw) */
    __IO Ifx_Strict_32Bit RST_CH6:1;       /**< \brief [14:14] Software reset of channel [k] (rw) */
    __IO Ifx_Strict_32Bit RST_CH7:1;       /**< \brief [15:15] Software reset of channel [k] (rw) */
    __IO Ifx_Strict_32Bit UPEN_CTRL0:2;    /**< \brief [17:16] ATOM channel [k] enable update of register ATOM[i]_CH[k]_CM0, ATOM[i]_CH[k]_CM1, ATOM[i]_CH[k]_CTRL.SL and ATOM[i]_CH[k]_CTRL.CLK_SRC from ATOM[i]_CH[k]_SR0, ATOM[i]_CH[k]_SR1, ATOM[i]_CH[k]_CTRL_SR.SL_SR and ATOM[i]_CH[k]_CTRL_SR.CLK_SRC_SR. (rw) */
    __IO Ifx_Strict_32Bit UPEN_CTRL1:2;    /**< \brief [19:18] ATOM channel [k] enable update of register ATOM[i]_CH[k]_CM0, ATOM[i]_CH[k]_CM1, ATOM[i]_CH[k]_CTRL.SL and ATOM[i]_CH[k]_CTRL.CLK_SRC from ATOM[i]_CH[k]_SR0, ATOM[i]_CH[k]_SR1, ATOM[i]_CH[k]_CTRL_SR.SL_SR and ATOM[i]_CH[k]_CTRL_SR.CLK_SRC_SR. (rw) */
    __IO Ifx_Strict_32Bit UPEN_CTRL2:2;    /**< \brief [21:20] ATOM channel [k] enable update of register ATOM[i]_CH[k]_CM0, ATOM[i]_CH[k]_CM1, ATOM[i]_CH[k]_CTRL.SL and ATOM[i]_CH[k]_CTRL.CLK_SRC from ATOM[i]_CH[k]_SR0, ATOM[i]_CH[k]_SR1, ATOM[i]_CH[k]_CTRL_SR.SL_SR and ATOM[i]_CH[k]_CTRL_SR.CLK_SRC_SR. (rw) */
    __IO Ifx_Strict_32Bit UPEN_CTRL3:2;    /**< \brief [23:22] ATOM channel [k] enable update of register ATOM[i]_CH[k]_CM0, ATOM[i]_CH[k]_CM1, ATOM[i]_CH[k]_CTRL.SL and ATOM[i]_CH[k]_CTRL.CLK_SRC from ATOM[i]_CH[k]_SR0, ATOM[i]_CH[k]_SR1, ATOM[i]_CH[k]_CTRL_SR.SL_SR and ATOM[i]_CH[k]_CTRL_SR.CLK_SRC_SR. (rw) */
    __IO Ifx_Strict_32Bit UPEN_CTRL4:2;    /**< \brief [25:24] ATOM channel [k] enable update of register ATOM[i]_CH[k]_CM0, ATOM[i]_CH[k]_CM1, ATOM[i]_CH[k]_CTRL.SL and ATOM[i]_CH[k]_CTRL.CLK_SRC from ATOM[i]_CH[k]_SR0, ATOM[i]_CH[k]_SR1, ATOM[i]_CH[k]_CTRL_SR.SL_SR and ATOM[i]_CH[k]_CTRL_SR.CLK_SRC_SR. (rw) */
    __IO Ifx_Strict_32Bit UPEN_CTRL5:2;    /**< \brief [27:26] ATOM channel [k] enable update of register ATOM[i]_CH[k]_CM0, ATOM[i]_CH[k]_CM1, ATOM[i]_CH[k]_CTRL.SL and ATOM[i]_CH[k]_CTRL.CLK_SRC from ATOM[i]_CH[k]_SR0, ATOM[i]_CH[k]_SR1, ATOM[i]_CH[k]_CTRL_SR.SL_SR and ATOM[i]_CH[k]_CTRL_SR.CLK_SRC_SR. (rw) */
    __IO Ifx_Strict_32Bit UPEN_CTRL6:2;    /**< \brief [29:28] ATOM channel [k] enable update of register ATOM[i]_CH[k]_CM0, ATOM[i]_CH[k]_CM1, ATOM[i]_CH[k]_CTRL.SL and ATOM[i]_CH[k]_CTRL.CLK_SRC from ATOM[i]_CH[k]_SR0, ATOM[i]_CH[k]_SR1, ATOM[i]_CH[k]_CTRL_SR.SL_SR and ATOM[i]_CH[k]_CTRL_SR.CLK_SRC_SR. (rw) */
    __IO Ifx_Strict_32Bit UPEN_CTRL7:2;    /**< \brief [31:30] ATOM channel [k] enable update of register ATOM[i]_CH[k]_CM0, ATOM[i]_CH[k]_CM1, ATOM[i]_CH[k]_CTRL.SL and ATOM[i]_CH[k]_CTRL.CLK_SRC from ATOM[i]_CH[k]_SR0, ATOM[i]_CH[k]_SR1, ATOM[i]_CH[k]_CTRL_SR.SL_SR and ATOM[i]_CH[k]_CTRL_SR.CLK_SRC_SR. (rw) */
} Ifx_EGTM_CLS_ATOM_AGC_GLB_CTRL_Bits;

/** \brief ATOM[i] AGC internal trigger control register */
typedef struct _Ifx_EGTM_CLS_ATOM_AGC_INT_TRIG_Bits
{
    __IO Ifx_Strict_32Bit INT_TRIG0:2;     /**< \brief [1:0] Select input signal ATOM_CH_TRIGOUT[k:k] as a trigger source (rw) */
    __IO Ifx_Strict_32Bit INT_TRIG1:2;     /**< \brief [3:2] Select input signal ATOM_CH_TRIGOUT[k:k] as a trigger source (rw) */
    __IO Ifx_Strict_32Bit INT_TRIG2:2;     /**< \brief [5:4] Select input signal ATOM_CH_TRIGOUT[k:k] as a trigger source (rw) */
    __IO Ifx_Strict_32Bit INT_TRIG3:2;     /**< \brief [7:6] Select input signal ATOM_CH_TRIGOUT[k:k] as a trigger source (rw) */
    __IO Ifx_Strict_32Bit INT_TRIG4:2;     /**< \brief [9:8] Select input signal ATOM_CH_TRIGOUT[k:k] as a trigger source (rw) */
    __IO Ifx_Strict_32Bit INT_TRIG5:2;     /**< \brief [11:10] Select input signal ATOM_CH_TRIGOUT[k:k] as a trigger source (rw) */
    __IO Ifx_Strict_32Bit INT_TRIG6:2;     /**< \brief [13:12] Select input signal ATOM_CH_TRIGOUT[k:k] as a trigger source (rw) */
    __IO Ifx_Strict_32Bit INT_TRIG7:2;     /**< \brief [15:14] Select input signal ATOM_CH_TRIGOUT[k:k] as a trigger source (rw) */
    __I  Ifx_Strict_32Bit :16;             /**< \brief [31:16] \internal Reserved */
} Ifx_EGTM_CLS_ATOM_AGC_INT_TRIG_Bits;

/** \brief ATOM[i] AGC output enable control register */
typedef struct _Ifx_EGTM_CLS_ATOM_AGC_OUTEN_CTRL_Bits
{
    __IO Ifx_Strict_32Bit OUTEN_CTRL0:2;    /**< \brief [1:0] Output enable control of ATOM [i] channel [k] ouput ATOM_OUT[x:x] (rw) */
    __IO Ifx_Strict_32Bit OUTEN_CTRL1:2;    /**< \brief [3:2] Output enable control of ATOM [i] channel [k] ouput ATOM_OUT[x:x] (rw) */
    __IO Ifx_Strict_32Bit OUTEN_CTRL2:2;    /**< \brief [5:4] Output enable control of ATOM [i] channel [k] ouput ATOM_OUT[x:x] (rw) */
    __IO Ifx_Strict_32Bit OUTEN_CTRL3:2;    /**< \brief [7:6] Output enable control of ATOM [i] channel [k] ouput ATOM_OUT[x:x] (rw) */
    __IO Ifx_Strict_32Bit OUTEN_CTRL4:2;    /**< \brief [9:8] Output enable control of ATOM [i] channel [k] ouput ATOM_OUT[x:x] (rw) */
    __IO Ifx_Strict_32Bit OUTEN_CTRL5:2;    /**< \brief [11:10] Output enable control of ATOM [i] channel [k] ouput ATOM_OUT[x:x] (rw) */
    __IO Ifx_Strict_32Bit OUTEN_CTRL6:2;    /**< \brief [13:12] Output enable control of ATOM [i] channel [k] ouput ATOM_OUT[x:x] (rw) */
    __IO Ifx_Strict_32Bit OUTEN_CTRL7:2;    /**< \brief [15:14] Output enable control of ATOM [i] channel [k] ouput ATOM_OUT[x:x] (rw) */
    __I  Ifx_Strict_32Bit :16;             /**< \brief [31:16] \internal Reserved */
} Ifx_EGTM_CLS_ATOM_AGC_OUTEN_CTRL_Bits;

/** \brief ATOM[i] AGC output enable status register */
typedef struct _Ifx_EGTM_CLS_ATOM_AGC_OUTEN_STAT_Bits
{
    __IO Ifx_Strict_32Bit OUTEN_STAT0:2;    /**< \brief [1:0] Output enable status of ATOM [i] channel [x] ouput ATOM_OUT[k:k] (rwh) */
    __IO Ifx_Strict_32Bit OUTEN_STAT1:2;    /**< \brief [3:2] Output enable status of ATOM [i] channel [x] ouput ATOM_OUT[k:k] (rwh) */
    __IO Ifx_Strict_32Bit OUTEN_STAT2:2;    /**< \brief [5:4] Output enable status of ATOM [i] channel [x] ouput ATOM_OUT[k:k] (rwh) */
    __IO Ifx_Strict_32Bit OUTEN_STAT3:2;    /**< \brief [7:6] Output enable status of ATOM [i] channel [x] ouput ATOM_OUT[k:k] (rwh) */
    __IO Ifx_Strict_32Bit OUTEN_STAT4:2;    /**< \brief [9:8] Output enable status of ATOM [i] channel [x] ouput ATOM_OUT[k:k] (rwh) */
    __IO Ifx_Strict_32Bit OUTEN_STAT5:2;    /**< \brief [11:10] Output enable status of ATOM [i] channel [x] ouput ATOM_OUT[k:k] (rwh) */
    __IO Ifx_Strict_32Bit OUTEN_STAT6:2;    /**< \brief [13:12] Output enable status of ATOM [i] channel [x] ouput ATOM_OUT[k:k] (rwh) */
    __IO Ifx_Strict_32Bit OUTEN_STAT7:2;    /**< \brief [15:14] Output enable status of ATOM [i] channel [x] ouput ATOM_OUT[k:k] (rwh) */
    __I  Ifx_Strict_32Bit :16;             /**< \brief [31:16] \internal Reserved */
} Ifx_EGTM_CLS_ATOM_AGC_OUTEN_STAT_Bits;

/** \brief ATOM[i] channel [x] CCU0 compare register */
typedef struct _Ifx_EGTM_CLS_ATOM_CH_CM0_Bits
{
    __IO Ifx_Strict_32Bit CM0:24;          /**< \brief [23:0] ATOM CCU0 compare register. (rwh) */
    __I  Ifx_Strict_32Bit :8;              /**< \brief [31:24] \internal Reserved */
} Ifx_EGTM_CLS_ATOM_CH_CM0_Bits;

/** \brief ATOM[i] channel [x] CCU1 compare register */
typedef struct _Ifx_EGTM_CLS_ATOM_CH_CM1_Bits
{
    __IO Ifx_Strict_32Bit CM1:24;          /**< \brief [23:0] ATOM CCU1 compare register. (rwh) */
    __I  Ifx_Strict_32Bit :8;              /**< \brief [31:24] \internal Reserved */
} Ifx_EGTM_CLS_ATOM_CH_CM1_Bits;

/** \brief ATOM[i] channel [x] CCU0 counter register */
typedef struct _Ifx_EGTM_CLS_ATOM_CH_CN0_Bits
{
    __IO Ifx_Strict_32Bit CN0:24;          /**< \brief [23:0] ATOM CCU0 counter register. (rwh) */
    __I  Ifx_Strict_32Bit :8;              /**< \brief [31:24] \internal Reserved */
} Ifx_EGTM_CLS_ATOM_CH_CN0_Bits;

/** \brief ATOM[i] channel [x] control register */
typedef struct _Ifx_EGTM_CLS_ATOM_CH_CTRL_Bits
{
    __IO Ifx_Strict_32Bit MODE:2;          /**< \brief [1:0] ATOM channel mode select. (rw) */
    __IO Ifx_Strict_32Bit TB12_SEL:1;      /**< \brief [2:2] Select time base value CCM[i]_TBU_TS1 or CCM[i]_TBU_TS2. (rw) */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [3:3] \internal Reserved */
    __IO Ifx_Strict_32Bit ACB:5;           /**< \brief [8:4] ATOM Mode control bits. (rw) */
    __IO Ifx_Strict_32Bit CMP_CTRL:1;      /**< \brief [9:9] CCU[x] compare strategy select. (rw) */
    __IO Ifx_Strict_32Bit EUPM:1;          /**< \brief [10:10] Extended update mode (rw) */
    __IO Ifx_Strict_32Bit SL:1;            /**< \brief [11:11] Initial signal level. (rwh) */
    __IO Ifx_Strict_32Bit CLK_SRC:4;       /**< \brief [15:12] CMU clock source (rwh) */
    __IO Ifx_Strict_32Bit WR_REQ:1;        /**< \brief [16:16] CPU Write request bit for late compare register update. (rw) */
    __IO Ifx_Strict_32Bit TRIG_PULSE:1;    /**< \brief [17:17] Trigger output pulse length of one cluster clock period (rw) */
    __IO Ifx_Strict_32Bit UDMODE:2;        /**< \brief [19:18] Up/down counter mode (rw) */
    __IO Ifx_Strict_32Bit RST_CCU0:1;      /**< \brief [20:20] Reset source of CCU0 (rw) */
    __IO Ifx_Strict_32Bit OSM_TRIG:1;      /**< \brief [21:21] Enable trigger of one-shot pulse by the selected trigger signal (rw) */
    __IO Ifx_Strict_32Bit EXT_TRIG:1;      /**< \brief [22:22] Select EXT_TRIGIN[x:x] as trigger signal (rw) */
    __IO Ifx_Strict_32Bit EXTTRIGOUT:1;    /**< \brief [23:23] Select EXT_TRIGIN[x:x] as potential output signal ATOM_CH_TRIGOUT[x:x] (rw) */
    __IO Ifx_Strict_32Bit TRIGOUT:1;       /**< \brief [24:24] Trigger output selection (output signal ATOM_CH_TRIGOUT[x:x]) of module ATOM [i] channel [x]. (rw) */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [25:25] \internal Reserved */
    __IO Ifx_Strict_32Bit OSM:1;           /**< \brief [26:26] One-shot mode (rw) */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [27:27] \internal Reserved */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [28:28] \internal Reserved */
    __IO Ifx_Strict_32Bit EXT_FUPD:1;      /**< \brief [29:29] Enable force update by external trigger signal (rw) */
    __IO Ifx_Strict_32Bit SOMB:1;          /**< \brief [30:30] SOMB mode (rw) */
    __IO Ifx_Strict_32Bit FREEZE:1;        /**< \brief [31:31] ATOM Freeze Mode enable (rw) */
} Ifx_EGTM_CLS_ATOM_CH_CTRL_Bits;

/** \brief ATOM[i] channel [x] control2 register */
typedef struct _Ifx_EGTM_CLS_ATOM_CH_CTRL2_Bits
{
    __IO Ifx_Strict_32Bit HRES:1;          /**< \brief [0:0] ATOM[i]_CH[x]_CTRL2.HRES: ATOM high resolution support (rw) */
    __I  Ifx_Strict_32Bit :31;             /**< \brief [31:1] \internal Reserved */
} Ifx_EGTM_CLS_ATOM_CH_CTRL2_Bits;

/** \brief ATOM[i] channel [x] control register */
typedef struct _Ifx_EGTM_CLS_ATOM_CH_CTRL_SOMB_Bits
{
    __IO Ifx_Strict_32Bit MODE:2;          /**< \brief [1:0] ATOM channel mode select, but not applicable in SOMB mode. (rw) */
    __IO Ifx_Strict_32Bit TB12_SEL:1;      /**< \brief [2:2] Select time base value CCM[i]_TBU_TS1 or CCM[i]_TBU_TS2. (rw) */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [3:3] \internal Reserved */
    __IO Ifx_Strict_32Bit ACB10:2;         /**< \brief [5:4] Signal level control (rw) */
    __IO Ifx_Strict_32Bit ACB42:3;         /**< \brief [8:6] Compare strategy (rw) */
    __IO Ifx_Strict_32Bit CMP_CTRL:1;      /**< \brief [9:9] CCU[x] compare strategy select. (rw) */
    __IO Ifx_Strict_32Bit EUPM:1;          /**< \brief [10:10] Extended update mode (rw) */
    __IO Ifx_Strict_32Bit SL:1;            /**< \brief [11:11] Initial signal level. (rw) */
    __IO Ifx_Strict_32Bit CLK_SRC:4;       /**< \brief [15:12] CMU clock source but not applicable in SOMB mode (rw) */
    __IO Ifx_Strict_32Bit WR_REQ:1;        /**< \brief [16:16] CPU Write request bit for late compare register update. (rwh) */
    __IO Ifx_Strict_32Bit TRIG_PULSE:1;    /**< \brief [17:17] Trigger output pulse length of one cluster clock period, , but not applicable in SOMB mode. (rw) */
    __IO Ifx_Strict_32Bit UDMODE:2;        /**< \brief [19:18] Up/down counter mode, but not applicable in SOMB mode. (rw) */
    __IO Ifx_Strict_32Bit RST_CCU0:1;      /**< \brief [20:20] Reset source of CCU0, but not applicable in SOMB mode. (rw) */
    __IO Ifx_Strict_32Bit OSM_TRIG:1;      /**< \brief [21:21] Enable trigger of one-shot pulse by trigger signal ATOM_CH_TRIGOUT[x-1:x-1] or EXT_TRIGIN[x:x], but not applicable in SOMB mode. (rw) */
    __IO Ifx_Strict_32Bit EXT_TRIG:1;      /**< \brief [22:22] Select EXT_TRIGIN[x:x] as trigger signal, but not applicable in SOMB mode. (rw) */
    __IO Ifx_Strict_32Bit EXTTRIGOUT:1;    /**< \brief [23:23] Select EXT_TRIGIN[x:x] as potential output signal ATOM_CH_TRIGOUT[x:x] (rw) */
    __IO Ifx_Strict_32Bit TRIGOUT:1;       /**< \brief [24:24] Trigger output selection (output signal ATOM_CH_TRIGOUT[x:x]) of module ATOM [i] channel [x]. (rw) */
    __IO Ifx_Strict_32Bit SLA:1;           /**< \brief [25:25] "'Serve last' ARU communication strategy, but not applicable in SOMP mode." (rw) */
    __IO Ifx_Strict_32Bit OSM:1;           /**< \brief [26:26] One-shot mode, but not applicable in SOMB mode. (rw) */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [27:27] \internal Reserved */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [28:28] \internal Reserved */
    __IO Ifx_Strict_32Bit EXT_FUPD:1;      /**< \brief [29:29] External forced update (rw) */
    __IO Ifx_Strict_32Bit SOMB:1;          /**< \brief [30:30] SOMB mode (rw) */
    __IO Ifx_Strict_32Bit FREEZE:1;        /**< \brief [31:31] ATOM Freeze Mode enable (rw) */
} Ifx_EGTM_CLS_ATOM_CH_CTRL_SOMB_Bits;

/** \brief ATOM[i] channel [x] control register */
typedef struct _Ifx_EGTM_CLS_ATOM_CH_CTRL_SOMC_Bits
{
    __IO Ifx_Strict_32Bit MODE:2;          /**< \brief [1:0] ATOM channel mode select (rw) */
    __IO Ifx_Strict_32Bit TB12_SEL:1;      /**< \brief [2:2] Select time base value CCM[i]_TBU_TS1 or CCM[i]_TBU_TS2. (rw) */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [3:3] \internal Reserved */
    __IO Ifx_Strict_32Bit ACB10:2;         /**< \brief [5:4] Signal level control (rw) */
    __IO Ifx_Strict_32Bit ACB42:3;         /**< \brief [8:6] Compare strategy (rw) */
    __IO Ifx_Strict_32Bit CMP_CTRL:1;      /**< \brief [9:9] CCU[x] compare strategy select. (rw) */
    __IO Ifx_Strict_32Bit EUPM:1;          /**< \brief [10:10] Extended update mode (rw) */
    __IO Ifx_Strict_32Bit SL:1;            /**< \brief [11:11] Initial signal level. (rw) */
    __IO Ifx_Strict_32Bit CLK_SRC:4;       /**< \brief [15:12] CMU clock source but not applicable in SOMC mode (rw) */
    __IO Ifx_Strict_32Bit WR_REQ:1;        /**< \brief [16:16] CPU Write request bit for late compare register update. (rwh) */
    __IO Ifx_Strict_32Bit TRIG_PULSE:1;    /**< \brief [17:17] Trigger output pulse length of one cluster clock period, , but not applicable in SOMC mode. (rw) */
    __IO Ifx_Strict_32Bit UDMODE:2;        /**< \brief [19:18] Up/down counter mode, but not applicable in SOMC mode. (rw) */
    __IO Ifx_Strict_32Bit RST_CCU0:1;      /**< \brief [20:20] Reset source of CCU0, but not applicable in SOMC mode. (rw) */
    __IO Ifx_Strict_32Bit OSM_TRIG:1;      /**< \brief [21:21] Enable trigger of one-shot pulse by trigger signal ATOM_CH_TRIGOUT[x-1:x-1] or EXT_TRIGIN[x:x], but not applicable in SOMC mode. (rw) */
    __IO Ifx_Strict_32Bit EXT_TRIG:1;      /**< \brief [22:22] Select EXT_TRIGIN[x:x] as trigger signal, but not applicable in SOMC mode. (rw) */
    __IO Ifx_Strict_32Bit EXTTRIGOUT:1;    /**< \brief [23:23] Select EXT_TRIGIN[x:x] as potential output signal ATOM_CH_TRIGOUT[x:x] (rw) */
    __IO Ifx_Strict_32Bit TRIGOUT:1;       /**< \brief [24:24] Trigger output selection (output signal ATOM_CH_TRIGOUT[x:x]) of module ATOM channel x. (rw) */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [25:25] \internal Reserved */
    __IO Ifx_Strict_32Bit OSM:1;           /**< \brief [26:26] One-shot mode, but not applicable in SOMC mode. (rw) */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [27:27] \internal Reserved */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [28:28] \internal Reserved */
    __IO Ifx_Strict_32Bit EXT_FUPD:1;      /**< \brief [29:29] External forced update, but not applicable in SOMC mode. (rw) */
    __IO Ifx_Strict_32Bit SOMB:1;          /**< \brief [30:30] SOMB mode (rw) */
    __IO Ifx_Strict_32Bit FREEZE:1;        /**< \brief [31:31] ATOM freeze mode enable (rw) */
} Ifx_EGTM_CLS_ATOM_CH_CTRL_SOMC_Bits;

/** \brief ATOM[i] channel [x] control register */
typedef struct _Ifx_EGTM_CLS_ATOM_CH_CTRL_SOMI_Bits
{
    __IO Ifx_Strict_32Bit MODE:2;          /**< \brief [1:0] ATOM channel mode select. (rw) */
    __IO Ifx_Strict_32Bit TB12_SEL:1;      /**< \brief [2:2] Select time base value CCM[i]_TBU_TS1 or CCM[i]_TBU_TS2, but not applicable in SOMI mode. (rw) */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [3:3] \internal Reserved */
    __IO Ifx_Strict_32Bit ACB0:1;          /**< \brief [4:4] ATOM output control (rw) */
    __IO Ifx_Strict_32Bit ACB41:4;         /**< \brief [8:5] ATOM Mode control bits but not applicable in SOMI mode. (rw) */
    __IO Ifx_Strict_32Bit CMP_CTRL:1;      /**< \brief [9:9] CCU[x] compare strategy selection, but not applicable in SOMI mode. (rw) */
    __IO Ifx_Strict_32Bit EUPM:1;          /**< \brief [10:10] Extended update mode, but not applicable in SOMI mode. (rw) */
    __IO Ifx_Strict_32Bit SL:1;            /**< \brief [11:11] Initial signal level. (rw) */
    __IO Ifx_Strict_32Bit CLK_SRC:4;       /**< \brief [15:12] CMU clock source but not applicable in SOMI mode (rw) */
    __IO Ifx_Strict_32Bit WR_REQ:1;        /**< \brief [16:16] CPU Write request bit for late compare register update, but not applicable in SOMI mode. (rw) */
    __IO Ifx_Strict_32Bit TRIG_PULSE:1;    /**< \brief [17:17] Trigger output pulse length of one cluster clock period, , but not applicable in SOMI mode. (rw) */
    __IO Ifx_Strict_32Bit UDMODE:2;        /**< \brief [19:18] Up/down counter mode, but not applicable in SOMI mode. (rw) */
    __IO Ifx_Strict_32Bit RST_CCU0:1;      /**< \brief [20:20] Reset source of CCU0, but not applicable in SOMI mode. (rw) */
    __IO Ifx_Strict_32Bit OSM_TRIG:1;      /**< \brief [21:21] Enable trigger of one-shot pulse by trigger signal ATOM_CH_TRIGOUT[x-1:x-1] or EXT_TRIGIN[x:x], but not applicable in SOMI mode. (rw) */
    __IO Ifx_Strict_32Bit EXT_TRIG:1;      /**< \brief [22:22] Select EXT_TRIGIN[x:x] as trigger signal, but not applicable in SOMI mode. (rw) */
    __IO Ifx_Strict_32Bit EXTTRIGOUT:1;    /**< \brief [23:23] Select EXT_TRIGIN[x:x] as potential output signal ATOM_CH_TRIGOUT[x:x] (rw) */
    __IO Ifx_Strict_32Bit TRIGOUT:1;       /**< \brief [24:24] Trigger output selection (output signal ATOM_CH_TRIGOUT[x:x]) of module ATOM channel x. (rw) */
    __IO Ifx_Strict_32Bit SLA:1;           /**< \brief [25:25] "'Serve last' ARU communication strategy, but not applicable in SOMI mode." (rw) */
    __IO Ifx_Strict_32Bit OSM:1;           /**< \brief [26:26] One-shot mode, but not applicable in SOMI mode. (rw) */
    __IO Ifx_Strict_32Bit ABM:1;           /**< \brief [27:27] ARU blocking mode, but not applicable in SOMI mode. (rw) */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [28:28] \internal Reserved */
    __IO Ifx_Strict_32Bit EXT_FUPD:1;      /**< \brief [29:29] External forced update (rw) */
    __IO Ifx_Strict_32Bit SOMB:1;          /**< \brief [30:30] SOMB mode (rw) */
    __IO Ifx_Strict_32Bit FREEZE:1;        /**< \brief [31:31] ATOM freeze mode enable configuration but it is not valid and supported in SOMI mode. (rw) */
} Ifx_EGTM_CLS_ATOM_CH_CTRL_SOMI_Bits;

/** \brief ATOM[i] channel [x] control register */
typedef struct _Ifx_EGTM_CLS_ATOM_CH_CTRL_SOMP_Bits
{
    __IO Ifx_Strict_32Bit MODE:2;          /**< \brief [1:0] ATOM channel mode select (rw) */
    __IO Ifx_Strict_32Bit TB12_SEL:1;      /**< \brief [2:2] Select time base value CCM[i]_TBU_TS1 or CCM[i]_TBU_TS2, but not applicable in SOMP mode. (rw) */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [3:3] \internal Reserved */
    __I  Ifx_Strict_32Bit :2;              /**< \brief [5:4] \internal Reserved */
    __IO Ifx_Strict_32Bit BITREV:1;        /**< \brief [6:6] PCM mode enable (rw) */
    __IO Ifx_Strict_32Bit SR0_TRIG:1;      /**< \brief [7:7] SR0 used for ATOM_OUT_T of instance i and channel x (rw) */
    __IO Ifx_Strict_32Bit ACB4:1;          /**< \brief [8:8] ATOM output control, but not applicable in SOMP mode. (rw) */
    __IO Ifx_Strict_32Bit CMP_CTRL:1;      /**< \brief [9:9] CCU[x] compare strategy selection, but not applicable in SOMP mode. (rw) */
    __IO Ifx_Strict_32Bit EUPM:1;          /**< \brief [10:10] Extended update mode, but not applicable in SOMP mode. (rw) */
    __IO Ifx_Strict_32Bit SL:1;            /**< \brief [11:11] Initial signal level. (rwh) */
    __IO Ifx_Strict_32Bit CLK_SRC:4;       /**< \brief [15:12] CMU clock source for SOMP mode (rwh) */
    __IO Ifx_Strict_32Bit WR_REQ:1;        /**< \brief [16:16] CPU Write request bit for late compare register update, but not applicable in SOMP mode. (rw) */
    __IO Ifx_Strict_32Bit TRIG_PULSE:1;    /**< \brief [17:17] Trigger output pulse length of one cluster clock period (rw) */
    __IO Ifx_Strict_32Bit UDMODE:2;        /**< \brief [19:18] Up/down counter mode (rw) */
    __IO Ifx_Strict_32Bit RST_CCU0:1;      /**< \brief [20:20] Reset source of CCU0 (rw) */
    __IO Ifx_Strict_32Bit OSM_TRIG:1;      /**< \brief [21:21] Enable trigger of one-shot pulse by trigger signal ATOM_CH_TRIGOUT[x-1:x-1] or EXT_TRIGIN[x:x] (rw) */
    __IO Ifx_Strict_32Bit EXT_TRIG:1;      /**< \brief [22:22] Select EXT_TRIGIN[x:x] as trigger signal (rw) */
    __IO Ifx_Strict_32Bit EXTTRIGOUT:1;    /**< \brief [23:23] Select EXT_TRIGIN[x:x] as potential output signal ATOM_CH_TRIGOUT[x:x] (rw) */
    __IO Ifx_Strict_32Bit TRIGOUT:1;       /**< \brief [24:24] Trigger output selection (output signal ATOM_CH_TRIGOUT[x:x]) of module ATOM [i] channel [x]. (rw) */
    __IO Ifx_Strict_32Bit SLA:1;           /**< \brief [25:25] "'Serve last' ARU communication strategy, but not applicable in SOMP mode." (rw) */
    __IO Ifx_Strict_32Bit OSM:1;           /**< \brief [26:26] One-shot mode (rw) */
    __IO Ifx_Strict_32Bit ABM:1;           /**< \brief [27:27] ARU blocking mode, but not applicable in SOMP mode. (rw) */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [28:28] \internal Reserved */
    __IO Ifx_Strict_32Bit EXT_FUPD:1;      /**< \brief [29:29] External forced update (rw) */
    __IO Ifx_Strict_32Bit SOMB:1;          /**< \brief [30:30] SOMB mode (rw) */
    __IO Ifx_Strict_32Bit FREEZE:1;        /**< \brief [31:31] ATOM Freeze Mode enable (rw) */
} Ifx_EGTM_CLS_ATOM_CH_CTRL_SOMP_Bits;

/** \brief ATOM[i] channel [x] control register */
typedef struct _Ifx_EGTM_CLS_ATOM_CH_CTRL_SOMS_Bits
{
    __IO Ifx_Strict_32Bit MODE:2;          /**< \brief [1:0] ATOM channel mode select. (rw) */
    __IO Ifx_Strict_32Bit TB12_SEL:1;      /**< \brief [2:2] Select time base value CCM[i]_TBU_TS1 or CCM[i]_TBU_TS2, but not applicable in SOMS mode. (rw) */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [3:3] \internal Reserved */
    __IO Ifx_Strict_32Bit ACB0:1;          /**< \brief [4:4] Shift direction (rw) */
    __IO Ifx_Strict_32Bit ACB21:2;         /**< \brief [6:5] ATOM output control, but not applicable in SOMS mode. (rw) */
    __IO Ifx_Strict_32Bit DSO:1;           /**< \brief [7:7] Double shift output (rw) */
    __IO Ifx_Strict_32Bit ACB4:1;          /**< \brief [8:8] ATOM output control, but not applicable in SOMS mode. (rw) */
    __IO Ifx_Strict_32Bit CMP_CTRL:1;      /**< \brief [9:9] CCU[x] compare strategy selection, but not applicable in SOMS mode. (rw) */
    __IO Ifx_Strict_32Bit EUPM:1;          /**< \brief [10:10] Extended update mode, but not applicable in SOMS mode. (rw) */
    __IO Ifx_Strict_32Bit SL:1;            /**< \brief [11:11] Initial signal level. (rw) */
    __IO Ifx_Strict_32Bit CLK_SRC:4;       /**< \brief [15:12] CMU clock source for SOMS mode (rwh) */
    __IO Ifx_Strict_32Bit WR_REQ:1;        /**< \brief [16:16] CPU Write request bit for late compare register update, but not applicable in SOMS mode. (rw) */
    __IO Ifx_Strict_32Bit TRIG_PULSE:1;    /**< \brief [17:17] Trigger output pulse length of one cluster clock period, , but not applicable in SOMS mode. (rw) */
    __IO Ifx_Strict_32Bit UDMODE:2;        /**< \brief [19:18] Up/down counter mode, but not applicable in SOMS mode. (rw) */
    __IO Ifx_Strict_32Bit RST_CCU0:1;      /**< \brief [20:20] Reset source of CCU0, but not applicable in SOMS mode. (rw) */
    __IO Ifx_Strict_32Bit OSM_TRIG:1;      /**< \brief [21:21] Enable trigger of one-shot pulse by trigger signal ATOM_CH_TRIGOUT[x-1:x-1] or EXT_TRIGIN[x:x], but not applicable in SOMS mode. (rw) */
    __IO Ifx_Strict_32Bit EXT_TRIG:1;      /**< \brief [22:22] Select EXT_TRIGIN[x:x] as trigger signal, but not applicable in SOMS mode. (rw) */
    __IO Ifx_Strict_32Bit EXTTRIGOUT:1;    /**< \brief [23:23] Select EXT_TRIGIN[x:x] as potential output signal ATOM_CH_TRIGOUT[x:x] (rw) */
    __IO Ifx_Strict_32Bit TRIGOUT:1;       /**< \brief [24:24] Trigger output selection (output signal ATOM_CH_TRIGOUT[x:x]) of module ATOM channel x. (rw) */
    __IO Ifx_Strict_32Bit SLA:1;           /**< \brief [25:25] "'Serve last' ARU communication strategy, but not applicable in SOMS mode." (rw) */
    __IO Ifx_Strict_32Bit OSM:1;           /**< \brief [26:26] One-shot mode (rw) */
    __IO Ifx_Strict_32Bit ABM:1;           /**< \brief [27:27] ARU blocking mode, but not applicable in SOMS mode. (rw) */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [28:28] \internal Reserved */
    __IO Ifx_Strict_32Bit EXT_FUPD:1;      /**< \brief [29:29] External forced update (rw) */
    __IO Ifx_Strict_32Bit SOMB:1;          /**< \brief [30:30] SOMB mode (rw) */
    __IO Ifx_Strict_32Bit FREEZE:1;        /**< \brief [31:31] ATOM Freeze Mode enable (rw) */
} Ifx_EGTM_CLS_ATOM_CH_CTRL_SOMS_Bits;

/** \brief ATOM[i] channel [x] control shadow register */
typedef struct _Ifx_EGTM_CLS_ATOM_CH_CTRL_SR_Bits
{
    __I  Ifx_Strict_32Bit :11;             /**< \brief [10:0] \internal Reserved */
    __IO Ifx_Strict_32Bit SL_SR:1;         /**< \brief [11:11] Shadow register for ATOM[i]_CH[x]_CTRL.SL (rw) */
    __IO Ifx_Strict_32Bit CLK_SRC_SR:4;    /**< \brief [15:12] Shadow register for ATOM[i]_CH[x]_CTRL.CLK_SRC (rw) */
    __I  Ifx_Strict_32Bit :16;             /**< \brief [31:16] \internal Reserved */
} Ifx_EGTM_CLS_ATOM_CH_CTRL_SR_Bits;

/** \brief ATOM[i] channel [x] interrupt enable register */
typedef struct _Ifx_EGTM_CLS_ATOM_CH_IRQ_EN_Bits
{
    __IO Ifx_Strict_32Bit CCU0TC_IRQ_EN:1;    /**< \brief [0:0] ATOM_CCU0TC[x]_IRQ interrupt enable. (rw) */
    __IO Ifx_Strict_32Bit CCU1TC_IRQ_EN:1;    /**< \brief [1:1] ATOM_CCU1TC[x]_IRQ interrupt enable. (rw) */
    __I  Ifx_Strict_32Bit :30;             /**< \brief [31:2] \internal Reserved */
} Ifx_EGTM_CLS_ATOM_CH_IRQ_EN_Bits;

/** \brief ATOM[i] channel [x] software interrupt generation */
typedef struct _Ifx_EGTM_CLS_ATOM_CH_IRQ_FORCINT_Bits
{
    __IO Ifx_Strict_32Bit TRG_CCU0TC:1;    /**< \brief [0:0] Trigger the bit ATOM[i]_CH[x]_IRQ_NOTIFY.CCU0TC by software. (rw) */
    __IO Ifx_Strict_32Bit TRG_CCU1TC:1;    /**< \brief [1:1] Trigger the bit ATOM[i]_CH[x]_IRQ_NOTIFY.CCU1TC by software. (rw) */
    __I  Ifx_Strict_32Bit :30;             /**< \brief [31:2] \internal Reserved */
} Ifx_EGTM_CLS_ATOM_CH_IRQ_FORCINT_Bits;

/** \brief ATOM[i] channel [x] interrupt mode configuration register */
typedef struct _Ifx_EGTM_CLS_ATOM_CH_IRQ_MODE_Bits
{
    __IO Ifx_Strict_32Bit IRQ_MODE:2;      /**< \brief [1:0] IRQ mode selection (rw) */
    __I  Ifx_Strict_32Bit :30;             /**< \brief [31:2] \internal Reserved */
} Ifx_EGTM_CLS_ATOM_CH_IRQ_MODE_Bits;

/** \brief ATOM[i] channel [x] interrupt notification register */
typedef struct _Ifx_EGTM_CLS_ATOM_CH_IRQ_NOTIFY_Bits
{
    __IO Ifx_Strict_32Bit CCU0TC:1;        /**< \brief [0:0] CCU0 Trigger condition interrupt for channel [x]. (rw1ch) */
    __IO Ifx_Strict_32Bit CCU1TC:1;        /**< \brief [1:1] CCU Trigger condition interrupt for channel [x]. (rw1ch) */
    __I  Ifx_Strict_32Bit :30;             /**< \brief [31:2] \internal Reserved */
} Ifx_EGTM_CLS_ATOM_CH_IRQ_NOTIFY_Bits;

/** \brief ATOM[i] channel [x] CCU0 compare shadow register */
typedef struct _Ifx_EGTM_CLS_ATOM_CH_SR0_Bits
{
    __IO Ifx_Strict_32Bit SR0:24;          /**< \brief [23:0] ATOM channel [x] shadow register SR0. (rwh) */
    __I  Ifx_Strict_32Bit :8;              /**< \brief [31:24] \internal Reserved */
} Ifx_EGTM_CLS_ATOM_CH_SR0_Bits;

/** \brief ATOM[i] channel [x] CCU1 compare shadow register */
typedef struct _Ifx_EGTM_CLS_ATOM_CH_SR1_Bits
{
    __IO Ifx_Strict_32Bit SR1:24;          /**< \brief [23:0] ATOM channel [x] shadow register SR1. (rwh) */
    __I  Ifx_Strict_32Bit :8;              /**< \brief [31:24] \internal Reserved */
} Ifx_EGTM_CLS_ATOM_CH_SR1_Bits;

/** \brief ATOM[i] channel [x] status register */
typedef struct _Ifx_EGTM_CLS_ATOM_CH_STAT_Bits
{
    __I  Ifx_Strict_32Bit OL:1;            /**< \brief [0:0] Output signal level of ATOM_OUT[x:x]. (rh) */
    __I  Ifx_Strict_32Bit :15;             /**< \brief [15:1] \internal Reserved */
    __I  Ifx_Strict_32Bit ACBI:5;          /**< \brief [20:16] ATOM Mode control bits. (rh) */
    __I  Ifx_Strict_32Bit DV:1;            /**< \brief [21:21] Valid ARU Data stored in compare registers. (rh) */
    __IO Ifx_Strict_32Bit WRF:1;           /**< \brief [22:22] Write request of CPU failed for late update. (rw1ch) */
    __I  Ifx_Strict_32Bit DR:1;            /**< \brief [23:23] ARU data rejected flag (rh) */
    __I  Ifx_Strict_32Bit ACBO:5;          /**< \brief [28:24] ATOM Internal status bits. (rh) */
    __IO Ifx_Strict_32Bit OSM_RTF:1;       /**< \brief [29:29] One-shot mode retrigger failed flag. (rw1ch) */
    __I  Ifx_Strict_32Bit :2;              /**< \brief [31:30] \internal Reserved */
} Ifx_EGTM_CLS_ATOM_CH_STAT_Bits;

/** \brief CCM[i] ATOM Output Register */
typedef struct _Ifx_EGTM_CLS_CCM_ATOM_OUT_Bits
{
    __I  Ifx_Strict_32Bit ATOM_I_OUT0:1;    /**< \brief [0:0] Output level snapshot of CCM_ATOM_OUT channel [x] (rh) */
    __I  Ifx_Strict_32Bit ATOM_I_OUT1:1;    /**< \brief [1:1] Output level snapshot of CCM_ATOM_OUT channel [x] (rh) */
    __I  Ifx_Strict_32Bit ATOM_I_OUT2:1;    /**< \brief [2:2] Output level snapshot of CCM_ATOM_OUT channel [x] (rh) */
    __I  Ifx_Strict_32Bit ATOM_I_OUT3:1;    /**< \brief [3:3] Output level snapshot of CCM_ATOM_OUT channel [x] (rh) */
    __I  Ifx_Strict_32Bit ATOM_I_OUT4:1;    /**< \brief [4:4] Output level snapshot of CCM_ATOM_OUT channel [x] (rh) */
    __I  Ifx_Strict_32Bit ATOM_I_OUT5:1;    /**< \brief [5:5] Output level snapshot of CCM_ATOM_OUT channel [x] (rh) */
    __I  Ifx_Strict_32Bit ATOM_I_OUT6:1;    /**< \brief [6:6] Output level snapshot of CCM_ATOM_OUT channel [x] (rh) */
    __I  Ifx_Strict_32Bit ATOM_I_OUT7:1;    /**< \brief [7:7] Output level snapshot of CCM_ATOM_OUT channel [x] (rh) */
    __I  Ifx_Strict_32Bit ATOM_I_OUT_N0:1;    /**< \brief [8:8] Output level snapshot of CCM_ATOM_OUT_N channel [x] (rh) */
    __I  Ifx_Strict_32Bit ATOM_I_OUT_N1:1;    /**< \brief [9:9] Output level snapshot of CCM_ATOM_OUT_N channel [x] (rh) */
    __I  Ifx_Strict_32Bit ATOM_I_OUT_N2:1;    /**< \brief [10:10] Output level snapshot of CCM_ATOM_OUT_N channel [x] (rh) */
    __I  Ifx_Strict_32Bit ATOM_I_OUT_N3:1;    /**< \brief [11:11] Output level snapshot of CCM_ATOM_OUT_N channel [x] (rh) */
    __I  Ifx_Strict_32Bit ATOM_I_OUT_N4:1;    /**< \brief [12:12] Output level snapshot of CCM_ATOM_OUT_N channel [x] (rh) */
    __I  Ifx_Strict_32Bit ATOM_I_OUT_N5:1;    /**< \brief [13:13] Output level snapshot of CCM_ATOM_OUT_N channel [x] (rh) */
    __I  Ifx_Strict_32Bit ATOM_I_OUT_N6:1;    /**< \brief [14:14] Output level snapshot of CCM_ATOM_OUT_N channel [x] (rh) */
    __I  Ifx_Strict_32Bit ATOM_I_OUT_N7:1;    /**< \brief [15:15] Output level snapshot of CCM_ATOM_OUT_N channel [x] (rh) */
    __I  Ifx_Strict_32Bit ATOM_IP1_OUT0:1;    /**< \brief [16:16] Output level snapshot of ATOM[i+1]_OUT channel [x] (rh) */
    __I  Ifx_Strict_32Bit ATOM_IP1_OUT1:1;    /**< \brief [17:17] Output level snapshot of ATOM[i+1]_OUT channel [x] (rh) */
    __I  Ifx_Strict_32Bit ATOM_IP1_OUT2:1;    /**< \brief [18:18] Output level snapshot of ATOM[i+1]_OUT channel [x] (rh) */
    __I  Ifx_Strict_32Bit ATOM_IP1_OUT3:1;    /**< \brief [19:19] Output level snapshot of ATOM[i+1]_OUT channel [x] (rh) */
    __I  Ifx_Strict_32Bit ATOM_IP1_OUT4:1;    /**< \brief [20:20] Output level snapshot of ATOM[i+1]_OUT channel [x] (rh) */
    __I  Ifx_Strict_32Bit ATOM_IP1_OUT5:1;    /**< \brief [21:21] Output level snapshot of ATOM[i+1]_OUT channel [x] (rh) */
    __I  Ifx_Strict_32Bit ATOM_IP1_OUT6:1;    /**< \brief [22:22] Output level snapshot of ATOM[i+1]_OUT channel [x] (rh) */
    __I  Ifx_Strict_32Bit ATOM_IP1_OUT7:1;    /**< \brief [23:23] Output level snapshot of ATOM[i+1]_OUT channel [x] (rh) */
    __I  Ifx_Strict_32Bit ATOM_IP1_OUT_N0:1;    /**< \brief [24:24] Output level snapshot of CCM_ATOM_OUT[x:x] of instance i+1 channel x (rh) */
    __I  Ifx_Strict_32Bit ATOM_IP1_OUT_N1:1;    /**< \brief [25:25] Output level snapshot of CCM_ATOM_OUT[x:x] of instance i+1 channel x (rh) */
    __I  Ifx_Strict_32Bit ATOM_IP1_OUT_N2:1;    /**< \brief [26:26] Output level snapshot of CCM_ATOM_OUT[x:x] of instance i+1 channel x (rh) */
    __I  Ifx_Strict_32Bit ATOM_IP1_OUT_N3:1;    /**< \brief [27:27] Output level snapshot of CCM_ATOM_OUT[x:x] of instance i+1 channel x (rh) */
    __I  Ifx_Strict_32Bit ATOM_IP1_OUT_N4:1;    /**< \brief [28:28] Output level snapshot of CCM_ATOM_OUT[x:x] of instance i+1 channel x (rh) */
    __I  Ifx_Strict_32Bit ATOM_IP1_OUT_N5:1;    /**< \brief [29:29] Output level snapshot of CCM_ATOM_OUT[x:x] of instance i+1 channel x (rh) */
    __I  Ifx_Strict_32Bit ATOM_IP1_OUT_N6:1;    /**< \brief [30:30] Output level snapshot of CCM_ATOM_OUT[x:x] of instance i+1 channel x (rh) */
    __I  Ifx_Strict_32Bit ATOM_IP1_OUT_N7:1;    /**< \brief [31:31] Output level snapshot of CCM_ATOM_OUT[x:x] of instance i+1 channel x (rh) */
} Ifx_EGTM_CLS_CCM_ATOM_OUT_Bits;

/** \brief CCM[i] Configuration Register */
typedef struct _Ifx_EGTM_CLS_CCM_CFG_Bits
{
    __IO Ifx_Strict_32Bit EN_TIM:1;        /**< \brief [0:0] Enable TIM (rwh) */
    __IO Ifx_Strict_32Bit EN_TOM_SPE_TDTM:1;    /**< \brief [1:1] Enable TOM, SPE and TDTM (rwh) */
    __IO Ifx_Strict_32Bit EN_ATOM_ADTM:1;    /**< \brief [2:2] Enable ATOM and ADTM (rwh) */
    __I  Ifx_Strict_32Bit :4;              /**< \brief [6:3] \internal Reserved */
    __IO Ifx_Strict_32Bit EN_CMP_MON:1;    /**< \brief [7:7] Enable CMP and MON (rwh) */
    __I  Ifx_Strict_32Bit :8;              /**< \brief [15:8] \internal Reserved */
    __I  Ifx_Strict_32Bit CLS_CLK_DIV:2;    /**< \brief [17:16] Cluster Clock Divider (rh) */
    __I  Ifx_Strict_32Bit :12;             /**< \brief [29:18] \internal Reserved */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [30:30] \internal Reserved */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [31:31] \internal Reserved */
} Ifx_EGTM_CLS_CCM_CFG_Bits;

/** \brief CCM[i] CMU Clock Configuration Register */
typedef struct _Ifx_EGTM_CLS_CCM_CMU_CLK_CFG_Bits
{
    __IO Ifx_Strict_32Bit CLK0_SRC:2;      /**< \brief [1:0] Clock [y] source signal selector (rwh) */
    __I  Ifx_Strict_32Bit :2;              /**< \brief [3:2] \internal Reserved */
    __IO Ifx_Strict_32Bit CLK1_SRC:2;      /**< \brief [5:4] Clock [y] source signal selector (rwh) */
    __I  Ifx_Strict_32Bit :2;              /**< \brief [7:6] \internal Reserved */
    __IO Ifx_Strict_32Bit CLK2_SRC:2;      /**< \brief [9:8] Clock [y] source signal selector (rwh) */
    __I  Ifx_Strict_32Bit :2;              /**< \brief [11:10] \internal Reserved */
    __IO Ifx_Strict_32Bit CLK3_SRC:2;      /**< \brief [13:12] Clock [y] source signal selector (rwh) */
    __I  Ifx_Strict_32Bit :2;              /**< \brief [15:14] \internal Reserved */
    __IO Ifx_Strict_32Bit CLK4_SRC:2;      /**< \brief [17:16] Clock [y] source signal selector (rwh) */
    __I  Ifx_Strict_32Bit :2;              /**< \brief [19:18] \internal Reserved */
    __IO Ifx_Strict_32Bit CLK5_SRC:2;      /**< \brief [21:20] Clock [y] source signal selector (rwh) */
    __I  Ifx_Strict_32Bit :2;              /**< \brief [23:22] \internal Reserved */
    __IO Ifx_Strict_32Bit CLK6_SRC:2;      /**< \brief [25:24] Clock [y] source signal selector (rwh) */
    __I  Ifx_Strict_32Bit :2;              /**< \brief [27:26] \internal Reserved */
    __IO Ifx_Strict_32Bit CLK7_SRC:2;      /**< \brief [29:28] Clock [y] source signal selector (rwh) */
    __I  Ifx_Strict_32Bit :2;              /**< \brief [31:30] \internal Reserved */
} Ifx_EGTM_CLS_CCM_CMU_CLK_CFG_Bits;

/** \brief CCM[i] CMU Fixed Clock Configuration Register */
typedef struct _Ifx_EGTM_CLS_CCM_CMU_FXCLK_CFG_Bits
{
    __IO Ifx_Strict_32Bit FXCLK0_SRC:4;    /**< \brief [3:0] Fixed clock 0 source signal selector (rwh) */
    __I  Ifx_Strict_32Bit :28;             /**< \brief [31:4] \internal Reserved */
} Ifx_EGTM_CLS_CCM_CMU_FXCLK_CFG_Bits;

/** \brief CCM[i] Hardware Configuration Register */
typedef struct _Ifx_EGTM_CLS_CCM_HW_CONF_Bits
{
    __I  Ifx_Strict_32Bit GRSTEN:1;        /**< \brief [0:0] Global Reset Enable (r) */
    __I  Ifx_Strict_32Bit BRIDGE_MODE_RST:1;    /**< \brief [1:1] Bridge mode after reset (r) */
    __I  Ifx_Strict_32Bit SYNC_INPUT_REG:1;    /**< \brief [2:2] Additional pipelined stage in synchronous bridge mode (r) */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [3:3] \internal Reserved */
    __I  Ifx_Strict_32Bit ATOM_OUT_RST:1;    /**< \brief [4:4] CCM_ATOM_OUT reset level (r) */
    __I  Ifx_Strict_32Bit ATOM_TRIG_CHAIN:3;    /**< \brief [7:5] ATOM trigger chain length without synchronization register (r) */
    __I  Ifx_Strict_32Bit TOM_OUT_RST:1;    /**< \brief [8:8] CCM_TOM_OUT reset level (r) */
    __I  Ifx_Strict_32Bit TOM_TRIG_CHAIN:3;    /**< \brief [11:9] TOM trigger chain length without synchronization register (r) */
    __I  Ifx_Strict_32Bit RAM_INIT_RST:1;    /**< \brief [12:12] RAM initialization from reset (r) */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [13:13] \internal Reserved */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [14:14] \internal Reserved */
    __I  Ifx_Strict_32Bit RESET_ACTIVE:1;    /**< \brief [15:15] Active level of asynchronous reset (r) */
    __I  Ifx_Strict_32Bit IRQ_MODE_LEVEL:1;    /**< \brief [16:16] Signalize availability of Level IRQ mode (r) */
    __I  Ifx_Strict_32Bit IRQ_MODE_PULSE:1;    /**< \brief [17:17] Signalize availability of Pulse IRQ mode (r) */
    __I  Ifx_Strict_32Bit IRQ_MODE_PULSE_NOTIFY:1;    /**< \brief [18:18] Signalize availability of Pulse Notify IRQ mode (r) */
    __I  Ifx_Strict_32Bit IRQ_MODE_SINGLE_PULSE:1;    /**< \brief [19:19] Signalize availability of Single Pulse IRQ mode (r) */
    __I  Ifx_Strict_32Bit ATOM_TRIG_INTCHAIN:4;    /**< \brief [23:20] ATOM internal trigger chain length for pipeline register (r) */
    __I  Ifx_Strict_32Bit TOM_TRIG_INTCHAIN:5;    /**< \brief [28:24] TOM internal trigger chain length for pipeline register (r) */
    __I  Ifx_Strict_32Bit INT_CLK_EN_GEN:1;    /**< \brief [29:29] Internal clock enable generation (r) */
    __I  Ifx_Strict_32Bit AEI_ADDR_PIPELINE_STAGE:1;    /**< \brief [30:30] Address pipeline stage implemented (r) */
    __I  Ifx_Strict_32Bit AEI_RDATA_PIPELINE_STAGE:1;    /**< \brief [31:31] Read data pipeline stage implemented (r) */
} Ifx_EGTM_CLS_CCM_HW_CONF_Bits;

/** \brief CCM[i] 2. Hardware Configuration Register */
typedef struct _Ifx_EGTM_CLS_CCM_HW_CONF2_Bits
{
    __I  Ifx_Strict_32Bit :8;              /**< \brief [7:0] \internal Reserved */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [8:8] \internal Reserved */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [9:9] \internal Reserved */
    __I  Ifx_Strict_32Bit :6;              /**< \brief [15:10] \internal Reserved */
    __I  Ifx_Strict_32Bit AXIS_DATA_SIZE:1;    /**< \brief [16:16] Defines the data bus width of the AXI slave interface (r) */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [17:17] \internal Reserved */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [18:18] \internal Reserved */
    __I  Ifx_Strict_32Bit :13;             /**< \brief [31:19] \internal Reserved */
} Ifx_EGTM_CLS_CCM_HW_CONF2_Bits;

/** \brief CCM[i] Protection Register */
typedef struct _Ifx_EGTM_CLS_CCM_PROT_Bits
{
    __IO Ifx_Strict_32Bit CLS_PROT:1;      /**< \brief [0:0] Cluster Protection (rw) */
    __I  Ifx_Strict_32Bit :31;             /**< \brief [31:1] \internal Reserved */
} Ifx_EGTM_CLS_CCM_PROT_Bits;

/** \brief CCM[i] TIM AUX Input Source Register */
typedef struct _Ifx_EGTM_CLS_CCM_TIM_AUX_IN_SRC_Bits
{
    __IO Ifx_Strict_32Bit SRC_CH0:1;       /**< \brief [0:0] Defines CCM_AUX_IN source of TIM[i] channel 0 (rw) */
    __IO Ifx_Strict_32Bit SRC_CH1:1;       /**< \brief [1:1] Defines AUX_IN source of TIM[i] channel 1 (rw) */
    __IO Ifx_Strict_32Bit SRC_CH2:1;       /**< \brief [2:2] Defines CCM_AUX_IN source of TIM[i] channel 2 (rw) */
    __IO Ifx_Strict_32Bit SRC_CH3:1;       /**< \brief [3:3] Defines CCM_AUX_IN source of TIM[i] channel 3 (rw) */
    __IO Ifx_Strict_32Bit SRC_CH4:1;       /**< \brief [4:4] Defines CCM_AUX_IN source of TIM[i] channel 4 (rw) */
    __IO Ifx_Strict_32Bit SRC_CH5:1;       /**< \brief [5:5] Defines CCM_AUX_IN source of TIM[i] channel 5 (rw) */
    __IO Ifx_Strict_32Bit SRC_CH6:1;       /**< \brief [6:6] Defines CCM_AUX_IN source of TIM[i] channel 6 (rw) */
    __IO Ifx_Strict_32Bit SRC_CH7:1;       /**< \brief [7:7] Defines CCM_AUX_IN source of TIM[i] channel 7 (rw) */
    __I  Ifx_Strict_32Bit :8;              /**< \brief [15:8] \internal Reserved */
    __IO Ifx_Strict_32Bit SEL_OUT_N_CH0:1;    /**< \brief [16:16] Use DTM_OUT[q] or DTM_OUT[q]_N signals as CCM_AUX_IN source of TIM[i] channel [x] (rw) */
    __IO Ifx_Strict_32Bit SEL_OUT_N_CH1:1;    /**< \brief [17:17] Use DTM_OUT[q] or DTM_OUT[q]_N signals as CCM_AUX_IN source of TIM[i] channel [x] (rw) */
    __IO Ifx_Strict_32Bit SEL_OUT_N_CH2:1;    /**< \brief [18:18] Use DTM_OUT[q] or DTM_OUT[q]_N signals as CCM_AUX_IN source of TIM[i] channel [x] (rw) */
    __IO Ifx_Strict_32Bit SEL_OUT_N_CH3:1;    /**< \brief [19:19] Use DTM_OUT[q] or DTM_OUT[q]_N signals as CCM_AUX_IN source of TIM[i] channel [x] (rw) */
    __IO Ifx_Strict_32Bit SEL_OUT_N_CH4:1;    /**< \brief [20:20] Use DTM_OUT[q] or DTM_OUT[q]_N signals as CCM_AUX_IN source of TIM[i] channel [x] (rw) */
    __IO Ifx_Strict_32Bit SEL_OUT_N_CH5:1;    /**< \brief [21:21] Use DTM_OUT[q] or DTM_OUT[q]_N signals as CCM_AUX_IN source of TIM[i] channel [x] (rw) */
    __IO Ifx_Strict_32Bit SEL_OUT_N_CH6:1;    /**< \brief [22:22] Use DTM_OUT[q] or DTM_OUT[q]_N signals as CCM_AUX_IN source of TIM[i] channel [x] (rw) */
    __IO Ifx_Strict_32Bit SEL_OUT_N_CH7:1;    /**< \brief [23:23] Use DTM_OUT[q] or DTM_OUT[q]_N signals as CCM_AUX_IN source of TIM[i] channel [x] (rw) */
    __I  Ifx_Strict_32Bit :8;              /**< \brief [31:24] \internal Reserved */
} Ifx_EGTM_CLS_CCM_TIM_AUX_IN_SRC_Bits;

/** \brief CCM[i] TOM Output Register */
typedef struct _Ifx_EGTM_CLS_CCM_TOM_OUT_Bits
{
    __I  Ifx_Strict_32Bit TOM_OUT0:1;      /**< \brief [0:0] Output level snapshot of CCM_TOM_OUT channel [x] (rh) */
    __I  Ifx_Strict_32Bit TOM_OUT1:1;      /**< \brief [1:1] Output level snapshot of CCM_TOM_OUT channel [x] (rh) */
    __I  Ifx_Strict_32Bit TOM_OUT2:1;      /**< \brief [2:2] Output level snapshot of CCM_TOM_OUT channel [x] (rh) */
    __I  Ifx_Strict_32Bit TOM_OUT3:1;      /**< \brief [3:3] Output level snapshot of CCM_TOM_OUT channel [x] (rh) */
    __I  Ifx_Strict_32Bit TOM_OUT4:1;      /**< \brief [4:4] Output level snapshot of CCM_TOM_OUT channel [x] (rh) */
    __I  Ifx_Strict_32Bit TOM_OUT5:1;      /**< \brief [5:5] Output level snapshot of CCM_TOM_OUT channel [x] (rh) */
    __I  Ifx_Strict_32Bit TOM_OUT6:1;      /**< \brief [6:6] Output level snapshot of CCM_TOM_OUT channel [x] (rh) */
    __I  Ifx_Strict_32Bit TOM_OUT7:1;      /**< \brief [7:7] Output level snapshot of CCM_TOM_OUT channel [x] (rh) */
    __I  Ifx_Strict_32Bit TOM_OUT8:1;      /**< \brief [8:8] Output level snapshot of CCM_TOM_OUT channel [x] (rh) */
    __I  Ifx_Strict_32Bit TOM_OUT9:1;      /**< \brief [9:9] Output level snapshot of CCM_TOM_OUT channel [x] (rh) */
    __I  Ifx_Strict_32Bit TOM_OUT10:1;     /**< \brief [10:10] Output level snapshot of CCM_TOM_OUT channel [x] (rh) */
    __I  Ifx_Strict_32Bit TOM_OUT11:1;     /**< \brief [11:11] Output level snapshot of CCM_TOM_OUT channel [x] (rh) */
    __I  Ifx_Strict_32Bit TOM_OUT12:1;     /**< \brief [12:12] Output level snapshot of CCM_TOM_OUT channel [x] (rh) */
    __I  Ifx_Strict_32Bit TOM_OUT13:1;     /**< \brief [13:13] Output level snapshot of CCM_TOM_OUT channel [x] (rh) */
    __I  Ifx_Strict_32Bit TOM_OUT14:1;     /**< \brief [14:14] Output level snapshot of CCM_TOM_OUT channel [x] (rh) */
    __I  Ifx_Strict_32Bit TOM_OUT15:1;     /**< \brief [15:15] Output level snapshot of CCM_TOM_OUT channel [x] (rh) */
    __I  Ifx_Strict_32Bit TOM_OUT_N0:1;    /**< \brief [16:16] Output level snapshot of CCM_TOM_OUT_N channel [x] (rh) */
    __I  Ifx_Strict_32Bit TOM_OUT_N1:1;    /**< \brief [17:17] Output level snapshot of CCM_TOM_OUT_N channel [x] (rh) */
    __I  Ifx_Strict_32Bit TOM_OUT_N2:1;    /**< \brief [18:18] Output level snapshot of CCM_TOM_OUT_N channel [x] (rh) */
    __I  Ifx_Strict_32Bit TOM_OUT_N3:1;    /**< \brief [19:19] Output level snapshot of CCM_TOM_OUT_N channel [x] (rh) */
    __I  Ifx_Strict_32Bit TOM_OUT_N4:1;    /**< \brief [20:20] Output level snapshot of CCM_TOM_OUT_N channel [x] (rh) */
    __I  Ifx_Strict_32Bit TOM_OUT_N5:1;    /**< \brief [21:21] Output level snapshot of CCM_TOM_OUT_N channel [x] (rh) */
    __I  Ifx_Strict_32Bit TOM_OUT_N6:1;    /**< \brief [22:22] Output level snapshot of CCM_TOM_OUT_N channel [x] (rh) */
    __I  Ifx_Strict_32Bit TOM_OUT_N7:1;    /**< \brief [23:23] Output level snapshot of CCM_TOM_OUT_N channel [x] (rh) */
    __I  Ifx_Strict_32Bit TOM_OUT_N8:1;    /**< \brief [24:24] Output level snapshot of CCM_TOM_OUT_N channel [x] (rh) */
    __I  Ifx_Strict_32Bit TOM_OUT_N9:1;    /**< \brief [25:25] Output level snapshot of CCM_TOM_OUT_N channel [x] (rh) */
    __I  Ifx_Strict_32Bit TOM_OUT_N10:1;    /**< \brief [26:26] Output level snapshot of CCM_TOM_OUT_N channel [x] (rh) */
    __I  Ifx_Strict_32Bit TOM_OUT_N11:1;    /**< \brief [27:27] Output level snapshot of CCM_TOM_OUT_N channel [x] (rh) */
    __I  Ifx_Strict_32Bit TOM_OUT_N12:1;    /**< \brief [28:28] Output level snapshot of CCM_TOM_OUT_N channel [x] (rh) */
    __I  Ifx_Strict_32Bit TOM_OUT_N13:1;    /**< \brief [29:29] Output level snapshot of CCM_TOM_OUT_N channel [x] (rh) */
    __I  Ifx_Strict_32Bit TOM_OUT_N14:1;    /**< \brief [30:30] Output level snapshot of CCM_TOM_OUT_N channel [x] (rh) */
    __I  Ifx_Strict_32Bit TOM_OUT_N15:1;    /**< \brief [31:31] Output level snapshot of CCM_TOM_OUT_N channel [x] (rh) */
} Ifx_EGTM_CLS_CCM_TOM_OUT_Bits;

/** \brief CDTM[i]_DTM[d] channel control register 1 */
typedef struct _Ifx_EGTM_CLS_CDTM_DTM_CH_CTRL1_Bits
{
    __IO Ifx_Strict_32Bit O1SEL_0:1;       /**< \brief [0:0] Output 1 select channel 0 (rw) */
    __IO Ifx_Strict_32Bit I1SEL_0:1;       /**< \brief [1:1] Input 1 select channel 0 (rw) */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [2:2] \internal Reserved */
    __IO Ifx_Strict_32Bit SWAP_0:1;        /**< \brief [3:3] Swap outputs DTM_OUT0[0:0] of instance d and DTM_OUT1[0:0] of instance d (before final output register) (rw) */
    __IO Ifx_Strict_32Bit O1F_0:2;         /**< \brief [5:4] Output 1 function channel 0 (rw) */
    __IO Ifx_Strict_32Bit XDT_EN_0_1:1;    /**< \brief [6:6] Cross dead time enable on channel 0 and 1 (rw) */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [7:7] \internal Reserved */
    __IO Ifx_Strict_32Bit O1SEL_1:1;       /**< \brief [8:8] Output 1 select channel 1 (rw) */
    __IO Ifx_Strict_32Bit I1SEL_1:1;       /**< \brief [9:9] Input 1 select channel 1 (rw) */
    __IO Ifx_Strict_32Bit SH_EN_1:1;       /**< \brief [10:10] Shift enable channel 1 (rw) */
    __IO Ifx_Strict_32Bit SWAP_1:1;        /**< \brief [11:11] Swap outputs DTM_OUT0[1:1] of instance d and DTM_OUT1[1:1] of instance d (before final output register) (rw) */
    __IO Ifx_Strict_32Bit O1F_1:2;         /**< \brief [13:12] Output 1 function channel 1 (rw) */
    __I  Ifx_Strict_32Bit :2;              /**< \brief [15:14] \internal Reserved */
    __IO Ifx_Strict_32Bit O1SEL_2:1;       /**< \brief [16:16] Output 1 select channel 2 (rw) */
    __IO Ifx_Strict_32Bit I1SEL_2:1;       /**< \brief [17:17] Input 1 select channel 2 (rw) */
    __IO Ifx_Strict_32Bit SH_EN_2:1;       /**< \brief [18:18] Shift enable channel 2 (rw) */
    __IO Ifx_Strict_32Bit SWAP_2:1;        /**< \brief [19:19] Swap outputs DTM_OUT0[2:2] of instance d and DTM_OUT1[2:2] of instance d (before final output register) (rw) */
    __IO Ifx_Strict_32Bit O1F_2:2;         /**< \brief [21:20] Output 1 function channel 2 (rw) */
    __IO Ifx_Strict_32Bit XDT_EN_2_3:1;    /**< \brief [22:22] Cross dead time enable on channel 2 and 3 (rw) */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [23:23] \internal Reserved */
    __IO Ifx_Strict_32Bit O1SEL_3:1;       /**< \brief [24:24] Output 1 select channel 3 (rw) */
    __IO Ifx_Strict_32Bit I1SEL_3:1;       /**< \brief [25:25] Input 1 select channel 3 (rw) */
    __IO Ifx_Strict_32Bit SH_EN_3:1;       /**< \brief [26:26] Shift enable channel 3 (rw) */
    __IO Ifx_Strict_32Bit SWAP_3:1;        /**< \brief [27:27] Swap outputs DTM_OUT0[3:3] of instance d and DTM_OUT1[3:3] of instance d (before final output register) (rw) */
    __IO Ifx_Strict_32Bit O1F_3:2;         /**< \brief [29:28] Output 1 function channel 3 (rw) */
    __I  Ifx_Strict_32Bit :2;              /**< \brief [31:30] \internal Reserved */
} Ifx_EGTM_CLS_CDTM_DTM_CH_CTRL1_Bits;

/** \brief CDTM[i]_DTM[d] channel control register 2 */
typedef struct _Ifx_EGTM_CLS_CDTM_DTM_CH_CTRL2_Bits
{
    __IO Ifx_Strict_32Bit POL0_0:1;        /**< \brief [0:0] Polarity on output 0 channel 0 (rwh) */
    __IO Ifx_Strict_32Bit OC0_0:1;         /**< \brief [1:1] Output 0 control channel 0 (rwh) */
    __IO Ifx_Strict_32Bit SL0_0:1;         /**< \brief [2:2] Signal level on output 0 channel 0 (rwh) */
    __IO Ifx_Strict_32Bit DT0_0:1;         /**< \brief [3:3] Dead time path enable on output 0 channel 0 (rwh) */
    __IO Ifx_Strict_32Bit POL1_0:1;        /**< \brief [4:4] Polarity on output 1 channel 0 (rwh) */
    __IO Ifx_Strict_32Bit OC1_0:1;         /**< \brief [5:5] Output 1 control channel 0 (rwh) */
    __IO Ifx_Strict_32Bit SL1_0:1;         /**< \brief [6:6] Signal level on output 1 channel 0 (rwh) */
    __IO Ifx_Strict_32Bit DT1_0:1;         /**< \brief [7:7] Dead time path enable on output 1 channel 0 (rwh) */
    __IO Ifx_Strict_32Bit POL0_1:1;        /**< \brief [8:8] Polarity on output 0 channel 1 (rwh) */
    __IO Ifx_Strict_32Bit OC0_1:1;         /**< \brief [9:9] Output 0 control channel 1 (rwh) */
    __IO Ifx_Strict_32Bit SL0_1:1;         /**< \brief [10:10] Signal level on output 0 channel 1 (rwh) */
    __IO Ifx_Strict_32Bit DT0_1:1;         /**< \brief [11:11] Dead time path enable on output 0 channel 1 (rwh) */
    __IO Ifx_Strict_32Bit POL1_1:1;        /**< \brief [12:12] Polarity on output 1 channel 1 (rwh) */
    __IO Ifx_Strict_32Bit OC1_1:1;         /**< \brief [13:13] Output 1 control channel 1 (rwh) */
    __IO Ifx_Strict_32Bit SL1_1:1;         /**< \brief [14:14] Signal level on output 1 channel 1 (rwh) */
    __IO Ifx_Strict_32Bit DT1_1:1;         /**< \brief [15:15] Dead time path enable on output 1 channel 1 (rwh) */
    __IO Ifx_Strict_32Bit POL0_2:1;        /**< \brief [16:16] Polarity on output 0 channel 2 (rwh) */
    __IO Ifx_Strict_32Bit OC0_2:1;         /**< \brief [17:17] Output 0 control channel 2 (rwh) */
    __IO Ifx_Strict_32Bit SL0_2:1;         /**< \brief [18:18] Signal level on output 0 channel 2 (rwh) */
    __IO Ifx_Strict_32Bit DT0_2:1;         /**< \brief [19:19] Dead time path enable on output 0 channel 2 (rwh) */
    __IO Ifx_Strict_32Bit POL1_2:1;        /**< \brief [20:20] Polarity on output 1 channel 2 (rwh) */
    __IO Ifx_Strict_32Bit OC1_2:1;         /**< \brief [21:21] Output 1 control channel 2 (rwh) */
    __IO Ifx_Strict_32Bit SL1_2:1;         /**< \brief [22:22] Signal level on output 1 channel 2 (rwh) */
    __IO Ifx_Strict_32Bit DT1_2:1;         /**< \brief [23:23] Dead time path enable on output 1 channel 2 (rwh) */
    __IO Ifx_Strict_32Bit POL0_3:1;        /**< \brief [24:24] Polarity on output 0 channel 3 (rwh) */
    __IO Ifx_Strict_32Bit OC0_3:1;         /**< \brief [25:25] Output 0 control channel 3 (rwh) */
    __IO Ifx_Strict_32Bit SL0_3:1;         /**< \brief [26:26] Signal level on output 0 channel 3 (rwh) */
    __IO Ifx_Strict_32Bit DT0_3:1;         /**< \brief [27:27] Dead time path enable on output 0 channel 3 (rwh) */
    __IO Ifx_Strict_32Bit POL1_3:1;        /**< \brief [28:28] Polarity on output 1 channel 3 (rwh) */
    __IO Ifx_Strict_32Bit OC1_3:1;         /**< \brief [29:29] Output 1 control channel 3 (rwh) */
    __IO Ifx_Strict_32Bit SL1_3:1;         /**< \brief [30:30] Signal level on output 1 channel 3 (rwh) */
    __IO Ifx_Strict_32Bit DT1_3:1;         /**< \brief [31:31] Dead time path enable on output 1 channel 3 (rwh) */
} Ifx_EGTM_CLS_CDTM_DTM_CH_CTRL2_Bits;

/** \brief CDTM[i] DTM[j] channel control register 2 shadow */
typedef struct _Ifx_EGTM_CLS_CDTM_DTM_CH_CTRL2_SR_Bits
{
    __IO Ifx_Strict_32Bit POL0_0_SR:1;     /**< \brief [0:0] Polarity on output 0 channel 0 shadow register (rw) */
    __IO Ifx_Strict_32Bit OC0_0_SR:1;      /**< \brief [1:1] Output 0 control channel 0 shadow register (rw) */
    __IO Ifx_Strict_32Bit SL0_0_SR:1;      /**< \brief [2:2] Signal level on output 0 channel 0 shadow register (rwh) */
    __IO Ifx_Strict_32Bit DT0_0_SR:1;      /**< \brief [3:3] Dead time path enable on output 0 channel 0 shadow register (rw) */
    __IO Ifx_Strict_32Bit POL1_0_SR:1;     /**< \brief [4:4] Polarity on output 1 channel 0 shadow register (rw) */
    __IO Ifx_Strict_32Bit OC1_0_SR:1;      /**< \brief [5:5] Output 1 control channel 0 shadow register (rw) */
    __IO Ifx_Strict_32Bit SL1_0_SR:1;      /**< \brief [6:6] Signal level on output 1 channel 0 shadow register (rwh) */
    __IO Ifx_Strict_32Bit DT1_0_SR:1;      /**< \brief [7:7] Dead time path enable on output 1 channel 0 shadow register (rw) */
    __IO Ifx_Strict_32Bit POL0_1_SR:1;     /**< \brief [8:8] Polarity on output 0 channel 1 shadow register (rw) */
    __IO Ifx_Strict_32Bit OC0_1_SR:1;      /**< \brief [9:9] Output 0 control channel 1 shadow register (rw) */
    __IO Ifx_Strict_32Bit SL0_1_SR:1;      /**< \brief [10:10] Signal level on output 0 channel 1 shadow register (rwh) */
    __IO Ifx_Strict_32Bit DT0_1_SR:1;      /**< \brief [11:11] Dead time path enable on output 0 channel 1 shadow register (rw) */
    __IO Ifx_Strict_32Bit POL1_1_SR:1;     /**< \brief [12:12] Polarity on output 1 channel 1 shadow register (rw) */
    __IO Ifx_Strict_32Bit OC1_1_SR:1;      /**< \brief [13:13] Output 1 control channel 1 shadow register (rw) */
    __IO Ifx_Strict_32Bit SL1_1_SR:1;      /**< \brief [14:14] Signal level on output 1 channel 1 shadow register (rwh) */
    __IO Ifx_Strict_32Bit DT1_1_SR:1;      /**< \brief [15:15] Dead time path enable on output 1 channel 1 shadow register (rw) */
    __IO Ifx_Strict_32Bit POL0_2_SR:1;     /**< \brief [16:16] Polarity on output 0 channel 2 shadow register (rw) */
    __IO Ifx_Strict_32Bit OC0_2_SR:1;      /**< \brief [17:17] Output 0 control channel 2 shadow register (rw) */
    __IO Ifx_Strict_32Bit SL0_2_SR:1;      /**< \brief [18:18] Signal level on output 0 channel 2 shadow register (rwh) */
    __IO Ifx_Strict_32Bit DT0_2_SR:1;      /**< \brief [19:19] Dead time path enable on output 0 channel 2 shadow register (rw) */
    __IO Ifx_Strict_32Bit POL1_2_SR:1;     /**< \brief [20:20] Polarity on output 1 channel 2 shadow register (rw) */
    __IO Ifx_Strict_32Bit OC1_2_SR:1;      /**< \brief [21:21] Output 1 control channel 2 shadow register (rw) */
    __IO Ifx_Strict_32Bit SL1_2_SR:1;      /**< \brief [22:22] Signal level on output 1 channel 2 shadow register (rwh) */
    __IO Ifx_Strict_32Bit DT1_2_SR:1;      /**< \brief [23:23] Dead time path enable on output 1 channel 2 shadow register (rw) */
    __IO Ifx_Strict_32Bit POL0_3_SR:1;     /**< \brief [24:24] Polarity on output 0 channel 3 shadow register (rw) */
    __IO Ifx_Strict_32Bit OC0_3_SR:1;      /**< \brief [25:25] Output 0 control channel 3 shadow register (rw) */
    __IO Ifx_Strict_32Bit SL0_3_SR:1;      /**< \brief [26:26] Signal level on output 0 channel 3 shadow register (rwh) */
    __IO Ifx_Strict_32Bit DT0_3_SR:1;      /**< \brief [27:27] Dead time path enable on output 0 channel 3 shadow register (rw) */
    __IO Ifx_Strict_32Bit POL1_3_SR:1;     /**< \brief [28:28] Polarity on output 1 channel 3 shadow register (rw) */
    __IO Ifx_Strict_32Bit OC1_3_SR:1;      /**< \brief [29:29] Output 1 control channel 3 shadow register (rw) */
    __IO Ifx_Strict_32Bit SL1_3_SR:1;      /**< \brief [30:30] Signal level on output 1 channel 3 shadow register (rwh) */
    __IO Ifx_Strict_32Bit DT1_3_SR:1;      /**< \brief [31:31] Dead time path enable on output 1 channel 3 shadow register (rw) */
} Ifx_EGTM_CLS_CDTM_DTM_CH_CTRL2_SR_Bits;

/** \brief CDTM[i]_DTM[d] channel control register 3 */
typedef struct _Ifx_EGTM_CLS_CDTM_DTM_CH_CTRL3_Bits
{
    __IO Ifx_Strict_32Bit CII0:1;          /**< \brief [0:0] Combinational input invert channel 0 (rw) */
    __IO Ifx_Strict_32Bit CIS0:1;          /**< \brief [1:1] Combinational input select channel 0 (rw) */
    __IO Ifx_Strict_32Bit TSEL0_0:1;       /**< \brief [2:2] Input selection for dead time / edge trigger generation (rw) */
    __IO Ifx_Strict_32Bit TSEL1_0:1;       /**< \brief [3:3] Input selection combinational logic path (rw) */
    __I  Ifx_Strict_32Bit :4;              /**< \brief [7:4] \internal Reserved */
    __IO Ifx_Strict_32Bit CII1:1;          /**< \brief [8:8] Combinational input invert channel 1 (rw) */
    __IO Ifx_Strict_32Bit CIS1:1;          /**< \brief [9:9] Combinational input select channel 1 (rw) */
    __IO Ifx_Strict_32Bit TSEL0_1:1;       /**< \brief [10:10] Input selection for dead time / edge trigger generation (rw) */
    __IO Ifx_Strict_32Bit TSEL1_1:1;       /**< \brief [11:11] Input selection combinational logic path (rw) */
    __I  Ifx_Strict_32Bit :4;              /**< \brief [15:12] \internal Reserved */
    __IO Ifx_Strict_32Bit CII2:1;          /**< \brief [16:16] Combinational input invert channel 2 (rw) */
    __IO Ifx_Strict_32Bit CIS2:1;          /**< \brief [17:17] Combinational input select channel 2 (rw) */
    __IO Ifx_Strict_32Bit TSEL0_2:1;       /**< \brief [18:18] Input selection for dead time / edge trigger generation (rw) */
    __IO Ifx_Strict_32Bit TSEL1_2:1;       /**< \brief [19:19] Input selection combinational logic path (rw) */
    __I  Ifx_Strict_32Bit :4;              /**< \brief [23:20] \internal Reserved */
    __IO Ifx_Strict_32Bit CII3:1;          /**< \brief [24:24] Combinational input invert channel 3 (rw) */
    __IO Ifx_Strict_32Bit CIS3:1;          /**< \brief [25:25] Combinational input select channel 3 (rw) */
    __IO Ifx_Strict_32Bit TSEL0_3:1;       /**< \brief [26:26] Input selection for dead time / edge trigger generation (rw) */
    __IO Ifx_Strict_32Bit TSEL1_3:1;       /**< \brief [27:27] Input selection combinational logic path (rw) */
    __I  Ifx_Strict_32Bit :4;              /**< \brief [31:28] \internal Reserved */
} Ifx_EGTM_CLS_CDTM_DTM_CH_CTRL3_Bits;

/** \brief CDTM[i]_DTM[d] channel [x] dead time reload values */
typedef struct _Ifx_EGTM_CLS_CDTM_DTM_CH_DTV_Bits
{
    __IO Ifx_Strict_32Bit RELRISE:13;      /**< \brief [12:0] Reload value for rising edge dead time (rwh) */
    __I  Ifx_Strict_32Bit :3;              /**< \brief [15:13] \internal Reserved */
    __IO Ifx_Strict_32Bit RELFALL:13;      /**< \brief [28:16] Reload value for falling edge dead time (rwh) */
    __I  Ifx_Strict_32Bit :2;              /**< \brief [30:29] \internal Reserved */
    __IO Ifx_Strict_32Bit HRES:1;          /**< \brief [31:31] high resolution PWM support (rw) */
} Ifx_EGTM_CLS_CDTM_DTM_CH_DTV_Bits;

/** \brief CDTM[i]_DTM[d] channel [x] dead time shadow values */
typedef struct _Ifx_EGTM_CLS_CDTM_DTM_CH_DTV_SR_Bits
{
    __IO Ifx_Strict_32Bit RELRISE_SR:13;    /**< \brief [12:0] Shadow value for rising edge dead time (rw) */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [13:13] \internal Reserved */
    __IO Ifx_Strict_32Bit RELRISE_UPD_FE0RE1:1;    /**< \brief [14:14] Control if falling edge or rising edge triggers update of CDTM[i]_DTM[d]_CH[x]_DTV.RELRISE (rw) */
    __IO Ifx_Strict_32Bit RELRISE_UPD_EN:1;    /**< \brief [15:15] Control bit to enable update of CDTM[i]_DTM[d]_CH[x]_DTV.RELRISE (rw) */
    __IO Ifx_Strict_32Bit RELFALL_SR:13;    /**< \brief [28:16] Shadow value for falling edge dead time (rw) */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [29:29] \internal Reserved */
    __IO Ifx_Strict_32Bit RELFALL_UPD_FE0RE1:1;    /**< \brief [30:30] Control if falling edge or rising edge triggers update of CDTM[i]_DTM[d]_CH[x]_DTV.RELFALL (rw) */
    __IO Ifx_Strict_32Bit RELFALL_UPD_EN:1;    /**< \brief [31:31] Control bit to enable update of CDTM[i]_DTM[d]_CH[x]_DTV.RELFALL (rw) */
} Ifx_EGTM_CLS_CDTM_DTM_CH_DTV_SR_Bits;

/** \brief CDTM[i]_DTM[d] channel shadow register */
typedef struct _Ifx_EGTM_CLS_CDTM_DTM_CH_SR_Bits
{
    __IO Ifx_Strict_32Bit SL0_0_SR_SR:1;    /**< \brief [0:0] Shadow register for bit CDTM[i]_DTM[d]_CH_CTRL2_SR.SL0_0_SR (rw) */
    __IO Ifx_Strict_32Bit SL1_0_SR_SR:1;    /**< \brief [1:1] Shadow register for bit CDTM[i]_DTM[d]_CH_CTRL2_SR.SL1_0_SR (rw) */
    __IO Ifx_Strict_32Bit SL0_1_SR_SR:1;    /**< \brief [2:2] Shadow register for bit CDTM[i]_DTM[d]_CH_CTRL2_SR.SL0_1_SR (rw) */
    __IO Ifx_Strict_32Bit SL1_1_SR_SR:1;    /**< \brief [3:3] Shadow register for bit CDTM[i]_DTM[d]_CH_CTRL2_SR.SL1_1_SR (rw) */
    __IO Ifx_Strict_32Bit SL0_2_SR_SR:1;    /**< \brief [4:4] Shadow register for bit CDTM[i]_DTM[d]_CH_CTRL2_SR.SL0_2_SR (rw) */
    __IO Ifx_Strict_32Bit SL1_2_SR_SR:1;    /**< \brief [5:5] Shadow register for bit CDTM[i]_DTM[d]_CH_CTRL2_SR.SL1_2_SR (rw) */
    __IO Ifx_Strict_32Bit SL0_3_SR_SR:1;    /**< \brief [6:6] Shadow register for bit CDTM[i]_DTM[d]_CH_CTRL2_SR.SL0_3_SR (rw) */
    __IO Ifx_Strict_32Bit SL1_3_SR_SR:1;    /**< \brief [7:7] Shadow register for bit CDTM[i]_DTM[d]_CH_CTRL2_SR.SL1_3_SR (rw) */
    __I  Ifx_Strict_32Bit :24;             /**< \brief [31:8] \internal Reserved */
} Ifx_EGTM_CLS_CDTM_DTM_CH_SR_Bits;

/** \brief CDTM[i]_DTM[d] global configuration and control register */
typedef struct _Ifx_EGTM_CLS_CDTM_DTM_CTRL_Bits
{
    __IO Ifx_Strict_32Bit CLK_SEL:2;       /**< \brief [1:0] Clock resolution selection (rw) */
    __IO Ifx_Strict_32Bit DTM_SEL:2;       /**< \brief [3:2] Select DTM update and PSU_SHUT_OFF reset signal (rw) */
    __IO Ifx_Strict_32Bit UPD_MODE:3;      /**< \brief [6:4] Update mode (rw) */
    __IO Ifx_Strict_32Bit CH_SHUTOFF_EN:1;    /**< \brief [7:7] Individual shutoff feature enable (rw) */
    __IO Ifx_Strict_32Bit SR_UPD_EN:1;     /**< \brief [8:8] Shadow register update enable (rw) */
    __I  Ifx_Strict_32Bit :7;              /**< \brief [15:9] \internal Reserved */
    __IO Ifx_Strict_32Bit SHUT_OFF_RST:1;    /**< \brief [16:16] Shut off reset (rw) */
    __I  Ifx_Strict_32Bit :15;             /**< \brief [31:17] \internal Reserved */
} Ifx_EGTM_CLS_CDTM_DTM_CTRL_Bits;

/** \brief CDTM[i]_DTM[d] global configuration and control register 2 */
typedef struct _Ifx_EGTM_CLS_CDTM_DTM_CTRL2_Bits
{
    __IO Ifx_Strict_32Bit SHUTOFF_SEL_0:3;    /**< \brief [2:0] Channel 0: Select input signal to be used as shut off signal. (rw) */
    __IO Ifx_Strict_32Bit SHUTOFF_POL_0:1;    /**< \brief [3:3] Channel 0: Configure if the selected shut off input signal used as shut off output signal is inverted or not. (rw) */
    __IO Ifx_Strict_32Bit UPD_MODE_0:2;    /**< \brief [5:4] Channel 0: Control the update mode of the internal SHUTOFF_SYNC_0 signal. (rw) */
    __IO Ifx_Strict_32Bit SHUT_OFF_RST_0:1;    /**< \brief [6:6] Channel 0: Clear of internal signal SHUTOFF_SYNC_0 if selected as control source. (rw) */
    __IO Ifx_Strict_32Bit WR_EN_0:1;       /**< \brief [7:7] Channel 0: Write enable of Bitfields (rw) */
    __IO Ifx_Strict_32Bit SHUTOFF_SEL_1:3;    /**< \brief [10:8] Channel 1: Select input signal to be used as shut off signal. (rw) */
    __IO Ifx_Strict_32Bit SHUTOFF_POL_1:1;    /**< \brief [11:11] Channel 1: Configure if the selected shut off input signal used as shut off output signal is inverted or not. (rw) */
    __IO Ifx_Strict_32Bit UPD_MODE_1:2;    /**< \brief [13:12] Channel 1: Control the update mode of the internal SHUTOFF_SYNC_1 signal. (rw) */
    __IO Ifx_Strict_32Bit SHUT_OFF_RST_1:1;    /**< \brief [14:14] Channel 1: Clear of internal signal SHUTOFF_SYNC_1 if selected as control source. (rw) */
    __IO Ifx_Strict_32Bit WR_EN_1:1;       /**< \brief [15:15] Channel 1: Write enable of Bitfields (rw) */
    __IO Ifx_Strict_32Bit SHUTOFF_SEL_2:3;    /**< \brief [18:16] Channel 2: Select input signal to be used as shut off signal. (rw) */
    __IO Ifx_Strict_32Bit SHUTOFF_POL_2:1;    /**< \brief [19:19] Channel 2: Configure if the selected shut off input signal used as shut off output signal is inverted or not. (rw) */
    __IO Ifx_Strict_32Bit UPD_MODE_2:2;    /**< \brief [21:20] Channel 2: Control the update mode of the internal SHUTOFF_SYNC_2 signal. (rw) */
    __IO Ifx_Strict_32Bit SHUT_OFF_RST_2:1;    /**< \brief [22:22] Channel 2: Clear of internal signal SHUTOFF_SYNC_2 if selected as control source. (rw) */
    __IO Ifx_Strict_32Bit WR_EN_2:1;       /**< \brief [23:23] Channel 2: Write enable of Bitfields (rw) */
    __IO Ifx_Strict_32Bit SHUTOFF_SEL_3:3;    /**< \brief [26:24] Channel 3: Select input signal to be used as shut off signal. (rw) */
    __IO Ifx_Strict_32Bit SHUTOFF_POL_3:1;    /**< \brief [27:27] Channel 3: Configure if the selected shut off input signal used as shut off output signal is inverted or not. (rw) */
    __IO Ifx_Strict_32Bit UPD_MODE_3:2;    /**< \brief [29:28] Channel 3: Control the update mode of the internal SHUTOFF_SYNC_3 signal. (rw) */
    __IO Ifx_Strict_32Bit SHUT_OFF_RST_3:1;    /**< \brief [30:30] Channel 3: Clear of internal signal SHUTOFF_SYNC_3 if selected as control source. (rw) */
    __IO Ifx_Strict_32Bit WR_EN_3:1;       /**< \brief [31:31] Channel 3: Write enable of Bitfields (rw) */
} Ifx_EGTM_CLS_CDTM_DTM_CTRL2_Bits;

/** \brief CDTM[i]_DTM[d] phase shift unit configuration and control register */
typedef struct _Ifx_EGTM_CLS_CDTM_DTM_PS_CTRL_Bits
{
    __IO Ifx_Strict_32Bit RELBLK:10;       /**< \brief [9:0] Reload value blanking window (rw) */
    __I  Ifx_Strict_32Bit :6;              /**< \brief [15:10] \internal Reserved */
    __IO Ifx_Strict_32Bit PSU_IN_SEL:1;    /**< \brief [16:16] PSU input select (rw) */
    __IO Ifx_Strict_32Bit IN_POL:1;        /**< \brief [17:17] Input polarity (rw) */
    __IO Ifx_Strict_32Bit TIM_SEL:1;       /**< \brief [18:18] TIM input select (rw) */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [19:19] \internal Reserved */
    __IO Ifx_Strict_32Bit SHIFT_SEL:2;     /**< \brief [21:20] Shift select (rw) */
    __I  Ifx_Strict_32Bit :10;             /**< \brief [31:22] \internal Reserved */
} Ifx_EGTM_CLS_CDTM_DTM_PS_CTRL_Bits;

/** \brief CMP error interrupt enable register */
typedef struct _Ifx_EGTM_CLS_CMP_EIRQ_EN_Bits
{
    __IO Ifx_Strict_32Bit ABWC0_EN_EIRQ:1;    /**< \brief [0:0] Enable ABWC comparator [c] interrupt source for CMP_EIRQ line (rw) */
    __IO Ifx_Strict_32Bit ABWC1_EN_EIRQ:1;    /**< \brief [1:1] Enable ABWC comparator [c] interrupt source for CMP_EIRQ line (rw) */
    __IO Ifx_Strict_32Bit ABWC2_EN_EIRQ:1;    /**< \brief [2:2] Enable ABWC comparator [c] interrupt source for CMP_EIRQ line (rw) */
    __IO Ifx_Strict_32Bit ABWC3_EN_EIRQ:1;    /**< \brief [3:3] Enable ABWC comparator [c] interrupt source for CMP_EIRQ line (rw) */
    __IO Ifx_Strict_32Bit ABWC4_EN_EIRQ:1;    /**< \brief [4:4] Enable ABWC comparator [c] interrupt source for CMP_EIRQ line (rw) */
    __IO Ifx_Strict_32Bit ABWC5_EN_EIRQ:1;    /**< \brief [5:5] Enable ABWC comparator [c] interrupt source for CMP_EIRQ line (rw) */
    __IO Ifx_Strict_32Bit ABWC6_EN_EIRQ:1;    /**< \brief [6:6] Enable ABWC comparator [c] interrupt source for CMP_EIRQ line (rw) */
    __IO Ifx_Strict_32Bit ABWC7_EN_EIRQ:1;    /**< \brief [7:7] Enable ABWC comparator [c] interrupt source for CMP_EIRQ line (rw) */
    __IO Ifx_Strict_32Bit ABWC8_EN_EIRQ:1;    /**< \brief [8:8] Enable ABWC comparator [c] interrupt source for CMP_EIRQ line (rw) */
    __IO Ifx_Strict_32Bit ABWC9_EN_EIRQ:1;    /**< \brief [9:9] Enable ABWC comparator [c] interrupt source for CMP_EIRQ line (rw) */
    __IO Ifx_Strict_32Bit ABWC10_EN_EIRQ:1;    /**< \brief [10:10] Enable ABWC comparator [c] interrupt source for CMP_EIRQ line (rw) */
    __IO Ifx_Strict_32Bit ABWC11_EN_EIRQ:1;    /**< \brief [11:11] Enable ABWC comparator [c] interrupt source for CMP_EIRQ line (rw) */
    __IO Ifx_Strict_32Bit TBWC0_EN_EIRQ:1;    /**< \brief [12:12] Enable TBWC comparator [c] interrupt source for CMP_EIRQ line (rw) */
    __IO Ifx_Strict_32Bit TBWC1_EN_EIRQ:1;    /**< \brief [13:13] Enable TBWC comparator [c] interrupt source for CMP_EIRQ line (rw) */
    __IO Ifx_Strict_32Bit TBWC2_EN_EIRQ:1;    /**< \brief [14:14] Enable TBWC comparator [c] interrupt source for CMP_EIRQ line (rw) */
    __IO Ifx_Strict_32Bit TBWC3_EN_EIRQ:1;    /**< \brief [15:15] Enable TBWC comparator [c] interrupt source for CMP_EIRQ line (rw) */
    __IO Ifx_Strict_32Bit TBWC4_EN_EIRQ:1;    /**< \brief [16:16] Enable TBWC comparator [c] interrupt source for CMP_EIRQ line (rw) */
    __IO Ifx_Strict_32Bit TBWC5_EN_EIRQ:1;    /**< \brief [17:17] Enable TBWC comparator [c] interrupt source for CMP_EIRQ line (rw) */
    __IO Ifx_Strict_32Bit TBWC6_EN_EIRQ:1;    /**< \brief [18:18] Enable TBWC comparator [c] interrupt source for CMP_EIRQ line (rw) */
    __IO Ifx_Strict_32Bit TBWC7_EN_EIRQ:1;    /**< \brief [19:19] Enable TBWC comparator [c] interrupt source for CMP_EIRQ line (rw) */
    __IO Ifx_Strict_32Bit TBWC8_EN_EIRQ:1;    /**< \brief [20:20] Enable TBWC comparator [c] interrupt source for CMP_EIRQ line (rw) */
    __IO Ifx_Strict_32Bit TBWC9_EN_EIRQ:1;    /**< \brief [21:21] Enable TBWC comparator [c] interrupt source for CMP_EIRQ line (rw) */
    __IO Ifx_Strict_32Bit TBWC10_EN_EIRQ:1;    /**< \brief [22:22] Enable TBWC comparator [c] interrupt source for CMP_EIRQ line (rw) */
    __IO Ifx_Strict_32Bit TBWC11_EN_EIRQ:1;    /**< \brief [23:23] Enable TBWC comparator [c] interrupt source for CMP_EIRQ line (rw) */
    __I  Ifx_Strict_32Bit :8;              /**< \brief [31:24] \internal Reserved */
} Ifx_EGTM_CLS_CMP_EIRQ_EN_Bits;

/** \brief CMP comparator enable register */
typedef struct _Ifx_EGTM_CLS_CMP_EN_Bits
{
    __IO Ifx_Strict_32Bit ABWC0_EN:1;      /**< \brief [0:0] Enable comparator channel [c] in ABWC (rw) */
    __IO Ifx_Strict_32Bit ABWC1_EN:1;      /**< \brief [1:1] Enable comparator channel [c] in ABWC (rw) */
    __IO Ifx_Strict_32Bit ABWC2_EN:1;      /**< \brief [2:2] Enable comparator channel [c] in ABWC (rw) */
    __IO Ifx_Strict_32Bit ABWC3_EN:1;      /**< \brief [3:3] Enable comparator channel [c] in ABWC (rw) */
    __IO Ifx_Strict_32Bit ABWC4_EN:1;      /**< \brief [4:4] Enable comparator channel [c] in ABWC (rw) */
    __IO Ifx_Strict_32Bit ABWC5_EN:1;      /**< \brief [5:5] Enable comparator channel [c] in ABWC (rw) */
    __IO Ifx_Strict_32Bit ABWC6_EN:1;      /**< \brief [6:6] Enable comparator channel [c] in ABWC (rw) */
    __IO Ifx_Strict_32Bit ABWC7_EN:1;      /**< \brief [7:7] Enable comparator channel [c] in ABWC (rw) */
    __IO Ifx_Strict_32Bit ABWC8_EN:1;      /**< \brief [8:8] Enable comparator channel [c] in ABWC (rw) */
    __IO Ifx_Strict_32Bit ABWC9_EN:1;      /**< \brief [9:9] Enable comparator channel [c] in ABWC (rw) */
    __IO Ifx_Strict_32Bit ABWC10_EN:1;     /**< \brief [10:10] Enable comparator channel [c] in ABWC (rw) */
    __IO Ifx_Strict_32Bit ABWC11_EN:1;     /**< \brief [11:11] Enable comparator channel [c] in ABWC (rw) */
    __IO Ifx_Strict_32Bit TBWC0_EN:1;      /**< \brief [12:12] Enable comparator channel [c] in TBWC (rw) */
    __IO Ifx_Strict_32Bit TBWC1_EN:1;      /**< \brief [13:13] Enable comparator channel [c] in TBWC (rw) */
    __IO Ifx_Strict_32Bit TBWC2_EN:1;      /**< \brief [14:14] Enable comparator channel [c] in TBWC (rw) */
    __IO Ifx_Strict_32Bit TBWC3_EN:1;      /**< \brief [15:15] Enable comparator channel [c] in TBWC (rw) */
    __IO Ifx_Strict_32Bit TBWC4_EN:1;      /**< \brief [16:16] Enable comparator channel [c] in TBWC (rw) */
    __IO Ifx_Strict_32Bit TBWC5_EN:1;      /**< \brief [17:17] Enable comparator channel [c] in TBWC (rw) */
    __IO Ifx_Strict_32Bit TBWC6_EN:1;      /**< \brief [18:18] Enable comparator channel [c] in TBWC (rw) */
    __IO Ifx_Strict_32Bit TBWC7_EN:1;      /**< \brief [19:19] Enable comparator channel [c] in TBWC (rw) */
    __IO Ifx_Strict_32Bit TBWC8_EN:1;      /**< \brief [20:20] Enable comparator channel [c] in TBWC (rw) */
    __IO Ifx_Strict_32Bit TBWC9_EN:1;      /**< \brief [21:21] Enable comparator channel [c] in TBWC (rw) */
    __IO Ifx_Strict_32Bit TBWC10_EN:1;     /**< \brief [22:22] Enable comparator channel [c] in TBWC (rw) */
    __IO Ifx_Strict_32Bit TBWC11_EN:1;     /**< \brief [23:23] Enable comparator channel [c] in TBWC (rw) */
    __I  Ifx_Strict_32Bit :8;              /**< \brief [31:24] \internal Reserved */
} Ifx_EGTM_CLS_CMP_EN_Bits;

/** \brief CMP interrupt enable register */
typedef struct _Ifx_EGTM_CLS_CMP_IRQ_EN_Bits
{
    __IO Ifx_Strict_32Bit ABWC0_EN_IRQ:1;    /**< \brief [0:0] Enable CMP_IRQ_NOTIFY.ABWC[c] interrupt source for CMP_IRQ line (rw) */
    __IO Ifx_Strict_32Bit ABWC1_EN_IRQ:1;    /**< \brief [1:1] Enable CMP_IRQ_NOTIFY.ABWC[c] interrupt source for CMP_IRQ line (rw) */
    __IO Ifx_Strict_32Bit ABWC2_EN_IRQ:1;    /**< \brief [2:2] Enable CMP_IRQ_NOTIFY.ABWC[c] interrupt source for CMP_IRQ line (rw) */
    __IO Ifx_Strict_32Bit ABWC3_EN_IRQ:1;    /**< \brief [3:3] Enable CMP_IRQ_NOTIFY.ABWC[c] interrupt source for CMP_IRQ line (rw) */
    __IO Ifx_Strict_32Bit ABWC4_EN_IRQ:1;    /**< \brief [4:4] Enable CMP_IRQ_NOTIFY.ABWC[c] interrupt source for CMP_IRQ line (rw) */
    __IO Ifx_Strict_32Bit ABWC5_EN_IRQ:1;    /**< \brief [5:5] Enable CMP_IRQ_NOTIFY.ABWC[c] interrupt source for CMP_IRQ line (rw) */
    __IO Ifx_Strict_32Bit ABWC6_EN_IRQ:1;    /**< \brief [6:6] Enable CMP_IRQ_NOTIFY.ABWC[c] interrupt source for CMP_IRQ line (rw) */
    __IO Ifx_Strict_32Bit ABWC7_EN_IRQ:1;    /**< \brief [7:7] Enable CMP_IRQ_NOTIFY.ABWC[c] interrupt source for CMP_IRQ line (rw) */
    __IO Ifx_Strict_32Bit ABWC8_EN_IRQ:1;    /**< \brief [8:8] Enable CMP_IRQ_NOTIFY.ABWC[c] interrupt source for CMP_IRQ line (rw) */
    __IO Ifx_Strict_32Bit ABWC9_EN_IRQ:1;    /**< \brief [9:9] Enable CMP_IRQ_NOTIFY.ABWC[c] interrupt source for CMP_IRQ line (rw) */
    __IO Ifx_Strict_32Bit ABWC10_EN_IRQ:1;    /**< \brief [10:10] Enable CMP_IRQ_NOTIFY.ABWC[c] interrupt source for CMP_IRQ line (rw) */
    __IO Ifx_Strict_32Bit ABWC11_EN_IRQ:1;    /**< \brief [11:11] Enable CMP_IRQ_NOTIFY.ABWC[c] interrupt source for CMP_IRQ line (rw) */
    __IO Ifx_Strict_32Bit TBWC0_EN_IRQ:1;    /**< \brief [12:12] Enable CMP_IRQ_NOTIFY.TBWC[c] interrupt source for CMP_IRQ line (rw) */
    __IO Ifx_Strict_32Bit TBWC1_EN_IRQ:1;    /**< \brief [13:13] Enable CMP_IRQ_NOTIFY.TBWC[c] interrupt source for CMP_IRQ line (rw) */
    __IO Ifx_Strict_32Bit TBWC2_EN_IRQ:1;    /**< \brief [14:14] Enable CMP_IRQ_NOTIFY.TBWC[c] interrupt source for CMP_IRQ line (rw) */
    __IO Ifx_Strict_32Bit TBWC3_EN_IRQ:1;    /**< \brief [15:15] Enable CMP_IRQ_NOTIFY.TBWC[c] interrupt source for CMP_IRQ line (rw) */
    __IO Ifx_Strict_32Bit TBWC4_EN_IRQ:1;    /**< \brief [16:16] Enable CMP_IRQ_NOTIFY.TBWC[c] interrupt source for CMP_IRQ line (rw) */
    __IO Ifx_Strict_32Bit TBWC5_EN_IRQ:1;    /**< \brief [17:17] Enable CMP_IRQ_NOTIFY.TBWC[c] interrupt source for CMP_IRQ line (rw) */
    __IO Ifx_Strict_32Bit TBWC6_EN_IRQ:1;    /**< \brief [18:18] Enable CMP_IRQ_NOTIFY.TBWC[c] interrupt source for CMP_IRQ line (rw) */
    __IO Ifx_Strict_32Bit TBWC7_EN_IRQ:1;    /**< \brief [19:19] Enable CMP_IRQ_NOTIFY.TBWC[c] interrupt source for CMP_IRQ line (rw) */
    __IO Ifx_Strict_32Bit TBWC8_EN_IRQ:1;    /**< \brief [20:20] Enable CMP_IRQ_NOTIFY.TBWC[c] interrupt source for CMP_IRQ line (rw) */
    __IO Ifx_Strict_32Bit TBWC9_EN_IRQ:1;    /**< \brief [21:21] Enable CMP_IRQ_NOTIFY.TBWC[c] interrupt source for CMP_IRQ line (rw) */
    __IO Ifx_Strict_32Bit TBWC10_EN_IRQ:1;    /**< \brief [22:22] Enable CMP_IRQ_NOTIFY.TBWC[c] interrupt source for CMP_IRQ line (rw) */
    __IO Ifx_Strict_32Bit TBWC11_EN_IRQ:1;    /**< \brief [23:23] Enable CMP_IRQ_NOTIFY.TBWC[c] interrupt source for CMP_IRQ line (rw) */
    __I  Ifx_Strict_32Bit :8;              /**< \brief [31:24] \internal Reserved */
} Ifx_EGTM_CLS_CMP_IRQ_EN_Bits;

/** \brief CMP interrupt force register */
typedef struct _Ifx_EGTM_CLS_CMP_IRQ_FORCINT_Bits
{
    __IO Ifx_Strict_32Bit TRG_ABWC0:1;     /**< \brief [0:0] Trigger the bit CMP_IRQ_NOTIFY.ABWC[c] bit by software (rw) */
    __IO Ifx_Strict_32Bit TRG_ABWC1:1;     /**< \brief [1:1] Trigger the bit CMP_IRQ_NOTIFY.ABWC[c] bit by software (rw) */
    __IO Ifx_Strict_32Bit TRG_ABWC2:1;     /**< \brief [2:2] Trigger the bit CMP_IRQ_NOTIFY.ABWC[c] bit by software (rw) */
    __IO Ifx_Strict_32Bit TRG_ABWC3:1;     /**< \brief [3:3] Trigger the bit CMP_IRQ_NOTIFY.ABWC[c] bit by software (rw) */
    __IO Ifx_Strict_32Bit TRG_ABWC4:1;     /**< \brief [4:4] Trigger the bit CMP_IRQ_NOTIFY.ABWC[c] bit by software (rw) */
    __IO Ifx_Strict_32Bit TRG_ABWC5:1;     /**< \brief [5:5] Trigger the bit CMP_IRQ_NOTIFY.ABWC[c] bit by software (rw) */
    __IO Ifx_Strict_32Bit TRG_ABWC6:1;     /**< \brief [6:6] Trigger the bit CMP_IRQ_NOTIFY.ABWC[c] bit by software (rw) */
    __IO Ifx_Strict_32Bit TRG_ABWC7:1;     /**< \brief [7:7] Trigger the bit CMP_IRQ_NOTIFY.ABWC[c] bit by software (rw) */
    __IO Ifx_Strict_32Bit TRG_ABWC8:1;     /**< \brief [8:8] Trigger the bit CMP_IRQ_NOTIFY.ABWC[c] bit by software (rw) */
    __IO Ifx_Strict_32Bit TRG_ABWC9:1;     /**< \brief [9:9] Trigger the bit CMP_IRQ_NOTIFY.ABWC[c] bit by software (rw) */
    __IO Ifx_Strict_32Bit TRG_ABWC10:1;    /**< \brief [10:10] Trigger the bit CMP_IRQ_NOTIFY.ABWC[c] bit by software (rw) */
    __IO Ifx_Strict_32Bit TRG_ABWC11:1;    /**< \brief [11:11] Trigger the bit CMP_IRQ_NOTIFY.ABWC[c] bit by software (rw) */
    __IO Ifx_Strict_32Bit TRG_TBWC0:1;     /**< \brief [12:12] Trigger CMP_IRQ_NOTIFY.TBWC[c] bit by software (rw) */
    __IO Ifx_Strict_32Bit TRG_TBWC1:1;     /**< \brief [13:13] Trigger CMP_IRQ_NOTIFY.TBWC[c] bit by software (rw) */
    __IO Ifx_Strict_32Bit TRG_TBWC2:1;     /**< \brief [14:14] Trigger CMP_IRQ_NOTIFY.TBWC[c] bit by software (rw) */
    __IO Ifx_Strict_32Bit TRG_TBWC3:1;     /**< \brief [15:15] Trigger CMP_IRQ_NOTIFY.TBWC[c] bit by software (rw) */
    __IO Ifx_Strict_32Bit TRG_TBWC4:1;     /**< \brief [16:16] Trigger CMP_IRQ_NOTIFY.TBWC[c] bit by software (rw) */
    __IO Ifx_Strict_32Bit TRG_TBWC5:1;     /**< \brief [17:17] Trigger CMP_IRQ_NOTIFY.TBWC[c] bit by software (rw) */
    __IO Ifx_Strict_32Bit TRG_TBWC6:1;     /**< \brief [18:18] Trigger CMP_IRQ_NOTIFY.TBWC[c] bit by software (rw) */
    __IO Ifx_Strict_32Bit TRG_TBWC7:1;     /**< \brief [19:19] Trigger CMP_IRQ_NOTIFY.TBWC[c] bit by software (rw) */
    __IO Ifx_Strict_32Bit TRG_TBWC8:1;     /**< \brief [20:20] Trigger CMP_IRQ_NOTIFY.TBWC[c] bit by software (rw) */
    __IO Ifx_Strict_32Bit TRG_TBWC9:1;     /**< \brief [21:21] Trigger CMP_IRQ_NOTIFY.TBWC[c] bit by software (rw) */
    __IO Ifx_Strict_32Bit TRG_TBWC10:1;    /**< \brief [22:22] Trigger CMP_IRQ_NOTIFY.TBWC[c] bit by software (rw) */
    __IO Ifx_Strict_32Bit TRG_TBWC11:1;    /**< \brief [23:23] Trigger CMP_IRQ_NOTIFY.TBWC[c] bit by software (rw) */
    __I  Ifx_Strict_32Bit :8;              /**< \brief [31:24] \internal Reserved */
} Ifx_EGTM_CLS_CMP_IRQ_FORCINT_Bits;

/** \brief CMP interrupt mode configuration register */
typedef struct _Ifx_EGTM_CLS_CMP_IRQ_MODE_Bits
{
    __IO Ifx_Strict_32Bit IRQ_MODE:2;      /**< \brief [1:0] IRQ mode selection (rw) */
    __I  Ifx_Strict_32Bit :30;             /**< \brief [31:2] \internal Reserved */
} Ifx_EGTM_CLS_CMP_IRQ_MODE_Bits;

/** \brief CMP event notification register */
typedef struct _Ifx_EGTM_CLS_CMP_IRQ_NOTIFY_Bits
{
    __IO Ifx_Strict_32Bit ABWC0:1;         /**< \brief [0:0] ATOM sub-modules output bitwise comparator [c] error indication (rw1ch) */
    __IO Ifx_Strict_32Bit ABWC1:1;         /**< \brief [1:1] ATOM sub-modules output bitwise comparator [c] error indication (rw1ch) */
    __IO Ifx_Strict_32Bit ABWC2:1;         /**< \brief [2:2] ATOM sub-modules output bitwise comparator [c] error indication (rw1ch) */
    __IO Ifx_Strict_32Bit ABWC3:1;         /**< \brief [3:3] ATOM sub-modules output bitwise comparator [c] error indication (rw1ch) */
    __IO Ifx_Strict_32Bit ABWC4:1;         /**< \brief [4:4] ATOM sub-modules output bitwise comparator [c] error indication (rw1ch) */
    __IO Ifx_Strict_32Bit ABWC5:1;         /**< \brief [5:5] ATOM sub-modules output bitwise comparator [c] error indication (rw1ch) */
    __IO Ifx_Strict_32Bit ABWC6:1;         /**< \brief [6:6] ATOM sub-modules output bitwise comparator [c] error indication (rw1ch) */
    __IO Ifx_Strict_32Bit ABWC7:1;         /**< \brief [7:7] ATOM sub-modules output bitwise comparator [c] error indication (rw1ch) */
    __IO Ifx_Strict_32Bit ABWC8:1;         /**< \brief [8:8] ATOM sub-modules output bitwise comparator [c] error indication (rw1ch) */
    __IO Ifx_Strict_32Bit ABWC9:1;         /**< \brief [9:9] ATOM sub-modules output bitwise comparator [c] error indication (rw1ch) */
    __IO Ifx_Strict_32Bit ABWC10:1;        /**< \brief [10:10] ATOM sub-modules output bitwise comparator [c] error indication (rw1ch) */
    __IO Ifx_Strict_32Bit ABWC11:1;        /**< \brief [11:11] ATOM sub-modules output bitwise comparator [c] error indication (rw1ch) */
    __IO Ifx_Strict_32Bit TBWC0:1;         /**< \brief [12:12] TOM sub-modules output bitwise comparator [c] error indication (rw1ch) */
    __IO Ifx_Strict_32Bit TBWC1:1;         /**< \brief [13:13] TOM sub-modules output bitwise comparator [c] error indication (rw1ch) */
    __IO Ifx_Strict_32Bit TBWC2:1;         /**< \brief [14:14] TOM sub-modules output bitwise comparator [c] error indication (rw1ch) */
    __IO Ifx_Strict_32Bit TBWC3:1;         /**< \brief [15:15] TOM sub-modules output bitwise comparator [c] error indication (rw1ch) */
    __IO Ifx_Strict_32Bit TBWC4:1;         /**< \brief [16:16] TOM sub-modules output bitwise comparator [c] error indication (rw1ch) */
    __IO Ifx_Strict_32Bit TBWC5:1;         /**< \brief [17:17] TOM sub-modules output bitwise comparator [c] error indication (rw1ch) */
    __IO Ifx_Strict_32Bit TBWC6:1;         /**< \brief [18:18] TOM sub-modules output bitwise comparator [c] error indication (rw1ch) */
    __IO Ifx_Strict_32Bit TBWC7:1;         /**< \brief [19:19] TOM sub-modules output bitwise comparator [c] error indication (rw1ch) */
    __IO Ifx_Strict_32Bit TBWC8:1;         /**< \brief [20:20] TOM sub-modules output bitwise comparator [c] error indication (rw1ch) */
    __IO Ifx_Strict_32Bit TBWC9:1;         /**< \brief [21:21] TOM sub-modules output bitwise comparator [c] error indication (rw1ch) */
    __IO Ifx_Strict_32Bit TBWC10:1;        /**< \brief [22:22] TOM sub-modules output bitwise comparator [c] error indication (rw1ch) */
    __IO Ifx_Strict_32Bit TBWC11:1;        /**< \brief [23:23] TOM sub-modules output bitwise comparator [c] error indication (rw1ch) */
    __I  Ifx_Strict_32Bit :8;              /**< \brief [31:24] \internal Reserved */
} Ifx_EGTM_CLS_CMP_IRQ_NOTIFY_Bits;

/** \brief CMU control for clock resolution generator [x] */
typedef struct _Ifx_EGTM_CLS_CMU_CLKX_CTRL_Bits
{
    __IO Ifx_Strict_32Bit CLK_CNT:24;      /**< \brief [23:0] Clock count. Defines count value for the clock divider. (rwh) */
    __I  Ifx_Strict_32Bit :8;              /**< \brief [31:24] \internal Reserved */
} Ifx_EGTM_CLS_CMU_CLKX_CTRL_Bits;

/** \brief CMU control for clock resolution generator 6 */
typedef struct _Ifx_EGTM_CLS_CMU_CLK_6_CTRL_Bits
{
    __IO Ifx_Strict_32Bit CLK_CNT:24;      /**< \brief [23:0] Clock count. Define count value for the clock resolution generator responsible for CMU_CLK_RES[6:6] generation. (rwh) */
    __IO Ifx_Strict_32Bit CLK_SEL:2;       /**< \brief [25:24] Source selection (rwh) */
    __I  Ifx_Strict_32Bit :6;              /**< \brief [31:26] \internal Reserved */
} Ifx_EGTM_CLS_CMU_CLK_6_CTRL_Bits;

/** \brief CMU control for clock resolution generator 7 */
typedef struct _Ifx_EGTM_CLS_CMU_CLK_7_CTRL_Bits
{
    __IO Ifx_Strict_32Bit CLK_CNT:24;      /**< \brief [23:0] Clock count. Define count value for the clock resolution generator responsible for CMU_CLK_RES[7:7] generation. (rwh) */
    __IO Ifx_Strict_32Bit CLK_SEL:2;       /**< \brief [25:24] Source selection (rwh) */
    __I  Ifx_Strict_32Bit :6;              /**< \brief [31:26] \internal Reserved */
} Ifx_EGTM_CLS_CMU_CLK_7_CTRL_Bits;

/** \brief CMU control for clock resolution generator */
typedef struct _Ifx_EGTM_CLS_CMU_CLK_CTRL_Bits
{
    __IO Ifx_Strict_32Bit CLK0_EXT_DIVIDER:1;    /**< \brief [0:0] Input selection for Clock Resolution Generator [x] (rwh) */
    __IO Ifx_Strict_32Bit CLK1_EXT_DIVIDER:1;    /**< \brief [1:1] Input selection for Clock Resolution Generator [x] (rwh) */
    __IO Ifx_Strict_32Bit CLK2_EXT_DIVIDER:1;    /**< \brief [2:2] Input selection for Clock Resolution Generator [x] (rwh) */
    __IO Ifx_Strict_32Bit CLK3_EXT_DIVIDER:1;    /**< \brief [3:3] Input selection for Clock Resolution Generator [x] (rwh) */
    __IO Ifx_Strict_32Bit CLK4_EXT_DIVIDER:1;    /**< \brief [4:4] Input selection for Clock Resolution Generator [x] (rwh) */
    __IO Ifx_Strict_32Bit CLK5_EXT_DIVIDER:1;    /**< \brief [5:5] Input selection for Clock Resolution Generator [x] (rwh) */
    __IO Ifx_Strict_32Bit CLK6_EXT_DIVIDER:1;    /**< \brief [6:6] Input selection for Clock Resolution Generator [x] (rwh) */
    __IO Ifx_Strict_32Bit CLK7_EXT_DIVIDER:1;    /**< \brief [7:7] Input selection for Clock Resolution Generator [x] (rwh) */
    __IO Ifx_Strict_32Bit CLK8_EXT_DIVIDER:1;    /**< \brief [8:8] Source selection for CMU_CLK_RES[8:8] (rwh) */
    __I  Ifx_Strict_32Bit :23;             /**< \brief [31:9] \internal Reserved */
} Ifx_EGTM_CLS_CMU_CLK_CTRL_Bits;

/** \brief CMU clock enable */
typedef struct _Ifx_EGTM_CLS_CMU_CLK_EN_Bits
{
    __IO Ifx_Strict_32Bit EN_CLK0:2;       /**< \brief [1:0] Enable clock resolution CMU_CLK_RES[x:x] (rwh) */
    __IO Ifx_Strict_32Bit EN_CLK1:2;       /**< \brief [3:2] Enable clock resolution CMU_CLK_RES[x:x] (rwh) */
    __IO Ifx_Strict_32Bit EN_CLK2:2;       /**< \brief [5:4] Enable clock resolution CMU_CLK_RES[x:x] (rwh) */
    __IO Ifx_Strict_32Bit EN_CLK3:2;       /**< \brief [7:6] Enable clock resolution CMU_CLK_RES[x:x] (rwh) */
    __IO Ifx_Strict_32Bit EN_CLK4:2;       /**< \brief [9:8] Enable clock resolution CMU_CLK_RES[x:x] (rwh) */
    __IO Ifx_Strict_32Bit EN_CLK5:2;       /**< \brief [11:10] Enable clock resolution CMU_CLK_RES[x:x] (rwh) */
    __IO Ifx_Strict_32Bit EN_CLK6:2;       /**< \brief [13:12] Enable clock resolution CMU_CLK_RES[x:x] (rwh) */
    __IO Ifx_Strict_32Bit EN_CLK7:2;       /**< \brief [15:14] Enable clock resolution CMU_CLK_RES[x:x] (rwh) */
    __IO Ifx_Strict_32Bit EN_ECLK0:2;      /**< \brief [17:16] Enable clock CMU_ECLK[z:z] (rwh) */
    __IO Ifx_Strict_32Bit EN_ECLK1:2;      /**< \brief [19:18] Enable clock CMU_ECLK[z:z] (rwh) */
    __IO Ifx_Strict_32Bit EN_ECLK2:2;      /**< \brief [21:20] Enable clock CMU_ECLK[z:z] (rwh) */
    __IO Ifx_Strict_32Bit EN_FXCLK:2;      /**< \brief [23:22] Enable clock resolution CMU_FXCLK_RES (rwh) */
    __I  Ifx_Strict_32Bit :8;              /**< \brief [31:24] \internal Reserved */
} Ifx_EGTM_CLS_CMU_CLK_EN_Bits;

/** \brief The denominator for the external clock resolution generator [z] */
typedef struct _Ifx_EGTM_CLS_CMU_ECLK_DEN_Bits
{
    __IO Ifx_Strict_32Bit ECLK_DEN:24;     /**< \brief [23:0] The denominator for external clock resolution generator. Defines denominator of the fractional divider. (rwh) */
    __I  Ifx_Strict_32Bit :8;              /**< \brief [31:24] \internal Reserved */
} Ifx_EGTM_CLS_CMU_ECLK_DEN_Bits;

/** \brief The numerator for the external clock resolution generator [z] */
typedef struct _Ifx_EGTM_CLS_CMU_ECLK_NUM_Bits
{
    __IO Ifx_Strict_32Bit ECLK_NUM:24;     /**< \brief [23:0] The numerator for external clock resolution generator. Defines numerator of the fractional divider. (rwh) */
    __I  Ifx_Strict_32Bit :8;              /**< \brief [31:24] \internal Reserved */
} Ifx_EGTM_CLS_CMU_ECLK_NUM_Bits;

/** \brief CMU control for selection of FCR subblock input */
typedef struct _Ifx_EGTM_CLS_CMU_FXCLK_CTRL_Bits
{
    __IO Ifx_Strict_32Bit FXCLK_SEL:4;     /**< \brief [3:0] Input selection for EN_FXCLK line (rwh) */
    __I  Ifx_Strict_32Bit :28;             /**< \brief [31:4] \internal Reserved */
} Ifx_EGTM_CLS_CMU_FXCLK_CTRL_Bits;

/** \brief The denominator for CMU global clock resolution generator */
typedef struct _Ifx_EGTM_CLS_CMU_GCLK_DEN_Bits
{
    __IO Ifx_Strict_32Bit GCLK_DEN:24;     /**< \brief [23:0] Denominator for global resolution generator. Defines denominator of the fractional divider. (rwh) */
    __I  Ifx_Strict_32Bit :8;              /**< \brief [31:24] \internal Reserved */
} Ifx_EGTM_CLS_CMU_GCLK_DEN_Bits;

/** \brief The numerator for CMU global clock resolution generator */
typedef struct _Ifx_EGTM_CLS_CMU_GCLK_NUM_Bits
{
    __IO Ifx_Strict_32Bit GCLK_NUM:24;     /**< \brief [23:0] Numerator for global clock resolution generator. Defines numerator of the fractional divider. (rwh) */
    __I  Ifx_Strict_32Bit :8;              /**< \brief [31:24] \internal Reserved */
} Ifx_EGTM_CLS_CMU_GCLK_NUM_Bits;

/** \brief ICM_IRQG_0 */
typedef struct _Ifx_EGTM_CLS_ICM_IRQG_0_Bits
{
    __I  Ifx_Strict_32Bit :1;              /**< \brief [0:0] \internal Reserved */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [1:1] \internal Reserved */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [2:2] \internal Reserved */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [3:3] \internal Reserved */
    __I  Ifx_Strict_32Bit AEI_IRQ:1;       /**< \brief [4:4] ICM_IRQG_0.AEI_IRQ: AEI_IRQ interrupt (rh) */
    __I  Ifx_Strict_32Bit CMP_IRQ:1;       /**< \brief [5:5] CMP shared sub-module interrupt (rh) */
    __I  Ifx_Strict_32Bit SPE0_IRQ:1;      /**< \brief [6:6] SPE[j] shared sub-module interrupt (rh) */
    __I  Ifx_Strict_32Bit :7;              /**< \brief [13:7] \internal Reserved */
    __I  Ifx_Strict_32Bit :2;              /**< \brief [15:14] \internal Reserved */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [16:16] \internal Reserved */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [17:17] \internal Reserved */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [18:18] \internal Reserved */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [19:19] \internal Reserved */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [20:20] \internal Reserved */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [21:21] \internal Reserved */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [22:22] \internal Reserved */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [23:23] \internal Reserved */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [24:24] \internal Reserved */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [25:25] \internal Reserved */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [26:26] \internal Reserved */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [27:27] \internal Reserved */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [28:28] \internal Reserved */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [29:29] \internal Reserved */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [30:30] \internal Reserved */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [31:31] \internal Reserved */
} Ifx_EGTM_CLS_ICM_IRQG_0_Bits;

/** \brief ICM Interrupt group register covering TIM0, TIM1, TIM2, TIM3 */
typedef struct _Ifx_EGTM_CLS_ICM_IRQG_2_Bits
{
    __I  Ifx_Strict_32Bit TIM0_CH0_IRQ:1;    /**< \brief [0:0] TIM0 shared interrupt channel [x] (rh) */
    __I  Ifx_Strict_32Bit TIM0_CH1_IRQ:1;    /**< \brief [1:1] TIM0 shared interrupt channel [x] (rh) */
    __I  Ifx_Strict_32Bit TIM0_CH2_IRQ:1;    /**< \brief [2:2] TIM0 shared interrupt channel [x] (rh) */
    __I  Ifx_Strict_32Bit TIM0_CH3_IRQ:1;    /**< \brief [3:3] TIM0 shared interrupt channel [x] (rh) */
    __I  Ifx_Strict_32Bit TIM0_CH4_IRQ:1;    /**< \brief [4:4] TIM0 shared interrupt channel [x] (rh) */
    __I  Ifx_Strict_32Bit TIM0_CH5_IRQ:1;    /**< \brief [5:5] TIM0 shared interrupt channel [x] (rh) */
    __I  Ifx_Strict_32Bit TIM0_CH6_IRQ:1;    /**< \brief [6:6] TIM0 shared interrupt channel [x] (rh) */
    __I  Ifx_Strict_32Bit TIM0_CH7_IRQ:1;    /**< \brief [7:7] TIM0 shared interrupt channel [x] (rh) */
    __I  Ifx_Strict_32Bit TIM1_CH0_IRQ:1;    /**< \brief [8:8] TIM1 shared interrupt channel [x] (rh) */
    __I  Ifx_Strict_32Bit TIM1_CH1_IRQ:1;    /**< \brief [9:9] TIM1 shared interrupt channel [x] (rh) */
    __I  Ifx_Strict_32Bit TIM1_CH2_IRQ:1;    /**< \brief [10:10] TIM1 shared interrupt channel [x] (rh) */
    __I  Ifx_Strict_32Bit TIM1_CH3_IRQ:1;    /**< \brief [11:11] TIM1 shared interrupt channel [x] (rh) */
    __I  Ifx_Strict_32Bit TIM1_CH4_IRQ:1;    /**< \brief [12:12] TIM1 shared interrupt channel [x] (rh) */
    __I  Ifx_Strict_32Bit TIM1_CH5_IRQ:1;    /**< \brief [13:13] TIM1 shared interrupt channel [x] (rh) */
    __I  Ifx_Strict_32Bit TIM1_CH6_IRQ:1;    /**< \brief [14:14] TIM1 shared interrupt channel [x] (rh) */
    __I  Ifx_Strict_32Bit TIM1_CH7_IRQ:1;    /**< \brief [15:15] TIM1 shared interrupt channel [x] (rh) */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [16:16] \internal Reserved */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [17:17] \internal Reserved */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [18:18] \internal Reserved */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [19:19] \internal Reserved */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [20:20] \internal Reserved */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [21:21] \internal Reserved */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [22:22] \internal Reserved */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [23:23] \internal Reserved */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [24:24] \internal Reserved */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [25:25] \internal Reserved */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [26:26] \internal Reserved */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [27:27] \internal Reserved */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [28:28] \internal Reserved */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [29:29] \internal Reserved */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [30:30] \internal Reserved */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [31:31] \internal Reserved */
} Ifx_EGTM_CLS_ICM_IRQG_2_Bits;

/** \brief ICM_IRQG_ATOM_[g]_CI */
typedef struct _Ifx_EGTM_CLS_ICM_IRQG_ATOM_CI_Bits
{
    __I  Ifx_Strict_32Bit ATOM_M0_CH0_IRQ:1;    /**< \brief [0:0] ATOM[j] channel [x] interrupt ([j]=4*[g]+0) (rh) */
    __I  Ifx_Strict_32Bit ATOM_M0_CH1_IRQ:1;    /**< \brief [1:1] ATOM[j] channel [x] interrupt ([j]=4*[g]+0) (rh) */
    __I  Ifx_Strict_32Bit ATOM_M0_CH2_IRQ:1;    /**< \brief [2:2] ATOM[j] channel [x] interrupt ([j]=4*[g]+0) (rh) */
    __I  Ifx_Strict_32Bit ATOM_M0_CH3_IRQ:1;    /**< \brief [3:3] ATOM[j] channel [x] interrupt ([j]=4*[g]+0) (rh) */
    __I  Ifx_Strict_32Bit ATOM_M0_CH4_IRQ:1;    /**< \brief [4:4] ATOM[j] channel [x] interrupt ([j]=4*[g]+0) (rh) */
    __I  Ifx_Strict_32Bit ATOM_M0_CH5_IRQ:1;    /**< \brief [5:5] ATOM[j] channel [x] interrupt ([j]=4*[g]+0) (rh) */
    __I  Ifx_Strict_32Bit ATOM_M0_CH6_IRQ:1;    /**< \brief [6:6] ATOM[j] channel [x] interrupt ([j]=4*[g]+0) (rh) */
    __I  Ifx_Strict_32Bit ATOM_M0_CH7_IRQ:1;    /**< \brief [7:7] ATOM[j] channel [x] interrupt ([j]=4*[g]+0) (rh) */
    __I  Ifx_Strict_32Bit ATOM_M1_CH0_IRQ:1;    /**< \brief [8:8] ATOM[j] channel [x] interrupt ([j]=4*[g]+1) (rh) */
    __I  Ifx_Strict_32Bit ATOM_M1_CH1_IRQ:1;    /**< \brief [9:9] ATOM[j] channel [x] interrupt ([j]=4*[g]+1) (rh) */
    __I  Ifx_Strict_32Bit ATOM_M1_CH2_IRQ:1;    /**< \brief [10:10] ATOM[j] channel [x] interrupt ([j]=4*[g]+1) (rh) */
    __I  Ifx_Strict_32Bit ATOM_M1_CH3_IRQ:1;    /**< \brief [11:11] ATOM[j] channel [x] interrupt ([j]=4*[g]+1) (rh) */
    __I  Ifx_Strict_32Bit ATOM_M1_CH4_IRQ:1;    /**< \brief [12:12] ATOM[j] channel [x] interrupt ([j]=4*[g]+1) (rh) */
    __I  Ifx_Strict_32Bit ATOM_M1_CH5_IRQ:1;    /**< \brief [13:13] ATOM[j] channel [x] interrupt ([j]=4*[g]+1) (rh) */
    __I  Ifx_Strict_32Bit ATOM_M1_CH6_IRQ:1;    /**< \brief [14:14] ATOM[j] channel [x] interrupt ([j]=4*[g]+1) (rh) */
    __I  Ifx_Strict_32Bit ATOM_M1_CH7_IRQ:1;    /**< \brief [15:15] ATOM[j] channel [x] interrupt ([j]=4*[g]+1) (rh) */
    __I  Ifx_Strict_32Bit ATOM_M2_CH0_IRQ:1;    /**< \brief [16:16] ATOMm channel [x] interrupt ([j]=4*[g]+2) (rh) */
    __I  Ifx_Strict_32Bit ATOM_M2_CH1_IRQ:1;    /**< \brief [17:17] ATOMm channel [x] interrupt ([j]=4*[g]+2) (rh) */
    __I  Ifx_Strict_32Bit ATOM_M2_CH2_IRQ:1;    /**< \brief [18:18] ATOMm channel [x] interrupt ([j]=4*[g]+2) (rh) */
    __I  Ifx_Strict_32Bit ATOM_M2_CH3_IRQ:1;    /**< \brief [19:19] ATOMm channel [x] interrupt ([j]=4*[g]+2) (rh) */
    __I  Ifx_Strict_32Bit ATOM_M2_CH4_IRQ:1;    /**< \brief [20:20] ATOMm channel [x] interrupt ([j]=4*[g]+2) (rh) */
    __I  Ifx_Strict_32Bit ATOM_M2_CH5_IRQ:1;    /**< \brief [21:21] ATOMm channel [x] interrupt ([j]=4*[g]+2) (rh) */
    __I  Ifx_Strict_32Bit ATOM_M2_CH6_IRQ:1;    /**< \brief [22:22] ATOMm channel [x] interrupt ([j]=4*[g]+2) (rh) */
    __I  Ifx_Strict_32Bit ATOM_M2_CH7_IRQ:1;    /**< \brief [23:23] ATOMm channel [x] interrupt ([j]=4*[g]+2) (rh) */
    __I  Ifx_Strict_32Bit :8;              /**< \brief [31:24] \internal Reserved */
} Ifx_EGTM_CLS_ICM_IRQG_ATOM_CI_Bits;

/** \brief ICM Interrupt group register 1 for channel error interrupt information */
typedef struct _Ifx_EGTM_CLS_ICM_IRQG_CEI1_Bits
{
    __I  Ifx_Strict_32Bit TIM0_CH0_EIRQ:1;    /**< \brief [0:0] TIM0 channel [x] error interrupt (rh) */
    __I  Ifx_Strict_32Bit TIM0_CH1_EIRQ:1;    /**< \brief [1:1] TIM0 channel [x] error interrupt (rh) */
    __I  Ifx_Strict_32Bit TIM0_CH2_EIRQ:1;    /**< \brief [2:2] TIM0 channel [x] error interrupt (rh) */
    __I  Ifx_Strict_32Bit TIM0_CH3_EIRQ:1;    /**< \brief [3:3] TIM0 channel [x] error interrupt (rh) */
    __I  Ifx_Strict_32Bit TIM0_CH4_EIRQ:1;    /**< \brief [4:4] TIM0 channel [x] error interrupt (rh) */
    __I  Ifx_Strict_32Bit TIM0_CH5_EIRQ:1;    /**< \brief [5:5] TIM0 channel [x] error interrupt (rh) */
    __I  Ifx_Strict_32Bit TIM0_CH6_EIRQ:1;    /**< \brief [6:6] TIM0 channel [x] error interrupt (rh) */
    __I  Ifx_Strict_32Bit TIM0_CH7_EIRQ:1;    /**< \brief [7:7] TIM0 channel [x] error interrupt (rh) */
    __I  Ifx_Strict_32Bit TIM1_CH0_EIRQ:1;    /**< \brief [8:8] TIM1 channel [x] error interrupt (rh) */
    __I  Ifx_Strict_32Bit TIM1_CH1_EIRQ:1;    /**< \brief [9:9] TIM1 channel [x] error interrupt (rh) */
    __I  Ifx_Strict_32Bit TIM1_CH2_EIRQ:1;    /**< \brief [10:10] TIM1 channel [x] error interrupt (rh) */
    __I  Ifx_Strict_32Bit TIM1_CH3_EIRQ:1;    /**< \brief [11:11] TIM1 channel [x] error interrupt (rh) */
    __I  Ifx_Strict_32Bit TIM1_CH4_EIRQ:1;    /**< \brief [12:12] TIM1 channel [x] error interrupt (rh) */
    __I  Ifx_Strict_32Bit TIM1_CH5_EIRQ:1;    /**< \brief [13:13] TIM1 channel [x] error interrupt (rh) */
    __I  Ifx_Strict_32Bit TIM1_CH6_EIRQ:1;    /**< \brief [14:14] TIM1 channel [x] error interrupt (rh) */
    __I  Ifx_Strict_32Bit TIM1_CH7_EIRQ:1;    /**< \brief [15:15] TIM1 channel [x] error interrupt (rh) */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [16:16] \internal Reserved */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [17:17] \internal Reserved */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [18:18] \internal Reserved */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [19:19] \internal Reserved */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [20:20] \internal Reserved */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [21:21] \internal Reserved */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [22:22] \internal Reserved */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [23:23] \internal Reserved */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [24:24] \internal Reserved */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [25:25] \internal Reserved */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [26:26] \internal Reserved */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [27:27] \internal Reserved */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [28:28] \internal Reserved */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [29:29] \internal Reserved */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [30:30] \internal Reserved */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [31:31] \internal Reserved */
} Ifx_EGTM_CLS_ICM_IRQG_CEI1_Bits;

/** \brief ICM_IRQG_CLS_[g]_MEI */
typedef struct _Ifx_EGTM_CLS_ICM_IRQG_CLS_MEI_Bits
{
    __I  Ifx_Strict_32Bit TIM_M0_EIRQ:1;    /**< \brief [0:0] Error interrupt TIM[j]_EIRQ (j=4*[g]) (rh) */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [1:1] \internal Reserved */
    __I  Ifx_Strict_32Bit SPE_M0_EIRQ:1;    /**< \brief [2:2] Error interrupt SPE[j]_EIRQ ([j]=4*[g]+0) (rh) */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [3:3] \internal Reserved */
    __I  Ifx_Strict_32Bit :4;              /**< \brief [7:4] \internal Reserved */
    __I  Ifx_Strict_32Bit TIM_M1_EIRQ:1;    /**< \brief [8:8] Error interrupt TIM[j]_EIRQ ([j]=4*[g]+1) (rh) */
    __I  Ifx_Strict_32Bit :3;              /**< \brief [11:9] \internal Reserved */
    __I  Ifx_Strict_32Bit :4;              /**< \brief [15:12] \internal Reserved */
    __I  Ifx_Strict_32Bit :4;              /**< \brief [19:16] \internal Reserved */
    __I  Ifx_Strict_32Bit :4;              /**< \brief [23:20] \internal Reserved */
    __I  Ifx_Strict_32Bit :3;              /**< \brief [26:24] \internal Reserved */
    __I  Ifx_Strict_32Bit FIFO_M3_EIRQ:1;    /**< \brief [27:27] Error interrupt FIFO[j]_EIRQ ([j]=4*[g]+2) (rh) */
    __I  Ifx_Strict_32Bit :4;              /**< \brief [31:28] \internal Reserved */
} Ifx_EGTM_CLS_ICM_IRQG_CLS_MEI_Bits;

/** \brief ICM Interrupt group register for module error interrupt information */
typedef struct _Ifx_EGTM_CLS_ICM_IRQG_MEI_Bits
{
    __I  Ifx_Strict_32Bit GTM_EIRQ:1;      /**< \brief [0:0] AEI error interrupt request (rh) */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [1:1] \internal Reserved */
    __I  Ifx_Strict_32Bit :2;              /**< \brief [3:2] \internal Reserved */
    __I  Ifx_Strict_32Bit TIM0_EIRQ:1;     /**< \brief [4:4] TIM[j] error interrupt (rh) */
    __I  Ifx_Strict_32Bit TIM1_EIRQ:1;     /**< \brief [5:5] TIM[j] error interrupt (rh) */
    __I  Ifx_Strict_32Bit :14;             /**< \brief [19:6] \internal Reserved */
    __I  Ifx_Strict_32Bit SPE0_EIRQ:1;     /**< \brief [20:20] SPE[j] error interrupt (rh) */
    __I  Ifx_Strict_32Bit :3;              /**< \brief [23:21] \internal Reserved */
    __I  Ifx_Strict_32Bit CMP_EIRQ:1;      /**< \brief [24:24] CMP error interrupt (rh) */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [25:25] \internal Reserved */
    __I  Ifx_Strict_32Bit :6;              /**< \brief [31:26] \internal Reserved */
} Ifx_EGTM_CLS_ICM_IRQG_MEI_Bits;

/** \brief ICM Interrupt group SPE for module Error Interrupt information */
typedef struct _Ifx_EGTM_CLS_ICM_IRQG_SPE_CEI_Bits
{
    __I  Ifx_Strict_32Bit SPE0_EIRQ:1;     /**< \brief [0:0] SPE[j] error interrupt (rh) */
    __I  Ifx_Strict_32Bit :7;              /**< \brief [7:1] \internal Reserved */
    __I  Ifx_Strict_32Bit :24;             /**< \brief [31:8] \internal Reserved */
} Ifx_EGTM_CLS_ICM_IRQG_SPE_CEI_Bits;

/** \brief ICM Interrupt group SPE for module Interrupt information */
typedef struct _Ifx_EGTM_CLS_ICM_IRQG_SPE_CI_Bits
{
    __I  Ifx_Strict_32Bit SPE0_IRQ:1;      /**< \brief [0:0] SPE[j] interrupt (rh) */
    __I  Ifx_Strict_32Bit :7;              /**< \brief [7:1] \internal Reserved */
    __I  Ifx_Strict_32Bit :24;             /**< \brief [31:8] \internal Reserved */
} Ifx_EGTM_CLS_ICM_IRQG_SPE_CI_Bits;

/** \brief ICM_IRQG_TOM_[g]_CI */
typedef struct _Ifx_EGTM_CLS_ICM_IRQG_TOM_CI_Bits
{
    __I  Ifx_Strict_32Bit TOM_M0_CH0_IRQ:1;    /**< \brief [0:0] TOM[j] channel [x] interrupt ([j]=2*[g]+0) (rh) */
    __I  Ifx_Strict_32Bit TOM_M0_CH1_IRQ:1;    /**< \brief [1:1] TOM[j] channel [x] interrupt ([j]=2*[g]+0) (rh) */
    __I  Ifx_Strict_32Bit TOM_M0_CH2_IRQ:1;    /**< \brief [2:2] TOM[j] channel [x] interrupt ([j]=2*[g]+0) (rh) */
    __I  Ifx_Strict_32Bit TOM_M0_CH3_IRQ:1;    /**< \brief [3:3] TOM[j] channel [x] interrupt ([j]=2*[g]+0) (rh) */
    __I  Ifx_Strict_32Bit TOM_M0_CH4_IRQ:1;    /**< \brief [4:4] TOM[j] channel [x] interrupt ([j]=2*[g]+0) (rh) */
    __I  Ifx_Strict_32Bit TOM_M0_CH5_IRQ:1;    /**< \brief [5:5] TOM[j] channel [x] interrupt ([j]=2*[g]+0) (rh) */
    __I  Ifx_Strict_32Bit TOM_M0_CH6_IRQ:1;    /**< \brief [6:6] TOM[j] channel [x] interrupt ([j]=2*[g]+0) (rh) */
    __I  Ifx_Strict_32Bit TOM_M0_CH7_IRQ:1;    /**< \brief [7:7] TOM[j] channel [x] interrupt ([j]=2*[g]+0) (rh) */
    __I  Ifx_Strict_32Bit TOM_M0_CH8_IRQ:1;    /**< \brief [8:8] TOM[j] channel [x] interrupt ([j]=2*[g]+0) (rh) */
    __I  Ifx_Strict_32Bit TOM_M0_CH9_IRQ:1;    /**< \brief [9:9] TOM[j] channel [x] interrupt ([j]=2*[g]+0) (rh) */
    __I  Ifx_Strict_32Bit TOM_M0_CH10_IRQ:1;    /**< \brief [10:10] TOM[j] channel [x] interrupt ([j]=2*[g]+0) (rh) */
    __I  Ifx_Strict_32Bit TOM_M0_CH11_IRQ:1;    /**< \brief [11:11] TOM[j] channel [x] interrupt ([j]=2*[g]+0) (rh) */
    __I  Ifx_Strict_32Bit TOM_M0_CH12_IRQ:1;    /**< \brief [12:12] TOM[j] channel [x] interrupt ([j]=2*[g]+0) (rh) */
    __I  Ifx_Strict_32Bit TOM_M0_CH13_IRQ:1;    /**< \brief [13:13] TOM[j] channel [x] interrupt ([j]=2*[g]+0) (rh) */
    __I  Ifx_Strict_32Bit TOM_M0_CH14_IRQ:1;    /**< \brief [14:14] TOM[j] channel [x] interrupt ([j]=2*[g]+0) (rh) */
    __I  Ifx_Strict_32Bit TOM_M0_CH15_IRQ:1;    /**< \brief [15:15] TOM[j] channel [x] interrupt ([j]=2*[g]+0) (rh) */
    __I  Ifx_Strict_32Bit TOM_M1_CH0_IRQ:1;    /**< \brief [16:16] TOM[j] channel [x] interrupt ([j]=2*[g]+1) (rh) */
    __I  Ifx_Strict_32Bit TOM_M1_CH1_IRQ:1;    /**< \brief [17:17] TOM[j] channel [x] interrupt ([j]=2*[g]+1) (rh) */
    __I  Ifx_Strict_32Bit TOM_M1_CH2_IRQ:1;    /**< \brief [18:18] TOM[j] channel [x] interrupt ([j]=2*[g]+1) (rh) */
    __I  Ifx_Strict_32Bit TOM_M1_CH3_IRQ:1;    /**< \brief [19:19] TOM[j] channel [x] interrupt ([j]=2*[g]+1) (rh) */
    __I  Ifx_Strict_32Bit TOM_M1_CH4_IRQ:1;    /**< \brief [20:20] TOM[j] channel [x] interrupt ([j]=2*[g]+1) (rh) */
    __I  Ifx_Strict_32Bit TOM_M1_CH5_IRQ:1;    /**< \brief [21:21] TOM[j] channel [x] interrupt ([j]=2*[g]+1) (rh) */
    __I  Ifx_Strict_32Bit TOM_M1_CH6_IRQ:1;    /**< \brief [22:22] TOM[j] channel [x] interrupt ([j]=2*[g]+1) (rh) */
    __I  Ifx_Strict_32Bit TOM_M1_CH7_IRQ:1;    /**< \brief [23:23] TOM[j] channel [x] interrupt ([j]=2*[g]+1) (rh) */
    __I  Ifx_Strict_32Bit TOM_M1_CH8_IRQ:1;    /**< \brief [24:24] TOM[j] channel [x] interrupt ([j]=2*[g]+1) (rh) */
    __I  Ifx_Strict_32Bit TOM_M1_CH9_IRQ:1;    /**< \brief [25:25] TOM[j] channel [x] interrupt ([j]=2*[g]+1) (rh) */
    __I  Ifx_Strict_32Bit TOM_M1_CH10_IRQ:1;    /**< \brief [26:26] TOM[j] channel [x] interrupt ([j]=2*[g]+1) (rh) */
    __I  Ifx_Strict_32Bit TOM_M1_CH11_IRQ:1;    /**< \brief [27:27] TOM[j] channel [x] interrupt ([j]=2*[g]+1) (rh) */
    __I  Ifx_Strict_32Bit TOM_M1_CH12_IRQ:1;    /**< \brief [28:28] TOM[j] channel [x] interrupt ([j]=2*[g]+1) (rh) */
    __I  Ifx_Strict_32Bit TOM_M1_CH13_IRQ:1;    /**< \brief [29:29] TOM[j] channel [x] interrupt ([j]=2*[g]+1) (rh) */
    __I  Ifx_Strict_32Bit TOM_M1_CH14_IRQ:1;    /**< \brief [30:30] TOM[j] channel [x] interrupt ([j]=2*[g]+1) (rh) */
    __I  Ifx_Strict_32Bit TOM_M1_CH15_IRQ:1;    /**< \brief [31:31] TOM[j] channel [x] interrupt ([j]=2*[g]+1) (rh) */
} Ifx_EGTM_CLS_ICM_IRQG_TOM_CI_Bits;

/** \brief MON status register */
typedef struct _Ifx_EGTM_CLS_MON_STATUS_Bits
{
    __IO Ifx_Strict_32Bit ACT_CMU0:1;      /**< \brief [0:0] CCM[1]_CLK_RES activity (rw1ch) */
    __IO Ifx_Strict_32Bit ACT_CMU1:1;      /**< \brief [1:1] CCM[1]_CLK_RES activity (rw1ch) */
    __IO Ifx_Strict_32Bit ACT_CMU2:1;      /**< \brief [2:2] CCM[1]_CLK_RES activity (rw1ch) */
    __IO Ifx_Strict_32Bit ACT_CMU3:1;      /**< \brief [3:3] CCM[1]_CLK_RES activity (rw1ch) */
    __IO Ifx_Strict_32Bit ACT_CMU4:1;      /**< \brief [4:4] CCM[1]_CLK_RES activity (rw1ch) */
    __IO Ifx_Strict_32Bit ACT_CMU5:1;      /**< \brief [5:5] CCM[1]_CLK_RES activity (rw1ch) */
    __IO Ifx_Strict_32Bit ACT_CMU6:1;      /**< \brief [6:6] CCM[1]_CLK_RES activity (rw1ch) */
    __IO Ifx_Strict_32Bit ACT_CMU7:1;      /**< \brief [7:7] CCM[1]_CLK_RES activity (rw1ch) */
    __IO Ifx_Strict_32Bit ACT_CMUFX0:1;    /**< \brief [8:8] CCM[1]_FXCLK_RES activity (rw1ch) */
    __IO Ifx_Strict_32Bit ACT_CMUFX1:1;    /**< \brief [9:9] CCM[1]_FXCLK_RES activity (rw1ch) */
    __IO Ifx_Strict_32Bit ACT_CMUFX2:1;    /**< \brief [10:10] CCM[1]_FXCLK_RES activity (rw1ch) */
    __IO Ifx_Strict_32Bit ACT_CMUFX3:1;    /**< \brief [11:11] CCM[1]_FXCLK_RES activity (rw1ch) */
    __IO Ifx_Strict_32Bit ACT_CMUFX4:1;    /**< \brief [12:12] CCM[1]_FXCLK_RES activity (rw1ch) */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [13:13] \internal Reserved */
    __IO Ifx_Strict_32Bit ACT_CMU8:1;      /**< \brief [14:14] CCM[1]_CLK_RES[8:8] activity (rw1ch) */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [15:15] \internal Reserved */
    __I  Ifx_Strict_32Bit CMP_ERR:1;       /**< \brief [16:16] Error detected at CMP (rh) */
    __I  Ifx_Strict_32Bit :3;              /**< \brief [19:17] \internal Reserved */
    __I  Ifx_Strict_32Bit :10;             /**< \brief [29:20] \internal Reserved */
    __I  Ifx_Strict_32Bit :2;              /**< \brief [31:30] \internal Reserved */
} Ifx_EGTM_CLS_MON_STATUS_Bits;

/** \brief SPE[i] Command Register */
typedef struct _Ifx_EGTM_CLS_SPE_CMD_Bits
{
    __IO Ifx_Strict_32Bit SPE_CTRL_CMD:2;    /**< \brief [1:0] SPE control command (rw) */
    __I  Ifx_Strict_32Bit :14;             /**< \brief [15:2] \internal Reserved */
    __IO Ifx_Strict_32Bit SPE_UPD_TRIG:1;    /**< \brief [16:16] SPE updater trigger (rwch) */
    __I  Ifx_Strict_32Bit :15;             /**< \brief [31:17] \internal Reserved */
} Ifx_EGTM_CLS_SPE_CMD_Bits;

/** \brief SPE[i] Control Status Register */
typedef struct _Ifx_EGTM_CLS_SPE_CTRL_STAT_Bits
{
    __IO Ifx_Strict_32Bit EN:1;            /**< \brief [0:0] SPE Submodule enable (rw) */
    __IO Ifx_Strict_32Bit SIE0:1;          /**< \brief [1:1] SPE Input [k] enable for TIM[i]_CH[x:x], TIM[i]_CH[y:y], TIM[i]_CH[z:z]. (rw) */
    __IO Ifx_Strict_32Bit SIE1:1;          /**< \brief [2:2] SPE Input [k] enable for TIM[i]_CH[x:x], TIM[i]_CH[y:y], TIM[i]_CH[z:z]. (rw) */
    __IO Ifx_Strict_32Bit SIE2:1;          /**< \brief [3:3] SPE Input [k] enable for TIM[i]_CH[x:x], TIM[i]_CH[y:y], TIM[i]_CH[z:z]. (rw) */
    __IO Ifx_Strict_32Bit TRIG_SEL:2;      /**< \brief [5:4] Select trigger input signal (rw) */
    __IO Ifx_Strict_32Bit TIM_SEL:1;       /**< \brief [6:6] Select TIM input signal (rw) */
    __IO Ifx_Strict_32Bit FSOM:1;          /**< \brief [7:7] Fast Shutoff Mode (rw) */
    __IO Ifx_Strict_32Bit SPE_PAT_PTR:3;    /**< \brief [10:8] Pattern selector for TOM output signals. (rw) */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [11:11] \internal Reserved */
    __IO Ifx_Strict_32Bit AIP:3;           /**< \brief [14:12] Input pattern that was detected by a regular input pattern change. (rw) */
    __IO Ifx_Strict_32Bit ADIR:1;          /**< \brief [15:15] Rotation direction. Will be reflected in the signal SPE[i]_DIR. (rw) */
    __IO Ifx_Strict_32Bit PIP:3;           /**< \brief [18:16] Previous input pattern that was detected by a regular input pattern change. (rw) */
    __IO Ifx_Strict_32Bit PDIR:1;          /**< \brief [19:19] Previous rotation direction (rw) */
    __I  Ifx_Strict_32Bit NIP:3;           /**< \brief [22:20] New input pattern that was detected. (rh) */
    __IO Ifx_Strict_32Bit ETRIG_SEL:1;     /**< \brief [23:23] Extended trigger selection of signal TRIG_SEL (rw) */
    __IO Ifx_Strict_32Bit FSOL:8;          /**< \brief [31:24] Fast Shutoff Level for TOM[i] channel 0 to 7 (rw) */
} Ifx_EGTM_CLS_SPE_CTRL_STAT_Bits;

/** \brief SPE[i] Control Status Register 2 */
typedef struct _Ifx_EGTM_CLS_SPE_CTRL_STAT2_Bits
{
    __I  Ifx_Strict_32Bit :8;              /**< \brief [7:0] \internal Reserved */
    __IO Ifx_Strict_32Bit SPE_PAT_PTR_BWD:3;    /**< \brief [10:8] Pattern selector for TOM output signals in case of SPE[i]_CMD.SPE_CTRL_CMD = 0b01 (e.g. backward direction). (rw) */
    __I  Ifx_Strict_32Bit :21;             /**< \brief [31:11] \internal Reserved */
} Ifx_EGTM_CLS_SPE_CTRL_STAT2_Bits;

/** \brief SPE[i] Error Interrupt Enable Register */
typedef struct _Ifx_EGTM_CLS_SPE_EIRQ_EN_Bits
{
    __IO Ifx_Strict_32Bit SPE_NIPD_EIRQ_EN:1;    /**< \brief [0:0] SPE_NIPD_EIRQ interrupt enable (rw) */
    __IO Ifx_Strict_32Bit SPE_DCHG_EIRQ_EN:1;    /**< \brief [1:1] SPE_DCHG_EIRQ error interrupt enable (rw) */
    __IO Ifx_Strict_32Bit SPE_PERR_EIRQ_EN:1;    /**< \brief [2:2] SPE_PERR_EIRQ error interrupt enable (rw) */
    __IO Ifx_Strict_32Bit SPE_BIS_EIRQ_EN:1;    /**< \brief [3:3] SPE[i]_BIS_EIRQ error interrupt enable (rw) */
    __IO Ifx_Strict_32Bit SPE_RCMP_EIRQ_EN:1;    /**< \brief [4:4] SPE[i]_RCMP_EIRQ error interrupt enable (rw) */
    __I  Ifx_Strict_32Bit :27;             /**< \brief [31:5] \internal Reserved */
} Ifx_EGTM_CLS_SPE_EIRQ_EN_Bits;

/** \brief SPE[i] Interrupt Enable Register */
typedef struct _Ifx_EGTM_CLS_SPE_IRQ_EN_Bits
{
    __IO Ifx_Strict_32Bit SPE_NIPD_IRQ_EN:1;    /**< \brief [0:0] SPE_NIPD_IRQ interrupt enable (rw) */
    __IO Ifx_Strict_32Bit SPE_DCHG_IRQ_EN:1;    /**< \brief [1:1] SPE_DCHG_IRQ interrupt enable (rw) */
    __IO Ifx_Strict_32Bit SPE_PERR_IRQ_EN:1;    /**< \brief [2:2] SPE_PERR_IRQ interrupt enable (rw) */
    __IO Ifx_Strict_32Bit SPE_BIS_IRQ_EN:1;    /**< \brief [3:3] SPE_BIS_IRQ interrupt enable (rw) */
    __IO Ifx_Strict_32Bit SPE_RCMP_IRQ_EN:1;    /**< \brief [4:4] SPE_RCMP_IRQ interrupt enable (rw) */
    __I  Ifx_Strict_32Bit :27;             /**< \brief [31:5] \internal Reserved */
} Ifx_EGTM_CLS_SPE_IRQ_EN_Bits;

/** \brief SPE[i] Interrupt Generation By Software */
typedef struct _Ifx_EGTM_CLS_SPE_IRQ_FORCINT_Bits
{
    __IO Ifx_Strict_32Bit TRG_SPE_NIPD:1;    /**< \brief [0:0] Trigger SPE[i]_IRQ_NOTIFY.SPE_NIPD by software (rw) */
    __IO Ifx_Strict_32Bit TRG_SPE_DCHG:1;    /**< \brief [1:1] Trigger SPE[i]_IRQ_NOTIFY.SPE_DCHG by software. (rw) */
    __IO Ifx_Strict_32Bit TRG_SPE_PERR:1;    /**< \brief [2:2] Trigger SPE[i]_IRQ_NOTIFY.SPE_PERR by software. (rw) */
    __IO Ifx_Strict_32Bit TRG_SPE_BIS:1;    /**< \brief [3:3] Trigger SPE[i]_IRQ_NOTIFY.SPE_BIS by software. (rw) */
    __IO Ifx_Strict_32Bit TRG_SPE_RCMP:1;    /**< \brief [4:4] Trigger SPE[i]_IRQ_NOTIFY.SPE_RCMP by software. (rw) */
    __I  Ifx_Strict_32Bit :27;             /**< \brief [31:5] \internal Reserved */
} Ifx_EGTM_CLS_SPE_IRQ_FORCINT_Bits;

/** \brief SPE[i] Interrupt Mode Configuration Register */
typedef struct _Ifx_EGTM_CLS_SPE_IRQ_MODE_Bits
{
    __IO Ifx_Strict_32Bit IRQ_MODE:2;      /**< \brief [1:0] IRQ mode selection (rw) */
    __I  Ifx_Strict_32Bit :30;             /**< \brief [31:2] \internal Reserved */
} Ifx_EGTM_CLS_SPE_IRQ_MODE_Bits;

/** \brief SPE[i] Interrupt Notification Register */
typedef struct _Ifx_EGTM_CLS_SPE_IRQ_NOTIFY_Bits
{
    __IO Ifx_Strict_32Bit SPE_NIPD:1;      /**< \brief [0:0] New input pattern interrupt occurred (rw1ch) */
    __IO Ifx_Strict_32Bit SPE_DCHG:1;      /**< \brief [1:1] SPE_DIR bit changed on behalf of new input pattern. (rw1ch) */
    __IO Ifx_Strict_32Bit SPE_PERR:1;      /**< \brief [2:2] Wrong or invalid pattern detected at input. (rw1ch) */
    __IO Ifx_Strict_32Bit SPE_BIS:1;       /**< \brief [3:3] Bouncing input signal detected (rw1ch) */
    __IO Ifx_Strict_32Bit SPE_RCMP:1;      /**< \brief [4:4] SPE revolution counter match event (rw1ch) */
    __I  Ifx_Strict_32Bit :27;             /**< \brief [31:5] \internal Reserved */
} Ifx_EGTM_CLS_SPE_IRQ_NOTIFY_Bits;

/** \brief SPE[i] Output Control Register */
typedef struct _Ifx_EGTM_CLS_SPE_OUT_CTRL_Bits
{
    __IO Ifx_Strict_32Bit SPE_OUT_CTRL0:2;    /**< \brief [1:0] SPE output control value for TOM channel0 to TOM channel7 (rw) */
    __IO Ifx_Strict_32Bit SPE_OUT_CTRL1:2;    /**< \brief [3:2] SPE output control value for TOM channel0 to TOM channel7 (rw) */
    __IO Ifx_Strict_32Bit SPE_OUT_CTRL2:2;    /**< \brief [5:4] SPE output control value for TOM channel0 to TOM channel7 (rw) */
    __IO Ifx_Strict_32Bit SPE_OUT_CTRL3:2;    /**< \brief [7:6] SPE output control value for TOM channel0 to TOM channel7 (rw) */
    __IO Ifx_Strict_32Bit SPE_OUT_CTRL4:2;    /**< \brief [9:8] SPE output control value for TOM channel0 to TOM channel7 (rw) */
    __IO Ifx_Strict_32Bit SPE_OUT_CTRL5:2;    /**< \brief [11:10] SPE output control value for TOM channel0 to TOM channel7 (rw) */
    __IO Ifx_Strict_32Bit SPE_OUT_CTRL6:2;    /**< \brief [13:12] SPE output control value for TOM channel0 to TOM channel7 (rw) */
    __IO Ifx_Strict_32Bit SPE_OUT_CTRL7:2;    /**< \brief [15:14] SPE output control value for TOM channel0 to TOM channel7 (rw) */
    __I  Ifx_Strict_32Bit :16;             /**< \brief [31:16] \internal Reserved */
} Ifx_EGTM_CLS_SPE_OUT_CTRL_Bits;

/** \brief SPE[i] Output Definition Register */
typedef struct _Ifx_EGTM_CLS_SPE_OUT_PAT_Bits
{
    __IO Ifx_Strict_32Bit SPE_OUT_PAT0:2;    /**< \brief [1:0] SPE output control value for TOM channel0 to TOM channel7 (rw) */
    __IO Ifx_Strict_32Bit SPE_OUT_PAT1:2;    /**< \brief [3:2] SPE output control value for TOM channel0 to TOM channel7 (rw) */
    __IO Ifx_Strict_32Bit SPE_OUT_PAT2:2;    /**< \brief [5:4] SPE output control value for TOM channel0 to TOM channel7 (rw) */
    __IO Ifx_Strict_32Bit SPE_OUT_PAT3:2;    /**< \brief [7:6] SPE output control value for TOM channel0 to TOM channel7 (rw) */
    __IO Ifx_Strict_32Bit SPE_OUT_PAT4:2;    /**< \brief [9:8] SPE output control value for TOM channel0 to TOM channel7 (rw) */
    __IO Ifx_Strict_32Bit SPE_OUT_PAT5:2;    /**< \brief [11:10] SPE output control value for TOM channel0 to TOM channel7 (rw) */
    __IO Ifx_Strict_32Bit SPE_OUT_PAT6:2;    /**< \brief [13:12] SPE output control value for TOM channel0 to TOM channel7 (rw) */
    __IO Ifx_Strict_32Bit SPE_OUT_PAT7:2;    /**< \brief [15:14] SPE output control value for TOM channel0 to TOM channel7 (rw) */
    __I  Ifx_Strict_32Bit :16;             /**< \brief [31:16] \internal Reserved */
} Ifx_EGTM_CLS_SPE_OUT_PAT_Bits;

/** \brief SPE[i] Input Pattern Definition Register */
typedef struct _Ifx_EGTM_CLS_SPE_PAT_Bits
{
    __IO Ifx_Strict_32Bit IP0_VAL:1;       /**< \brief [0:0] Input pattern [t] is a valid pattern. (rw) */
    __IO Ifx_Strict_32Bit IP0_PAT:3;       /**< \brief [3:1] Input pattern [t] (rw) */
    __IO Ifx_Strict_32Bit IP1_VAL:1;       /**< \brief [4:4] Input pattern [t] is a valid pattern. (rw) */
    __IO Ifx_Strict_32Bit IP1_PAT:3;       /**< \brief [7:5] Input pattern [t] (rw) */
    __IO Ifx_Strict_32Bit IP2_VAL:1;       /**< \brief [8:8] Input pattern [t] is a valid pattern. (rw) */
    __IO Ifx_Strict_32Bit IP2_PAT:3;       /**< \brief [11:9] Input pattern [t] (rw) */
    __IO Ifx_Strict_32Bit IP3_VAL:1;       /**< \brief [12:12] Input pattern [t] is a valid pattern. (rw) */
    __IO Ifx_Strict_32Bit IP3_PAT:3;       /**< \brief [15:13] Input pattern [t] (rw) */
    __IO Ifx_Strict_32Bit IP4_VAL:1;       /**< \brief [16:16] Input pattern [t] is a valid pattern. (rw) */
    __IO Ifx_Strict_32Bit IP4_PAT:3;       /**< \brief [19:17] Input pattern [t] (rw) */
    __IO Ifx_Strict_32Bit IP5_VAL:1;       /**< \brief [20:20] Input pattern [t] is a valid pattern. (rw) */
    __IO Ifx_Strict_32Bit IP5_PAT:3;       /**< \brief [23:21] Input pattern [t] (rw) */
    __IO Ifx_Strict_32Bit IP6_VAL:1;       /**< \brief [24:24] Input pattern [t] is a valid pattern. (rw) */
    __IO Ifx_Strict_32Bit IP6_PAT:3;       /**< \brief [27:25] Input pattern [t] (rw) */
    __IO Ifx_Strict_32Bit IP7_VAL:1;       /**< \brief [28:28] Input pattern [t] is a valid pattern. (rw) */
    __IO Ifx_Strict_32Bit IP7_PAT:3;       /**< \brief [31:29] Input pattern [t] (rw) */
} Ifx_EGTM_CLS_SPE_PAT_Bits;

/** \brief SPE[i] Revolution Counter Compare Value */
typedef struct _Ifx_EGTM_CLS_SPE_REV_CMP_Bits
{
    __IO Ifx_Strict_32Bit REV_CMP:24;      /**< \brief [23:0] Input signal revolution counter compare value (rw) */
    __I  Ifx_Strict_32Bit :8;              /**< \brief [31:24] \internal Reserved */
} Ifx_EGTM_CLS_SPE_REV_CMP_Bits;

/** \brief SPE[i] Input Revolution Counter */
typedef struct _Ifx_EGTM_CLS_SPE_REV_CNT_Bits
{
    __IO Ifx_Strict_32Bit REV_CNT:24;      /**< \brief [23:0] Input signal revolution counter (rw) */
    __I  Ifx_Strict_32Bit :8;              /**< \brief [31:24] \internal Reserved */
} Ifx_EGTM_CLS_SPE_REV_CNT_Bits;

/** \brief TBU channel 0 base */
typedef struct _Ifx_EGTM_CLS_TBU_CH0_BASE_Bits
{
    __IO Ifx_Strict_32Bit BASE:27;         /**< \brief [26:0] Time base value for channel 0 (rwh) */
    __I  Ifx_Strict_32Bit :5;              /**< \brief [31:27] \internal Reserved */
} Ifx_EGTM_CLS_TBU_CH0_BASE_Bits;

/** \brief TBU channel 0 control */
typedef struct _Ifx_EGTM_CLS_TBU_CH0_CTRL_Bits
{
    __IO Ifx_Strict_32Bit LOW_RES:1;       /**< \brief [0:0] TBU_CH0_BASE register resolution (rwh) */
    __IO Ifx_Strict_32Bit CH_CLK_SRC:3;    /**< \brief [3:1] Clock source for channel 0, channel 1 and channel 2 time base counter (rwh) */
    __I  Ifx_Strict_32Bit :28;             /**< \brief [31:4] \internal Reserved */
} Ifx_EGTM_CLS_TBU_CH0_CTRL_Bits;

/** \brief TBU channel 1 control */
typedef struct _Ifx_EGTM_CLS_TBU_CH1_CTRL_Bits
{
    __IO Ifx_Strict_32Bit CH_MODE:1;       /**< \brief [0:0] Channel mode (rwh) */
    __IO Ifx_Strict_32Bit CH_CLK_SRC:3;    /**< \brief [3:1] Clock source for channel 1 time base counter (rwh) */
    __I  Ifx_Strict_32Bit :28;             /**< \brief [31:4] \internal Reserved */
} Ifx_EGTM_CLS_TBU_CH1_CTRL_Bits;

/** \brief TBU channel 2 control */
typedef struct _Ifx_EGTM_CLS_TBU_CH2_CTRL_Bits
{
    __IO Ifx_Strict_32Bit CH_MODE:1;       /**< \brief [0:0] Channel mode (rwh) */
    __IO Ifx_Strict_32Bit CH_CLK_SRC:3;    /**< \brief [3:1] Clock source for channel 2 time base counter (rwh) */
    __I  Ifx_Strict_32Bit :28;             /**< \brief [31:4] \internal Reserved */
} Ifx_EGTM_CLS_TBU_CH2_CTRL_Bits;

/** \brief TBU channel 3 base */
typedef struct _Ifx_EGTM_CLS_TBU_CH3_BASE_Bits
{
    __IO Ifx_Strict_32Bit BASE:24;         /**< \brief [23:0] Time base value for channel 3 (rwh) */
    __I  Ifx_Strict_32Bit :8;              /**< \brief [31:24] \internal Reserved */
} Ifx_EGTM_CLS_TBU_CH3_BASE_Bits;

/** \brief TBU channel 3 base captured */
typedef struct _Ifx_EGTM_CLS_TBU_CH3_BASE_CAPTURE_Bits
{
    __I  Ifx_Strict_32Bit BASE_CAPTURE:24;    /**< \brief [23:0] Captured value of time base channel 1 or channel 2 (rh) */
    __I  Ifx_Strict_32Bit :8;              /**< \brief [31:24] \internal Reserved */
} Ifx_EGTM_CLS_TBU_CH3_BASE_CAPTURE_Bits;

/** \brief TBU channel 3 modulo value */
typedef struct _Ifx_EGTM_CLS_TBU_CH3_BASE_MARK_Bits
{
    __IO Ifx_Strict_32Bit BASE_MARK:24;    /**< \brief [23:0] Modulo value for channel 3 (rwh) */
    __I  Ifx_Strict_32Bit :8;              /**< \brief [31:24] \internal Reserved */
} Ifx_EGTM_CLS_TBU_CH3_BASE_MARK_Bits;

/** \brief TBU channel 3 control */
typedef struct _Ifx_EGTM_CLS_TBU_CH3_CTRL_Bits
{
    __I  Ifx_Strict_32Bit CH_MODE:1;       /**< \brief [0:0] Channel mode (rh) */
    __I  Ifx_Strict_32Bit :3;              /**< \brief [3:1] \internal Reserved */
    __IO Ifx_Strict_32Bit USE_CH2:1;       /**< \brief [4:4] Channel selector for modulo counter (rwh) */
    __I  Ifx_Strict_32Bit :27;             /**< \brief [31:5] \internal Reserved */
} Ifx_EGTM_CLS_TBU_CH3_CTRL_Bits;

/** \brief TBU global channel enable */
typedef struct _Ifx_EGTM_CLS_TBU_CHEN_Bits
{
    __IO Ifx_Strict_32Bit ENDIS_CH0:2;     /**< \brief [1:0] TBU channel [y] enable/disable control (rwh) */
    __IO Ifx_Strict_32Bit ENDIS_CH1:2;     /**< \brief [3:2] TBU channel [y] enable/disable control (rwh) */
    __IO Ifx_Strict_32Bit ENDIS_CH2:2;     /**< \brief [5:4] TBU channel [y] enable/disable control (rwh) */
    __IO Ifx_Strict_32Bit ENDIS_CH3:2;     /**< \brief [7:6] TBU channel [y] enable/disable control (rwh) */
    __I  Ifx_Strict_32Bit :24;             /**< \brief [31:8] \internal Reserved */
} Ifx_EGTM_CLS_TBU_CHEN_Bits;

/** \brief TBU channel [x] base */
typedef struct _Ifx_EGTM_CLS_TBU_CH_BASE_Bits
{
    __IO Ifx_Strict_32Bit BASE:24;         /**< \brief [23:0] Time base value for channel [x] (rwh) */
    __I  Ifx_Strict_32Bit :8;              /**< \brief [31:24] \internal Reserved */
} Ifx_EGTM_CLS_TBU_CH_BASE_Bits;

/** \brief TIM[i] channel [x] SMU counter register */
typedef struct _Ifx_EGTM_CLS_TIM_CH_CNT_Bits
{
    __I  Ifx_Strict_32Bit CNT:24;          /**< \brief [23:0] Actual SMU counter value (rh) */
    __I  Ifx_Strict_32Bit :8;              /**< \brief [31:24] \internal Reserved */
} Ifx_EGTM_CLS_TIM_CH_CNT_Bits;

/** \brief TIM[i] channel [x] SMU shadow counter register */
typedef struct _Ifx_EGTM_CLS_TIM_CH_CNTS_Bits
{
    __IO Ifx_Strict_32Bit CNTS:24;         /**< \brief [23:0] Counter shadow register (rwh) */
    __I  Ifx_Strict_32Bit ECNT:8;          /**< \brief [31:24] Edge counter (rh) */
} Ifx_EGTM_CLS_TIM_CH_CNTS_Bits;

/** \brief TIM[i] channel [x] control register */
typedef struct _Ifx_EGTM_CLS_TIM_CH_CTRL_Bits
{
    __IO Ifx_Strict_32Bit TIM_EN:1;        /**< \brief [0:0] TIM channel [x] enable (rwh) */
    __IO Ifx_Strict_32Bit TIM_MODE:3;      /**< \brief [3:1] TIM channel [x] mode (rw) */
    __IO Ifx_Strict_32Bit OSM:1;           /**< \brief [4:4] One-shot mode (rw) */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [5:5] \internal Reserved */
    __IO Ifx_Strict_32Bit CICTRL:1;        /**< \brief [6:6] Channel Input Control (rw) */
    __IO Ifx_Strict_32Bit TBU0_SEL:1;      /**< \brief [7:7] TIM_TBU_TS0 bits input select for TIM0_CH[x]_GPR0 and TIM0_CH[x]_GPR1 (rw) */
    __IO Ifx_Strict_32Bit GPR0_SEL:2;      /**< \brief [9:8] Selection for TIM[i]_CH[x]_GPR0 register (rw) */
    __IO Ifx_Strict_32Bit GPR1_SEL:2;      /**< \brief [11:10] Selection for TIM[i]_CH[x]_GPR1 register (rw) */
    __IO Ifx_Strict_32Bit CNTS_SEL:1;      /**< \brief [12:12] Selection for TIM[i]_CH[x]_CNTS register (rw) */
    __IO Ifx_Strict_32Bit DSL:1;           /**< \brief [13:13] Signal level control (rw) */
    __IO Ifx_Strict_32Bit ISL:1;           /**< \brief [14:14] Ignore signal level (rw) */
    __IO Ifx_Strict_32Bit ECNT_RESET:1;    /**< \brief [15:15] Enables resetting of counter in certain modes (rw) */
    __IO Ifx_Strict_32Bit FLT_EN:1;        /**< \brief [16:16] Filter enable for channel [x] (rw) */
    __IO Ifx_Strict_32Bit FLT_CNT_FRQ:2;    /**< \brief [18:17] Filter counter frequency select (rw) */
    __IO Ifx_Strict_32Bit EXT_CAP_EN:1;    /**< \brief [19:19] Enables external capture mode. The selected TIM mode is only sensitive to external capture pulses the input event changes are ignored. (rw) */
    __IO Ifx_Strict_32Bit FLT_MODE_RE:1;    /**< \brief [20:20] Filter mode for rising edge (rw) */
    __IO Ifx_Strict_32Bit FLT_CTR_RE:1;    /**< \brief [21:21] Filter counter mode for rising edge (rw) */
    __IO Ifx_Strict_32Bit FLT_MODE_FE:1;    /**< \brief [22:22] Filter mode for falling edge (rw) */
    __IO Ifx_Strict_32Bit FLT_CTR_FE:1;    /**< \brief [23:23] Filter counter mode for falling edge (rw) */
    __IO Ifx_Strict_32Bit CLK_SEL:3;       /**< \brief [26:24] CMU clock source select for channel (rw) */
    __IO Ifx_Strict_32Bit FR_ECNT_OFL:1;    /**< \brief [27:27] Extended Edge counter overflow behavior (rw) */
    __IO Ifx_Strict_32Bit EGPR0_SEL:1;     /**< \brief [28:28] Extension of TIM[i]_CH[x]_CTRL.GPR0_SEL bit field (rw) */
    __IO Ifx_Strict_32Bit EGPR1_SEL:1;     /**< \brief [29:29] Extension of TIM[i]_CH[x]_CTRL.GPR1_SEL bit field (rw) */
    __IO Ifx_Strict_32Bit TOCTRL:2;        /**< \brief [31:30] Timeout control (rw) */
} Ifx_EGTM_CLS_TIM_CH_CTRL_Bits;

/** \brief TIM[i] channel [x] SMU edge counter register */
typedef struct _Ifx_EGTM_CLS_TIM_CH_ECNT_Bits
{
    __I  Ifx_Strict_32Bit ECNT:16;         /**< \brief [15:0] Edge counter (rh) */
    __I  Ifx_Strict_32Bit :16;             /**< \brief [31:16] \internal Reserved */
} Ifx_EGTM_CLS_TIM_CH_ECNT_Bits;

/** \brief TIM[i] channel [x] extended control register */
typedef struct _Ifx_EGTM_CLS_TIM_CH_ECTRL_Bits
{
    __IO Ifx_Strict_32Bit EXT_CAP_SRC:4;    /**< \brief [3:0] Defines selected source for triggering the TIM_EXT_CAPTURE functionality. (rw) */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [4:4] \internal Reserved */
    __IO Ifx_Strict_32Bit USE_PREV_TDU_IN:1;    /**< \brief [5:5] Select input data source for TDU (rw) */
    __IO Ifx_Strict_32Bit TODET_IRQ_SRC:2;    /**< \brief [7:6] Selection of source for TIM_TODET_IRQ (rw) */
    __IO Ifx_Strict_32Bit TDU_START:3;     /**< \brief [10:8] Defines condition which will start the TDU unit. (rw) */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [11:11] \internal Reserved */
    __IO Ifx_Strict_32Bit TDU_STOP:3;      /**< \brief [14:12] Defines condition which will stop the TDU unit. (rw) */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [15:15] \internal Reserved */
    __IO Ifx_Strict_32Bit TDU_RESYNC:4;    /**< \brief [19:16] Defines condition which will resynchronize the TDU unit. (rw) */
    __I  Ifx_Strict_32Bit :2;              /**< \brief [21:20] \internal Reserved */
    __IO Ifx_Strict_32Bit USE_LUT:2;       /**< \brief [23:22] Generate filter input by lookup table (rw) */
    __IO Ifx_Strict_32Bit EFLT_CTR_RE:1;    /**< \brief [24:24] Extension of bit field TIM[i]_CH[x]_CTRL.FLT_CTR_RE (rw) */
    __IO Ifx_Strict_32Bit EFLT_CTR_FE:1;    /**< \brief [25:25] Extension of bit field TIM[i]_CH[x]_CTRL.FLT_CTR_FE (rw) */
    __I  Ifx_Strict_32Bit :2;              /**< \brief [27:26] \internal Reserved */
    __IO Ifx_Strict_32Bit SWAP_CAPTURE:1;    /**< \brief [28:28] Swap point in time of capturing TIM[i]_CH[x]_CNTS and TIM[i]_CH[x]_GPR1 (rw) */
    __IO Ifx_Strict_32Bit IMM_START:1;     /**< \brief [29:29] Start the measurement immediately (rw) */
    __IO Ifx_Strict_32Bit ECLK_SEL:1;      /**< \brief [30:30] Extension of bit field TIM[i]_CH[x]_CTRL.CLK_SEL (rw) */
    __IO Ifx_Strict_32Bit USE_PREV_CH_IN:1;    /**< \brief [31:31] Select input data source for TIM channel (rw) */
} Ifx_EGTM_CLS_TIM_CH_ECTRL_Bits;

/** \brief TIM[i] channel [x] error interrupt enable register */
typedef struct _Ifx_EGTM_CLS_TIM_CH_EIRQ_EN_Bits
{
    __IO Ifx_Strict_32Bit NEWVAL_EIRQ_EN:1;    /**< \brief [0:0] TIM_NEWVAL[x]_EIRQ error interrupt enable (rw) */
    __IO Ifx_Strict_32Bit ECNTOFL_EIRQ_EN:1;    /**< \brief [1:1] TIM_ECNTOFL_IRQ[x:x] interrupt enable (rw) */
    __IO Ifx_Strict_32Bit CNTOFL_EIRQ_EN:1;    /**< \brief [2:2] TIM_CNTOFL_IRQ[x:x] interrupt enable (rw) */
    __IO Ifx_Strict_32Bit GPROFL_EIRQ_EN:1;    /**< \brief [3:3] TIM_GPROFL_IRQ[x:x] interrupt enable (rw) */
    __IO Ifx_Strict_32Bit TODET_EIRQ_EN:1;    /**< \brief [4:4] TIM_TODET_IRQ[x:x] interrupt enable (rw) */
    __IO Ifx_Strict_32Bit GLITCHDET_EIRQ_EN:1;    /**< \brief [5:5] TIM_GLITCHDET_IRQ[x:x] interrupt enable (rw) */
    __I  Ifx_Strict_32Bit :26;             /**< \brief [31:6] \internal Reserved */
} Ifx_EGTM_CLS_TIM_CH_EIRQ_EN_Bits;

/** \brief TIM[i] channel [x] filter parameter 1 register */
typedef struct _Ifx_EGTM_CLS_TIM_CH_FLT_FE_Bits
{
    __IO Ifx_Strict_32Bit FLT_FE:24;       /**< \brief [23:0] Filter parameter for falling edge (rw) */
    __I  Ifx_Strict_32Bit :8;              /**< \brief [31:24] \internal Reserved */
} Ifx_EGTM_CLS_TIM_CH_FLT_FE_Bits;

/** \brief TIM[i] channel [x] filter parameter 0 register */
typedef struct _Ifx_EGTM_CLS_TIM_CH_FLT_RE_Bits
{
    __IO Ifx_Strict_32Bit FLT_RE:24;       /**< \brief [23:0] Filter parameter for rising edge (rw) */
    __I  Ifx_Strict_32Bit :8;              /**< \brief [31:24] \internal Reserved */
} Ifx_EGTM_CLS_TIM_CH_FLT_RE_Bits;

/** \brief TIM[i] channel [x] general purpose 0 register */
typedef struct _Ifx_EGTM_CLS_TIM_CH_GPR0_Bits
{
    __IO Ifx_Strict_32Bit GPR0:24;         /**< \brief [23:0] Input signal characteristic parameter 0 (rwh) */
    __I  Ifx_Strict_32Bit ECNT:8;          /**< \brief [31:24] Edge counter, value refers to TIM[i]_CH[x]_ECNT.ECNT[7:0]. (rh) */
} Ifx_EGTM_CLS_TIM_CH_GPR0_Bits;

/** \brief TIM[i] channel [x] general purpose 1 register */
typedef struct _Ifx_EGTM_CLS_TIM_CH_GPR1_Bits
{
    __IO Ifx_Strict_32Bit GPR1:24;         /**< \brief [23:0] Input signal characteristic parameter 1 (rwh) */
    __I  Ifx_Strict_32Bit ECNT:8;          /**< \brief [31:24] Edge counter, value refers to TIM[i]_CH[x]_ECNT.ECNT[7:0]. (rh) */
} Ifx_EGTM_CLS_TIM_CH_GPR1_Bits;

/** \brief TIM[i] channel [x] interrupt enable register */
typedef struct _Ifx_EGTM_CLS_TIM_CH_IRQ_EN_Bits
{
    __IO Ifx_Strict_32Bit NEWVAL_IRQ_EN:1;    /**< \brief [0:0] TIM_NEWVAL_IRQ[x:x] interrupt enable (rw) */
    __IO Ifx_Strict_32Bit ECNTOFL_IRQ_EN:1;    /**< \brief [1:1] TIM_ECNTOFL_IRQ[x:x] interrupt enable (rw) */
    __IO Ifx_Strict_32Bit CNTOFL_IRQ_EN:1;    /**< \brief [2:2] TIM_CNTOFL_IRQ[x:x] interrupt enable (rw) */
    __IO Ifx_Strict_32Bit GPROFL_IRQ_EN:1;    /**< \brief [3:3] TIM_GPROFL_IRQ[x:x] interrupt enable (rw) */
    __IO Ifx_Strict_32Bit TODET_IRQ_EN:1;    /**< \brief [4:4] TIM_TODET_IRQ[x:x] interrupt enable (rw) */
    __IO Ifx_Strict_32Bit GLITCHDET_IRQ_EN:1;    /**< \brief [5:5] TIM_GLITCHDET_IRQ[x:x] interrupt enable (rw) */
    __I  Ifx_Strict_32Bit :26;             /**< \brief [31:6] \internal Reserved */
} Ifx_EGTM_CLS_TIM_CH_IRQ_EN_Bits;

/** \brief TIM[i] channel [x] force interrupt register */
typedef struct _Ifx_EGTM_CLS_TIM_CH_IRQ_FORCINT_Bits
{
    __IO Ifx_Strict_32Bit TRG_NEWVAL:1;    /**< \brief [0:0] Trigger the bit TIM_CH[x]_IRQ_NOTIFY.NEWVAL by software (rw) */
    __IO Ifx_Strict_32Bit TRG_ECNTOFL:1;    /**< \brief [1:1] Trigger the bit TIM_CHx_IRQ_NOTIFY.ECNTOFL by software (rw) */
    __IO Ifx_Strict_32Bit TRG_CNTOFL:1;    /**< \brief [2:2] Trigger the bit TIM_CH[x]_IRQ_NOTIFY.CNTOFL by software (rw) */
    __IO Ifx_Strict_32Bit TRG_GPROFL:1;    /**< \brief [3:3] Trigger the bit TIM_CH[x]_IRQ_NOTIFY.GPROFL by software (rw) */
    __IO Ifx_Strict_32Bit TRG_TODET:1;     /**< \brief [4:4] Trigger the bit TIM_CH[x]_IRQ_NOTIFY.TODET by software (rw) */
    __IO Ifx_Strict_32Bit TRG_GLITCHDET:1;    /**< \brief [5:5] Trigger the bit TIM_CH[x]_IRQ_NOTIFY.GLITCHDET by software (rw) */
    __I  Ifx_Strict_32Bit :26;             /**< \brief [31:6] \internal Reserved */
} Ifx_EGTM_CLS_TIM_CH_IRQ_FORCINT_Bits;

/** \brief TIM[i] channel [x] interrupt mode configuration register */
typedef struct _Ifx_EGTM_CLS_TIM_CH_IRQ_MODE_Bits
{
    __IO Ifx_Strict_32Bit IRQ_MODE:2;      /**< \brief [1:0] IRQ mode selection of channel [x] (rw) */
    __I  Ifx_Strict_32Bit :30;             /**< \brief [31:2] \internal Reserved */
} Ifx_EGTM_CLS_TIM_CH_IRQ_MODE_Bits;

/** \brief TIM[i] channel [x] interrupt notification register */
typedef struct _Ifx_EGTM_CLS_TIM_CH_IRQ_NOTIFY_Bits
{
    __IO Ifx_Strict_32Bit NEWVAL:1;        /**< \brief [0:0] New measurement value detected by the channel [x] ([x]:0...m-1) (rw1ch) */
    __IO Ifx_Strict_32Bit ECNTOFL:1;       /**< \brief [1:1] ECNT counter overflow of channel [x] ([x]:0...m-1) (rw1ch) */
    __IO Ifx_Strict_32Bit CNTOFL:1;        /**< \brief [2:2] SMU TIM[i]_CH[x]_CNT counter overflow of channel [x], ([x]:0...m-1) (rw1ch) */
    __IO Ifx_Strict_32Bit GPROFL:1;        /**< \brief [3:3] TIM[i]_CH[x]_GPR0 and TIM[i]_CH[x]_GPR1 data overflow, old data not read out before new data has arrived at input pin, ([x]:0...m-1) (rw1ch) */
    __IO Ifx_Strict_32Bit TODET:1;         /**< \brief [4:4] Timeout reached for input signal of channel [x], ([x]:0...m-1) (rw1ch) */
    __IO Ifx_Strict_32Bit GLITCHDET:1;     /**< \brief [5:5] Glitch detected on channel [x], ([x]:0...m-1) (rw1ch) */
    __I  Ifx_Strict_32Bit :26;             /**< \brief [31:6] \internal Reserved */
} Ifx_EGTM_CLS_TIM_CH_IRQ_NOTIFY_Bits;

/** \brief TIM[i]_CH[x]_TDUC */
typedef struct _Ifx_EGTM_CLS_TIM_CH_TDUC_Bits
{
    __IO Ifx_Strict_32Bit TO_CNT:8;        /**< \brief [7:0] Current Timeout value slice0 for channel [y] (rwh) */
    __IO Ifx_Strict_32Bit TO_CNT1:8;       /**< \brief [15:8] Current Timeout value slice1 for channel [y] (rwh) */
    __IO Ifx_Strict_32Bit TO_CNT2:8;       /**< \brief [23:16] Current Timeout value slice2 for channel [y] (rwh) */
    __I  Ifx_Strict_32Bit :8;              /**< \brief [31:24] \internal Reserved */
} Ifx_EGTM_CLS_TIM_CH_TDUC_Bits;

/** \brief TIM[i]_CH[x]_TDUV */
typedef struct _Ifx_EGTM_CLS_TIM_CH_TDUV_Bits
{
    __IO Ifx_Strict_32Bit TOV:8;           /**< \brief [7:0] Time out compare value slice0 for channel [y] (rw) */
    __IO Ifx_Strict_32Bit TOV1:8;          /**< \brief [15:8] Time out compare value slice1 for channel [y] (rw) */
    __IO Ifx_Strict_32Bit TOV2:8;          /**< \brief [23:16] Time out compare value slice2 for channel [y] (rw) */
    __IO Ifx_Strict_32Bit SLICING:2;       /**< \brief [25:24] Cascading of counter slices (rw) */
    __IO Ifx_Strict_32Bit TCS_USE_SAMPLE_EVT:1;    /**< \brief [26:26] Use TDU_SAMPLE_EVT as Timeout Clock (rw) */
    __IO Ifx_Strict_32Bit TDU_SAME_CNT_CLK:1;    /**< \brief [27:27] Define clocking of TO_CNT, TO_CNT1 (rw) */
    __IO Ifx_Strict_32Bit TCS:3;           /**< \brief [30:28] Timeout clock selection (rw) */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [31:31] \internal Reserved */
} Ifx_EGTM_CLS_TIM_CH_TDUV_Bits;

/** \brief TIM[i] input value observation register */
typedef struct _Ifx_EGTM_CLS_TIM_INP_VAL_Bits
{
    __I  Ifx_Strict_32Bit F_OUT0:1;        /**< \brief [0:0] Signal channel [x] after TIM FLT unit (rh) */
    __I  Ifx_Strict_32Bit F_OUT1:1;        /**< \brief [1:1] Signal channel [x] after TIM FLT unit (rh) */
    __I  Ifx_Strict_32Bit F_OUT2:1;        /**< \brief [2:2] Signal channel [x] after TIM FLT unit (rh) */
    __I  Ifx_Strict_32Bit F_OUT3:1;        /**< \brief [3:3] Signal channel [x] after TIM FLT unit (rh) */
    __I  Ifx_Strict_32Bit F_OUT4:1;        /**< \brief [4:4] Signal channel [x] after TIM FLT unit (rh) */
    __I  Ifx_Strict_32Bit F_OUT5:1;        /**< \brief [5:5] Signal channel [x] after TIM FLT unit (rh) */
    __I  Ifx_Strict_32Bit F_OUT6:1;        /**< \brief [6:6] Signal channel [x] after TIM FLT unit (rh) */
    __I  Ifx_Strict_32Bit F_OUT7:1;        /**< \brief [7:7] Signal channel [x] after TIM FLT unit (rh) */
    __I  Ifx_Strict_32Bit F_IN0:1;         /**< \brief [8:8] Signal channel [x] after INPSRC selection, before TIM FLT unit (rh) */
    __I  Ifx_Strict_32Bit F_IN1:1;         /**< \brief [9:9] Signal channel [x] after INPSRC selection, before TIM FLT unit (rh) */
    __I  Ifx_Strict_32Bit F_IN2:1;         /**< \brief [10:10] Signal channel [x] after INPSRC selection, before TIM FLT unit (rh) */
    __I  Ifx_Strict_32Bit F_IN3:1;         /**< \brief [11:11] Signal channel [x] after INPSRC selection, before TIM FLT unit (rh) */
    __I  Ifx_Strict_32Bit F_IN4:1;         /**< \brief [12:12] Signal channel [x] after INPSRC selection, before TIM FLT unit (rh) */
    __I  Ifx_Strict_32Bit F_IN5:1;         /**< \brief [13:13] Signal channel [x] after INPSRC selection, before TIM FLT unit (rh) */
    __I  Ifx_Strict_32Bit F_IN6:1;         /**< \brief [14:14] Signal channel [x] after INPSRC selection, before TIM FLT unit (rh) */
    __I  Ifx_Strict_32Bit F_IN7:1;         /**< \brief [15:15] Signal channel [x] after INPSRC selection, before TIM FLT unit (rh) */
    __I  Ifx_Strict_32Bit TIM_IN0:1;       /**< \brief [16:16] Signal channel [x] after TIM input signal synchronization (rh) */
    __I  Ifx_Strict_32Bit TIM_IN1:1;       /**< \brief [17:17] Signal channel [x] after TIM input signal synchronization (rh) */
    __I  Ifx_Strict_32Bit TIM_IN2:1;       /**< \brief [18:18] Signal channel [x] after TIM input signal synchronization (rh) */
    __I  Ifx_Strict_32Bit TIM_IN3:1;       /**< \brief [19:19] Signal channel [x] after TIM input signal synchronization (rh) */
    __I  Ifx_Strict_32Bit TIM_IN4:1;       /**< \brief [20:20] Signal channel [x] after TIM input signal synchronization (rh) */
    __I  Ifx_Strict_32Bit TIM_IN5:1;       /**< \brief [21:21] Signal channel [x] after TIM input signal synchronization (rh) */
    __I  Ifx_Strict_32Bit TIM_IN6:1;       /**< \brief [22:22] Signal channel [x] after TIM input signal synchronization (rh) */
    __I  Ifx_Strict_32Bit TIM_IN7:1;       /**< \brief [23:23] Signal channel [x] after TIM input signal synchronization (rh) */
    __I  Ifx_Strict_32Bit :8;              /**< \brief [31:24] \internal Reserved */
} Ifx_EGTM_CLS_TIM_INP_VAL_Bits;

/** \brief TIM[i] AUX IN source selection register */
typedef struct _Ifx_EGTM_CLS_TIM_IN_SRC_Bits
{
    __IO Ifx_Strict_32Bit VAL0:2;          /**< \brief [1:0] Value to be fed to channel [x] (rwh) */
    __IO Ifx_Strict_32Bit MODE0:2;         /**< \brief [3:2] Input source to channel [x] (rwh) */
    __IO Ifx_Strict_32Bit VAL1:2;          /**< \brief [5:4] Value to be fed to channel [x] (rwh) */
    __IO Ifx_Strict_32Bit MODE1:2;         /**< \brief [7:6] Input source to channel [x] (rwh) */
    __IO Ifx_Strict_32Bit VAL2:2;          /**< \brief [9:8] Value to be fed to channel [x] (rwh) */
    __IO Ifx_Strict_32Bit MODE2:2;         /**< \brief [11:10] Input source to channel [x] (rwh) */
    __IO Ifx_Strict_32Bit VAL3:2;          /**< \brief [13:12] Value to be fed to channel [x] (rwh) */
    __IO Ifx_Strict_32Bit MODE3:2;         /**< \brief [15:14] Input source to channel [x] (rwh) */
    __IO Ifx_Strict_32Bit VAL4:2;          /**< \brief [17:16] Value to be fed to channel [x] (rwh) */
    __IO Ifx_Strict_32Bit MODE4:2;         /**< \brief [19:18] Input source to channel [x] (rwh) */
    __IO Ifx_Strict_32Bit VAL5:2;          /**< \brief [21:20] Value to be fed to channel [x] (rwh) */
    __IO Ifx_Strict_32Bit MODE5:2;         /**< \brief [23:22] Input source to channel [x] (rwh) */
    __IO Ifx_Strict_32Bit VAL6:2;          /**< \brief [25:24] Value to be fed to channel [x] (rwh) */
    __IO Ifx_Strict_32Bit MODE6:2;         /**< \brief [27:26] Input source to channel [x] (rwh) */
    __IO Ifx_Strict_32Bit VAL7:2;          /**< \brief [29:28] Value to be fed to channel [x] (rwh) */
    __IO Ifx_Strict_32Bit MODE7:2;         /**< \brief [31:30] Input source to channel [x] (rwh) */
} Ifx_EGTM_CLS_TIM_IN_SRC_Bits;

/** \brief TIM[i] global software reset register */
typedef struct _Ifx_EGTM_CLS_TIM_RST_Bits
{
    __IO Ifx_Strict_32Bit RST_CH0:1;       /**< \brief [0:0] Software reset of channel [x] (rw) */
    __IO Ifx_Strict_32Bit RST_CH1:1;       /**< \brief [1:1] Software reset of channel [x] (rw) */
    __IO Ifx_Strict_32Bit RST_CH2:1;       /**< \brief [2:2] Software reset of channel [x] (rw) */
    __IO Ifx_Strict_32Bit RST_CH3:1;       /**< \brief [3:3] Software reset of channel [x] (rw) */
    __IO Ifx_Strict_32Bit RST_CH4:1;       /**< \brief [4:4] Software reset of channel [x] (rw) */
    __IO Ifx_Strict_32Bit RST_CH5:1;       /**< \brief [5:5] Software reset of channel [x] (rw) */
    __IO Ifx_Strict_32Bit RST_CH6:1;       /**< \brief [6:6] Software reset of channel [x] (rw) */
    __IO Ifx_Strict_32Bit RST_CH7:1;       /**< \brief [7:7] Software reset of channel [x] (rw) */
    __I  Ifx_Strict_32Bit :24;             /**< \brief [31:8] \internal Reserved */
} Ifx_EGTM_CLS_TIM_RST_Bits;

/** \brief TOM[i] channel [x] CCU0 compare register */
typedef struct _Ifx_EGTM_CLS_TOM_CH_CM0_Bits
{
    __IO Ifx_Strict_32Bit CM0:16;          /**< \brief [15:0] TOM[i] channel [x] CCU0 compare register (rwh) */
    __I  Ifx_Strict_32Bit :16;             /**< \brief [31:16] \internal Reserved */
} Ifx_EGTM_CLS_TOM_CH_CM0_Bits;

/** \brief TOM[i] channel [x] CCU1 compare register */
typedef struct _Ifx_EGTM_CLS_TOM_CH_CM1_Bits
{
    __IO Ifx_Strict_32Bit CM1:16;          /**< \brief [15:0] TOM[i] channel [x] CCU1 compare register (rwh) */
    __I  Ifx_Strict_32Bit :16;             /**< \brief [31:16] \internal Reserved */
} Ifx_EGTM_CLS_TOM_CH_CM1_Bits;

/** \brief TOM[i] channel [x] CCU0 counter */
typedef struct _Ifx_EGTM_CLS_TOM_CH_CN0_Bits
{
    __IO Ifx_Strict_32Bit CN0:16;          /**< \brief [15:0] TOM[i] CCU0 counter (rwh) */
    __I  Ifx_Strict_32Bit :16;             /**< \brief [31:16] \internal Reserved */
} Ifx_EGTM_CLS_TOM_CH_CN0_Bits;

/** \brief TOM[i] channel [x] control register */
typedef struct _Ifx_EGTM_CLS_TOM_CH_CTRL_Bits
{
    __I  Ifx_Strict_32Bit :7;              /**< \brief [6:0] \internal Reserved */
    __IO Ifx_Strict_32Bit SR0_TRIG:1;      /**< \brief [7:7] TOM[i]_CH[x]_SR0 is used to generate a trigger on output TOM_OUT_T[x:x] if equal to TOM[i]_CH[x]_CN0. (rw) */
    __I  Ifx_Strict_32Bit :3;              /**< \brief [10:8] \internal Reserved */
    __IO Ifx_Strict_32Bit SL:1;            /**< \brief [11:11] Signal level for pulse width (rwh) */
    __IO Ifx_Strict_32Bit CLK_SRC:4;       /**< \brief [15:12] Clock source select for channel (rwh) */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [16:16] \internal Reserved */
    __IO Ifx_Strict_32Bit TRIG_PULSE:1;    /**< \brief [17:17] Trigger output pulse length of one cluster clock period (rw) */
    __IO Ifx_Strict_32Bit UDMODE:2;        /**< \brief [19:18] Up-down counter mode (rw) */
    __IO Ifx_Strict_32Bit RST_CCU0:1;      /**< \brief [20:20] Reset source of CCU0 (rw) */
    __IO Ifx_Strict_32Bit OSM_TRIG:1;      /**< \brief [21:21] One-shot pulse generation enabled by the selected trigger signal (rw) */
    __IO Ifx_Strict_32Bit EXT_TRIG:1;      /**< \brief [22:22] Select TOM_EXT_TRIGIN[x:x] as trigger signal (rw) */
    __IO Ifx_Strict_32Bit EXTTRIGOUT:1;    /**< \brief [23:23] Select TOM_EXT_TRIGIN[x:x] as potential output signal TOM_CH_TRIGOUT[x:x] (rw) */
    __IO Ifx_Strict_32Bit TRIGOUT:1;       /**< \brief [24:24] Trigger output selection (output signal TOM_CH_TRIGOUT[x:x]) of module TOM channel [x] (rw) */
    __IO Ifx_Strict_32Bit SPE_TRIG:1;      /**< \brief [25:25] SPE trigger to reset TOM[i]_CH[x]_CN0 (rw) */
    __IO Ifx_Strict_32Bit OSM:1;           /**< \brief [26:26] One-shot mode. In this mode the counter TOM[i]_CH[x]_CN0 counts for only one period. The length of period is defined by TOM[i]_CH[x]_CM0. A write access to the register TOM[i]_CH[x]_CN0 triggers the start of counting. (rw) */
    __IO Ifx_Strict_32Bit BITREV:1;        /**< \brief [27:27] Bit-reversing of output of counter TOM[i]_CH[x]_CN0. (rw) */
    __IO Ifx_Strict_32Bit SPEM:1;          /**< \brief [28:28] SPE output mode enable for channel. (rw) */
    __IO Ifx_Strict_32Bit GCM:1;           /**< \brief [29:29] Gated Counter Mode enable (rw) */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [30:30] \internal Reserved */
    __IO Ifx_Strict_32Bit FREEZE:1;        /**< \brief [31:31] TOM[i] Freeze Mode enable (rw) */
} Ifx_EGTM_CLS_TOM_CH_CTRL_Bits;

/** \brief TOM[i] channel [x] control shadow register */
typedef struct _Ifx_EGTM_CLS_TOM_CH_CTRL_SR_Bits
{
    __I  Ifx_Strict_32Bit :11;             /**< \brief [10:0] \internal Reserved */
    __IO Ifx_Strict_32Bit SL_SR:1;         /**< \brief [11:11] Shadow register for TOM[i]_CH[x]_CTRL.SL (rw) */
    __IO Ifx_Strict_32Bit CLK_SRC_SR:4;    /**< \brief [15:12] Shadow register for TOM[i]_CH[x]_CTRL.CLK_SRC (rw) */
    __I  Ifx_Strict_32Bit :16;             /**< \brief [31:16] \internal Reserved */
} Ifx_EGTM_CLS_TOM_CH_CTRL_SR_Bits;

/** \brief TOM[i] channel [x] interrupt enable register */
typedef struct _Ifx_EGTM_CLS_TOM_CH_IRQ_EN_Bits
{
    __IO Ifx_Strict_32Bit CCU0TC_IRQ_EN:1;    /**< \brief [0:0] TOM_CCU0TC[x]_IRQ interrupt enable (rw) */
    __IO Ifx_Strict_32Bit CCU1TC_IRQ_EN:1;    /**< \brief [1:1] TOM_CCU1TC[x]_IRQ interrupt enable (rw) */
    __I  Ifx_Strict_32Bit :30;             /**< \brief [31:2] \internal Reserved */
} Ifx_EGTM_CLS_TOM_CH_IRQ_EN_Bits;

/** \brief TOM[i] channel [x] force interrupt register */
typedef struct _Ifx_EGTM_CLS_TOM_CH_IRQ_FORCINT_Bits
{
    __IO Ifx_Strict_32Bit TRG_CCU0TC:1;    /**< \brief [0:0] Trigger the bit TOM[i]_CH[x]_IRQ_NOTIFY.CCU0TC by software (rw) */
    __IO Ifx_Strict_32Bit TRG_CCU1TC:1;    /**< \brief [1:1] Trigger the bit TOM[i]_CH[x]_IRQ_NOTIFY.CCU1TC by software (rw) */
    __I  Ifx_Strict_32Bit :30;             /**< \brief [31:2] \internal Reserved */
} Ifx_EGTM_CLS_TOM_CH_IRQ_FORCINT_Bits;

/** \brief TOM[i] channel [x] interrupt mode register */
typedef struct _Ifx_EGTM_CLS_TOM_CH_IRQ_MODE_Bits
{
    __IO Ifx_Strict_32Bit IRQ_MODE:2;      /**< \brief [1:0] IRQ mode selection (rw) */
    __I  Ifx_Strict_32Bit :30;             /**< \brief [31:2] \internal Reserved */
} Ifx_EGTM_CLS_TOM_CH_IRQ_MODE_Bits;

/** \brief TOM[i] channel [x] interrupt notification register */
typedef struct _Ifx_EGTM_CLS_TOM_CH_IRQ_NOTIFY_Bits
{
    __IO Ifx_Strict_32Bit CCU0TC:1;        /**< \brief [0:0] CCU0 Trigger condition interrupt for channel [x] (rw1ch) */
    __IO Ifx_Strict_32Bit CCU1TC:1;        /**< \brief [1:1] CCU1 Trigger condition interrupt for channel [x] (rw1ch) */
    __I  Ifx_Strict_32Bit :30;             /**< \brief [31:2] \internal Reserved */
} Ifx_EGTM_CLS_TOM_CH_IRQ_NOTIFY_Bits;

/** \brief TOM[i] channel [x] CCU0 compare shadow register */
typedef struct _Ifx_EGTM_CLS_TOM_CH_SR0_Bits
{
    __IO Ifx_Strict_32Bit SR0:16;          /**< \brief [15:0] TOM[i] channel [x] shadow register TOM[i]_CH[x]_SR0 for update of compare register TOM[i]_CH[x]_CM0 (rw) */
    __I  Ifx_Strict_32Bit :16;             /**< \brief [31:16] \internal Reserved */
} Ifx_EGTM_CLS_TOM_CH_SR0_Bits;

/** \brief TOM[i] channel [x] CCU1 compare shadow register */
typedef struct _Ifx_EGTM_CLS_TOM_CH_SR1_Bits
{
    __IO Ifx_Strict_32Bit SR1:16;          /**< \brief [15:0] TOM[i] channel [x] shadow register TOM[i]_CH[x]_SR1 for update of compare register TOM[i]_CH[x]_CM1 (rw) */
    __I  Ifx_Strict_32Bit :16;             /**< \brief [31:16] \internal Reserved */
} Ifx_EGTM_CLS_TOM_CH_SR1_Bits;

/** \brief TOM[i] channel [x] status register */
typedef struct _Ifx_EGTM_CLS_TOM_CH_STAT_Bits
{
    __I  Ifx_Strict_32Bit OL:1;            /**< \brief [0:0] Output level of output TOM_OUT[x:x] (rh) */
    __I  Ifx_Strict_32Bit :28;             /**< \brief [28:1] \internal Reserved */
    __IO Ifx_Strict_32Bit OSM_RTF:1;       /**< \brief [29:29] Oneshot mode retrigger failed flag (rw1ch) */
    __I  Ifx_Strict_32Bit :2;              /**< \brief [31:30] \internal Reserved */
} Ifx_EGTM_CLS_TOM_CH_STAT_Bits;

/** \brief TOM[i] TGC [g] action time base register */
typedef struct _Ifx_EGTM_CLS_TOM_TGC_ACT_TB_Bits
{
    __IO Ifx_Strict_32Bit ACT_TB:24;       /**< \brief [23:0] Specifies the signed compare value with selected signal CCM[i]_TBU_TS0, CCM[i]_TBU_TS1 and CCM[i]_TBU_TS2. If selected CCM[i]_TBU_TS0, CCM[i]_TBU_TS1 and CCM[i]_TBU_TS2 value is in the interval [TOM[i]_TGC[g]_ACT_TB.ACT_TB-007FFFFFh,TOM[i]_TGC[g]_ACT_TB.ACT_TB] the event is in the past and the trigger is generated immediately. Otherwise the event is in the future and the trigger is generated if selected CCM[i]_TBU_TS0, CCM[i]_TBU_TS1 and CCM[i]_TBU_TS2 is equal to TOM[i]_TGC[g]_ACT_TB.ACT_TB. (rw) */
    __IO Ifx_Strict_32Bit TB_TRIG:1;       /**< \brief [24:24] Set trigger request (rwh) */
    __IO Ifx_Strict_32Bit TBU_SEL:2;       /**< \brief [26:25] Selection of time base used for comparison (rw) */
    __I  Ifx_Strict_32Bit :5;              /**< \brief [31:27] \internal Reserved */
} Ifx_EGTM_CLS_TOM_TGC_ACT_TB_Bits;

/** \brief TOM[i] TGC [g] enable/disable control register */
typedef struct _Ifx_EGTM_CLS_TOM_TGC_ENDIS_CTRL_Bits
{
    __IO Ifx_Strict_32Bit ENDIS_CTRL0:2;    /**< \brief [1:0] TOM[i] channel [x] (x=c + g*8) enable/disable control register. (rw) */
    __IO Ifx_Strict_32Bit ENDIS_CTRL1:2;    /**< \brief [3:2] TOM[i] channel [x] (x=c + g*8) enable/disable control register. (rw) */
    __IO Ifx_Strict_32Bit ENDIS_CTRL2:2;    /**< \brief [5:4] TOM[i] channel [x] (x=c + g*8) enable/disable control register. (rw) */
    __IO Ifx_Strict_32Bit ENDIS_CTRL3:2;    /**< \brief [7:6] TOM[i] channel [x] (x=c + g*8) enable/disable control register. (rw) */
    __IO Ifx_Strict_32Bit ENDIS_CTRL4:2;    /**< \brief [9:8] TOM[i] channel [x] (x=c + g*8) enable/disable control register. (rw) */
    __IO Ifx_Strict_32Bit ENDIS_CTRL5:2;    /**< \brief [11:10] TOM[i] channel [x] (x=c + g*8) enable/disable control register. (rw) */
    __IO Ifx_Strict_32Bit ENDIS_CTRL6:2;    /**< \brief [13:12] TOM[i] channel [x] (x=c + g*8) enable/disable control register. (rw) */
    __IO Ifx_Strict_32Bit ENDIS_CTRL7:2;    /**< \brief [15:14] TOM[i] channel [x] (x=c + g*8) enable/disable control register. (rw) */
    __I  Ifx_Strict_32Bit :16;             /**< \brief [31:16] \internal Reserved */
} Ifx_EGTM_CLS_TOM_TGC_ENDIS_CTRL_Bits;

/** \brief TOM[i] TGC [g] enable/disable status register */
typedef struct _Ifx_EGTM_CLS_TOM_TGC_ENDIS_STAT_Bits
{
    __IO Ifx_Strict_32Bit ENDIS_STAT0:2;    /**< \brief [1:0] TOM[i] channel [x] ( x=c + g*8 ) enable/disable status register (rwh) */
    __IO Ifx_Strict_32Bit ENDIS_STAT1:2;    /**< \brief [3:2] TOM[i] channel [x] ( x=c + g*8 ) enable/disable status register (rwh) */
    __IO Ifx_Strict_32Bit ENDIS_STAT2:2;    /**< \brief [5:4] TOM[i] channel [x] ( x=c + g*8 ) enable/disable status register (rwh) */
    __IO Ifx_Strict_32Bit ENDIS_STAT3:2;    /**< \brief [7:6] TOM[i] channel [x] ( x=c + g*8 ) enable/disable status register (rwh) */
    __IO Ifx_Strict_32Bit ENDIS_STAT4:2;    /**< \brief [9:8] TOM[i] channel [x] ( x=c + g*8 ) enable/disable status register (rwh) */
    __IO Ifx_Strict_32Bit ENDIS_STAT5:2;    /**< \brief [11:10] TOM[i] channel [x] ( x=c + g*8 ) enable/disable status register (rwh) */
    __IO Ifx_Strict_32Bit ENDIS_STAT6:2;    /**< \brief [13:12] TOM[i] channel [x] ( x=c + g*8 ) enable/disable status register (rwh) */
    __IO Ifx_Strict_32Bit ENDIS_STAT7:2;    /**< \brief [15:14] TOM[i] channel [x] ( x=c + g*8 ) enable/disable status register (rwh) */
    __I  Ifx_Strict_32Bit :16;             /**< \brief [31:16] \internal Reserved */
} Ifx_EGTM_CLS_TOM_TGC_ENDIS_STAT_Bits;

/** \brief TOM[i] TGC [g] force update control register */
typedef struct _Ifx_EGTM_CLS_TOM_TGC_FUPD_CTRL_Bits
{
    __IO Ifx_Strict_32Bit FUPD_CTRL0:2;    /**< \brief [1:0] Force update control of operation registers of TOM[i] channel [x] (x = c + g*8) (rw) */
    __IO Ifx_Strict_32Bit FUPD_CTRL1:2;    /**< \brief [3:2] Force update control of operation registers of TOM[i] channel [x] (x = c + g*8) (rw) */
    __IO Ifx_Strict_32Bit FUPD_CTRL2:2;    /**< \brief [5:4] Force update control of operation registers of TOM[i] channel [x] (x = c + g*8) (rw) */
    __IO Ifx_Strict_32Bit FUPD_CTRL3:2;    /**< \brief [7:6] Force update control of operation registers of TOM[i] channel [x] (x = c + g*8) (rw) */
    __IO Ifx_Strict_32Bit FUPD_CTRL4:2;    /**< \brief [9:8] Force update control of operation registers of TOM[i] channel [x] (x = c + g*8) (rw) */
    __IO Ifx_Strict_32Bit FUPD_CTRL5:2;    /**< \brief [11:10] Force update control of operation registers of TOM[i] channel [x] (x = c + g*8) (rw) */
    __IO Ifx_Strict_32Bit FUPD_CTRL6:2;    /**< \brief [13:12] Force update control of operation registers of TOM[i] channel [x] (x = c + g*8) (rw) */
    __IO Ifx_Strict_32Bit FUPD_CTRL7:2;    /**< \brief [15:14] Force update control of operation registers of TOM[i] channel [x] (x = c + g*8) (rw) */
    __IO Ifx_Strict_32Bit RSTCN0_CH0:2;    /**< \brief [17:16] Reset TOM[i]_CH[x]_CN0 of channel [x] (x=c + g*8) with the force update event (rw) */
    __IO Ifx_Strict_32Bit RSTCN0_CH1:2;    /**< \brief [19:18] Reset TOM[i]_CH[x]_CN0 of channel [x] (x=c + g*8) with the force update event (rw) */
    __IO Ifx_Strict_32Bit RSTCN0_CH2:2;    /**< \brief [21:20] Reset TOM[i]_CH[x]_CN0 of channel [x] (x=c + g*8) with the force update event (rw) */
    __IO Ifx_Strict_32Bit RSTCN0_CH3:2;    /**< \brief [23:22] Reset TOM[i]_CH[x]_CN0 of channel [x] (x=c + g*8) with the force update event (rw) */
    __IO Ifx_Strict_32Bit RSTCN0_CH4:2;    /**< \brief [25:24] Reset TOM[i]_CH[x]_CN0 of channel [x] (x=c + g*8) with the force update event (rw) */
    __IO Ifx_Strict_32Bit RSTCN0_CH5:2;    /**< \brief [27:26] Reset TOM[i]_CH[x]_CN0 of channel [x] (x=c + g*8) with the force update event (rw) */
    __IO Ifx_Strict_32Bit RSTCN0_CH6:2;    /**< \brief [29:28] Reset TOM[i]_CH[x]_CN0 of channel [x] (x=c + g*8) with the force update event (rw) */
    __IO Ifx_Strict_32Bit RSTCN0_CH7:2;    /**< \brief [31:30] Reset TOM[i]_CH[x]_CN0 of channel [x] (x=c + g*8) with the force update event (rw) */
} Ifx_EGTM_CLS_TOM_TGC_FUPD_CTRL_Bits;

/** \brief TOM[i] TGC [g] global control register */
typedef struct _Ifx_EGTM_CLS_TOM_TGC_GLB_CTRL_Bits
{
    __IO Ifx_Strict_32Bit HOST_TRIG:1;     /**< \brief [0:0] Trigger request signal to update the register TOM[i]_TGC[g]_ENDIS_STAT, TOM[i]_TGC[g]_OUTEN_STAT (rwh) */
    __I  Ifx_Strict_32Bit :7;              /**< \brief [7:1] \internal Reserved */
    __IO Ifx_Strict_32Bit RST_CH0:1;       /**< \brief [8:8] Software reset of channel [x]; x = c + g*8 (rw) */
    __IO Ifx_Strict_32Bit RST_CH1:1;       /**< \brief [9:9] Software reset of channel [x]; x = c + g*8 (rw) */
    __IO Ifx_Strict_32Bit RST_CH2:1;       /**< \brief [10:10] Software reset of channel [x]; x = c + g*8 (rw) */
    __IO Ifx_Strict_32Bit RST_CH3:1;       /**< \brief [11:11] Software reset of channel [x]; x = c + g*8 (rw) */
    __IO Ifx_Strict_32Bit RST_CH4:1;       /**< \brief [12:12] Software reset of channel [x]; x = c + g*8 (rw) */
    __IO Ifx_Strict_32Bit RST_CH5:1;       /**< \brief [13:13] Software reset of channel [x]; x = c + g*8 (rw) */
    __IO Ifx_Strict_32Bit RST_CH6:1;       /**< \brief [14:14] Software reset of channel [x]; x = c + g*8 (rw) */
    __IO Ifx_Strict_32Bit RST_CH7:1;       /**< \brief [15:15] Software reset of channel [x]; x = c + g*8 (rw) */
    __IO Ifx_Strict_32Bit UPEN_CTRL0:2;    /**< \brief [17:16] TOM[i] channel [x] ( x=c + g*8 ) enable update of register TOM[i]_CH[x]_CM0, TOM[i]_CH[x]_CM1, TOM[i]_CH[x]_CTRL.SL and TOM[i]_CH[x]_CTRL.CLK_SRC from TOM[i]_CH[x]_SR0, TOM[i]_CH[x]_SR1, TOM[i]_CH[x]_CTRL_SL.SL_SR and TOM[i]_CH[x]_CTRL_SR.CLK_SRC_SR. (rw) */
    __IO Ifx_Strict_32Bit UPEN_CTRL1:2;    /**< \brief [19:18] TOM[i] channel [x] ( x=c + g*8 ) enable update of register TOM[i]_CH[x]_CM0, TOM[i]_CH[x]_CM1, TOM[i]_CH[x]_CTRL.SL and TOM[i]_CH[x]_CTRL.CLK_SRC from TOM[i]_CH[x]_SR0, TOM[i]_CH[x]_SR1, TOM[i]_CH[x]_CTRL_SL.SL_SR and TOM[i]_CH[x]_CTRL_SR.CLK_SRC_SR. (rw) */
    __IO Ifx_Strict_32Bit UPEN_CTRL2:2;    /**< \brief [21:20] TOM[i] channel [x] ( x=c + g*8 ) enable update of register TOM[i]_CH[x]_CM0, TOM[i]_CH[x]_CM1, TOM[i]_CH[x]_CTRL.SL and TOM[i]_CH[x]_CTRL.CLK_SRC from TOM[i]_CH[x]_SR0, TOM[i]_CH[x]_SR1, TOM[i]_CH[x]_CTRL_SL.SL_SR and TOM[i]_CH[x]_CTRL_SR.CLK_SRC_SR. (rw) */
    __IO Ifx_Strict_32Bit UPEN_CTRL3:2;    /**< \brief [23:22] TOM[i] channel [x] ( x=c + g*8 ) enable update of register TOM[i]_CH[x]_CM0, TOM[i]_CH[x]_CM1, TOM[i]_CH[x]_CTRL.SL and TOM[i]_CH[x]_CTRL.CLK_SRC from TOM[i]_CH[x]_SR0, TOM[i]_CH[x]_SR1, TOM[i]_CH[x]_CTRL_SL.SL_SR and TOM[i]_CH[x]_CTRL_SR.CLK_SRC_SR. (rw) */
    __IO Ifx_Strict_32Bit UPEN_CTRL4:2;    /**< \brief [25:24] TOM[i] channel [x] ( x=c + g*8 ) enable update of register TOM[i]_CH[x]_CM0, TOM[i]_CH[x]_CM1, TOM[i]_CH[x]_CTRL.SL and TOM[i]_CH[x]_CTRL.CLK_SRC from TOM[i]_CH[x]_SR0, TOM[i]_CH[x]_SR1, TOM[i]_CH[x]_CTRL_SL.SL_SR and TOM[i]_CH[x]_CTRL_SR.CLK_SRC_SR. (rw) */
    __IO Ifx_Strict_32Bit UPEN_CTRL5:2;    /**< \brief [27:26] TOM[i] channel [x] ( x=c + g*8 ) enable update of register TOM[i]_CH[x]_CM0, TOM[i]_CH[x]_CM1, TOM[i]_CH[x]_CTRL.SL and TOM[i]_CH[x]_CTRL.CLK_SRC from TOM[i]_CH[x]_SR0, TOM[i]_CH[x]_SR1, TOM[i]_CH[x]_CTRL_SL.SL_SR and TOM[i]_CH[x]_CTRL_SR.CLK_SRC_SR. (rw) */
    __IO Ifx_Strict_32Bit UPEN_CTRL6:2;    /**< \brief [29:28] TOM[i] channel [x] ( x=c + g*8 ) enable update of register TOM[i]_CH[x]_CM0, TOM[i]_CH[x]_CM1, TOM[i]_CH[x]_CTRL.SL and TOM[i]_CH[x]_CTRL.CLK_SRC from TOM[i]_CH[x]_SR0, TOM[i]_CH[x]_SR1, TOM[i]_CH[x]_CTRL_SL.SL_SR and TOM[i]_CH[x]_CTRL_SR.CLK_SRC_SR. (rw) */
    __IO Ifx_Strict_32Bit UPEN_CTRL7:2;    /**< \brief [31:30] TOM[i] channel [x] ( x=c + g*8 ) enable update of register TOM[i]_CH[x]_CM0, TOM[i]_CH[x]_CM1, TOM[i]_CH[x]_CTRL.SL and TOM[i]_CH[x]_CTRL.CLK_SRC from TOM[i]_CH[x]_SR0, TOM[i]_CH[x]_SR1, TOM[i]_CH[x]_CTRL_SL.SL_SR and TOM[i]_CH[x]_CTRL_SR.CLK_SRC_SR. (rw) */
} Ifx_EGTM_CLS_TOM_TGC_GLB_CTRL_Bits;

/** \brief TOM[i] TGC [g] internal trigger control register */
typedef struct _Ifx_EGTM_CLS_TOM_TGC_INT_TRIG_Bits
{
    __IO Ifx_Strict_32Bit INT_TRIG0:2;     /**< \brief [1:0] Select input signal TOM_CH_TRIGOUT[x:x] as a trigger source for TGC[g] (x=c + g*8) (rw) */
    __IO Ifx_Strict_32Bit INT_TRIG1:2;     /**< \brief [3:2] Select input signal TOM_CH_TRIGOUT[x:x] as a trigger source for TGC[g] (x=c + g*8) (rw) */
    __IO Ifx_Strict_32Bit INT_TRIG2:2;     /**< \brief [5:4] Select input signal TOM_CH_TRIGOUT[x:x] as a trigger source for TGC[g] (x=c + g*8) (rw) */
    __IO Ifx_Strict_32Bit INT_TRIG3:2;     /**< \brief [7:6] Select input signal TOM_CH_TRIGOUT[x:x] as a trigger source for TGC[g] (x=c + g*8) (rw) */
    __IO Ifx_Strict_32Bit INT_TRIG4:2;     /**< \brief [9:8] Select input signal TOM_CH_TRIGOUT[x:x] as a trigger source for TGC[g] (x=c + g*8) (rw) */
    __IO Ifx_Strict_32Bit INT_TRIG5:2;     /**< \brief [11:10] Select input signal TOM_CH_TRIGOUT[x:x] as a trigger source for TGC[g] (x=c + g*8) (rw) */
    __IO Ifx_Strict_32Bit INT_TRIG6:2;     /**< \brief [13:12] Select input signal TOM_CH_TRIGOUT[x:x] as a trigger source for TGC[g] (x=c + g*8) (rw) */
    __IO Ifx_Strict_32Bit INT_TRIG7:2;     /**< \brief [15:14] Select input signal TOM_CH_TRIGOUT[x:x] as a trigger source for TGC[g] (x=c + g*8) (rw) */
    __I  Ifx_Strict_32Bit :16;             /**< \brief [31:16] \internal Reserved */
} Ifx_EGTM_CLS_TOM_TGC_INT_TRIG_Bits;

/** \brief TOM[i] TGC [g] output enable control register */
typedef struct _Ifx_EGTM_CLS_TOM_TGC_OUTEN_CTRL_Bits
{
    __IO Ifx_Strict_32Bit OUTEN_CTRL0:2;    /**< \brief [1:0] Output enable control of TOM [i] channel [x] ouput TOM_OUT[x:x], x=c+g*8 (rw) */
    __IO Ifx_Strict_32Bit OUTEN_CTRL1:2;    /**< \brief [3:2] Output enable control of TOM [i] channel [x] ouput TOM_OUT[x:x], x=c+g*8 (rw) */
    __IO Ifx_Strict_32Bit OUTEN_CTRL2:2;    /**< \brief [5:4] Output enable control of TOM [i] channel [x] ouput TOM_OUT[x:x], x=c+g*8 (rw) */
    __IO Ifx_Strict_32Bit OUTEN_CTRL3:2;    /**< \brief [7:6] Output enable control of TOM [i] channel [x] ouput TOM_OUT[x:x], x=c+g*8 (rw) */
    __IO Ifx_Strict_32Bit OUTEN_CTRL4:2;    /**< \brief [9:8] Output enable control of TOM [i] channel [x] ouput TOM_OUT[x:x], x=c+g*8 (rw) */
    __IO Ifx_Strict_32Bit OUTEN_CTRL5:2;    /**< \brief [11:10] Output enable control of TOM [i] channel [x] ouput TOM_OUT[x:x], x=c+g*8 (rw) */
    __IO Ifx_Strict_32Bit OUTEN_CTRL6:2;    /**< \brief [13:12] Output enable control of TOM [i] channel [x] ouput TOM_OUT[x:x], x=c+g*8 (rw) */
    __IO Ifx_Strict_32Bit OUTEN_CTRL7:2;    /**< \brief [15:14] Output enable control of TOM [i] channel [x] ouput TOM_OUT[x:x], x=c+g*8 (rw) */
    __I  Ifx_Strict_32Bit :16;             /**< \brief [31:16] \internal Reserved */
} Ifx_EGTM_CLS_TOM_TGC_OUTEN_CTRL_Bits;

/** \brief TOM[i] TGC [g] output enable status register */
typedef struct _Ifx_EGTM_CLS_TOM_TGC_OUTEN_STAT_Bits
{
    __IO Ifx_Strict_32Bit OUTEN_STAT0:2;    /**< \brief [1:0] Output enable status of TOM [i] channel [x] ouput TOM_OUT[x:x], x=c+g*8 (rwh) */
    __IO Ifx_Strict_32Bit OUTEN_STAT1:2;    /**< \brief [3:2] Output enable status of TOM [i] channel [x] ouput TOM_OUT[x:x], x=c+g*8 (rwh) */
    __IO Ifx_Strict_32Bit OUTEN_STAT2:2;    /**< \brief [5:4] Output enable status of TOM [i] channel [x] ouput TOM_OUT[x:x], x=c+g*8 (rwh) */
    __IO Ifx_Strict_32Bit OUTEN_STAT3:2;    /**< \brief [7:6] Output enable status of TOM [i] channel [x] ouput TOM_OUT[x:x], x=c+g*8 (rwh) */
    __IO Ifx_Strict_32Bit OUTEN_STAT4:2;    /**< \brief [9:8] Output enable status of TOM [i] channel [x] ouput TOM_OUT[x:x], x=c+g*8 (rwh) */
    __IO Ifx_Strict_32Bit OUTEN_STAT5:2;    /**< \brief [11:10] Output enable status of TOM [i] channel [x] ouput TOM_OUT[x:x], x=c+g*8 (rwh) */
    __IO Ifx_Strict_32Bit OUTEN_STAT6:2;    /**< \brief [13:12] Output enable status of TOM [i] channel [x] ouput TOM_OUT[x:x], x=c+g*8 (rwh) */
    __IO Ifx_Strict_32Bit OUTEN_STAT7:2;    /**< \brief [15:14] Output enable status of TOM [i] channel [x] ouput TOM_OUT[x:x], x=c+g*8 (rwh) */
    __I  Ifx_Strict_32Bit :16;             /**< \brief [31:16] \internal Reserved */
} Ifx_EGTM_CLS_TOM_TGC_OUTEN_STAT_Bits;

/** \brief Cluster 0 DTMAUX input 0 selection register */
typedef struct _Ifx_EGTM_DTMAUX_IN_Bits
{
    __O  Ifx_UReg_32Bit SEL0:3;            /**< \brief [2:0] Input selection for CDTM0_DTM0_AUXINy (w) */
    __I  Ifx_UReg_32Bit :1;                /**< \brief [3:3] \internal Reserved */
    __O  Ifx_UReg_32Bit SEL1:3;            /**< \brief [6:4] Input selection for CDTM0_DTM1_AUXINy (w) */
    __I  Ifx_UReg_32Bit :1;                /**< \brief [7:7] \internal Reserved */
    __O  Ifx_UReg_32Bit SEL2:3;            /**< \brief [10:8] Input selection for CDTM0_DTM2_AUXINy (w) */
    __I  Ifx_UReg_32Bit :1;                /**< \brief [11:11] \internal Reserved */
    __O  Ifx_UReg_32Bit SEL3:3;            /**< \brief [14:12] Input selection for CDTM0_DTM3_AUXINy (w) */
    __I  Ifx_UReg_32Bit :1;                /**< \brief [15:15] \internal Reserved */
    __O  Ifx_UReg_32Bit SEL4:3;            /**< \brief [18:16] Input selection for CDTM0_DTM4_AUXINy (w) */
    __I  Ifx_UReg_32Bit :1;                /**< \brief [19:19] \internal Reserved */
    __O  Ifx_UReg_32Bit SEL5:3;            /**< \brief [22:20] Input selection for CDTM0_DTM5_AUXINy (w) */
    __I  Ifx_UReg_32Bit :1;                /**< \brief [23:23] \internal Reserved */
    __I  Ifx_UReg_32Bit :8;                /**< \brief [31:24] \internal Reserved */
} Ifx_EGTM_DTMAUX_IN_Bits;

/** \brief FOUT Selection for Encoder Interface 0 */
typedef struct _Ifx_EGTM_FOUTENC_Bits
{
    __IO Ifx_UReg_32Bit TIM_IN:3;          /**< \brief [2:0] TIM module selection for encoder interface input IN of GPT12x (rw) */
    __I  Ifx_UReg_32Bit :1;                /**< \brief [3:3] \internal Reserved */
    __IO Ifx_UReg_32Bit CH_IN:3;           /**< \brief [6:4] TIM channel selection for encoder interface input IN of GPT12x (rw) */
    __IO Ifx_UReg_32Bit EN_IN:1;           /**< \brief [7:7] Enable connection to encoder interface input IN of GPT12x (rw) */
    __IO Ifx_UReg_32Bit TIM_EUD:3;         /**< \brief [10:8] TIM module selection for encoder interface input EUD of GPT12x (rw) */
    __I  Ifx_UReg_32Bit :1;                /**< \brief [11:11] \internal Reserved */
    __IO Ifx_UReg_32Bit CH_EUD:3;          /**< \brief [14:12] TIM channel selection for encoder interface input EUD of GPT12x (rw) */
    __IO Ifx_UReg_32Bit EN_EUD:1;          /**< \brief [15:15] Enable connection to encoder interface input EUD of GPT12x (rw) */
    __IO Ifx_UReg_32Bit TIM_TOPZ:3;        /**< \brief [18:16] TIM module selection for encoder interface input TOP Zero (T4IN) of GPT12x (rw) */
    __I  Ifx_UReg_32Bit :1;                /**< \brief [19:19] \internal Reserved */
    __IO Ifx_UReg_32Bit CH_TOPZ:3;         /**< \brief [22:20] TIM channel selection for encoder interface input TOP Zero (T4IN) of GPT12x (rw) */
    __IO Ifx_UReg_32Bit EN_TOPZ:1;         /**< \brief [23:23] Enable connection to encoder interface input TOP Zero (T4IN) of GPT12x (rw) */
    __IO Ifx_UReg_32Bit TIM_CAPB:3;        /**< \brief [26:24] TIM module selection for CAPINB input of GPT12x (rw) */
    __I  Ifx_UReg_32Bit :1;                /**< \brief [27:27] \internal Reserved */
    __IO Ifx_UReg_32Bit CH_CAPB:3;         /**< \brief [30:28] TIM channel selection for CAPINB input of GPT12x (rw) */
    __IO Ifx_UReg_32Bit EN_CAPB:1;         /**< \brief [31:31] Enable connection to CAPINB input of GPT12x (rw) */
} Ifx_EGTM_FOUTENC_Bits;

/** \brief HRPWM0 16:1 Channel MUX select */
typedef struct _Ifx_EGTM_HRPWMMUX_CHSEL_Bits
{
    __IO Ifx_UReg_32Bit CH0:4;             /**< \brief [3:0] Channel 0 select (rw) */
    __IO Ifx_UReg_32Bit CH1:4;             /**< \brief [7:4] Channel 1 select (rw) */
    __IO Ifx_UReg_32Bit CH2:4;             /**< \brief [11:8] Channel 2 select (rw) */
    __IO Ifx_UReg_32Bit CH3:4;             /**< \brief [15:12] Channel 3 select (rw) */
    __IO Ifx_UReg_32Bit CH4:4;             /**< \brief [19:16] Channel 4 select (rw) */
    __IO Ifx_UReg_32Bit CH5:4;             /**< \brief [23:20] Channel 5 select (rw) */
    __IO Ifx_UReg_32Bit CH6:4;             /**< \brief [27:24] Channel 6 select (rw) */
    __IO Ifx_UReg_32Bit CH7:4;             /**< \brief [31:28] Channel 7 select (rw) */
} Ifx_EGTM_HRPWMMUX_CHSEL_Bits;

/** \brief HRPWM0 DLL configuration register High */
typedef struct _Ifx_EGTM_HRPWM_DLLCFGH_Bits
{
    __IO Ifx_UReg_32Bit LCNTRST:5;         /**< \brief [4:0] HRPWM0 DLL lock counter reset value (rw) */
    __IO Ifx_UReg_32Bit ULCNTRST:5;        /**< \brief [9:5] HRPWM0 DLL unlock counter reset value (rw) */
    __IO Ifx_UReg_32Bit LDETEXT:1;         /**< \brief [10:10] Lock Detection Extension. (rw) */
    __IO Ifx_UReg_32Bit FTCLKDIV:2;        /**< \brief [12:11] HRPWM0 Fine Tuning Clock Divider (rw) */
    __IO Ifx_UReg_32Bit CTCLKDIV:2;        /**< \brief [14:13] HRPWM0 Coarse Tuning Clock Divider. (rw) */
    __IO Ifx_UReg_32Bit LCLKBFEN:1;        /**< \brief [15:15] HRPWM0 Enable the lock with best fine tune circuit (rw) */
    __IO Ifx_UReg_32Bit FT_DELTA:7;        /**< \brief [22:16] HRPWM0 Fine Tuning Delta (rw) */
    __IO Ifx_UReg_32Bit CTMODSEL:2;        /**< \brief [24:23] HRPWM0 Coarse Tuning mode selection (rw) */
    __IO Ifx_UReg_32Bit IBIASSEL:3;        /**< \brief [27:25] HRPWM0 Bias current select (rw) */
    __I  Ifx_UReg_32Bit :4;                /**< \brief [31:28] \internal Reserved */
} Ifx_EGTM_HRPWM_DLLCFGH_Bits;

/** \brief HRPWM0 DLL configuration register Low */
typedef struct _Ifx_EGTM_HRPWM_DLLCFGL_Bits
{
    __IO Ifx_UReg_32Bit CTCORREN:1;        /**< \brief [0:0] HRPWM0 DLL course tune correction enable (rw) */
    __IO Ifx_UReg_32Bit TFTDELTA:4;        /**< \brief [4:1] HRPWM0 DLL tuning finetune delta for CT correction. (rw) */
    __I  Ifx_UReg_32Bit :27;               /**< \brief [31:5] \internal Reserved */
} Ifx_EGTM_HRPWM_DLLCFGL_Bits;

/** \brief HRPWM0 DLL status register */
typedef struct _Ifx_EGTM_HRPWM_DLLSTAT_Bits
{
    __I  Ifx_UReg_32Bit DLL_LOCK:1;        /**< \brief [0:0] DLL lock status (rh) */
    __I  Ifx_UReg_32Bit :31;               /**< \brief [31:1] \internal Reserved */
} Ifx_EGTM_HRPWM_DLLSTAT_Bits;

/** \brief HRPWM0 module and channel enable register */
typedef struct _Ifx_EGTM_HRPWM_EN_Bits
{
    __IO Ifx_UReg_32Bit MOD:1;             /**< \brief [0:0] HRPWM0 module enable (rw) */
    __I  Ifx_UReg_32Bit :23;               /**< \brief [23:1] \internal Reserved */
    __IO Ifx_UReg_32Bit CH0:1;             /**< \brief [24:24] HRPWM0 channel 0 enable (rw) */
    __IO Ifx_UReg_32Bit CH1:1;             /**< \brief [25:25] HRPWM0 channel 1 enable (rw) */
    __IO Ifx_UReg_32Bit CH2:1;             /**< \brief [26:26] HRPWM0 channel 2 enable (rw) */
    __IO Ifx_UReg_32Bit CH3:1;             /**< \brief [27:27] HRPWM0 channel 3 enable (rw) */
    __IO Ifx_UReg_32Bit CH4:1;             /**< \brief [28:28] HRPWM0 channel 4 enable (rw) */
    __IO Ifx_UReg_32Bit CH5:1;             /**< \brief [29:29] HRPWM0 channel 5 enable (rw) */
    __IO Ifx_UReg_32Bit CH6:1;             /**< \brief [30:30] HRPWM0 channel 6 enable (rw) */
    __IO Ifx_UReg_32Bit CH7:1;             /**< \brief [31:31] HRPWM0 channel 7 enable (rw) */
} Ifx_EGTM_HRPWM_EN_Bits;

/** \brief eGTM to LCDCDC output trigger selection register */
typedef struct _Ifx_EGTM_LCDCDC_OUT_Bits
{
    __IO Ifx_UReg_32Bit SEL:4;             /**< \brief [3:0] eGTM to LCDCDC trigger output selection (rw) */
    __I  Ifx_UReg_32Bit :28;               /**< \brief [31:4] \internal Reserved */
} Ifx_EGTM_LCDCDC_OUT_Bits;

/** \brief eGTM to MSC SET0 output selection register 0 */
typedef struct _Ifx_EGTM_MSCSET_CON0_Bits
{
    __IO Ifx_UReg_32Bit SEL0:5;            /**< \brief [4:0] SET0.x signal output selection (rw) */
    __I  Ifx_UReg_32Bit :3;                /**< \brief [7:5] \internal Reserved */
    __IO Ifx_UReg_32Bit SEL1:5;            /**< \brief [12:8] SET0.x signal output selection (rw) */
    __I  Ifx_UReg_32Bit :3;                /**< \brief [15:13] \internal Reserved */
    __IO Ifx_UReg_32Bit SEL2:5;            /**< \brief [20:16] SET0.x signal output selection (rw) */
    __I  Ifx_UReg_32Bit :3;                /**< \brief [23:21] \internal Reserved */
    __IO Ifx_UReg_32Bit SEL3:5;            /**< \brief [28:24] SET0.x signal output selection (rw) */
    __I  Ifx_UReg_32Bit :3;                /**< \brief [31:29] \internal Reserved */
} Ifx_EGTM_MSCSET_CON0_Bits;

/** \brief eGTM to MSC SET0 output selection register 1 */
typedef struct _Ifx_EGTM_MSCSET_CON1_Bits
{
    __IO Ifx_UReg_32Bit SEL4:5;            /**< \brief [4:0] SET0.x signal output selection (rw) */
    __I  Ifx_UReg_32Bit :3;                /**< \brief [7:5] \internal Reserved */
    __IO Ifx_UReg_32Bit SEL5:5;            /**< \brief [12:8] SET0.x signal output selection (rw) */
    __I  Ifx_UReg_32Bit :3;                /**< \brief [15:13] \internal Reserved */
    __IO Ifx_UReg_32Bit SEL6:5;            /**< \brief [20:16] SET0.x signal output selection (rw) */
    __I  Ifx_UReg_32Bit :3;                /**< \brief [23:21] \internal Reserved */
    __IO Ifx_UReg_32Bit SEL7:5;            /**< \brief [28:24] SET0.x signal output selection (rw) */
    __I  Ifx_UReg_32Bit :3;                /**< \brief [31:29] \internal Reserved */
} Ifx_EGTM_MSCSET_CON1_Bits;

/** \brief eGTM to MSC SET0 output selection register 2 */
typedef struct _Ifx_EGTM_MSCSET_CON2_Bits
{
    __IO Ifx_UReg_32Bit SEL8:5;            /**< \brief [4:0] SET0.x signal output selection (rw) */
    __I  Ifx_UReg_32Bit :3;                /**< \brief [7:5] \internal Reserved */
    __IO Ifx_UReg_32Bit SEL9:5;            /**< \brief [12:8] SET0.x signal output selection (rw) */
    __I  Ifx_UReg_32Bit :3;                /**< \brief [15:13] \internal Reserved */
    __IO Ifx_UReg_32Bit SEL10:5;           /**< \brief [20:16] SET0.x signal output selection (rw) */
    __I  Ifx_UReg_32Bit :3;                /**< \brief [23:21] \internal Reserved */
    __IO Ifx_UReg_32Bit SEL11:5;           /**< \brief [28:24] SET0.x signal output selection (rw) */
    __I  Ifx_UReg_32Bit :3;                /**< \brief [31:29] \internal Reserved */
} Ifx_EGTM_MSCSET_CON2_Bits;

/** \brief eGTM to MSC SET0 output selection register 3 */
typedef struct _Ifx_EGTM_MSCSET_CON3_Bits
{
    __IO Ifx_UReg_32Bit SEL12:5;           /**< \brief [4:0] SET0.x signal output selection (rw) */
    __I  Ifx_UReg_32Bit :3;                /**< \brief [7:5] \internal Reserved */
    __IO Ifx_UReg_32Bit SEL13:5;           /**< \brief [12:8] SET0.x signal output selection (rw) */
    __I  Ifx_UReg_32Bit :3;                /**< \brief [15:13] \internal Reserved */
    __IO Ifx_UReg_32Bit SEL14:5;           /**< \brief [20:16] SET0.x signal output selection (rw) */
    __I  Ifx_UReg_32Bit :3;                /**< \brief [23:21] \internal Reserved */
    __IO Ifx_UReg_32Bit SEL15:5;           /**< \brief [28:24] SET0.x signal output selection (rw) */
    __I  Ifx_UReg_32Bit :3;                /**< \brief [31:29] \internal Reserved */
} Ifx_EGTM_MSCSET_CON3_Bits;

/** \brief eGTM to MSC0 input bus ALTINH signal selection register */
typedef struct _Ifx_EGTM_MSC_INHCON_Bits
{
    __IO Ifx_UReg_32Bit SEL0:2;            /**< \brief [1:0] MSC0 bus line ALTINH.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL1:2;            /**< \brief [3:2] MSC0 bus line ALTINH.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL2:2;            /**< \brief [5:4] MSC0 bus line ALTINH.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL3:2;            /**< \brief [7:6] MSC0 bus line ALTINH.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL4:2;            /**< \brief [9:8] MSC0 bus line ALTINH.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL5:2;            /**< \brief [11:10] MSC0 bus line ALTINH.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL6:2;            /**< \brief [13:12] MSC0 bus line ALTINH.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL7:2;            /**< \brief [15:14] MSC0 bus line ALTINH.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL8:2;            /**< \brief [17:16] MSC0 bus line ALTINH.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL9:2;            /**< \brief [19:18] MSC0 bus line ALTINH.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL10:2;           /**< \brief [21:20] MSC0 bus line ALTINH.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL11:2;           /**< \brief [23:22] MSC0 bus line ALTINH.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL12:2;           /**< \brief [25:24] MSC0 bus line ALTINH.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL13:2;           /**< \brief [27:26] MSC0 bus line ALTINH.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL14:2;           /**< \brief [29:28] MSC0 bus line ALTINH.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL15:2;           /**< \brief [31:30] MSC0 bus line ALTINH.x SETi signal selection (rw) */
} Ifx_EGTM_MSC_INHCON_Bits;

/** \brief eGTM to MSC0 input bus ALTINHE signal selection register */
typedef struct _Ifx_EGTM_MSC_INHECON_Bits
{
    __IO Ifx_UReg_32Bit SEL0:2;            /**< \brief [1:0] MSC0 bus line ALTINHE.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL1:2;            /**< \brief [3:2] MSC0 bus line ALTINHE.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL2:2;            /**< \brief [5:4] MSC0 bus line ALTINHE.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL3:2;            /**< \brief [7:6] MSC0 bus line ALTINHE.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL4:2;            /**< \brief [9:8] MSC0 bus line ALTINHE.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL5:2;            /**< \brief [11:10] MSC0 bus line ALTINHE.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL6:2;            /**< \brief [13:12] MSC0 bus line ALTINHE.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL7:2;            /**< \brief [15:14] MSC0 bus line ALTINHE.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL8:2;            /**< \brief [17:16] MSC0 bus line ALTINHE.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL9:2;            /**< \brief [19:18] MSC0 bus line ALTINHE.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL10:2;           /**< \brief [21:20] MSC0 bus line ALTINHE.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL11:2;           /**< \brief [23:22] MSC0 bus line ALTINHE.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL12:2;           /**< \brief [25:24] MSC0 bus line ALTINHE.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL13:2;           /**< \brief [27:26] MSC0 bus line ALTINHE.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL14:2;           /**< \brief [29:28] MSC0 bus line ALTINHE.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL15:2;           /**< \brief [31:30] MSC0 bus line ALTINHE.x SETi signal selection (rw) */
} Ifx_EGTM_MSC_INHECON_Bits;

/** \brief eGTM to MSC0 input bus ALTINL signal selection register */
typedef struct _Ifx_EGTM_MSC_INLCON_Bits
{
    __IO Ifx_UReg_32Bit SEL0:2;            /**< \brief [1:0] MSC0 bus line ALTINL.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL1:2;            /**< \brief [3:2] MSC0 bus line ALTINL.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL2:2;            /**< \brief [5:4] MSC0 bus line ALTINL.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL3:2;            /**< \brief [7:6] MSC0 bus line ALTINL.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL4:2;            /**< \brief [9:8] MSC0 bus line ALTINL.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL5:2;            /**< \brief [11:10] MSC0 bus line ALTINL.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL6:2;            /**< \brief [13:12] MSC0 bus line ALTINL.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL7:2;            /**< \brief [15:14] MSC0 bus line ALTINL.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL8:2;            /**< \brief [17:16] MSC0 bus line ALTINL.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL9:2;            /**< \brief [19:18] MSC0 bus line ALTINL.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL10:2;           /**< \brief [21:20] MSC0 bus line ALTINL.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL11:2;           /**< \brief [23:22] MSC0 bus line ALTINL.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL12:2;           /**< \brief [25:24] MSC0 bus line ALTINL.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL13:2;           /**< \brief [27:26] MSC0 bus line ALTINL.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL14:2;           /**< \brief [29:28] MSC0 bus line ALTINL.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL15:2;           /**< \brief [31:30] MSC0 bus line ALTINL.x SETi signal selection (rw) */
} Ifx_EGTM_MSC_INLCON_Bits;

/** \brief eGTM to MSC0 input bus ALTINLE signal selection register */
typedef struct _Ifx_EGTM_MSC_INLECON_Bits
{
    __IO Ifx_UReg_32Bit SEL0:2;            /**< \brief [1:0] MSC0 bus line ALTINLE.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL1:2;            /**< \brief [3:2] MSC0 bus line ALTINLE.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL2:2;            /**< \brief [5:4] MSC0 bus line ALTINLE.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL3:2;            /**< \brief [7:6] MSC0 bus line ALTINLE.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL4:2;            /**< \brief [9:8] MSC0 bus line ALTINLE.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL5:2;            /**< \brief [11:10] MSC0 bus line ALTINLE.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL6:2;            /**< \brief [13:12] MSC0 bus line ALTINLE.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL7:2;            /**< \brief [15:14] MSC0 bus line ALTINLE.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL8:2;            /**< \brief [17:16] MSC0 bus line ALTINLE.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL9:2;            /**< \brief [19:18] MSC0 bus line ALTINLE.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL10:2;           /**< \brief [21:20] MSC0 bus line ALTINLE.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL11:2;           /**< \brief [23:22] MSC0 bus line ALTINLE.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL12:2;           /**< \brief [25:24] MSC0 bus line ALTINLE.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL13:2;           /**< \brief [27:26] MSC0 bus line ALTINLE.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL14:2;           /**< \brief [29:28] MSC0 bus line ALTINLE.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL15:2;           /**< \brief [31:30] MSC0 bus line ALTINLE.x SETi signal selection (rw) */
} Ifx_EGTM_MSC_INLECON_Bits;

/** \brief OCDS TBU0 trigger register */
typedef struct _Ifx_EGTM_OCDS_OTBU0T_Bits
{
    __IO Ifx_UReg_32Bit CV:27;             /**< \brief [26:0] Compare value (rw) */
    __I  Ifx_UReg_32Bit :1;                /**< \brief [27:27] \internal Reserved */
    __IO Ifx_UReg_32Bit CM:2;              /**< \brief [29:28] Compare mode (rw) */
    __I  Ifx_UReg_32Bit :2;                /**< \brief [31:30] \internal Reserved */
} Ifx_EGTM_OCDS_OTBU0T_Bits;

/** \brief OCDS TBU1 trigger register */
typedef struct _Ifx_EGTM_OCDS_OTBU1T_Bits
{
    __IO Ifx_UReg_32Bit CV:24;             /**< \brief [23:0] Compare value (rw) */
    __I  Ifx_UReg_32Bit :4;                /**< \brief [27:24] \internal Reserved */
    __IO Ifx_UReg_32Bit EN:1;              /**< \brief [28:28] Enable (rw) */
    __I  Ifx_UReg_32Bit :3;                /**< \brief [31:29] \internal Reserved */
} Ifx_EGTM_OCDS_OTBU1T_Bits;

/** \brief OCDS TBU2 trigger register */
typedef struct _Ifx_EGTM_OCDS_OTBU2T_Bits
{
    __IO Ifx_UReg_32Bit CV:24;             /**< \brief [23:0] Compare value (rw) */
    __I  Ifx_UReg_32Bit :4;                /**< \brief [27:24] \internal Reserved */
    __IO Ifx_UReg_32Bit EN:1;              /**< \brief [28:28] Enable (rw) */
    __I  Ifx_UReg_32Bit :3;                /**< \brief [31:29] \internal Reserved */
} Ifx_EGTM_OCDS_OTBU2T_Bits;

/** \brief OCDS TBU3 trigger register */
typedef struct _Ifx_EGTM_OCDS_OTBU3T_Bits
{
    __IO Ifx_UReg_32Bit CV:24;             /**< \brief [23:0] Compare value (rw) */
    __I  Ifx_UReg_32Bit :4;                /**< \brief [27:24] \internal Reserved */
    __IO Ifx_UReg_32Bit EN:1;              /**< \brief [28:28] Enable (rw) */
    __I  Ifx_UReg_32Bit :3;                /**< \brief [31:29] \internal Reserved */
} Ifx_EGTM_OCDS_OTBU3T_Bits;

/** \brief OCDS trigger set control 0 register */
typedef struct _Ifx_EGTM_OCDS_OTSC0_Bits
{
    __IO Ifx_UReg_32Bit B0LMT:3;           /**< \brief [2:0] OTGB0 TS16_IOS low-byte module type (rw) */
    __I  Ifx_UReg_32Bit :1;                /**< \brief [3:3] \internal Reserved */
    __IO Ifx_UReg_32Bit B0LMI:4;           /**< \brief [7:4] OTGB0 TS16_IOS low-byte module instance (rw) */
    __IO Ifx_UReg_32Bit B0HMT:3;           /**< \brief [10:8] OTGB0 TS16_IOS high-byte module type (rw) */
    __I  Ifx_UReg_32Bit :1;                /**< \brief [11:11] \internal Reserved */
    __IO Ifx_UReg_32Bit B0HMI:4;           /**< \brief [15:12] OTGB0 TS16_IOS high-byte module instance (rw) */
    __IO Ifx_UReg_32Bit B1LMT:3;           /**< \brief [18:16] OTGB1 TS16_IOS low-byte module type (rw) */
    __I  Ifx_UReg_32Bit :1;                /**< \brief [19:19] \internal Reserved */
    __IO Ifx_UReg_32Bit B1LMI:4;           /**< \brief [23:20] OTGB1 TS16_IOS low-byte module instance (rw) */
    __IO Ifx_UReg_32Bit B1HMT:3;           /**< \brief [26:24] OTGB1 TS16_IOS high-byte module type (rw) */
    __I  Ifx_UReg_32Bit :1;                /**< \brief [27:27] \internal Reserved */
    __IO Ifx_UReg_32Bit B1HMI:4;           /**< \brief [31:28] OTGB1 TS16_IOS high-byte module instance (rw) */
} Ifx_EGTM_OCDS_OTSC0_Bits;

/** \brief OCDS trigger set select register */
typedef struct _Ifx_EGTM_OCDS_OTSS_Bits
{
    __IO Ifx_UReg_32Bit OTGB0:4;           /**< \brief [3:0] Trigger set for OTGB0 (rw) */
    __I  Ifx_UReg_32Bit :4;                /**< \brief [7:4] \internal Reserved */
    __IO Ifx_UReg_32Bit OTGB1:4;           /**< \brief [11:8] Trigger set for OTGB1 (rw) */
    __I  Ifx_UReg_32Bit :4;                /**< \brief [15:12] \internal Reserved */
    __I  Ifx_UReg_32Bit :16;               /**< \brief [31:16] \internal Reserved */
} Ifx_EGTM_OCDS_OTSS_Bits;

/** \brief OCDS control and status register */
typedef struct _Ifx_EGTM_OCS_Bits
{
    __I  Ifx_UReg_32Bit :24;               /**< \brief [23:0] \internal Reserved */
    __IO Ifx_UReg_32Bit SUS:4;             /**< \brief [27:24] OCDS suspend control (rw) */
    __O  Ifx_UReg_32Bit SUS_P:1;           /**< \brief [28:28] SUS write protection (w) */
    __I  Ifx_UReg_32Bit SUSSTA:1;          /**< \brief [29:29] Suspend state (rh) */
    __I  Ifx_UReg_32Bit :2;                /**< \brief [31:30] \internal Reserved */
} Ifx_EGTM_OCS_Bits;

/** \brief Resource Protection Register */
typedef struct _Ifx_EGTM_PROT_Bits
{
    __IO Ifx_UReg_32Bit STATE:3;           /**< \brief [2:0] Resource protection state (rwh) */
    __O  Ifx_UReg_32Bit SWEN:1;            /**< \brief [3:3] State write enable (w) */
    __I  Ifx_UReg_32Bit :12;               /**< \brief [15:4] \internal Reserved */
    __IO Ifx_UReg_32Bit VM:3;              /**< \brief [18:16] Virtual Machine definition for PROT owner (rw) */
    __IO Ifx_UReg_32Bit VMEN:1;            /**< \brief [19:19] Virtual Machine definition Enable for PROT owner (rw) */
    __IO Ifx_UReg_32Bit PRS:3;             /**< \brief [22:20] Protection Set definition for PROT owner (rw) */
    __IO Ifx_UReg_32Bit PRSEN:1;           /**< \brief [23:23] Protection Set definition Enable for PROT owner (rw) */
    __IO Ifx_UReg_32Bit TAGID:6;           /**< \brief [29:24] TAG ID definition for PROT owner (rw) */
    __IO Ifx_UReg_32Bit ODEF:1;            /**< \brief [30:30] Enable for PROT owner definition (rw) */
    __O  Ifx_UReg_32Bit OWEN:1;            /**< \brief [31:31] Owner write enable (w) */
} Ifx_EGTM_PROT_Bits;

/** \brief eGTM to PSI5-S0 output trigger selection register */
typedef struct _Ifx_EGTM_PSI5S_OUT_Bits
{
    __IO Ifx_UReg_32Bit SEL0:4;            /**< \brief [3:0] eGTM to PSI5-Sn trigger 0 output selection (rw) */
    __IO Ifx_UReg_32Bit SEL1:4;            /**< \brief [7:4] eGTM to PSI5-Sn trigger 1 output selection (rw) */
    __IO Ifx_UReg_32Bit SEL2:4;            /**< \brief [11:8] eGTM to PSI5-Sn trigger 2 output selection (rw) */
    __IO Ifx_UReg_32Bit SEL3:4;            /**< \brief [15:12] eGTM to PSI5-Sn trigger 3 output selection (rw) */
    __IO Ifx_UReg_32Bit SEL4:4;            /**< \brief [19:16] eGTM to PSI5-Sn trigger 4 output selection (rw) */
    __IO Ifx_UReg_32Bit SEL5:4;            /**< \brief [23:20] eGTM to PSI5-Sn trigger 5 output selection (rw) */
    __IO Ifx_UReg_32Bit SEL6:4;            /**< \brief [27:24] eGTM to PSI5-Sn trigger 6 output selection (rw) */
    __IO Ifx_UReg_32Bit SEL7:4;            /**< \brief [31:28] eGTM to PSI5-Sn trigger 7 output selection (rw) */
} Ifx_EGTM_PSI5S_OUT_Bits;

/** \brief eGTM to PSI5 output trigger selection register */
typedef struct _Ifx_EGTM_PSI5_OUT_Bits
{
    __IO Ifx_UReg_32Bit SEL0:4;            /**< \brief [3:0] eGTM to PSI5 trigger 0 output selection (rw) */
    __IO Ifx_UReg_32Bit SEL1:4;            /**< \brief [7:4] eGTM to PSI5 trigger 1 output selection (rw) */
    __IO Ifx_UReg_32Bit SEL2:4;            /**< \brief [11:8] eGTM to PSI5 trigger 2 output selection (rw) */
    __IO Ifx_UReg_32Bit SEL3:4;            /**< \brief [15:12] eGTM to PSI5 trigger 3 output selection (rw) */
    __IO Ifx_UReg_32Bit SEL4:4;            /**< \brief [19:16] eGTM to PSI5 trigger 4 output selection (rw) */
    __IO Ifx_UReg_32Bit SEL5:4;            /**< \brief [23:20] eGTM to PSI5 trigger 5 output selection (rw) */
    __I  Ifx_UReg_32Bit :8;                /**< \brief [31:24] \internal Reserved */
} Ifx_EGTM_PSI5_OUT_Bits;

/** \brief eGTM to QSPI0 output selection register */
typedef struct _Ifx_EGTM_QSPI_OUT_Bits
{
    __IO Ifx_UReg_32Bit SEL:5;             /**< \brief [4:0] eGTM to QSPI0 trigger output selection (rw) */
    __I  Ifx_UReg_32Bit :27;               /**< \brief [31:5] \internal Reserved */
} Ifx_EGTM_QSPI_OUT_Bits;

/** \brief Reset control register A */
typedef struct _Ifx_EGTM_RST_CTRLA_Bits
{
    __IO Ifx_UReg_32Bit KRST:1;            /**< \brief [0:0] Kernel Reset - KRST (rw1sh) */
    __I  Ifx_UReg_32Bit :7;                /**< \brief [7:1] \internal Reserved */
    __IO Ifx_UReg_32Bit GRSTEN0:1;         /**< \brief [8:8] Enable for Global Module Reset Group 0 - GRSTEN0 (rw) */
    __IO Ifx_UReg_32Bit GRSTEN1:1;         /**< \brief [9:9] Enable for Global Module Reset Group 1 - GRSTEN1 (rw) */
    __IO Ifx_UReg_32Bit GRSTEN2:1;         /**< \brief [10:10] Enable for Global Module Reset Group 2 - GRSTEN2 (rw) */
    __IO Ifx_UReg_32Bit GRSTEN3:1;         /**< \brief [11:11] Enable for Global Module Reset Group 3 - GRSTEN3 (rw) */
    __I  Ifx_UReg_32Bit :20;               /**< \brief [31:12] \internal Reserved */
} Ifx_EGTM_RST_CTRLA_Bits;

/** \brief Reset control register B */
typedef struct _Ifx_EGTM_RST_CTRLB_Bits
{
    __IO Ifx_UReg_32Bit KRST:1;            /**< \brief [0:0] Kernel Reset - KRST (rw1sh) */
    __I  Ifx_UReg_32Bit :30;               /**< \brief [30:1] \internal Reserved */
    __O  Ifx_UReg_32Bit STATCLR:1;         /**< \brief [31:31] Kernel Reset Status Clear - STATCLR (w) */
} Ifx_EGTM_RST_CTRLB_Bits;

/** \brief Reset status register */
typedef struct _Ifx_EGTM_RST_STAT_Bits
{
    __I  Ifx_UReg_32Bit KRST:1;            /**< \brief [0:0] Kernel Reset Status - KRST (rh) */
    __I  Ifx_UReg_32Bit :7;                /**< \brief [7:1] \internal Reserved */
    __I  Ifx_UReg_32Bit GRST0:1;           /**< \brief [8:8] Status for Global Module Reset Group 0 - GRST0 (rh) */
    __I  Ifx_UReg_32Bit GRST1:1;           /**< \brief [9:9] Status for Global Module Reset Group 1 - GRST1 (rh) */
    __I  Ifx_UReg_32Bit GRST2:1;           /**< \brief [10:10] Status for Global Module Reset Group 2 - GRST2 (rh) */
    __I  Ifx_UReg_32Bit GRST3:1;           /**< \brief [11:11] Status for Global Module Reset Group 3 - GRST3 (rh) */
    __I  Ifx_UReg_32Bit :20;               /**< \brief [31:12] \internal Reserved */
} Ifx_EGTM_RST_STAT_Bits;

/** \brief Error injection from eGTM wrapper slave interface */
typedef struct _Ifx_EGTM_SEGEN_Bits
{
    __IO Ifx_UReg_32Bit WPR:1;             /**< \brief [0:0] Error Injection on slave interface eGTM for LLI wrapper EDC error on R channel (rw) */
    __IO Ifx_UReg_32Bit WPWR:1;            /**< \brief [1:1] Error Injection on slave interface eGTM for LLI wrapper EDC error on WR channel (rw) */
    __I  Ifx_UReg_32Bit :4;                /**< \brief [5:2] \internal Reserved */
    __IO Ifx_UReg_32Bit ARREADY:1;         /**< \brief [6:6] Error injection on slave interface eGTM for parity error on ARREADY signal (rw) */
    __IO Ifx_UReg_32Bit AWREADY:1;         /**< \brief [7:7] Error injection on slave interface eGTM for parity error on AWREADY signal (rw) */
    __IO Ifx_UReg_32Bit WREADY:1;          /**< \brief [8:8] Error injection on slave interface eGTM for parity error on WREADY signal (rw) */
    __IO Ifx_UReg_32Bit RVALID:1;          /**< \brief [9:9] Error injection on slave interface eGTM for parity error on RVALID signal (rw) */
    __IO Ifx_UReg_32Bit BVALID:1;          /**< \brief [10:10] Error injection on slave interface eGTM for parity error on BVALID signal (rw) */
    __IO Ifx_UReg_32Bit RCTRL1:1;          /**< \brief [11:11] Error injection on slave interface eGTM for parity error on RID signal (rw) */
    __IO Ifx_UReg_32Bit RCTRL2:1;          /**< \brief [12:12] Error injection on slave interface eGTM for parity error on RRESP, RLAST signal (rw) */
    __IO Ifx_UReg_32Bit BCTRL1:1;          /**< \brief [13:13] Error injection on slave interface eGTM for parity error on BID signal (rw) */
    __IO Ifx_UReg_32Bit BCTRL2:1;          /**< \brief [14:14] Error injection on slave interface eGTM for parity error on BRESP signal (rw) */
    __I  Ifx_UReg_32Bit :4;                /**< \brief [18:15] \internal Reserved */
    __IO Ifx_UReg_32Bit RDATA:1;           /**< \brief [19:19] Error injection on slave interface eGTM for ECC error on RDATA signal (rw) */
    __I  Ifx_UReg_32Bit :12;               /**< \brief [31:20] \internal Reserved */
} Ifx_EGTM_SEGEN_Bits;

/** \brief eGTM to SENT0 trigger x output selection register A */
typedef struct _Ifx_EGTM_SENT_OUTA_Bits
{
    __IO Ifx_UReg_32Bit SEL0:5;            /**< \brief [4:0] eGTM to SENTn trigger 0 output selection (rw) */
    __IO Ifx_UReg_32Bit SEL1:5;            /**< \brief [9:5] eGTM to SENTn trigger 1 output selection (rw) */
    __IO Ifx_UReg_32Bit SEL2:5;            /**< \brief [14:10] eGTM to SENTn trigger 2 output selection (rw) */
    __I  Ifx_UReg_32Bit :17;               /**< \brief [31:15] \internal Reserved */
} Ifx_EGTM_SENT_OUTA_Bits;

/** \brief Spare Bits */
typedef struct _Ifx_EGTM_SPARE_Bits
{
    __IO Ifx_UReg_32Bit SPABA:4;           /**< \brief [3:0] Spare Bits A - For future extensions (rwh) */
    __IO Ifx_UReg_32Bit SPABB:4;           /**< \brief [7:4] Spare Bits B - for future extensions (rwh) */
    __IO Ifx_UReg_32Bit SPABC:4;           /**< \brief [11:8] Spare Bits C - for future extensions (rwh) */
    __IO Ifx_UReg_32Bit SPABD:4;           /**< \brief [15:12] Spare Bits D - for future extensions (rwh) */
    __IO Ifx_UReg_32Bit SPABE:4;           /**< \brief [19:16] Spare Bits E - for future extensions (rwh) */
    __IO Ifx_UReg_32Bit SPABF:4;           /**< \brief [23:20] Spare Bits F - for future extensions (rwh) */
    __IO Ifx_UReg_32Bit SPABG:4;           /**< \brief [27:24] Spare Bits G - for future extensions (rwh) */
    __IO Ifx_UReg_32Bit SPABH:4;           /**< \brief [31:28] Spare Bits H - for future extensions (rwh) */
} Ifx_EGTM_SPARE_Bits;

/** \brief TIM0 input selection register */
typedef struct _Ifx_EGTM_TIMINSEL_Bits
{
    __IO Ifx_UReg_32Bit CH0SEL:4;          /**< \brief [3:0] eGTM TIM0 channel 0 input selection (rw) */
    __IO Ifx_UReg_32Bit CH1SEL:4;          /**< \brief [7:4] eGTM TIM0 channel 1 input selection (rw) */
    __IO Ifx_UReg_32Bit CH2SEL:4;          /**< \brief [11:8] eGTM TIM0 channel 2 input selection (rw) */
    __IO Ifx_UReg_32Bit CH3SEL:4;          /**< \brief [15:12] eGTM TIM0 channel 3 input selection (rw) */
    __IO Ifx_UReg_32Bit CH4SEL:4;          /**< \brief [19:16] eGTM TIM0 channel 4 input selection (rw) */
    __IO Ifx_UReg_32Bit CH5SEL:4;          /**< \brief [23:20] eGTM TIM0 channel 5 input selection (rw) */
    __IO Ifx_UReg_32Bit CH6SEL:4;          /**< \brief [27:24] eGTM TIM0 channel 6 input selection (rw) */
    __IO Ifx_UReg_32Bit CH7SEL:4;          /**< \brief [31:28] eGTM TIM0 channel 7 input selection (rw) */
} Ifx_EGTM_TIMINSEL_Bits;

/** \brief eGTM to Ports signal TOUT output selection register 0 */
typedef struct _Ifx_EGTM_TOUTSEL_Bits
{
    __IO Ifx_UReg_32Bit SEL0:5;            /**< \brief [4:0] eGTM to Ports signal TOUT(0*6+0) output selection (rw) */
    __IO Ifx_UReg_32Bit SEL1:5;            /**< \brief [9:5] eGTM to Ports signal TOUT(0*6+1) output selection (rw) */
    __IO Ifx_UReg_32Bit SEL2:5;            /**< \brief [14:10] eGTM to Ports signal TOUT(0*6+2) output selection (rw) */
    __I  Ifx_UReg_32Bit :1;                /**< \brief [15:15] \internal Reserved */
    __IO Ifx_UReg_32Bit SEL3:5;            /**< \brief [20:16] eGTM to Ports signal TOUT(0*6+3) output selection (rw) */
    __IO Ifx_UReg_32Bit SEL4:5;            /**< \brief [25:21] eGTM to Ports signal TOUT(0*6+4) output selection (rw) */
    __IO Ifx_UReg_32Bit SEL5:5;            /**< \brief [30:26] eGTM to Ports signal TOUT(0*6+5) output selection (rw) */
    __I  Ifx_UReg_32Bit :1;                /**< \brief [31:31] \internal Reserved */
} Ifx_EGTM_TOUTSEL_Bits;

/** \}  */
/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_egtm_Registers_union
 * \{   */
/** \brief PRS access enable register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_ACCEN_PRS_Bits B;             /**< \brief Bitfield access */
} Ifx_EGTM_ACCEN_PRS;

/** \brief Read access enable register A   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_ACCEN_RDA_Bits B;             /**< \brief Bitfield access */
} Ifx_EGTM_ACCEN_RDA;

/** \brief Read access enable register B   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_ACCEN_RDB_FPI_Bits B;         /**< \brief Bitfield access */
} Ifx_EGTM_ACCEN_RDB_FPI;

/** \brief VM access enable register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_ACCEN_VM_Bits B;              /**< \brief Bitfield access */
} Ifx_EGTM_ACCEN_VM;

/** \brief Write access enable register A   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_ACCEN_WRA_Bits B;             /**< \brief Bitfield access */
} Ifx_EGTM_ACCEN_WRA;

/** \brief Write access enable register B   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_ACCEN_WRB_FPI_Bits B;         /**< \brief Bitfield access */
} Ifx_EGTM_ACCEN_WRB_FPI;

/** \brief eGTM to ADC output selection register 0   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_ADC_OUT_Bits B;               /**< \brief Bitfield access */
} Ifx_EGTM_ADC_OUT;

/** \brief eGTM to ASCLIN0 output selection register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_ASCLIN_OUT_Bits B;            /**< \brief Bitfield access */
} Ifx_EGTM_ASCLIN_OUT;

/** \brief eGTM to CAN0 output selection register 0   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CAN_OUT_Bits B;               /**< \brief Bitfield access */
} Ifx_EGTM_CAN_OUT;

/** \brief Clock control register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLC_Bits B;                   /**< \brief Bitfield access */
} Ifx_EGTM_CLC;

/** \brief BRIDGE_MODE   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_AEI_BRIDGE_MODE_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_AEI_BRIDGE_MODE;

/** \brief BRIDGE_PTR1   */
typedef union
{
    __I  Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __I  Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_AEI_BRIDGE_PTR1_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_AEI_BRIDGE_PTR1;

/** \brief BRIDGE_PTR2   */
typedef union
{
    __I  Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __I  Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_AEI_BRIDGE_PTR2_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_AEI_BRIDGE_PTR2;

/** \brief GTM_AEI_ADDR_XPT   */
typedef union
{
    __I  Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __I  Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ARCH_AEI_ADDR_XPT_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ARCH_AEI_ADDR_XPT;

/** \brief GTM_AEI_STA_XPT   */
typedef union
{
    __I  Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __I  Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ARCH_AEI_STA_XPT_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ARCH_AEI_STA_XPT;

/** \brief eGTM configuration register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ARCH_CFG_Bits B;          /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ARCH_CFG;

/** \brief eGTM Cluster Clock Configuration   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ARCH_CLK_CFG_Bits B;      /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ARCH_CLK_CFG;

/** \brief eGTM global control register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ARCH_CTRL_Bits B;         /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ARCH_CTRL;

/** \brief eGTM error interrupt enable register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ARCH_EIRQ_EN_Bits B;      /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ARCH_EIRQ_EN;

/** \brief eGTM interrupt enable register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ARCH_IRQ_EN_Bits B;       /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ARCH_IRQ_EN;

/** \brief eGTM Software interrupt generation register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ARCH_IRQ_FORCINT_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ARCH_IRQ_FORCINT;

/** \brief eGTM top level interrupts mode selection   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ARCH_IRQ_MODE_Bits B;     /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ARCH_IRQ_MODE;

/** \brief eGTM Interrupt notification register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ARCH_IRQ_NOTIFY_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ARCH_IRQ_NOTIFY;

/** \brief eGTM version control register   */
typedef union
{
    __I  Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __I  Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ARCH_REV_Bits B;          /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ARCH_REV;

/** \brief eGTM global reset register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ARCH_RST_Bits B;          /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ARCH_RST;

/** \brief ATOM[i] AGC action time base register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ATOM_AGC_ACT_TB_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ATOM_AGC_ACT_TB;

/** \brief ATOM[i] AGC enable/disable control register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ATOM_AGC_ENDIS_CTRL_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ATOM_AGC_ENDIS_CTRL;

/** \brief ATOM[i] AGC enable/disable status register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ATOM_AGC_ENDIS_STAT_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ATOM_AGC_ENDIS_STAT;

/** \brief ATOM[i] AGC force update control register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ATOM_AGC_FUPD_CTRL_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ATOM_AGC_FUPD_CTRL;

/** \brief ATOM[i] AGC global control register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ATOM_AGC_GLB_CTRL_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ATOM_AGC_GLB_CTRL;

/** \brief ATOM[i] AGC internal trigger control register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ATOM_AGC_INT_TRIG_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ATOM_AGC_INT_TRIG;

/** \brief ATOM[i] AGC output enable control register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ATOM_AGC_OUTEN_CTRL_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ATOM_AGC_OUTEN_CTRL;

/** \brief ATOM[i] AGC output enable status register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ATOM_AGC_OUTEN_STAT_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ATOM_AGC_OUTEN_STAT;

/** \brief ATOM[i] channel [x] CCU0 compare register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ATOM_CH_CM0_Bits B;       /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ATOM_CH_CM0;

/** \brief ATOM[i] channel [x] CCU1 compare register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ATOM_CH_CM1_Bits B;       /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ATOM_CH_CM1;

/** \brief ATOM[i] channel [x] CCU0 counter register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ATOM_CH_CN0_Bits B;       /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ATOM_CH_CN0;

/** \brief ATOM[i] channel [x] control register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ATOM_CH_CTRL_Bits B;      /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ATOM_CH_CTRL;

/** \brief ATOM[i] channel [x] control2 register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ATOM_CH_CTRL2_Bits B;     /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ATOM_CH_CTRL2;

/** \brief ATOM[i] channel [x] control register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ATOM_CH_CTRL_SOMB_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ATOM_CH_CTRL_SOMB;

/** \brief ATOM[i] channel [x] control register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ATOM_CH_CTRL_SOMC_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ATOM_CH_CTRL_SOMC;

/** \brief ATOM[i] channel [x] control register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ATOM_CH_CTRL_SOMI_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ATOM_CH_CTRL_SOMI;

/** \brief ATOM[i] channel [x] control register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ATOM_CH_CTRL_SOMP_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ATOM_CH_CTRL_SOMP;

/** \brief ATOM[i] channel [x] control register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ATOM_CH_CTRL_SOMS_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ATOM_CH_CTRL_SOMS;

/** \brief ATOM[i] channel [x] control shadow register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ATOM_CH_CTRL_SR_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ATOM_CH_CTRL_SR;

/** \brief ATOM[i] channel [x] interrupt enable register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ATOM_CH_IRQ_EN_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ATOM_CH_IRQ_EN;

/** \brief ATOM[i] channel [x] software interrupt generation   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ATOM_CH_IRQ_FORCINT_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ATOM_CH_IRQ_FORCINT;

/** \brief ATOM[i] channel [x] interrupt mode configuration register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ATOM_CH_IRQ_MODE_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ATOM_CH_IRQ_MODE;

/** \brief ATOM[i] channel [x] interrupt notification register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ATOM_CH_IRQ_NOTIFY_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ATOM_CH_IRQ_NOTIFY;

/** \brief ATOM[i] channel [x] CCU0 compare shadow register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ATOM_CH_SR0_Bits B;       /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ATOM_CH_SR0;

/** \brief ATOM[i] channel [x] CCU1 compare shadow register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ATOM_CH_SR1_Bits B;       /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ATOM_CH_SR1;

/** \brief ATOM[i] channel [x] status register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ATOM_CH_STAT_Bits B;      /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ATOM_CH_STAT;

/** \brief CCM[i] ATOM Output Register   */
typedef union
{
    __I  Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __I  Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_CCM_ATOM_OUT_Bits B;      /**< \brief Bitfield access */
} Ifx_EGTM_CLS_CCM_ATOM_OUT;

/** \brief CCM[i] Configuration Register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_CCM_CFG_Bits B;           /**< \brief Bitfield access */
} Ifx_EGTM_CLS_CCM_CFG;

/** \brief CCM[i] CMU Clock Configuration Register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_CCM_CMU_CLK_CFG_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_CCM_CMU_CLK_CFG;

/** \brief CCM[i] CMU Fixed Clock Configuration Register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_CCM_CMU_FXCLK_CFG_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_CCM_CMU_FXCLK_CFG;

/** \brief CCM[i] Hardware Configuration Register   */
typedef union
{
    __I  Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __I  Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_CCM_HW_CONF_Bits B;       /**< \brief Bitfield access */
} Ifx_EGTM_CLS_CCM_HW_CONF;

/** \brief CCM[i] 2. Hardware Configuration Register   */
typedef union
{
    __I  Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __I  Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_CCM_HW_CONF2_Bits B;      /**< \brief Bitfield access */
} Ifx_EGTM_CLS_CCM_HW_CONF2;

/** \brief CCM[i] Protection Register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_CCM_PROT_Bits B;          /**< \brief Bitfield access */
} Ifx_EGTM_CLS_CCM_PROT;

/** \brief CCM[i] TIM AUX Input Source Register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_CCM_TIM_AUX_IN_SRC_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_CCM_TIM_AUX_IN_SRC;

/** \brief CCM[i] TOM Output Register   */
typedef union
{
    __I  Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __I  Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_CCM_TOM_OUT_Bits B;       /**< \brief Bitfield access */
} Ifx_EGTM_CLS_CCM_TOM_OUT;

/** \brief CDTM[i]_DTM[d] channel control register 1   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_CDTM_DTM_CH_CTRL1_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_CDTM_DTM_CH_CTRL1;

/** \brief CDTM[i]_DTM[d] channel control register 2   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_CDTM_DTM_CH_CTRL2_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_CDTM_DTM_CH_CTRL2;

/** \brief CDTM[i] DTM[j] channel control register 2 shadow   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_CDTM_DTM_CH_CTRL2_SR_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_CDTM_DTM_CH_CTRL2_SR;

/** \brief CDTM[i]_DTM[d] channel control register 3   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_CDTM_DTM_CH_CTRL3_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_CDTM_DTM_CH_CTRL3;

/** \brief CDTM[i]_DTM[d] channel [x] dead time reload values   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_CDTM_DTM_CH_DTV_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_CDTM_DTM_CH_DTV;

/** \brief CDTM[i]_DTM[d] channel [x] dead time shadow values   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_CDTM_DTM_CH_DTV_SR_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_CDTM_DTM_CH_DTV_SR;

/** \brief CDTM[i]_DTM[d] channel shadow register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_CDTM_DTM_CH_SR_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_CDTM_DTM_CH_SR;

/** \brief CDTM[i]_DTM[d] global configuration and control register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_CDTM_DTM_CTRL_Bits B;     /**< \brief Bitfield access */
} Ifx_EGTM_CLS_CDTM_DTM_CTRL;

/** \brief CDTM[i]_DTM[d] global configuration and control register 2   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_CDTM_DTM_CTRL2_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_CDTM_DTM_CTRL2;

/** \brief CDTM[i]_DTM[d] phase shift unit configuration and control register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_CDTM_DTM_PS_CTRL_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_CDTM_DTM_PS_CTRL;

/** \brief CMP error interrupt enable register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_CMP_EIRQ_EN_Bits B;       /**< \brief Bitfield access */
} Ifx_EGTM_CLS_CMP_EIRQ_EN;

/** \brief CMP comparator enable register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_CMP_EN_Bits B;            /**< \brief Bitfield access */
} Ifx_EGTM_CLS_CMP_EN;

/** \brief CMP interrupt enable register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_CMP_IRQ_EN_Bits B;        /**< \brief Bitfield access */
} Ifx_EGTM_CLS_CMP_IRQ_EN;

/** \brief CMP interrupt force register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_CMP_IRQ_FORCINT_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_CMP_IRQ_FORCINT;

/** \brief CMP interrupt mode configuration register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_CMP_IRQ_MODE_Bits B;      /**< \brief Bitfield access */
} Ifx_EGTM_CLS_CMP_IRQ_MODE;

/** \brief CMP event notification register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_CMP_IRQ_NOTIFY_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_CMP_IRQ_NOTIFY;

/** \brief CMU control for clock resolution generator [x]   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_CMU_CLKX_CTRL_Bits B;     /**< \brief Bitfield access */
} Ifx_EGTM_CLS_CMU_CLKX_CTRL;

/** \brief CMU control for clock resolution generator 6   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_CMU_CLK_6_CTRL_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_CMU_CLK_6_CTRL;

/** \brief CMU control for clock resolution generator 7   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_CMU_CLK_7_CTRL_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_CMU_CLK_7_CTRL;

/** \brief CMU control for clock resolution generator   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_CMU_CLK_CTRL_Bits B;      /**< \brief Bitfield access */
} Ifx_EGTM_CLS_CMU_CLK_CTRL;

/** \brief CMU clock enable   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_CMU_CLK_EN_Bits B;        /**< \brief Bitfield access */
} Ifx_EGTM_CLS_CMU_CLK_EN;

/** \brief The denominator for the external clock resolution generator [z]   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_CMU_ECLK_DEN_Bits B;      /**< \brief Bitfield access */
} Ifx_EGTM_CLS_CMU_ECLK_DEN;

/** \brief The numerator for the external clock resolution generator [z]   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_CMU_ECLK_NUM_Bits B;      /**< \brief Bitfield access */
} Ifx_EGTM_CLS_CMU_ECLK_NUM;

/** \brief CMU control for selection of FCR subblock input   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_CMU_FXCLK_CTRL_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_CMU_FXCLK_CTRL;

/** \brief The denominator for CMU global clock resolution generator   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_CMU_GCLK_DEN_Bits B;      /**< \brief Bitfield access */
} Ifx_EGTM_CLS_CMU_GCLK_DEN;

/** \brief The numerator for CMU global clock resolution generator   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_CMU_GCLK_NUM_Bits B;      /**< \brief Bitfield access */
} Ifx_EGTM_CLS_CMU_GCLK_NUM;

/** \brief ICM_IRQG_0   */
typedef union
{
    __I  Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __I  Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ICM_IRQG_0_Bits B;        /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ICM_IRQG_0;

/** \brief ICM Interrupt group register covering TIM0, TIM1, TIM2, TIM3   */
typedef union
{
    __I  Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __I  Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ICM_IRQG_2_Bits B;        /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ICM_IRQG_2;

/** \brief ICM_IRQG_ATOM_[g]_CI   */
typedef union
{
    __I  Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __I  Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ICM_IRQG_ATOM_CI_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ICM_IRQG_ATOM_CI;

/** \brief ICM Interrupt group register 1 for channel error interrupt information   */
typedef union
{
    __I  Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __I  Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ICM_IRQG_CEI1_Bits B;     /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ICM_IRQG_CEI1;

/** \brief ICM_IRQG_CLS_[g]_MEI   */
typedef union
{
    __I  Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __I  Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ICM_IRQG_CLS_MEI_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ICM_IRQG_CLS_MEI;

/** \brief ICM Interrupt group register for module error interrupt information   */
typedef union
{
    __I  Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __I  Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ICM_IRQG_MEI_Bits B;      /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ICM_IRQG_MEI;

/** \brief ICM Interrupt group SPE for module Error Interrupt information   */
typedef union
{
    __I  Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __I  Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ICM_IRQG_SPE_CEI_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ICM_IRQG_SPE_CEI;

/** \brief ICM Interrupt group SPE for module Interrupt information   */
typedef union
{
    __I  Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __I  Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ICM_IRQG_SPE_CI_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ICM_IRQG_SPE_CI;

/** \brief ICM_IRQG_TOM_[g]_CI   */
typedef union
{
    __I  Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __I  Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ICM_IRQG_TOM_CI_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ICM_IRQG_TOM_CI;

/** \brief MON status register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_MON_STATUS_Bits B;        /**< \brief Bitfield access */
} Ifx_EGTM_CLS_MON_STATUS;

/** \brief SPE[i] Command Register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_SPE_CMD_Bits B;           /**< \brief Bitfield access */
} Ifx_EGTM_CLS_SPE_CMD;

/** \brief SPE[i] Control Status Register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_SPE_CTRL_STAT_Bits B;     /**< \brief Bitfield access */
} Ifx_EGTM_CLS_SPE_CTRL_STAT;

/** \brief SPE[i] Control Status Register 2   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_SPE_CTRL_STAT2_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_SPE_CTRL_STAT2;

/** \brief SPE[i] Error Interrupt Enable Register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_SPE_EIRQ_EN_Bits B;       /**< \brief Bitfield access */
} Ifx_EGTM_CLS_SPE_EIRQ_EN;

/** \brief SPE[i] Interrupt Enable Register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_SPE_IRQ_EN_Bits B;        /**< \brief Bitfield access */
} Ifx_EGTM_CLS_SPE_IRQ_EN;

/** \brief SPE[i] Interrupt Generation By Software   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_SPE_IRQ_FORCINT_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_SPE_IRQ_FORCINT;

/** \brief SPE[i] Interrupt Mode Configuration Register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_SPE_IRQ_MODE_Bits B;      /**< \brief Bitfield access */
} Ifx_EGTM_CLS_SPE_IRQ_MODE;

/** \brief SPE[i] Interrupt Notification Register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_SPE_IRQ_NOTIFY_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_SPE_IRQ_NOTIFY;

/** \brief SPE[i] Output Control Register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_SPE_OUT_CTRL_Bits B;      /**< \brief Bitfield access */
} Ifx_EGTM_CLS_SPE_OUT_CTRL;

/** \brief SPE[i] Output Definition Register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_SPE_OUT_PAT_Bits B;       /**< \brief Bitfield access */
} Ifx_EGTM_CLS_SPE_OUT_PAT;

/** \brief SPE[i] Input Pattern Definition Register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_SPE_PAT_Bits B;           /**< \brief Bitfield access */
} Ifx_EGTM_CLS_SPE_PAT;

/** \brief SPE[i] Revolution Counter Compare Value   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_SPE_REV_CMP_Bits B;       /**< \brief Bitfield access */
} Ifx_EGTM_CLS_SPE_REV_CMP;

/** \brief SPE[i] Input Revolution Counter   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_SPE_REV_CNT_Bits B;       /**< \brief Bitfield access */
} Ifx_EGTM_CLS_SPE_REV_CNT;

/** \brief TBU channel 0 base   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TBU_CH0_BASE_Bits B;      /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TBU_CH0_BASE;

/** \brief TBU channel 0 control   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TBU_CH0_CTRL_Bits B;      /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TBU_CH0_CTRL;

/** \brief TBU channel 1 control   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TBU_CH1_CTRL_Bits B;      /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TBU_CH1_CTRL;

/** \brief TBU channel 2 control   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TBU_CH2_CTRL_Bits B;      /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TBU_CH2_CTRL;

/** \brief TBU channel 3 base   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TBU_CH3_BASE_Bits B;      /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TBU_CH3_BASE;

/** \brief TBU channel 3 base captured   */
typedef union
{
    __I  Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __I  Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TBU_CH3_BASE_CAPTURE_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TBU_CH3_BASE_CAPTURE;

/** \brief TBU channel 3 modulo value   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TBU_CH3_BASE_MARK_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TBU_CH3_BASE_MARK;

/** \brief TBU channel 3 control   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TBU_CH3_CTRL_Bits B;      /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TBU_CH3_CTRL;

/** \brief TBU global channel enable   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TBU_CHEN_Bits B;          /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TBU_CHEN;

/** \brief TBU channel [x] base   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TBU_CH_BASE_Bits B;       /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TBU_CH_BASE;

/** \brief TIM[i] channel [x] SMU counter register   */
typedef union
{
    __I  Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __I  Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TIM_CH_CNT_Bits B;        /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TIM_CH_CNT;

/** \brief TIM[i] channel [x] SMU shadow counter register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TIM_CH_CNTS_Bits B;       /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TIM_CH_CNTS;

/** \brief TIM[i] channel [x] control register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TIM_CH_CTRL_Bits B;       /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TIM_CH_CTRL;

/** \brief TIM[i] channel [x] SMU edge counter register   */
typedef union
{
    __I  Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __I  Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TIM_CH_ECNT_Bits B;       /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TIM_CH_ECNT;

/** \brief TIM[i] channel [x] extended control register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TIM_CH_ECTRL_Bits B;      /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TIM_CH_ECTRL;

/** \brief TIM[i] channel [x] error interrupt enable register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TIM_CH_EIRQ_EN_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TIM_CH_EIRQ_EN;

/** \brief TIM[i] channel [x] filter parameter 1 register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TIM_CH_FLT_FE_Bits B;     /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TIM_CH_FLT_FE;

/** \brief TIM[i] channel [x] filter parameter 0 register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TIM_CH_FLT_RE_Bits B;     /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TIM_CH_FLT_RE;

/** \brief TIM[i] channel [x] general purpose 0 register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TIM_CH_GPR0_Bits B;       /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TIM_CH_GPR0;

/** \brief TIM[i] channel [x] general purpose 1 register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TIM_CH_GPR1_Bits B;       /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TIM_CH_GPR1;

/** \brief TIM[i] channel [x] interrupt enable register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TIM_CH_IRQ_EN_Bits B;     /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TIM_CH_IRQ_EN;

/** \brief TIM[i] channel [x] force interrupt register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TIM_CH_IRQ_FORCINT_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TIM_CH_IRQ_FORCINT;

/** \brief TIM[i] channel [x] interrupt mode configuration register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TIM_CH_IRQ_MODE_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TIM_CH_IRQ_MODE;

/** \brief TIM[i] channel [x] interrupt notification register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TIM_CH_IRQ_NOTIFY_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TIM_CH_IRQ_NOTIFY;

/** \brief TIM[i]_CH[x]_TDUC   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TIM_CH_TDUC_Bits B;       /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TIM_CH_TDUC;

/** \brief TIM[i]_CH[x]_TDUV   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TIM_CH_TDUV_Bits B;       /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TIM_CH_TDUV;

/** \brief TIM[i] input value observation register   */
typedef union
{
    __I  Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __I  Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TIM_INP_VAL_Bits B;       /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TIM_INP_VAL;

/** \brief TIM[i] AUX IN source selection register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TIM_IN_SRC_Bits B;        /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TIM_IN_SRC;

/** \brief TIM[i] global software reset register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TIM_RST_Bits B;           /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TIM_RST;

/** \brief TOM[i] channel [x] CCU0 compare register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TOM_CH_CM0_Bits B;        /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TOM_CH_CM0;

/** \brief TOM[i] channel [x] CCU1 compare register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TOM_CH_CM1_Bits B;        /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TOM_CH_CM1;

/** \brief TOM[i] channel [x] CCU0 counter   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TOM_CH_CN0_Bits B;        /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TOM_CH_CN0;

/** \brief TOM[i] channel [x] control register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TOM_CH_CTRL_Bits B;       /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TOM_CH_CTRL;

/** \brief TOM[i] channel [x] control shadow register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TOM_CH_CTRL_SR_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TOM_CH_CTRL_SR;

/** \brief TOM[i] channel [x] interrupt enable register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TOM_CH_IRQ_EN_Bits B;     /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TOM_CH_IRQ_EN;

/** \brief TOM[i] channel [x] force interrupt register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TOM_CH_IRQ_FORCINT_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TOM_CH_IRQ_FORCINT;

/** \brief TOM[i] channel [x] interrupt mode register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TOM_CH_IRQ_MODE_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TOM_CH_IRQ_MODE;

/** \brief TOM[i] channel [x] interrupt notification register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TOM_CH_IRQ_NOTIFY_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TOM_CH_IRQ_NOTIFY;

/** \brief TOM[i] channel [x] CCU0 compare shadow register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TOM_CH_SR0_Bits B;        /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TOM_CH_SR0;

/** \brief TOM[i] channel [x] CCU1 compare shadow register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TOM_CH_SR1_Bits B;        /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TOM_CH_SR1;

/** \brief TOM[i] channel [x] status register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TOM_CH_STAT_Bits B;       /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TOM_CH_STAT;

/** \brief TOM[i] TGC [g] action time base register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TOM_TGC_ACT_TB_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TOM_TGC_ACT_TB;

/** \brief TOM[i] TGC [g] enable/disable control register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TOM_TGC_ENDIS_CTRL_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TOM_TGC_ENDIS_CTRL;

/** \brief TOM[i] TGC [g] enable/disable status register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TOM_TGC_ENDIS_STAT_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TOM_TGC_ENDIS_STAT;

/** \brief TOM[i] TGC [g] force update control register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TOM_TGC_FUPD_CTRL_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TOM_TGC_FUPD_CTRL;

/** \brief TOM[i] TGC [g] global control register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TOM_TGC_GLB_CTRL_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TOM_TGC_GLB_CTRL;

/** \brief TOM[i] TGC [g] internal trigger control register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TOM_TGC_INT_TRIG_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TOM_TGC_INT_TRIG;

/** \brief TOM[i] TGC [g] output enable control register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TOM_TGC_OUTEN_CTRL_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TOM_TGC_OUTEN_CTRL;

/** \brief TOM[i] TGC [g] output enable status register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TOM_TGC_OUTEN_STAT_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TOM_TGC_OUTEN_STAT;

/** \brief Cluster 0 DTMAUX input 0 selection register   */
typedef union
{
    __O  Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __O  Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_DTMAUX_IN_Bits B;             /**< \brief Bitfield access */
} Ifx_EGTM_DTMAUX_IN;

/** \brief FOUT Selection for Encoder Interface 0   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_FOUTENC_Bits B;               /**< \brief Bitfield access */
} Ifx_EGTM_FOUTENC;

/** \brief HRPWM0 16:1 Channel MUX select   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_HRPWMMUX_CHSEL_Bits B;        /**< \brief Bitfield access */
} Ifx_EGTM_HRPWMMUX_CHSEL;

/** \brief HRPWM0 DLL configuration register High   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_HRPWM_DLLCFGH_Bits B;         /**< \brief Bitfield access */
} Ifx_EGTM_HRPWM_DLLCFGH;

/** \brief HRPWM0 DLL configuration register Low   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_HRPWM_DLLCFGL_Bits B;         /**< \brief Bitfield access */
} Ifx_EGTM_HRPWM_DLLCFGL;

/** \brief HRPWM0 DLL status register   */
typedef union
{
    __I  Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __I  Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_HRPWM_DLLSTAT_Bits B;         /**< \brief Bitfield access */
} Ifx_EGTM_HRPWM_DLLSTAT;

/** \brief HRPWM0 module and channel enable register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_HRPWM_EN_Bits B;              /**< \brief Bitfield access */
} Ifx_EGTM_HRPWM_EN;

/** \brief eGTM to LCDCDC output trigger selection register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_LCDCDC_OUT_Bits B;            /**< \brief Bitfield access */
} Ifx_EGTM_LCDCDC_OUT;

/** \brief eGTM to MSC SET0 output selection register 0   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_MSCSET_CON0_Bits B;           /**< \brief Bitfield access */
} Ifx_EGTM_MSCSET_CON0;

/** \brief eGTM to MSC SET0 output selection register 1   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_MSCSET_CON1_Bits B;           /**< \brief Bitfield access */
} Ifx_EGTM_MSCSET_CON1;

/** \brief eGTM to MSC SET0 output selection register 2   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_MSCSET_CON2_Bits B;           /**< \brief Bitfield access */
} Ifx_EGTM_MSCSET_CON2;

/** \brief eGTM to MSC SET0 output selection register 3   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_MSCSET_CON3_Bits B;           /**< \brief Bitfield access */
} Ifx_EGTM_MSCSET_CON3;

/** \brief eGTM to MSC0 input bus ALTINH signal selection register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_MSC_INHCON_Bits B;            /**< \brief Bitfield access */
} Ifx_EGTM_MSC_INHCON;

/** \brief eGTM to MSC0 input bus ALTINHE signal selection register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_MSC_INHECON_Bits B;           /**< \brief Bitfield access */
} Ifx_EGTM_MSC_INHECON;

/** \brief eGTM to MSC0 input bus ALTINL signal selection register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_MSC_INLCON_Bits B;            /**< \brief Bitfield access */
} Ifx_EGTM_MSC_INLCON;

/** \brief eGTM to MSC0 input bus ALTINLE signal selection register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_MSC_INLECON_Bits B;           /**< \brief Bitfield access */
} Ifx_EGTM_MSC_INLECON;

/** \brief OCDS TBU0 trigger register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_OCDS_OTBU0T_Bits B;           /**< \brief Bitfield access */
} Ifx_EGTM_OCDS_OTBU0T;

/** \brief OCDS TBU1 trigger register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_OCDS_OTBU1T_Bits B;           /**< \brief Bitfield access */
} Ifx_EGTM_OCDS_OTBU1T;

/** \brief OCDS TBU2 trigger register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_OCDS_OTBU2T_Bits B;           /**< \brief Bitfield access */
} Ifx_EGTM_OCDS_OTBU2T;

/** \brief OCDS TBU3 trigger register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_OCDS_OTBU3T_Bits B;           /**< \brief Bitfield access */
} Ifx_EGTM_OCDS_OTBU3T;

/** \brief OCDS trigger set control 0 register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_OCDS_OTSC0_Bits B;            /**< \brief Bitfield access */
} Ifx_EGTM_OCDS_OTSC0;

/** \brief OCDS trigger set select register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_OCDS_OTSS_Bits B;             /**< \brief Bitfield access */
} Ifx_EGTM_OCDS_OTSS;

/** \brief OCDS control and status register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_OCS_Bits B;                   /**< \brief Bitfield access */
} Ifx_EGTM_OCS;

/** \brief Resource Protection Register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_PROT_Bits B;                  /**< \brief Bitfield access */
} Ifx_EGTM_PROT;

/** \brief eGTM to PSI5-S0 output trigger selection register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_PSI5S_OUT_Bits B;             /**< \brief Bitfield access */
} Ifx_EGTM_PSI5S_OUT;

/** \brief eGTM to PSI5 output trigger selection register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_PSI5_OUT_Bits B;              /**< \brief Bitfield access */
} Ifx_EGTM_PSI5_OUT;

/** \brief eGTM to QSPI0 output selection register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_QSPI_OUT_Bits B;              /**< \brief Bitfield access */
} Ifx_EGTM_QSPI_OUT;

/** \brief Reset control register A   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_RST_CTRLA_Bits B;             /**< \brief Bitfield access */
} Ifx_EGTM_RST_CTRLA;

/** \brief Reset control register B   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_RST_CTRLB_Bits B;             /**< \brief Bitfield access */
} Ifx_EGTM_RST_CTRLB;

/** \brief Reset status register   */
typedef union
{
    __I  Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __I  Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_RST_STAT_Bits B;              /**< \brief Bitfield access */
} Ifx_EGTM_RST_STAT;

/** \brief Error injection from eGTM wrapper slave interface   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_SEGEN_Bits B;                 /**< \brief Bitfield access */
} Ifx_EGTM_SEGEN;

/** \brief eGTM to SENT0 trigger x output selection register A   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_SENT_OUTA_Bits B;             /**< \brief Bitfield access */
} Ifx_EGTM_SENT_OUTA;

/** \brief Spare Bits   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_SPARE_Bits B;                 /**< \brief Bitfield access */
} Ifx_EGTM_SPARE;

/** \brief TIM0 input selection register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_TIMINSEL_Bits B;              /**< \brief Bitfield access */
} Ifx_EGTM_TIMINSEL;

/** \brief eGTM to Ports signal TOUT output selection register 0   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_TOUTSEL_Bits B;               /**< \brief Bitfield access */
} Ifx_EGTM_TOUTSEL;

/** \}  */

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_CLS_ARCH_struct
 * \{  */
/******************************************************************************/
/** \name Object L3
 * \{  */
/** \brief ARCH object */
typedef volatile struct _Ifx_EGTM_CLS_ARCH
{
       __I  Ifx_EGTM_CLS_ARCH_REV               REV;                    /**< \brief 0, eGTM version control register*/
       __IO Ifx_EGTM_CLS_ARCH_RST               RST;                    /**< \brief 4, eGTM global reset register*/
       __IO Ifx_EGTM_CLS_ARCH_CTRL              CTRL;                   /**< \brief 8, eGTM global control register*/
       __IO Ifx_EGTM_CLS_ARCH_CFG               CFG;                    /**< \brief C, eGTM configuration register*/
       __I  Ifx_EGTM_CLS_ARCH_AEI_ADDR_XPT      AEI_ADDR_XPT;           /**< \brief 10, GTM_AEI_ADDR_XPT*/
       __I  Ifx_EGTM_CLS_ARCH_AEI_STA_XPT       AEI_STA_XPT;            /**< \brief 14, GTM_AEI_STA_XPT*/
       __IO Ifx_EGTM_CLS_ARCH_IRQ_NOTIFY        IRQ_NOTIFY;             /**< \brief 18, eGTM Interrupt notification register*/
       __IO Ifx_EGTM_CLS_ARCH_IRQ_EN            IRQ_EN;                 /**< \brief 1C, eGTM interrupt enable register*/
       __IO Ifx_EGTM_CLS_ARCH_EIRQ_EN           EIRQ_EN;                /**< \brief 20, eGTM error interrupt enable register*/
       __IO Ifx_EGTM_CLS_ARCH_IRQ_FORCINT       IRQ_FORCINT;            /**< \brief 24, eGTM Software interrupt generation register*/
       __IO Ifx_EGTM_CLS_ARCH_IRQ_MODE          IRQ_MODE;               /**< \brief 28, eGTM top level interrupts mode selection*/
       __IO Ifx_EGTM_CLS_ARCH_CLK_CFG           CLK_CFG;                /**< \brief 2C, eGTM Cluster Clock Configuration*/
       __I  Ifx_UReg_8Bit                       reserved_30[4];         /**< \brief 30, \internal Reserved */
} Ifx_EGTM_CLS_ARCH;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_CLS_AEI_struct
 * \{  */
/******************************************************************************/
/** \name Object L3
 * \{  */
/** \brief AEI object */
typedef volatile struct _Ifx_EGTM_CLS_AEI
{
       __IO Ifx_EGTM_CLS_AEI_BRIDGE_MODE        BRIDGE_MODE;            /**< \brief 0, BRIDGE_MODE*/
       __I  Ifx_EGTM_CLS_AEI_BRIDGE_PTR1        BRIDGE_PTR1;            /**< \brief 4, BRIDGE_PTR1*/
       __I  Ifx_EGTM_CLS_AEI_BRIDGE_PTR2        BRIDGE_PTR2;            /**< \brief 8, BRIDGE_PTR2*/
       __I  Ifx_UReg_8Bit                       reserved_C[4];          /**< \brief C, \internal Reserved */
} Ifx_EGTM_CLS_AEI;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_CLS_CMU_CLK_struct
 * \{  */
/******************************************************************************/
/** \name Object L4
 * \{  */
/** \brief CLK object */
typedef volatile struct _Ifx_EGTM_CLS_CMU_CLK
{
       __IO Ifx_EGTM_CLS_CMU_CLKX_CTRL          CTRL;                   /**< \brief 0, CMU control for clock resolution generator [x]*/
} Ifx_EGTM_CLS_CMU_CLK;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_CLS_CMU_ECLK_struct
 * \{  */
/******************************************************************************/
/** \name Object L4
 * \{  */
/** \brief ECLK object */
typedef volatile struct _Ifx_EGTM_CLS_CMU_ECLK
{
       __IO Ifx_EGTM_CLS_CMU_ECLK_NUM           NUM;                    /**< \brief 0, The numerator for the external clock resolution generator [z]*/
       __IO Ifx_EGTM_CLS_CMU_ECLK_DEN           DEN;                    /**< \brief 4, The denominator for the external clock resolution generator [z]*/
} Ifx_EGTM_CLS_CMU_ECLK;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_CLS_CMU_struct
 * \{  */
/******************************************************************************/
/** \name Object L3
 * \{  */
/** \brief CMU object */
typedef volatile struct _Ifx_EGTM_CLS_CMU
{
       __IO Ifx_EGTM_CLS_CMU_CLK_EN             CLK_EN;                 /**< \brief 0, CMU clock enable*/
       __IO Ifx_EGTM_CLS_CMU_GCLK_NUM           GCLK_NUM;               /**< \brief 4, The numerator for CMU global clock resolution generator*/
       __IO Ifx_EGTM_CLS_CMU_GCLK_DEN           GCLK_DEN;               /**< \brief 8, The denominator for CMU global clock resolution generator*/
        __IO Ifx_EGTM_CLS_CMU_CLK                CLK0;                   /**< \brief C, */
        __IO Ifx_EGTM_CLS_CMU_CLK                CLK1;                   /**< \brief 10, */
        __IO Ifx_EGTM_CLS_CMU_CLK                CLK2;                   /**< \brief 14, */
        __IO Ifx_EGTM_CLS_CMU_CLK                CLK3;                   /**< \brief 18, */
        __IO Ifx_EGTM_CLS_CMU_CLK                CLK4;                   /**< \brief 1C, */
        __IO Ifx_EGTM_CLS_CMU_CLK                CLK5;                   /**< \brief 20, */
       __IO Ifx_EGTM_CLS_CMU_CLK_6_CTRL         CLK_6_CTRL;             /**< \brief 24, CMU control for clock resolution generator 6*/
       __IO Ifx_EGTM_CLS_CMU_CLK_7_CTRL         CLK_7_CTRL;             /**< \brief 28, CMU control for clock resolution generator 7*/
       __IO Ifx_EGTM_CLS_CMU_ECLK               ECLK[3];                /**< \brief 2C, */
       __IO Ifx_EGTM_CLS_CMU_FXCLK_CTRL         FXCLK_CTRL;             /**< \brief 44, CMU control for selection of FCR subblock input*/
       __I  Ifx_UReg_8Bit                       reserved_48[4];         /**< \brief 48, \internal Reserved */
       __IO Ifx_EGTM_CLS_CMU_CLK_CTRL           CLK_CTRL;               /**< \brief 4C, CMU control for clock resolution generator*/
} Ifx_EGTM_CLS_CMU;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_CLS_TBU_CH_struct
 * \{  */
/******************************************************************************/
/** \name Object L4
 * \{  */
/** \brief CH object */
typedef volatile struct _Ifx_EGTM_CLS_TBU_CH
{
       __IO Ifx_EGTM_CLS_TBU_CH_BASE            BASE;                   /**< \brief 0, TBU channel [x] base*/
} Ifx_EGTM_CLS_TBU_CH;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_CLS_TBU_struct
 * \{  */
/******************************************************************************/
/** \name Object L3
 * \{  */
/** \brief TBU object */
typedef volatile struct _Ifx_EGTM_CLS_TBU
{
       __IO Ifx_EGTM_CLS_TBU_CHEN               CHEN;                   /**< \brief 0, TBU global channel enable*/
       __IO Ifx_EGTM_CLS_TBU_CH0_CTRL           CH0_CTRL;               /**< \brief 4, TBU channel 0 control*/
       __IO Ifx_EGTM_CLS_TBU_CH0_BASE           CH0_BASE;               /**< \brief 8, TBU channel 0 base*/
       __IO Ifx_EGTM_CLS_TBU_CH1_CTRL           CH1_CTRL;               /**< \brief C, TBU channel 1 control*/
        __IO Ifx_EGTM_CLS_TBU_CH                 CH1;                    /**< \brief 10, */
       __IO Ifx_EGTM_CLS_TBU_CH2_CTRL           CH2_CTRL;               /**< \brief 14, TBU channel 2 control*/
        __IO Ifx_EGTM_CLS_TBU_CH                 CH2;                    /**< \brief 18, */
       __IO Ifx_EGTM_CLS_TBU_CH3_CTRL           CH3_CTRL;               /**< \brief 1C, TBU channel 3 control*/
       __IO Ifx_EGTM_CLS_TBU_CH3_BASE           CH3_BASE;               /**< \brief 20, TBU channel 3 base*/
       __IO Ifx_EGTM_CLS_TBU_CH3_BASE_MARK      CH3_BASE_MARK;          /**< \brief 24, TBU channel 3 modulo value*/
       __I  Ifx_EGTM_CLS_TBU_CH3_BASE_CAPTURE   CH3_BASE_CAPTURE;       /**< \brief 28, TBU channel 3 base captured*/
} Ifx_EGTM_CLS_TBU;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_CLS_ICM_IRQG_CLS_struct
 * \{  */
/******************************************************************************/
/** \name Object L4
 * \{  */
/** \brief IRQG_CLS object */
typedef volatile struct _Ifx_EGTM_CLS_ICM_IRQG_CLS
{
       __I  Ifx_EGTM_CLS_ICM_IRQG_CLS_MEI       MEI;                    /**< \brief 0, ICM_IRQG_CLS_[g]_MEI*/
} Ifx_EGTM_CLS_ICM_IRQG_CLS;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_CLS_ICM_IRQG_ATOM_struct
 * \{  */
/******************************************************************************/
/** \name Object L4
 * \{  */
/** \brief IRQG_ATOM object */
typedef volatile struct _Ifx_EGTM_CLS_ICM_IRQG_ATOM
{
       __I  Ifx_EGTM_CLS_ICM_IRQG_ATOM_CI       CI;                     /**< \brief 0, ICM_IRQG_ATOM_[g]_CI*/
} Ifx_EGTM_CLS_ICM_IRQG_ATOM;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_CLS_ICM_IRQG_TOM_struct
 * \{  */
/******************************************************************************/
/** \name Object L4
 * \{  */
/** \brief IRQG_TOM object */
typedef volatile struct _Ifx_EGTM_CLS_ICM_IRQG_TOM
{
       __I  Ifx_EGTM_CLS_ICM_IRQG_TOM_CI        CI;                     /**< \brief 0, ICM_IRQG_TOM_[g]_CI*/
} Ifx_EGTM_CLS_ICM_IRQG_TOM;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_CLS_ICM_struct
 * \{  */
/******************************************************************************/
/** \name Object L3
 * \{  */
/** \brief ICM object */
typedef volatile struct _Ifx_EGTM_CLS_ICM
{
       __I  Ifx_EGTM_CLS_ICM_IRQG_0             IRQG_0;                 /**< \brief 0, ICM_IRQG_0*/
       __I  Ifx_UReg_8Bit                       reserved_4[4];          /**< \brief 4, \internal Reserved */
       __I  Ifx_EGTM_CLS_ICM_IRQG_2             IRQG_2;                 /**< \brief 8, ICM Interrupt group register covering TIM0, TIM1, TIM2, TIM3*/
       __I  Ifx_UReg_8Bit                       reserved_C[36];         /**< \brief C, \internal Reserved */
       __I  Ifx_EGTM_CLS_ICM_IRQG_MEI           IRQG_MEI;               /**< \brief 30, ICM Interrupt group register for module error interrupt information*/
       __I  Ifx_UReg_8Bit                       reserved_34[4];         /**< \brief 34, \internal Reserved */
       __I  Ifx_EGTM_CLS_ICM_IRQG_CEI1          IRQG_CEI1;              /**< \brief 38, ICM Interrupt group register 1 for channel error interrupt information*/
       __I  Ifx_UReg_8Bit                       reserved_3C[120];       /**< \brief 3C, \internal Reserved */
       __I  Ifx_EGTM_CLS_ICM_IRQG_SPE_CEI       IRQG_SPE_CEI;           /**< \brief B4, ICM Interrupt group SPE for module Error Interrupt information*/
       __I  Ifx_UReg_8Bit                       reserved_B8[88];        /**< \brief B8, \internal Reserved */
       __IO Ifx_EGTM_CLS_ICM_IRQG_CLS           IRQG_CLS[1];            /**< \brief 110, */
       __I  Ifx_UReg_8Bit                       reserved_114[92];       /**< \brief 114, \internal Reserved */
       __I  Ifx_EGTM_CLS_ICM_IRQG_SPE_CI        IRQG_SPE_CI;            /**< \brief 170, ICM Interrupt group SPE for module Interrupt information*/
       __I  Ifx_UReg_8Bit                       reserved_174[28];       /**< \brief 174, \internal Reserved */
       __IO Ifx_EGTM_CLS_ICM_IRQG_ATOM          IRQG_ATOM[1];           /**< \brief 190, */
       __I  Ifx_UReg_8Bit                       reserved_194[12];       /**< \brief 194, \internal Reserved */
       __IO Ifx_EGTM_CLS_ICM_IRQG_TOM           IRQG_TOM[1];            /**< \brief 1A0, */
       __I  Ifx_UReg_8Bit                       reserved_1A4[20];       /**< \brief 1A4, \internal Reserved */
} Ifx_EGTM_CLS_ICM;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_CLS_MON_struct
 * \{  */
/******************************************************************************/
/** \name Object L3
 * \{  */
/** \brief MON object */
typedef volatile struct _Ifx_EGTM_CLS_MON
{
       __IO Ifx_EGTM_CLS_MON_STATUS             STATUS;                 /**< \brief 0, MON status register*/
} Ifx_EGTM_CLS_MON;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_CLS_CMP_struct
 * \{  */
/******************************************************************************/
/** \name Object L3
 * \{  */
/** \brief CMP object */
typedef volatile struct _Ifx_EGTM_CLS_CMP
{
       __IO Ifx_EGTM_CLS_CMP_EN                 EN;                     /**< \brief 0, CMP comparator enable register*/
       __IO Ifx_EGTM_CLS_CMP_IRQ_NOTIFY         IRQ_NOTIFY;             /**< \brief 4, CMP event notification register*/
       __IO Ifx_EGTM_CLS_CMP_IRQ_EN             IRQ_EN;                 /**< \brief 8, CMP interrupt enable register*/
       __IO Ifx_EGTM_CLS_CMP_IRQ_FORCINT        IRQ_FORCINT;            /**< \brief C, CMP interrupt force register*/
       __IO Ifx_EGTM_CLS_CMP_IRQ_MODE           IRQ_MODE;               /**< \brief 10, CMP interrupt mode configuration register*/
       __IO Ifx_EGTM_CLS_CMP_EIRQ_EN            EIRQ_EN;                /**< \brief 14, CMP error interrupt enable register*/
} Ifx_EGTM_CLS_CMP;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_CLS_TIM_CH_struct
 * \{  */
/******************************************************************************/
/** \name Object L4
 * \{  */
/** \brief CH object */
typedef volatile struct _Ifx_EGTM_CLS_TIM_CH
{
       __IO Ifx_EGTM_CLS_TIM_CH_GPR0            GPR0;                   /**< \brief 0, TIM[i] channel [x] general purpose 0 register*/
       __IO Ifx_EGTM_CLS_TIM_CH_GPR1            GPR1;                   /**< \brief 4, TIM[i] channel [x] general purpose 1 register*/
       __I  Ifx_EGTM_CLS_TIM_CH_CNT             CNT;                    /**< \brief 8, TIM[i] channel [x] SMU counter register*/
       __I  Ifx_EGTM_CLS_TIM_CH_ECNT            ECNT;                   /**< \brief C, TIM[i] channel [x] SMU edge counter register*/
       __IO Ifx_EGTM_CLS_TIM_CH_CNTS            CNTS;                   /**< \brief 10, TIM[i] channel [x] SMU shadow counter register*/
       __IO Ifx_EGTM_CLS_TIM_CH_TDUC            TDUC;                   /**< \brief 14, TIM[i]_CH[x]_TDUC*/
       __IO Ifx_EGTM_CLS_TIM_CH_TDUV            TDUV;                   /**< \brief 18, TIM[i]_CH[x]_TDUV*/
       __IO Ifx_EGTM_CLS_TIM_CH_FLT_RE          FLT_RE;                 /**< \brief 1C, TIM[i] channel [x] filter parameter 0 register*/
       __IO Ifx_EGTM_CLS_TIM_CH_FLT_FE          FLT_FE;                 /**< \brief 20, TIM[i] channel [x] filter parameter 1 register*/
       __IO Ifx_EGTM_CLS_TIM_CH_CTRL            CTRL;                   /**< \brief 24, TIM[i] channel [x] control register*/
       __IO Ifx_EGTM_CLS_TIM_CH_ECTRL           ECTRL;                  /**< \brief 28, TIM[i] channel [x] extended control register*/
       __IO Ifx_EGTM_CLS_TIM_CH_IRQ_NOTIFY      IRQ_NOTIFY;             /**< \brief 2C, TIM[i] channel [x] interrupt notification register*/
       __IO Ifx_EGTM_CLS_TIM_CH_IRQ_EN          IRQ_EN;                 /**< \brief 30, TIM[i] channel [x] interrupt enable register*/
       __IO Ifx_EGTM_CLS_TIM_CH_IRQ_FORCINT     IRQ_FORCINT;            /**< \brief 34, TIM[i] channel [x] force interrupt register*/
       __IO Ifx_EGTM_CLS_TIM_CH_IRQ_MODE        IRQ_MODE;               /**< \brief 38, TIM[i] channel [x] interrupt mode configuration register*/
       __IO Ifx_EGTM_CLS_TIM_CH_EIRQ_EN         EIRQ_EN;                /**< \brief 3C, TIM[i] channel [x] error interrupt enable register*/
       __I  Ifx_UReg_8Bit                       reserved_40[64];        /**< \brief 40, \internal Reserved */
} Ifx_EGTM_CLS_TIM_CH;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_CLS_TIM_struct
 * \{  */
/******************************************************************************/
/** \name Object L3
 * \{  */
/** \brief TIM object */
typedef volatile struct _Ifx_EGTM_CLS_TIM
{
       __IO Ifx_EGTM_CLS_TIM_CH                 CH[8];                  /**< \brief 0, */
       __I  Ifx_EGTM_CLS_TIM_INP_VAL            INP_VAL;                /**< \brief 400, TIM[i] input value observation register*/
       __IO Ifx_EGTM_CLS_TIM_IN_SRC             IN_SRC;                 /**< \brief 404, TIM[i] AUX IN source selection register*/
       __IO Ifx_EGTM_CLS_TIM_RST                RST;                    /**< \brief 408, TIM[i] global software reset register*/
} Ifx_EGTM_CLS_TIM;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_CLS_TOM_CH_struct
 * \{  */
/******************************************************************************/
/** \name Object L4
 * \{  */
/** \brief CH object */
typedef volatile struct _Ifx_EGTM_CLS_TOM_CH
{
       __IO Ifx_EGTM_CLS_TOM_CH_CTRL            CTRL;                   /**< \brief 0, TOM[i] channel [x] control register*/
       __IO Ifx_EGTM_CLS_TOM_CH_SR0             SR0;                    /**< \brief 4, TOM[i] channel [x] CCU0 compare shadow register*/
       __IO Ifx_EGTM_CLS_TOM_CH_SR1             SR1;                    /**< \brief 8, TOM[i] channel [x] CCU1 compare shadow register*/
       __IO Ifx_EGTM_CLS_TOM_CH_CM0             CM0;                    /**< \brief C, TOM[i] channel [x] CCU0 compare register*/
       __IO Ifx_EGTM_CLS_TOM_CH_CM1             CM1;                    /**< \brief 10, TOM[i] channel [x] CCU1 compare register*/
       __IO Ifx_EGTM_CLS_TOM_CH_CN0             CN0;                    /**< \brief 14, TOM[i] channel [x] CCU0 counter*/
       __IO Ifx_EGTM_CLS_TOM_CH_STAT            STAT;                   /**< \brief 18, TOM[i] channel [x] status register*/
       __IO Ifx_EGTM_CLS_TOM_CH_IRQ_NOTIFY      IRQ_NOTIFY;             /**< \brief 1C, TOM[i] channel [x] interrupt notification register*/
       __IO Ifx_EGTM_CLS_TOM_CH_IRQ_EN          IRQ_EN;                 /**< \brief 20, TOM[i] channel [x] interrupt enable register*/
       __IO Ifx_EGTM_CLS_TOM_CH_IRQ_FORCINT     IRQ_FORCINT;            /**< \brief 24, TOM[i] channel [x] force interrupt register*/
       __IO Ifx_EGTM_CLS_TOM_CH_IRQ_MODE        IRQ_MODE;               /**< \brief 28, TOM[i] channel [x] interrupt mode register*/
       __I  Ifx_UReg_8Bit                       reserved_2C[4];         /**< \brief 2C, \internal Reserved */
       __IO Ifx_EGTM_CLS_TOM_CH_CTRL_SR         CTRL_SR;                /**< \brief 30, TOM[i] channel [x] control shadow register*/
       __I  Ifx_UReg_8Bit                       reserved_34[12];        /**< \brief 34, \internal Reserved */
} Ifx_EGTM_CLS_TOM_CH;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_CLS_TOM_TGC_struct
 * \{  */
/******************************************************************************/
/** \name Object L4
 * \{  */
/** \brief TGC object */
typedef volatile struct _Ifx_EGTM_CLS_TOM_TGC
{
       __IO Ifx_EGTM_CLS_TOM_TGC_GLB_CTRL       GLB_CTRL;               /**< \brief 0, TOM[i] TGC [g] global control register*/
       __IO Ifx_EGTM_CLS_TOM_TGC_ACT_TB         ACT_TB;                 /**< \brief 4, TOM[i] TGC [g] action time base register*/
       __IO Ifx_EGTM_CLS_TOM_TGC_FUPD_CTRL      FUPD_CTRL;              /**< \brief 8, TOM[i] TGC [g] force update control register*/
       __IO Ifx_EGTM_CLS_TOM_TGC_INT_TRIG       INT_TRIG;               /**< \brief C, TOM[i] TGC [g] internal trigger control register*/
       __I  Ifx_UReg_8Bit                       reserved_10[48];        /**< \brief 10, \internal Reserved */
       __IO Ifx_EGTM_CLS_TOM_TGC_ENDIS_CTRL     ENDIS_CTRL;             /**< \brief 40, TOM[i] TGC [g] enable/disable control register*/
       __IO Ifx_EGTM_CLS_TOM_TGC_ENDIS_STAT     ENDIS_STAT;             /**< \brief 44, TOM[i] TGC [g] enable/disable status register*/
       __IO Ifx_EGTM_CLS_TOM_TGC_OUTEN_CTRL     OUTEN_CTRL;             /**< \brief 48, TOM[i] TGC [g] output enable control register*/
       __IO Ifx_EGTM_CLS_TOM_TGC_OUTEN_STAT     OUTEN_STAT;             /**< \brief 4C, TOM[i] TGC [g] output enable status register*/
       __I  Ifx_UReg_8Bit                       reserved_50[48];        /**< \brief 50, \internal Reserved */
} Ifx_EGTM_CLS_TOM_TGC;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_CLS_TOM_struct
 * \{  */
/******************************************************************************/
/** \name Object L3
 * \{  */
/** \brief TOM object */
typedef volatile struct _Ifx_EGTM_CLS_TOM
{
       __IO Ifx_EGTM_CLS_TOM_CH                 CH[16];                 /**< \brief 0, */
       __I  Ifx_UReg_8Bit                       reserved_400[48];       /**< \brief 400, \internal Reserved */
       __IO Ifx_EGTM_CLS_TOM_TGC                TGC[2];                 /**< \brief 430, */
} Ifx_EGTM_CLS_TOM;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_CLS_ATOM_CH_struct
 * \{  */
/******************************************************************************/
/** \name Object L4
 * \{  */
/** \brief CH object */
typedef volatile struct _Ifx_EGTM_CLS_ATOM_CH
{
       __I  Ifx_UReg_8Bit                       reserved_0[4];          /**< \brief 0, \internal Reserved */
       union
       {
            __IO Ifx_EGTM_CLS_ATOM_CH_CTRL_SOMI      CTRL_SOMI;              /**< \brief 4, ATOM[i] channel [x] control register*/
            __IO Ifx_EGTM_CLS_ATOM_CH_CTRL_SOMC      CTRL_SOMC;              /**< \brief 4, ATOM[i] channel [x] control register*/
            __IO Ifx_EGTM_CLS_ATOM_CH_CTRL_SOMP      CTRL_SOMP;              /**< \brief 4, ATOM[i] channel [x] control register*/
            __IO Ifx_EGTM_CLS_ATOM_CH_CTRL_SOMS      CTRL_SOMS;              /**< \brief 4, ATOM[i] channel [x] control register*/
            __IO Ifx_EGTM_CLS_ATOM_CH_CTRL_SOMB      CTRL_SOMB;              /**< \brief 4, ATOM[i] channel [x] control register*/
            __IO Ifx_EGTM_CLS_ATOM_CH_CTRL           CTRL;                   /**< \brief 4, ATOM[i] channel [x] control register*/
       };
       __IO Ifx_EGTM_CLS_ATOM_CH_SR0            SR0;                    /**< \brief 8, ATOM[i] channel [x] CCU0 compare shadow register*/
       __IO Ifx_EGTM_CLS_ATOM_CH_SR1            SR1;                    /**< \brief C, ATOM[i] channel [x] CCU1 compare shadow register*/
       __IO Ifx_EGTM_CLS_ATOM_CH_CM0            CM0;                    /**< \brief 10, ATOM[i] channel [x] CCU0 compare register*/
       __IO Ifx_EGTM_CLS_ATOM_CH_CM1            CM1;                    /**< \brief 14, ATOM[i] channel [x] CCU1 compare register*/
       __IO Ifx_EGTM_CLS_ATOM_CH_CN0            CN0;                    /**< \brief 18, ATOM[i] channel [x] CCU0 counter register*/
       __IO Ifx_EGTM_CLS_ATOM_CH_STAT           STAT;                   /**< \brief 1C, ATOM[i] channel [x] status register*/
       __IO Ifx_EGTM_CLS_ATOM_CH_IRQ_NOTIFY     IRQ_NOTIFY;             /**< \brief 20, ATOM[i] channel [x] interrupt notification register*/
       __IO Ifx_EGTM_CLS_ATOM_CH_IRQ_EN         IRQ_EN;                 /**< \brief 24, ATOM[i] channel [x] interrupt enable register*/
       __IO Ifx_EGTM_CLS_ATOM_CH_IRQ_FORCINT    IRQ_FORCINT;            /**< \brief 28, ATOM[i] channel [x] software interrupt generation*/
       __IO Ifx_EGTM_CLS_ATOM_CH_IRQ_MODE       IRQ_MODE;               /**< \brief 2C, ATOM[i] channel [x] interrupt mode configuration register*/
       __IO Ifx_EGTM_CLS_ATOM_CH_CTRL2          CTRL2;                  /**< \brief 30, ATOM[i] channel [x] control2 register*/
       __IO Ifx_EGTM_CLS_ATOM_CH_CTRL_SR        CTRL_SR;                /**< \brief 34, ATOM[i] channel [x] control shadow register*/
       __I  Ifx_UReg_8Bit                       reserved_38[72];        /**< \brief 38, \internal Reserved */
} Ifx_EGTM_CLS_ATOM_CH;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_CLS_ATOM_AGC_struct
 * \{  */
/******************************************************************************/
/** \name Object L4
 * \{  */
/** \brief AGC object */
typedef volatile struct _Ifx_EGTM_CLS_ATOM_AGC
{
       __IO Ifx_EGTM_CLS_ATOM_AGC_GLB_CTRL      GLB_CTRL;               /**< \brief 0, ATOM[i] AGC global control register*/
       __IO Ifx_EGTM_CLS_ATOM_AGC_ENDIS_CTRL    ENDIS_CTRL;             /**< \brief 4, ATOM[i] AGC enable/disable control register*/
       __IO Ifx_EGTM_CLS_ATOM_AGC_ENDIS_STAT    ENDIS_STAT;             /**< \brief 8, ATOM[i] AGC enable/disable status register*/
       __IO Ifx_EGTM_CLS_ATOM_AGC_ACT_TB        ACT_TB;                 /**< \brief C, ATOM[i] AGC action time base register*/
       __IO Ifx_EGTM_CLS_ATOM_AGC_OUTEN_CTRL    OUTEN_CTRL;             /**< \brief 10, ATOM[i] AGC output enable control register*/
       __IO Ifx_EGTM_CLS_ATOM_AGC_OUTEN_STAT    OUTEN_STAT;             /**< \brief 14, ATOM[i] AGC output enable status register*/
       __IO Ifx_EGTM_CLS_ATOM_AGC_FUPD_CTRL     FUPD_CTRL;              /**< \brief 18, ATOM[i] AGC force update control register*/
       __IO Ifx_EGTM_CLS_ATOM_AGC_INT_TRIG      INT_TRIG;               /**< \brief 1C, ATOM[i] AGC internal trigger control register*/
} Ifx_EGTM_CLS_ATOM_AGC;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_CLS_ATOM_struct
 * \{  */
/******************************************************************************/
/** \name Object L3
 * \{  */
/** \brief ATOM object */
typedef volatile struct _Ifx_EGTM_CLS_ATOM
{
       __IO Ifx_EGTM_CLS_ATOM_CH                CH[8];                  /**< \brief 0, */
       __I  Ifx_UReg_8Bit                       reserved_400[64];       /**< \brief 400, \internal Reserved */
       __IO Ifx_EGTM_CLS_ATOM_AGC               AGC;                    /**< \brief 440, */
} Ifx_EGTM_CLS_ATOM;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_CLS_CCM_struct
 * \{  */
/******************************************************************************/
/** \name Object L3
 * \{  */
/** \brief CCM object */
typedef volatile struct _Ifx_EGTM_CLS_CCM
{
       __I  Ifx_UReg_8Bit                       reserved_0[468];        /**< \brief 0, \internal Reserved */
       __I  Ifx_EGTM_CLS_CCM_HW_CONF2           HW_CONF2;               /**< \brief 1D4, CCM[i] 2. Hardware Configuration Register*/
       __I  Ifx_UReg_8Bit                       reserved_1D8[4];        /**< \brief 1D8, \internal Reserved */
       __I  Ifx_EGTM_CLS_CCM_HW_CONF            HW_CONF;                /**< \brief 1DC, CCM[i] Hardware Configuration Register*/
       __IO Ifx_EGTM_CLS_CCM_TIM_AUX_IN_SRC     TIM_AUX_IN_SRC;         /**< \brief 1E0, CCM[i] TIM AUX Input Source Register*/
       __I  Ifx_UReg_8Bit                       reserved_1E4[4];        /**< \brief 1E4, \internal Reserved */
       __I  Ifx_EGTM_CLS_CCM_TOM_OUT            TOM_OUT;                /**< \brief 1E8, CCM[i] TOM Output Register*/
       __I  Ifx_EGTM_CLS_CCM_ATOM_OUT           ATOM_OUT;               /**< \brief 1EC, CCM[i] ATOM Output Register*/
       __IO Ifx_EGTM_CLS_CCM_CMU_CLK_CFG        CMU_CLK_CFG;            /**< \brief 1F0, CCM[i] CMU Clock Configuration Register*/
       __IO Ifx_EGTM_CLS_CCM_CMU_FXCLK_CFG      CMU_FXCLK_CFG;          /**< \brief 1F4, CCM[i] CMU Fixed Clock Configuration Register*/
       __IO Ifx_EGTM_CLS_CCM_CFG                CFG;                    /**< \brief 1F8, CCM[i] Configuration Register*/
       __IO Ifx_EGTM_CLS_CCM_PROT               PROT;                   /**< \brief 1FC, CCM[i] Protection Register*/
} Ifx_EGTM_CLS_CCM;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_CLS_CDTM_DTM_struct
 * \{  */
/******************************************************************************/
/** \name Object L4
 * \{  */
/** \brief DTM object */
typedef volatile struct _Ifx_EGTM_CLS_CDTM_DTM
{
       __IO Ifx_EGTM_CLS_CDTM_DTM_CTRL          CTRL;                   /**< \brief 0, CDTM[i]_DTM[d] global configuration and control register*/
       __IO Ifx_EGTM_CLS_CDTM_DTM_CH_CTRL1      CH_CTRL1;               /**< \brief 4, CDTM[i]_DTM[d] channel control register 1*/
       __IO Ifx_EGTM_CLS_CDTM_DTM_CH_CTRL2      CH_CTRL2;               /**< \brief 8, CDTM[i]_DTM[d] channel control register 2*/
       __IO Ifx_EGTM_CLS_CDTM_DTM_CH_CTRL2_SR   CH_CTRL2_SR;            /**< \brief C, CDTM[i] DTM[j] channel control register 2 shadow*/
       __IO Ifx_EGTM_CLS_CDTM_DTM_PS_CTRL       PS_CTRL;                /**< \brief 10, CDTM[i]_DTM[d] phase shift unit configuration and control register*/
       __IO Ifx_EGTM_CLS_CDTM_DTM_CH_DTV        CH_DTV[4];              /**< \brief 14, CDTM[i]_DTM[d] channel [x] dead time reload values*/
       __IO Ifx_EGTM_CLS_CDTM_DTM_CH_SR         CH_SR;                  /**< \brief 24, CDTM[i]_DTM[d] channel shadow register*/
       __IO Ifx_EGTM_CLS_CDTM_DTM_CH_CTRL3      CH_CTRL3;               /**< \brief 28, CDTM[i]_DTM[d] channel control register 3*/
       __IO Ifx_EGTM_CLS_CDTM_DTM_CTRL2         CTRL2;                  /**< \brief 2C, CDTM[i]_DTM[d] global configuration and control register 2*/
       __IO Ifx_EGTM_CLS_CDTM_DTM_CH_DTV_SR     CH_DTV_SR[4];           /**< \brief 30, CDTM[i]_DTM[d] channel [x] dead time shadow values*/
} Ifx_EGTM_CLS_CDTM_DTM;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_CLS_CDTM_struct
 * \{  */
/******************************************************************************/
/** \name Object L3
 * \{  */
/** \brief CDTM object */
typedef volatile struct _Ifx_EGTM_CLS_CDTM
{
       __IO Ifx_EGTM_CLS_CDTM_DTM               DTM[6];                 /**< \brief 0, */
} Ifx_EGTM_CLS_CDTM;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_CLS_SPE_struct
 * \{  */
/******************************************************************************/
/** \name Object L3
 * \{  */
/** \brief SPE object */
typedef volatile struct _Ifx_EGTM_CLS_SPE
{
       __IO Ifx_EGTM_CLS_SPE_CTRL_STAT          CTRL_STAT;              /**< \brief 0, SPE[i] Control Status Register*/
       __IO Ifx_EGTM_CLS_SPE_PAT                PAT;                    /**< \brief 4, SPE[i] Input Pattern Definition Register*/
       __IO Ifx_EGTM_CLS_SPE_OUT_PAT            OUT_PAT[8];             /**< \brief 8, SPE[i] Output Definition Register*/
       __IO Ifx_EGTM_CLS_SPE_OUT_CTRL           OUT_CTRL;               /**< \brief 28, SPE[i] Output Control Register*/
       __IO Ifx_EGTM_CLS_SPE_IRQ_NOTIFY         IRQ_NOTIFY;             /**< \brief 2C, SPE[i] Interrupt Notification Register*/
       __IO Ifx_EGTM_CLS_SPE_IRQ_EN             IRQ_EN;                 /**< \brief 30, SPE[i] Interrupt Enable Register*/
       __IO Ifx_EGTM_CLS_SPE_IRQ_FORCINT        IRQ_FORCINT;            /**< \brief 34, SPE[i] Interrupt Generation By Software*/
       __IO Ifx_EGTM_CLS_SPE_IRQ_MODE           IRQ_MODE;               /**< \brief 38, SPE[i] Interrupt Mode Configuration Register*/
       __IO Ifx_EGTM_CLS_SPE_EIRQ_EN            EIRQ_EN;                /**< \brief 3C, SPE[i] Error Interrupt Enable Register*/
       __IO Ifx_EGTM_CLS_SPE_REV_CNT            REV_CNT;                /**< \brief 40, SPE[i] Input Revolution Counter*/
       __IO Ifx_EGTM_CLS_SPE_REV_CMP            REV_CMP;                /**< \brief 44, SPE[i] Revolution Counter Compare Value*/
       __IO Ifx_EGTM_CLS_SPE_CTRL_STAT2         CTRL_STAT2;             /**< \brief 48, SPE[i] Control Status Register 2*/
       __IO Ifx_EGTM_CLS_SPE_CMD                CMD;                    /**< \brief 4C, SPE[i] Command Register*/
} Ifx_EGTM_CLS_SPE;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_CLS_struct
 * \{  */
/******************************************************************************/
/** \name Object L2
 * \{  */
/** \brief CLS object */
typedef volatile struct _Ifx_EGTM_CLS
{
       __IO Ifx_EGTM_CLS_ARCH                   ARCH;                   /**< \brief 0, */
       __I  Ifx_UReg_8Bit                       reserved_34[12];        /**< \brief 34, \internal Reserved */
       __IO Ifx_EGTM_CLS_AEI                    AEI;                    /**< \brief 40, */
       __I  Ifx_UReg_8Bit                       reserved_50[48];        /**< \brief 50, \internal Reserved */
       __IO Ifx_EGTM_CLS_CMU                    CMU;                    /**< \brief 80, */
       __I  Ifx_UReg_8Bit                       reserved_D0[48];        /**< \brief D0, \internal Reserved */
       __IO Ifx_EGTM_CLS_TBU                    TBU;                    /**< \brief 100, */
       __I  Ifx_UReg_8Bit                       reserved_12C[724];      /**< \brief 12C, \internal Reserved */
       __IO Ifx_EGTM_CLS_ICM                    ICM;                    /**< \brief 400, */
       __I  Ifx_UReg_8Bit                       reserved_5B8[200];      /**< \brief 5B8, \internal Reserved */
       __IO Ifx_EGTM_CLS_MON                    MON;                    /**< \brief 680, */
       __I  Ifx_UReg_8Bit                       reserved_684[60];       /**< \brief 684, \internal Reserved */
       __IO Ifx_EGTM_CLS_CMP                    CMP;                    /**< \brief 6C0, */
       __I  Ifx_UReg_8Bit                       reserved_6D8[296];      /**< \brief 6D8, \internal Reserved */
       __IO Ifx_EGTM_CLS_TIM                    TIM;                    /**< \brief 800, */
       __I  Ifx_UReg_8Bit                       reserved_C0C[1012];     /**< \brief C0C, \internal Reserved */
       __IO Ifx_EGTM_CLS_TOM                    TOM;                    /**< \brief 1000, */
       __I  Ifx_UReg_8Bit                       reserved_1530[720];     /**< \brief 1530, \internal Reserved */
       __IO Ifx_EGTM_CLS_ATOM                   ATOM;                   /**< \brief 1800, */
       __I  Ifx_UReg_8Bit                       reserved_1C60[9120];    /**< \brief 1C60, \internal Reserved */
       __IO Ifx_EGTM_CLS_CCM                    CCM;                    /**< \brief 4000, */
       __I  Ifx_UReg_8Bit                       reserved_4200[512];     /**< \brief 4200, \internal Reserved */
       __IO Ifx_EGTM_CLS_CDTM                   CDTM;                   /**< \brief 4400, */
       __I  Ifx_UReg_8Bit                       reserved_4580[1664];    /**< \brief 4580, \internal Reserved */
       __IO Ifx_EGTM_CLS_SPE                    SPE;                    /**< \brief 4C00, */
       __I  Ifx_UReg_8Bit                       reserved_4C50[111536];    /**< \brief 4C50, \internal Reserved */
} Ifx_EGTM_CLS;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_RST_struct
 * \{  */
/******************************************************************************/
/** \name Object L2
 * \{  */
/** \brief RST object */
typedef volatile struct _Ifx_EGTM_RST
{
       __IO Ifx_EGTM_RST_CTRLA                  CTRLA;                  /**< \brief 0, Reset control register A*/
       __IO Ifx_EGTM_RST_CTRLB                  CTRLB;                  /**< \brief 4, Reset control register B*/
       __I  Ifx_EGTM_RST_STAT                   STAT;                   /**< \brief 8, Reset status register*/
} Ifx_EGTM_RST;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_CL_ACCEN_struct
 * \{  */
/******************************************************************************/
/** \name Object L3
 * \{  */
/** \brief ACCEN object */
typedef volatile struct _Ifx_EGTM_CL_ACCEN
{
       __IO Ifx_EGTM_ACCEN_WRA                  WRA;                    /**< \brief 0, Write access enable register A for cluster 0*/
       __IO Ifx_EGTM_ACCEN_WRB_FPI              WRB;                    /**< \brief 4, Write access enable register B for cluster 0*/
       __IO Ifx_EGTM_ACCEN_RDA                  RDA;                    /**< \brief 8, Read access enable register A for cluster 0*/
       __IO Ifx_EGTM_ACCEN_RDB_FPI              RDB;                    /**< \brief C, Read access enable register B for cluster 0*/
       __IO Ifx_EGTM_ACCEN_VM                   VM;                     /**< \brief 10, VM access enable register for cluster 0*/
       __IO Ifx_EGTM_ACCEN_PRS                  PRS;                    /**< \brief 14, PRS access enable register for cluster 0*/
       __I  Ifx_UReg_8Bit                       reserved_18[8];         /**< \brief 18, \internal Reserved */
} Ifx_EGTM_CL_ACCEN;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_CL_struct
 * \{  */
/******************************************************************************/
/** \name Object L2
 * \{  */
/** \brief CL object */
typedef volatile struct _Ifx_EGTM_CL
{
       __I  Ifx_UReg_8Bit                       reserved_0[4];          /**< \brief 0, \internal Reserved */
       __IO Ifx_EGTM_CL_ACCEN                   ACCEN;                  /**< \brief 4, */
} Ifx_EGTM_CL;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_CTRL_ACCEN_struct
 * \{  */
/******************************************************************************/
/** \name Object L3
 * \{  */
/** \brief ACCEN object */
typedef volatile struct _Ifx_EGTM_CTRL_ACCEN
{
       __IO Ifx_EGTM_ACCEN_WRA                  WRA;                    /**< \brief 0, Write access enable register A for control logic*/
       __IO Ifx_EGTM_ACCEN_WRB_FPI              WRB;                    /**< \brief 4, Write access enable register B for control logic*/
       __IO Ifx_EGTM_ACCEN_RDA                  RDA;                    /**< \brief 8, Read access enable register A for control logic*/
       __IO Ifx_EGTM_ACCEN_RDB_FPI              RDB;                    /**< \brief C, Read access enable register B for control logic*/
       __IO Ifx_EGTM_ACCEN_VM                   VM;                     /**< \brief 10, VM access enable register for control logic*/
       __IO Ifx_EGTM_ACCEN_PRS                  PRS;                    /**< \brief 14, PRS access enable register for control logic*/
       __I  Ifx_UReg_8Bit                       reserved_18[8];         /**< \brief 18, \internal Reserved */
} Ifx_EGTM_CTRL_ACCEN;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_CTRL_struct
 * \{  */
/******************************************************************************/
/** \name Object L2
 * \{  */
/** \brief CTRL object */
typedef volatile struct _Ifx_EGTM_CTRL
{
       __IO Ifx_EGTM_PROT                       PROTE;                  /**< \brief 0, PROT register Endinit for control logic*/
       __IO Ifx_EGTM_CTRL_ACCEN                 ACCEN;                  /**< \brief 4, */
} Ifx_EGTM_CTRL;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_WRAP_ACCEN_struct
 * \{  */
/******************************************************************************/
/** \name Object L3
 * \{  */
/** \brief ACCEN object */
typedef volatile struct _Ifx_EGTM_WRAP_ACCEN
{
       __IO Ifx_EGTM_ACCEN_WRA                  WRA;                    /**< \brief 0, Write access enable register A for wrapper logic*/
       __IO Ifx_EGTM_ACCEN_WRB_FPI              WRB;                    /**< \brief 4, Write access enable register B for wrapper logic*/
       __IO Ifx_EGTM_ACCEN_RDA                  RDA;                    /**< \brief 8, Read access enable register A for wrapper logic*/
       __IO Ifx_EGTM_ACCEN_RDB_FPI              RDB;                    /**< \brief C, Read access enable register B for wrapper logic*/
       __IO Ifx_EGTM_ACCEN_VM                   VM;                     /**< \brief 10, VM access enable register for wrapper logic*/
       __IO Ifx_EGTM_ACCEN_PRS                  PRS;                    /**< \brief 14, PRS access enable register for wrapper logic*/
       __I  Ifx_UReg_8Bit                       reserved_18[8];         /**< \brief 18, \internal Reserved */
} Ifx_EGTM_WRAP_ACCEN;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_WRAP_struct
 * \{  */
/******************************************************************************/
/** \name Object L2
 * \{  */
/** \brief WRAP object */
typedef volatile struct _Ifx_EGTM_WRAP
{
       __I  Ifx_UReg_8Bit                       reserved_0[4];          /**< \brief 0, \internal Reserved */
       __IO Ifx_EGTM_WRAP_ACCEN                 ACCEN;                  /**< \brief 4, */
} Ifx_EGTM_WRAP;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_OCDS_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief OCDS object */
typedef volatile struct _Ifx_EGTM_OCDS
{
       __IO Ifx_EGTM_OCDS_OTBU0T                OTBU0T;                 /**< \brief 0, OCDS TBU0 trigger register*/
       __IO Ifx_EGTM_OCDS_OTBU1T                OTBU1T;                 /**< \brief 4, OCDS TBU1 trigger register*/
       __IO Ifx_EGTM_OCDS_OTBU2T                OTBU2T;                 /**< \brief 8, OCDS TBU2 trigger register*/
       __IO Ifx_EGTM_OCDS_OTBU3T                OTBU3T;                 /**< \brief C, OCDS TBU3 trigger register*/
       __IO Ifx_EGTM_OCDS_OTSS                  OTSS;                   /**< \brief 10, OCDS trigger set select register*/
       __IO Ifx_EGTM_OCDS_OTSC0                 OTSC0;                  /**< \brief 14, OCDS trigger set control 0 register*/
} Ifx_EGTM_OCDS;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_MSCSET_struct
 * \{  */
/******************************************************************************/
/** \name Object L2
 * \{  */
/** \brief MSCSET object */
typedef volatile struct _Ifx_EGTM_MSCSET
{
       __IO Ifx_EGTM_MSCSET_CON0                CON0;                   /**< \brief 0, eGTM to MSC SET0 output selection register 0*/
       __IO Ifx_EGTM_MSCSET_CON1                CON1;                   /**< \brief 4, eGTM to MSC SET0 output selection register 0*/
       __IO Ifx_EGTM_MSCSET_CON2                CON2;                   /**< \brief 8, eGTM to MSC SET0 output selection register 0*/
       __IO Ifx_EGTM_MSCSET_CON3                CON3;                   /**< \brief C, eGTM to MSC SET0 output selection register 0*/
} Ifx_EGTM_MSCSET;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_MSC_struct
 * \{  */
/******************************************************************************/
/** \name Object L2
 * \{  */
/** \brief MSC object */
typedef volatile struct _Ifx_EGTM_MSC
{
       __IO Ifx_EGTM_MSC_INLCON                 INLCON;                 /**< \brief 0, eGTM to MSC0 input bus ALTINL signal selection register*/
       __IO Ifx_EGTM_MSC_INHCON                 INHCON;                 /**< \brief 4, eGTM to MSC0 input bus ALTINH signal selection register*/
       __IO Ifx_EGTM_MSC_INLECON                INLECON;                /**< \brief 8, eGTM to MSC0 input bus ALTINLE signal selection register*/
       __IO Ifx_EGTM_MSC_INHECON                INHECON;                /**< \brief C, eGTM to MSC0 input bus ALTINHE signal selection register*/
} Ifx_EGTM_MSC;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_PSI5_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief PSI5 object */
typedef volatile struct _Ifx_EGTM_PSI5
{
       __IO Ifx_EGTM_PSI5_OUT                   OUT;                    /**< \brief 0, eGTM to PSI5 output trigger selection register*/
} Ifx_EGTM_PSI5;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_PSI5S_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief PSI5S object */
typedef volatile struct _Ifx_EGTM_PSI5S
{
       __IO Ifx_EGTM_PSI5S_OUT                  OUT;                    /**< \brief 0, eGTM to PSI5-S0 output trigger selection register*/
} Ifx_EGTM_PSI5S;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_LCDCDC_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief LCDCDC object */
typedef volatile struct _Ifx_EGTM_LCDCDC
{
       __IO Ifx_EGTM_LCDCDC_OUT                 OUT;                    /**< \brief 0, eGTM to LCDCDC output trigger selection register*/
} Ifx_EGTM_LCDCDC;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_CAN_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief CAN object */
typedef volatile struct _Ifx_EGTM_CAN
{
       __IO Ifx_EGTM_CAN_OUT                    OUT[4];                 /**< \brief 0, eGTM to CAN0 output selection register 0*/
} Ifx_EGTM_CAN;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_QSPI_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief QSPI object */
typedef volatile struct _Ifx_EGTM_QSPI
{
       __IO Ifx_EGTM_QSPI_OUT                   OUT;                    /**< \brief 0, eGTM to QSPI0 output selection register*/
} Ifx_EGTM_QSPI;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_ASCLIN_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief ASCLIN object */
typedef volatile struct _Ifx_EGTM_ASCLIN
{
       __IO Ifx_EGTM_ASCLIN_OUT                 OUT;                    /**< \brief 0, eGTM to ASCLIN0 output selection register*/
} Ifx_EGTM_ASCLIN;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_SENT_struct
 * \{  */
/******************************************************************************/
/** \name Object L2
 * \{  */
/** \brief SENT object */
typedef volatile struct _Ifx_EGTM_SENT
{
       __IO Ifx_EGTM_SENT_OUTA                  OUTA;                   /**< \brief 0, eGTM to SENT0 trigger x output selection register A*/
       __I  Ifx_UReg_8Bit                       reserved_4[4];          /**< \brief 4, \internal Reserved */
} Ifx_EGTM_SENT;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_ADC_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief ADC object */
typedef volatile struct _Ifx_EGTM_ADC
{
       __IO Ifx_EGTM_ADC_OUT                    OUT[3];                 /**< \brief 0, eGTM to ADC output selection register 0*/
} Ifx_EGTM_ADC;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_DTMAUX_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief DTMAUX object */
typedef volatile struct _Ifx_EGTM_DTMAUX
{
       __O  Ifx_EGTM_DTMAUX_IN                  IN[2];                  /**< \brief 0, Cluster 0 DTMAUX input 0 selection register*/
} Ifx_EGTM_DTMAUX;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_HRPWMMUX_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief HRPWMMUX object */
typedef volatile struct _Ifx_EGTM_HRPWMMUX
{
       __IO Ifx_EGTM_HRPWMMUX_CHSEL             CHSEL;                  /**< \brief 0, HRPWM0 16:1 Channel MUX select*/
} Ifx_EGTM_HRPWMMUX;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_HRPWM_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief HRPWM object */
typedef volatile struct _Ifx_EGTM_HRPWM
{
       __IO Ifx_EGTM_HRPWM_EN                   EN;                     /**< \brief 0, HRPWM0 module and channel enable register*/
       __IO Ifx_EGTM_HRPWM_DLLCFGH              DLLCFGH;                /**< \brief 4, HRPWM0 DLL configuration register High*/
       __IO Ifx_EGTM_HRPWM_DLLCFGL              DLLCFGL;                /**< \brief 8, HRPWM0 DLL configuration register Low*/
       __I  Ifx_EGTM_HRPWM_DLLSTAT              DLLSTAT;                /**< \brief C, HRPWM0 DLL status register*/
       __I  Ifx_UReg_8Bit                       reserved_10[1008];      /**< \brief 10, \internal Reserved */
} Ifx_EGTM_HRPWM;

/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_Registers_struct
 * \{  */
/******************************************************************************/
/** \name Object L0
 * \{  */

/** \brief EGTM object */
typedef volatile struct _Ifx_EGTM
{
       __IO Ifx_EGTM_CLS                        CLS[3];                 /**< \brief 0, */
       __IO Ifx_EGTM_CLC                        CLC;                    /**< \brief 60000, Clock control register*/
       __IO Ifx_EGTM_OCS                        OCS;                    /**< \brief 60004, OCDS control and status register*/
       __I  Ifx_UReg_8Bit                       reserved_60008[8];      /**< \brief 60008, \internal Reserved */
       __IO Ifx_EGTM_RST                        RST;                    /**< \brief 60010, */
       __IO Ifx_EGTM_PROT                       PROTSE;                 /**< \brief 6001C, PROT register Safe Endinit*/
       __IO Ifx_EGTM_CL                         CL[3];                  /**< \brief 60020, Protection per cluster*/
       __I  Ifx_UReg_8Bit                       reserved_6008C[324];    /**< \brief 6008C, \internal Reserved */
       __IO Ifx_EGTM_CTRL                       CTRL;                   /**< \brief 601D0, Protection of UBS Registers*/
       __IO Ifx_EGTM_WRAP                       WRAP;                   /**< \brief 601F4, Protection of Wrapper Registers*/
       __I  Ifx_UReg_8Bit                       reserved_60218[488];    /**< \brief 60218, \internal Reserved */
       __IO Ifx_EGTM_SEGEN                      SEGEN;                  /**< \brief 60400, Error injection from eGTM wrapper slave interface*/
       __I  Ifx_UReg_8Bit                       reserved_60404[124];    /**< \brief 60404, \internal Reserved */
       __IO Ifx_EGTM_SPARE                      SPARE;                  /**< \brief 60480, Spare Bits*/
       __I  Ifx_UReg_8Bit                       reserved_60484[124];    /**< \brief 60484, \internal Reserved */
       __IO Ifx_EGTM_OCDS                       OCDS;                   /**< \brief 60500, Hardware breakpoint enable register*/
       __I  Ifx_UReg_8Bit                       reserved_60518[2792];    /**< \brief 60518, \internal Reserved */
       __IO Ifx_EGTM_TIMINSEL                   TIMINSEL[2];            /**< \brief 61000, TIM0 input selection register*/
       __I  Ifx_UReg_8Bit                       reserved_61008[248];    /**< \brief 61008, \internal Reserved */
       __IO Ifx_EGTM_TOUTSEL                    TOUTSEL[50];            /**< \brief 61100, eGTM to Ports signal TOUT output selection register 0*/
       __I  Ifx_UReg_8Bit                       reserved_611C8[312];    /**< \brief 611C8, \internal Reserved */
       __IO Ifx_EGTM_MSCSET                     MSCSET[4];              /**< \brief 61300, */
       __I  Ifx_UReg_8Bit                       reserved_61340[80];     /**< \brief 61340, \internal Reserved */
       __IO Ifx_EGTM_MSC                        MSC[4];                 /**< \brief 61390, */
       __I  Ifx_UReg_8Bit                       reserved_613D0[48];     /**< \brief 613D0, \internal Reserved */
       __IO Ifx_EGTM_PSI5                       PSI5;                   /**< \brief 61400, eGTM to PSI5 output trigger selection register*/
       __I  Ifx_UReg_8Bit                       reserved_61404[12];     /**< \brief 61404, \internal Reserved */
       __IO Ifx_EGTM_PSI5S                      PSI5S[2];               /**< \brief 61410, eGTM to PSI5-S0 output trigger selection register*/
       __I  Ifx_UReg_8Bit                       reserved_61418[8];      /**< \brief 61418, \internal Reserved */
       __IO Ifx_EGTM_LCDCDC                     LCDCDC;                 /**< \brief 61420, eGTM to LCDCDC output trigger selection register*/
       __I  Ifx_UReg_8Bit                       reserved_61424[92];     /**< \brief 61424, \internal Reserved */
       __IO Ifx_EGTM_CAN                        CAN[5];                 /**< \brief 61480, */
       __I  Ifx_UReg_8Bit                       reserved_614D0[48];     /**< \brief 614D0, \internal Reserved */
       __IO Ifx_EGTM_FOUTENC                    FOUTENC[4];             /**< \brief 61500, FOUT Selection for Encoder Interface 0*/
       __I  Ifx_UReg_8Bit                       reserved_61510[112];    /**< \brief 61510, \internal Reserved */
       __IO Ifx_EGTM_QSPI                       QSPI[8];                /**< \brief 61580, eGTM to QSPI0 output selection register*/
       __I  Ifx_UReg_8Bit                       reserved_615A0[96];     /**< \brief 615A0, \internal Reserved */
       __IO Ifx_EGTM_ASCLIN                     ASCLIN[28];             /**< \brief 61600, eGTM to ASCLIN0 output selection register*/
       __I  Ifx_UReg_8Bit                       reserved_61670[16];     /**< \brief 61670, \internal Reserved */
       __IO Ifx_EGTM_SENT                       SENT[2];                /**< \brief 61680, */
       __I  Ifx_UReg_8Bit                       reserved_61690[112];    /**< \brief 61690, \internal Reserved */
       __IO Ifx_EGTM_ADC                        ADC;                    /**< \brief 61700, */
       __I  Ifx_UReg_8Bit                       reserved_6170C[116];    /**< \brief 6170C, \internal Reserved */
       __IO Ifx_EGTM_DTMAUX                     DTMAUX[3];              /**< \brief 61780, */
       __I  Ifx_UReg_8Bit                       reserved_61798[104];    /**< \brief 61798, \internal Reserved */
       __IO Ifx_EGTM_HRPWMMUX                   HRPWMMUX[3];            /**< \brief 61800, HRPWM0 16:1 Channel MUX select*/
       __I  Ifx_UReg_8Bit                       reserved_6180C[500];    /**< \brief 6180C, \internal Reserved */
       __I  Ifx_UReg_8Bit                       reserved_61A00[4];      /**< \brief 61A00, HRPWM Test Register*/
       __I  Ifx_UReg_8Bit                       reserved_61A04[2556];    /**< \brief 61A04, \internal Reserved */
       __IO Ifx_EGTM_HRPWM                      HRPWM[3];               /**< \brief 62400, */
} Ifx_EGTM;

/** \}  */
/******************************************************************************/
/** \}  */

/******************************************************************************/
#if defined (_TASKING_)
#pragma restore
#endif
/******************************************************************************/

/******************************************************************************/

/******************************************************************************/

#endif /* IFXEGTM_REGDEF_H */
