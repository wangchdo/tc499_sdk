/**
 * \file IfxFlashCsrm.h
 * \brief FLASHCSRM  basic functionality
 * \ingroup IfxLld_FlashCsrm
 *
 * \version iLLD_2_0_1_2_19
 * \copyright Copyright (c) 2023 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 * \defgroup IfxLld_FlashCsrm_Std_Enumerations Enumerations
 * \ingroup IfxLld_FlashCsrm_Std
 * \defgroup IfxLld_FlashCsrm_Std_CommandSequence CommandSequence Functions
 * \ingroup IfxLld_FlashCsrm_Std
 * \defgroup IfxLld_FlashCsrm_Std_ErrorTracking Error Tracking Functions
 * \ingroup IfxLld_FlashCsrm_Std
 */

#ifndef IFXFLASHCSRM_H
#define IFXFLASHCSRM_H 1

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "_Impl/IfxFlashCsrm_cfg.h"
#include "_Impl/IfxFlash_cfg.h"
#include "Cpu/Std/IfxCpu_Intrinsics.h"
#include "_Utilities/Ifx_Assert.h"
#include "IfxDmu_reg.h"
#include "IfxFsi_reg.h"

/******************************************************************************/
/*--------------------------------Enumerations--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_FlashCsrm_Std_Enumerations
 * \{ */
/** \brief Enumeration describing the CSRM command interface error
 */
typedef enum
{
    IfxFlashCsrm_Error_address       = 0,  /**< \brief SRI bus address error */
    IfxFlashCsrm_Error_sequence      = 1,  /**< \brief Command Sequence error */
    IfxFlashCsrm_Error_protection    = 2,  /**< \brief Protection error */
    IfxFlashCsrm_Error_suspend       = 3,  /**< \brief Suspend error */
    IfxFlashCsrm_Error_abort         = 4,  /**< \brief Abort error */
    IfxFlashCsrm_Error_clear         = 5,  /**< \brief Clear error */
    IfxFlashCsrm_Error_programVerify = 6,  /**< \brief Program Verify error */
    IfxFlashCsrm_Error_eraseVerify   = 7,  /**< \brief Erase Verify error */
    IfxFlashCsrm_Error_operation     = 16, /**< \brief Operation error */
    IfxFlashCsrm_Error_original      = 17  /**< \brief Original error */
} IfxFlashCsrm_Error;

/** \brief Enumeration describing the status of an operation
 */
typedef enum
{
    IfxFlashCsrm_Status_success = 0,  /**< \brief operation successful */
    IfxFlashCsrm_Status_failure = 1   /**< \brief operation failed */
} IfxFlashCsrm_Status;

/** \} */

/** \addtogroup IfxLld_FlashCsrm_Std_CommandSequence
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Performs the "Clear Status" sequence. Operation and error flags are cleared.
 * \param flash selects the flash (PMU) module
 * \return None
 */
IFX_INLINE void IfxFlashCsrm_clearStatus(uint32 flash);

/** \brief Performs the sequence for entering program page mode
 * \param pageAddr pageAddr specifies the page being written - the command sequence will be varied accordingly
 * \return 0 on success, != 0 if invalid or not available page is selected
 *
 * Usage Example:
 * \code
 *
 * unsigned int pageAddr = IFXFLASHCSRM_DFLASH_START + page*IFXFLASHCSRM_DFLASH_PAGE_LENGTH;
 *
 * // enter page mode
 * IfxFlashCsrm_enterPageMode(pageAddr);
 *
 * \endcode
 * \see IfxFlashCsrm_writePage()
 *
 */
IFX_INLINE uint8 IfxFlashCsrm_enterPageMode(uint32 pageAddr);

/** \brief Performs the erase sequence for n  sectors in program or data flash
 * \param sectorAddr sector address
 * \param numSector the no.of sectors to be erased
 * \return None
 *
 * Usage Example:
 * \code
 *
 *  unsigned int sector_addr = IfxFlashCsrm_pFlashTableLog[sector].start;
 *  IfxFlashCsrm_clearStatus(0);
 *  IfxFlashCsrm_eraseMultipleSectors(sector_addr,2);
 *
 *  while(!IfxFlashCsrm_isRequestReceived()); // Wait until request acknowledged
 *  while(!IfxFlashCsrm_isRequestExecuted()); // Wait until request done
 *
 *   //Error Checks
 *   if(IfxFlashCsrm_isErrorDetected(IfxFlashCsrm_Error_sequence) || IfxFlashCsrm_isErrorDetected(IfxFlashCsrm_Error_protection) || \
 *    IfxFlashCsrm_isErrorDetected(IfxFlashCsrm_Error_programVerify) || IfxFlashCsrm_isErrorDetected(IfxFlashCsrm_Error_eraseVerify) || \
 *    IfxFlashCsrm_isErrorDetected(IfxFlashCsrm_Error_operation))
 *    {
 *     //Error handling
 *    }
 *    IfxFlashCsrm_clearStatus(0);
 *
 * \endcode
 *
 */
IFX_INLINE void IfxFlashCsrm_eraseMultipleSectors(uint32 sectorAddr, uint32 numSector);

/** \brief Performs the erase sequence for a sector in program or data flash.
 * \param sectorAddr sector address
 * \return None
 *
 * Usage Example:
 *  \code
 *
 *   unsigned int sector_addr = IfxFlashCsrm_pFlashTableLog[sector].start;
 *   IfxFlashCsrm_clearStatus(0);
 *   IfxFlashCsrm_eraseSector(sector_addr);
 *
 *   while(!IfxFlashCsrm_isRequestReceived()); // Wait until request acknowledged
 *   while(!IfxFlashCsrm_isRequestExecuted()); // Wait until request done
 *
 *    //Error Checks
 *    if(IfxFlashCsrm_isErrorDetected(IfxFlashCsrm_Error_sequence) || IfxFlashCsrm_isErrorDetected(IfxFlashCsrm_Error_protection) || \
 *     IfxFlashCsrm_isErrorDetected(IfxFlashCsrm_Error_programVerify) || IfxFlashCsrm_isErrorDetected(IfxFlashCsrm_Error_eraseVerify) || \
 *     IfxFlashCsrm_isErrorDetected(IfxFlashCsrm_Error_operation))
 *     {
 *      //Error handling
 *     }
 *     IfxFlashCsrm_clearStatus(0);
 *
 *  \endcode
 *
 */
IFX_INLINE void IfxFlashCsrm_eraseSector(uint32 sectorAddr);

/** \brief Performs the "Erase Verify" sequence for multiple sectors
 * \param sectorAddr sector address which should be verified
 * \param numSector no.of sectors to be operated on
 * \return None
 */
IFX_INLINE void IfxFlashCsrm_eraseVerifyMultipleSectors(uint32 sectorAddr, uint32 numSector);

/** \brief Performs the "Erase Verify" sequence
 * \param sectorAddr sector address which should be verified
 * \return None
 */
IFX_INLINE void IfxFlashCsrm_eraseVerifySector(uint32 sectorAddr);

/** \brief performs a load page sequence with a single 64bit access
 * \param pageAddr pageAddr start address of page which should be programmed
 * \param wordL Lower Address word
 * \param wordU Upper address word
 * \return None
 *
 * Usage Example:
 * \code
 *
 * // load 64bit into assembly buffer of program flash
 * IfxFlashCsrm_loadPage(IFXFLASHCSRM_PFLASH_START, 0x55555555, 0xaaaaaaaa);
 *
 * // load 64bit into assembly buffer of data flash
 * IfxFlashCsrm_loadPage(0XAF000000, 0x55555555, 0xaaaaaaaa);
 * \endcode
 * \see IfxFlashCsrm_writePage()
 *
 */
IFX_INLINE void IfxFlashCsrm_loadPage(uint32 pageAddr, uint32 wordL, uint32 wordU);

/** \brief performs a load page sequence with two 32bit accesses
 * \param pageAddr pageAddr start address of page which should be programmed
 * \param wordL Lower Address word
 * \param wordU Upper Address word
 * \return None
 *
 * Usage Example:
 * \code
 *
 * // load 2*32bit into assembly buffer of program flash
 * IfxFlashCsrm_loadPage2X32(IFXFLASHCSRM_PFLASH_START, 0x55555555, 0xaaaaaaaa);
 *
 * // load 2*32bit into assembly buffer of data flash
 * IfxFlashCsrm_loadPage2X32(0XAF000000, 0x55555555, 0xaaaaaaaa);
 * \endcode
 * \see IfxFlashCsrm_writePage()
 *
 */
IFX_INLINE void IfxFlashCsrm_loadPage2X32(uint32 pageAddr, uint32 wordL, uint32 wordU);

/** \brief reset to read mode
 * \param flash flash selects the flash (PMU) module
 * \return None
 *
 * Usage Example:
 * \code
 *
 * // reset to read mode
 *  IfxFlashCsrm_resetToRead(0);
 *
 * \endcode
 *
 */
IFX_INLINE void IfxFlashCsrm_resetToRead(uint32 flash);

/** \brief Performs the "Resume Protection" sequence
 * This command clears all DMU_GP_CSRM_PROTECT and enables again the Flash protection as it was configured.
 * \param flash selects the flash (PMU) module
 * \return None
 */
IFX_INLINE void IfxFlashCsrm_resumeProtection(uint32 flash);

/** \brief Performs the "Suspend Resume" sequence for multiple sectors
 * A suspended command may be resumed. The arguments sectorAddr of the Resume NVM operation must be
 * identical to the arguments of the suspended command
 * \param sectorAddr sector address
 * \param numSector the no.of sectors  to be operated on
 * \return None
 */
IFX_INLINE void IfxFlashCsrm_suspendResumeMultipleSectors(uint32 sectorAddr, uint32 numSector);

/** \brief Performs the "Suspend Resume" sequence
 * A suspended command may be resumed. The arguments sectorAddr of the Resume NVM operation must be
 * identical to the arguments of the suspended command
 * \param sectorAddr sector address which should be resumed
 * \return None
 */
IFX_INLINE void IfxFlashCsrm_suspendResumeSector(uint32 sectorAddr);

/** \brief The function issues command sequence for User Content count.The result of this function is dependent on the difference of the number of logic 1 bits in the selected pages at the  erase-verify condition (N_dv) and at the selected control gate voltage (N_pv). Calling this function with different control gate voltages allows calculation of the Vth distribution
 * \param wordAddr word address
 * \return None
 */
IFX_INLINE void IfxFlashCsrm_userContentCount(uint32 wordAddr);

/** \brief The function issues command sequence for User Margin Count. The result of this function is the number of logic 1 bits in the selected pages at the selected reference current. Calling this function with different reference currents allows calculation of the cell current distribution.
 * \param wordAddr word address
 * \return None
 */
IFX_INLINE void IfxFlashCsrm_userMarginCount(uint32 wordAddr);

/** \brief The function issues command sequence for User Vth Count.The result of this function is the number of logic 1 bits in the selected pages at the selected control gate voltage. Calling this function with different control gate voltages allows calculation of the Vth distribution.
 * \param wordAddr word address
 * \return None
 */
IFX_INLINE void IfxFlashCsrm_userVthCount(uint32 wordAddr);

/** \brief Performs the "Verify Erased Block (page)" sequence. This command verifies if one page addressed by "PA" is correctly erased, i.e. contain 0 data and ECC bits
 * \param pageAddr page address which should be verified
 * \return None
 *
 * Usage Example:
 *
 *  \code
 *
 *  uint32 pageAddr = IFXFLASHCSRM_DFLASH_START;
 *  IfxFlashCsrm_verifyErasedPage(pageAddr);
 *
 *  while(!IfxFlashCsrm_isRequestReceived()); // Wait until request acknowledged
 *  while(!IfxFlashCsrm_isRequestExecuted()); // Wait until request done
 *
 *   if(IfxFlashCsrm_isErrorDetected(IfxFlashCsrm_Error_eraseVerify) || IfxFlashCsrm_isErrorDetected(IfxFlashCsrm_Error_sequence))
 *  {
 *    //Error handling
 *  }
 *  IfxFlashCsrm_clearStatus(0);
 *  \endcode
 *
 *  \see IfxFlashCsrm_eraseSector()
 *
 */
IFX_INLINE void IfxFlashCsrm_verifyErasedPage(uint32 pageAddr);

/** \brief Performs the "Verify Erased WL" sequence.This command verifies if one word line addressed by "WA" is correctly erased, i.e. contain 0 data and ECC bits
 * \param wordLineAddr word line address which should be verified
 * \return None
 *
 * Usage Example:
 *
 *  \code
 *
 *  uint32 wdlineAddr = IFXFLASHCSRM_DFLASH_START;
 *  IfxFlashCsrm_verifyErasedWordLine(wdlineAddr);
 *
 *  while(!IfxFlashCsrm_isRequestReceived()); // Wait until request acknowledged
 *  while(!IfxFlashCsrm_isRequestExecuted()); // Wait until request done
 *
 *   if(IfxFlashCsrm_isErrorDetected(IfxFlashCsrm_Error_eraseVerify) || IfxFlashCsrm_isErrorDetected(IfxFlashCsrm_Error_sequence))
 *  {
 *    //Error handling
 *  }
 *  IfxFlashCsrm_clearStatus(0);
 *  \endcode
 *
 *  \see IfxFlashCsrm_eraseSector()
 *
 */
IFX_INLINE void IfxFlashCsrm_verifyErasedWordLine(uint32 wordLineAddr);

/** \brief Performs the "Write Burst" sequence, similar to write page but performs a burst transfer instead of page.Make sure the appropriate amount of data is loaded using load page command
 * \param pageAddr start address of page which should be programmed
 * \return None
 *
 * Usage Example:
 *  \code
 *    unsigned int pageAddr = IFXFLASHCSRM_DFLASH_START + page*IFXFLASHCSRM_DFLASH_PAGE_LENGTH;
 *    boolean pageStatus;
 *      //Clear status commands to clear flags
 *      IfxFlashCsrm_clearStatus(0);
 *      //Enter Page Mode
 *      IfxFlashCsrm_enterPageMode(pageAddr);
 *      do
 *      {
 *          pageStatus = IfxFlashCsrm_isDflashInPageMode();
 *      }while(pageStatus != TRUE);
 *
 *      if(IfxFlashCsrm_isErrorDetected(IfxFlashCsrm_Error_sequence) || IfxFlashCsrm_isErrorDetected(IfxFlashCsrm_Error_protection))
 *   {
 *   }
 *      // Repeat load page util page filled
 *       for(uint8 index =0; index < 4; index+=2)
 *   {
 *     IfxFlashCsrm_loadPage(pageAddr, (index), (index+1));
 *   }
 *
 *      //Write Page
 *      IfxFlashCsrm_clearStatus(0);
 *      IfxFlashCsrm_writeBurst(pageAddr);
 *
 *   while(!IfxFlashCsrm_isRequestReceived()); // Wait until request acknowledged
 *   while(!IfxFlashCsrm_isRequestExecuted()); // Wait until request done
 *
 *   //Error Checks
 *    if(IfxFlashCsrm_isErrorDetected(IfxFlashCsrm_Error_sequence) || IfxFlashCsrm_isErrorDetected(IfxFlashCsrm_Error_protection) || \
 *     IfxFlashCsrm_isErrorDetected(IfxFlashCsrm_Error_operation) || IfxFlashCsrm_isErrorDetected(IfxFlashCsrm_Error_programVerify))
 *     {
 *      //Error handling
 *     }
 *     IfxFlashCsrm_clearStatus(0);
 *  \endcode
 *
 */
IFX_INLINE void IfxFlashCsrm_writeBurst(uint32 pageAddr);

/** \brief Performs the "Write Burst once" sequence. The command starts the programming process for an aligned group of pages as the normal "Write Burst" does. But before programming it checks if the pages are erased. If the page is not erased (allowing correctable errors) the command fails with PVER and EVER.
 * The command is only supported for PFlash. On sectors with "write-once" protection only this write command can be applied.
 * \param pageAddr start address of page which should be programmed
 * \return None
 *
 * Usage Example:
 * \code
 *
 * // program the second page of the first sector of the Program Flash
 * IfxFlashCsrm_writeBurstOnce(0xa0000100);
 *
 * \endcode
 * \see IfxFlashCsrm_writeBurst()
 *
 */
IFX_INLINE void IfxFlashCsrm_writeBurstOnce(uint32 pageAddr);

/** \brief Performs the "Write Page" sequence
 * \param pageAddr start address of page which should be programmed
 * \return None
 *
 * Usage Example:
 *  \code
 *    unsigned int pageAddr = IFXFLASHCSRM_DFLASH_START + page*IFXFLASHCSRM_DFLASH_PAGE_LENGTH;
 *    boolean pageStatus;
 *      //Clear status commands to clear flags
 *      IfxFlashCsrm_clearStatus(0);
 *      //Enter Page Mode
 *      IfxFlashCsrm_enterPageMode(pageAddr);
 *      do
 *      {
 *          pageStatus = IfxFlashCsrm_isDflashInPageMode();
 *      }while(pageStatus != TRUE);
 *
 *      if(IfxFlashCsrm_isErrorDetected(IfxFlashCsrm_Error_sequenceError) || IfxFlashCsrm_isErrorDetected(IfxFlashCsrm_Error_protectionError))
 *   {
 *   }
 *      // Repeat load page util page filled
 *   IfxFlashCsrm_loadPage(pageAddr, 0x55555555, 0xaaaaaaaa);
 *
 *      //Write Page
 *      IfxFlashCsrm_clearStatus(0);
 *      IfxFlashCsrm_writePage(pageAddr);
 *
 *   while(!IfxFlashCsrm_isRequestReceived()); // Wait until request acknowledged
 *   while(!IfxFlashCsrm_isRequestExecuted()); // Wait until request done
 *
 *   //Error Checks
 *    if(IfxFlashCsrm_isErrorDetected(IfxFlashCsrm_Error_sequence) || IfxFlashCsrm_isErrorDetected(IfxFlashCsrm_Error_protection) || \
 *     IfxFlashCsrm_isErrorDetected(IfxFlashCsrm_Error_operation) || IfxFlashCsrm_isErrorDetected(IfxFlashCsrm_Error_programVerify))
 *     {
 *      //Error handling
 *     }
 *     IfxFlashCsrm_clearStatus(0);
 *  \endcode
 *
 */
IFX_INLINE void IfxFlashCsrm_writePage(uint32 pageAddr);

/** \brief Performs the "Write Page Once" sequence, similar to write page but performs a program verify after writing.
 * \param pageAddr start address of page which should be programmed
 * \return None
 *
 * Usage Example:
 *  \code
 *    unsigned int pageAddr = IFXFLASHCSRM_DFLASH_START + page*IFXFLASHCSRM_DFLASH_PAGE_LENGTH;
 *    boolean pageStatus;
 *      //Clear status commands to clear flags
 *      IfxFlashCsrm_clearStatus(0);
 *      //Enter Page Mode
 *      IfxFlashCsrm_enterPageMode(pageAddr);
 *      do
 *      {
 *          pageStatus = IfxFlashCsrm_isDflashInPageMode();
 *      }while(pageStatus != TRUE);
 *
 *      if(IfxFlashCsrm_isErrorDetected(IfxFlashCsrm_Error_sequenceError) || IfxFlashCsrm_isErrorDetected(IfxFlashCsrm_Error_protectionError))
 *   {
 *   }
 *      // Repeat load page util page filled
 *   IfxFlashCsrm_loadPage(pageAddr, 0x55555555, 0xaaaaaaaa);
 *
 *      //Write Page
 *      IfxFlashCsrm_clearStatus(0);
 *      IfxFlashCsrm_writePageOnce(pageAddr);
 *
 *   while(!IfxFlashCsrm_isRequestReceived()); // Wait until request acknowledged
 *   while(!IfxFlashCsrm_isRequestExecuted()); // Wait until request done
 *
 *   //Error Checks
 *    if(IfxFlashCsrm_isErrorDetected(IfxFlashCsrm_Error_sequence) || IfxFlashCsrm_isErrorDetected(IfxFlashCsrm_Error_protection) || \
 *     IfxFlashCsrm_isErrorDetected(IfxFlashCsrm_Error_operation) || IfxFlashCsrm_isErrorDetected(IfxFlashCsrm_Error_programVerify))
 *     {
 *      //Error handling
 *     }
 *     IfxFlashCsrm_clearStatus(0);
 *
 *  \endcode
 *
 */
IFX_INLINE void IfxFlashCsrm_writePageOnce(uint32 pageAddr);

/** \brief Function performs Replace Logical Sector operation that enables the replacement of a logical sector with hard fails with an available redundant logical sector. It can be used if a sector fails during an erase or program.
 * The number of available free redundant sectors can be retrieved by using the Count Free Redundant Sectors command
 * \param pageAddr start address of page which should be programmed
 * \return None
 */
IFX_INLINE void IfxFlashCsrm_replaceLogicalSector(uint32 pageAddr);

/** \brief Function returns the number of free redundant sectors in a Bank.
 * \param flashType selects the flash type
 * \return Number of free redundant sector.
 */
IFX_INLINE uint8 IfxFlashCsrm_countFreeRedundantSector(IfxFlashCsrm_FlashType flashType);

/** \brief Function set the banks or subset of bank to sleep state.
 * The command interface can only set to sleep those banks which are allocated to the command channel.
 * If all banks of both command interfaces are set to sleep then the NVM will enter a deep sleep state.
 * \param bankselect Bansk selection
 * \return None
 *
 * Usage Example:
 *  \code
 *  uint32 bankSel = 0u;
 *  //CSRM DFlash selected to go to sleep state
 *  bankSel = (1u << IfxFlashCsrm_FlashType_DCsrm);
 *  IfxFlashCsrm_sleepBank(bankSel);
 *  if(IfxFlashCsrm_isErrorDetected(IfxFlashCsrm_Error_sequence))
 *   {
 *     //Error handling
 *   }
 *  \endcode
 *
 */
IFX_INLINE void IfxFlashCsrm_sleepBank(uint32 bankselect);

/** \brief Function to wakeup the banks or subset of banks.
 * The command interface can only wakeup those banks which are allocated to the command channel.
 * \param bankselect Bank selection.
 * \return None
 *
 * Usage Example:
 *  \code
 *  uint32 bankSel = 0u;
 *  //CSRM DFlash selected to go to sleep state
 *  bankSel = (1u << IfxFlashCsrm_FlashType_DCsrm);
 *  IfxFlashCsrm_wakeupBank(bankSel);
 *  if(IfxFlashCsrm_isErrorDetected(IfxFlashCsrm_Error_sequence))
 *   {
 *     //Error handling
 *   }
 *  \endcode
 *
 */
IFX_INLINE void IfxFlashCsrm_wakeupBank(uint32 bankselect);

/** \brief Function to move the banks to other command interface.It is only possible to move all PFLASH HOST banks together but not a subset of it.
 * A command interface can only move those banks to other command interface which belong to the interface executing move command.
 * Security banks cannot be moved
 * \param bankselect Bank selection.
 * 0000 0FFF --> all HOST PFLASH banks selected
 * 0001 0000 --> HOST DFLash bank selected
 * 0001 0FFF --> HOST PFLASH bank and HOST DFLASH selected
 * \return None
 *
 * Usage Example:
 *  \code
 *   //Asumption DMU command interface mode is CSRM_ALL_PFLASH mode.
 *   //CSRM_ALL_PFLASH --> CSRM PFLASH, CSRM DFLASH and HOST PFLASH allocated to CSRM command interface
 *
 *  uint32 bankSel = 0u;
 *  //All host pflash bank(0x0FFF)
 *  bankSel = 0x0FFF;
 *  IfxFlashCsrm_reallocateBank(bankSel);
 *  if(IfxFlashCsrm_isErrorDetected(IfxFlashCsrm_Error_sequence) || IfxFlashCsrm_isErrorDetected(IfxFlashCsrm_Error_protection))
 *   {
 *     //Error handling
 *   }
 *   //Reallocation of the memory can be confirmed using MODULE_DMU.GP.BKALLOC.U
 *  \endcode
 *
 */
IFX_INLINE void IfxFlashCsrm_reallocateBank(uint32 bankselect);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief The password protection of the selected UCB (if this UCB offers this feature) is temporarily disabled. The command fails by setting PROER when any of the supplied PWs does not match. In this case until the next application reset all further calls of "Disable Protection" fail with PROER independent of the supplied password.
 * \param flash selects the flash (PMU) module
 * \param ucb selects the user configuration block (0 for UCB0, 1 for UCB1, 5 for UCB_HSMC)
 * \param password password pointer to an array of 8 words
 * \return None
 */
IFX_EXTERN void IfxFlashCsrm_disableWriteProtection(uint32 flash, IfxFlashCsrm_UcbType ucb, uint32 *password);

/** \} */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Polls the selected status flag in flash status register until it turns to 0
 * \param flash selects the flash (PMU) module
 * \param flashType selects the flash type
 * \return 0 on success, != 0 if invalid or not available page is selected
 *
 * Usage Example:
 * \code
 *
 * // wait until data flash 0 is unbusy
 *  IfxFlashCsrm_waitUnbusy(0, IfxFlash_FlashType_D0);
 *
 * \endcode
 *
 */
IFX_INLINE uint8 IfxFlashCsrm_waitUnbusy(uint32 flash, IfxFlashCsrm_FlashType flashType);

/** \brief Function to check if bank is allocated to Host command interface or Csrm command interface
 * \param flash Flash bank selection
 * \return Return
 * IfxFlashCsrm_Status_failure - Flash not allocated to CSRM
 * IfxFlashCsrm_Status_success - Flash allocated to CSRM
 */
IFX_INLINE IfxFlashCsrm_Status IfxFlashCsrm_isBankAllocatedToCsrm(IfxFlashCsrm_FlashType flash);

/** \brief Function to get flash bank from address.
 * \param address Address of PFLASH/DFLASH
 * \return Return bank to which the given address belongs.
 */
IFX_INLINE IfxFlashCsrm_FlashType IfxFlashCsrm_getBankFromAddress(uint32 address);

/** \brief Function to check if address provided belongs to bank allocated to CSRM command interface.
 * \param pageAddr Address of PFLASH/DFLASH
 * \return Return
 * IfxFlashCsrm_Status_failure - Flash allocated to host
 * IfxFlashCsrm_Status_success - Flash allocated to Csrm
 */
IFX_INLINE IfxFlashCsrm_Status IfxFlashCsrm_isAddressBelongToCsrmBank(uint32 pageAddr);

/** \brief Function to check if CSRM Pflash in page mode
 * \return True --> CSRM Pflash in page mode
 * False --> CSRM Pflash not in page mode
 */
IFX_INLINE boolean IfxFlashCsrm_isPflashInPageMode(void);

/** \brief Function to check if CSRM Dflash in page mode
 * \return True --> CSRM Dflash in page mode
 * False --> CSRM Dflash not in page mode
 */
IFX_INLINE boolean IfxFlashCsrm_isDflashInPageMode(void);

/** \brief Function to check if requested csrm command interface error detected
 * \param error Error type
 * \return True --> Requested error was detected
 * False --> Requested error was not detected
 */
IFX_INLINE boolean IfxFlashCsrm_isErrorDetected(IfxFlashCsrm_Error error);

/** \brief Function to check if command sequence request received
 * \return True --> Request received
 *  False --> No request received
 */
IFX_INLINE boolean IfxFlashCsrm_isRequestReceived(void);

/** \brief Function to check if requested command sequence executed.
 * \return True --> Request execution done
 *  False --> No request executed
 */
IFX_INLINE boolean IfxFlashCsrm_isRequestExecuted(void);

/** \brief Function to get error's occured during execution of NVM operation.
 * \return Returns error status
 */
IFX_INLINE uint32 IfxFlashCsrm_getCommandInterfaceError(void);

/******************************************************************************/
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE void IfxFlashCsrm_clearStatus(uint32 flash)
{
    IFX_UNUSED_PARAMETER(flash);
    volatile uint32 *addr1 = (volatile uint32 *)(IFXFLASHCSRM_CMD_BASE_ADDRESS | 0x5554);

    *addr1 = 0xFA;

    __dsync();
}


IFX_INLINE uint8 IfxFlashCsrm_enterPageMode(uint32 pageAddr)
{
    volatile uint32 *addr1 = (volatile uint32 *)(IFXFLASHCSRM_CMD_BASE_ADDRESS | 0x5554);

    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (IfxFlashCsrm_isAddressBelongToCsrmBank(pageAddr) == IfxFlashCsrm_Status_success));

    if (((pageAddr >= IFXFLASHCSRM_PFLASH_START) && (pageAddr <= IFXFLASHCSRM_PFLASH_END)) || \
        ((pageAddr >= IFXFLASH_PFLASH_P00_START) && (pageAddr <= IFXFLASH_PFLASH_P51_END)))   // program flash
    {
        *addr1 = 0x50;
        return 0;
    }
    else if (((pageAddr >= IFXFLASHCSRM_DFLASH_START) && (pageAddr <= IFXFLASHCSRM_DFLASH_END)) || \
             ((pageAddr >= IFXFLASHCSRM_UCB1_START) && (pageAddr <= IFXFLASHCSRM_UCB1_END)) ||     \
             ((pageAddr >= IFXFLASH_DFLASH_START) && (pageAddr <= IFXFLASH_DFLASH_END)) ||         \
             ((pageAddr >= IFXFLASH_UCB0_START) && (pageAddr <= IFXFLASH_UCB0_END))) // data flash
    {
        *addr1 = 0x5D;
        return 0;
    }

    __dsync();

    return 1; // invalid flash address
}


IFX_INLINE void IfxFlashCsrm_eraseMultipleSectors(uint32 sectorAddr, uint32 numSector)
{
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (IfxFlashCsrm_isAddressBelongToCsrmBank(sectorAddr) == IfxFlashCsrm_Status_success));

    volatile uint32 *addr1 = (volatile uint32 *)(IFXFLASHCSRM_CMD_BASE_ADDRESS | 0xaa50);
    volatile uint32 *addr2 = (volatile uint32 *)(IFXFLASHCSRM_CMD_BASE_ADDRESS | 0xaa58);
    volatile uint32 *addr3 = (volatile uint32 *)(IFXFLASHCSRM_CMD_BASE_ADDRESS | 0xaaa8);
    volatile uint32 *addr4 = (volatile uint32 *)(IFXFLASHCSRM_CMD_BASE_ADDRESS | 0xaaa8);

    *addr1 = sectorAddr;
    *addr2 = numSector;
    *addr3 = 0x80;
    *addr4 = 0x50;

    __dsync();
}


IFX_INLINE void IfxFlashCsrm_eraseSector(uint32 sectorAddr)
{
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (IfxFlashCsrm_isAddressBelongToCsrmBank(sectorAddr) == IfxFlashCsrm_Status_success));

    volatile uint32 *addr1 = (volatile uint32 *)(IFXFLASHCSRM_CMD_BASE_ADDRESS | 0xaa50);
    volatile uint32 *addr2 = (volatile uint32 *)(IFXFLASHCSRM_CMD_BASE_ADDRESS | 0xaa58);
    volatile uint32 *addr3 = (volatile uint32 *)(IFXFLASHCSRM_CMD_BASE_ADDRESS | 0xaaa8);
    volatile uint32 *addr4 = (volatile uint32 *)(IFXFLASHCSRM_CMD_BASE_ADDRESS | 0xaaa8);

    *addr1 = sectorAddr;
    *addr2 = 1;
    *addr3 = 0x80;
    *addr4 = 0x50;

    __dsync();
}


IFX_INLINE void IfxFlashCsrm_eraseVerifyMultipleSectors(uint32 sectorAddr, uint32 numSector)
{
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (IfxFlashCsrm_isAddressBelongToCsrmBank(sectorAddr) == IfxFlashCsrm_Status_success));

    volatile uint32 *addr1 = (volatile uint32 *)(IFXFLASHCSRM_CMD_BASE_ADDRESS | 0xaa50);
    volatile uint32 *addr2 = (volatile uint32 *)(IFXFLASHCSRM_CMD_BASE_ADDRESS | 0xaa58);
    volatile uint32 *addr3 = (volatile uint32 *)(IFXFLASHCSRM_CMD_BASE_ADDRESS | 0xaaa8);
    volatile uint32 *addr4 = (volatile uint32 *)(IFXFLASHCSRM_CMD_BASE_ADDRESS | 0xaaa8);

    *addr1 = sectorAddr;
    *addr2 = numSector;
    *addr3 = 0x80;
    *addr4 = 0x5F;

    __dsync();
}


IFX_INLINE void IfxFlashCsrm_eraseVerifySector(uint32 sectorAddr)
{
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (IfxFlashCsrm_isAddressBelongToCsrmBank(sectorAddr) == IfxFlashCsrm_Status_success));

    volatile uint32 *addr1 = (volatile uint32 *)(IFXFLASHCSRM_CMD_BASE_ADDRESS | 0xaa50);
    volatile uint32 *addr2 = (volatile uint32 *)(IFXFLASHCSRM_CMD_BASE_ADDRESS | 0xaa58);
    volatile uint32 *addr3 = (volatile uint32 *)(IFXFLASHCSRM_CMD_BASE_ADDRESS | 0xaaa8);
    volatile uint32 *addr4 = (volatile uint32 *)(IFXFLASHCSRM_CMD_BASE_ADDRESS | 0xaaa8);

    *addr1 = sectorAddr;
    *addr2 = 1;
    *addr3 = 0x80;
    *addr4 = 0x5F;

    __dsync();
}


IFX_INLINE void IfxFlashCsrm_loadPage(uint32 pageAddr, uint32 wordL, uint32 wordU)
{
    IFX_UNUSED_PARAMETER(pageAddr);
    uint64 *addr1 = (uint64 *)(IFXFLASHCSRM_CMD_BASE_ADDRESS | 0x55f0);

    __st64_lu(addr1, wordL, wordU);

    __dsync();
}


IFX_INLINE void IfxFlashCsrm_loadPage2X32(uint32 pageAddr, uint32 wordL, uint32 wordU)
{
    IFX_UNUSED_PARAMETER(pageAddr);

    volatile uint32 *addr1 = (volatile uint32 *)(IFXFLASHCSRM_CMD_BASE_ADDRESS | 0x55f4);

    *addr1 = wordL;
    *addr1 = wordU;

    __dsync();
}


IFX_INLINE void IfxFlashCsrm_resetToRead(uint32 flash)
{
    IFX_UNUSED_PARAMETER(flash);
    volatile uint32 *addr1 = (volatile uint32 *)(IFXFLASHCSRM_CMD_BASE_ADDRESS | 0x5554);
    *addr1 = 0xf0;

    __dsync();
}


IFX_INLINE void IfxFlashCsrm_resumeProtection(uint32 flash)
{
    IFX_UNUSED_PARAMETER(flash);

    volatile uint32 *addr1 = (volatile uint32 *)(IFXFLASHCSRM_CMD_BASE_ADDRESS | 0x5554);

    *addr1 = 0xF5;

    __dsync();
}


IFX_INLINE void IfxFlashCsrm_suspendResumeMultipleSectors(uint32 sectorAddr, uint32 numSector)
{
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (IfxFlashCsrm_isAddressBelongToCsrmBank(sectorAddr) == IfxFlashCsrm_Status_success));

    volatile uint32 *addr1 = (volatile uint32 *)(IFXFLASHCSRM_CMD_BASE_ADDRESS | 0xaa50);
    volatile uint32 *addr2 = (volatile uint32 *)(IFXFLASHCSRM_CMD_BASE_ADDRESS | 0xaa58);
    volatile uint32 *addr3 = (volatile uint32 *)(IFXFLASHCSRM_CMD_BASE_ADDRESS | 0xaaa8);
    volatile uint32 *addr4 = (volatile uint32 *)(IFXFLASHCSRM_CMD_BASE_ADDRESS | 0xaaa8);

    *addr1 = sectorAddr;
    *addr2 = numSector;
    *addr3 = 0x70;
    *addr4 = 0xCC;

    __dsync();
}


IFX_INLINE void IfxFlashCsrm_suspendResumeSector(uint32 sectorAddr)
{
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (IfxFlashCsrm_isAddressBelongToCsrmBank(sectorAddr) == IfxFlashCsrm_Status_success));

    volatile uint32 *addr1 = (volatile uint32 *)(IFXFLASHCSRM_CMD_BASE_ADDRESS | 0xaa50);
    volatile uint32 *addr2 = (volatile uint32 *)(IFXFLASHCSRM_CMD_BASE_ADDRESS | 0xaa58);
    volatile uint32 *addr3 = (volatile uint32 *)(IFXFLASHCSRM_CMD_BASE_ADDRESS | 0xaaa8);
    volatile uint32 *addr4 = (volatile uint32 *)(IFXFLASHCSRM_CMD_BASE_ADDRESS | 0xaaa8);

    *addr1 = sectorAddr;
    *addr2 = 1;
    *addr3 = 0x70;
    *addr4 = 0xCC;

    __dsync();
}


IFX_INLINE void IfxFlashCsrm_userContentCount(uint32 wordAddr)
{
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (IfxFlashCsrm_isAddressBelongToCsrmBank(wordAddr) == IfxFlashCsrm_Status_success));

    volatile uint32 *addr1 = (volatile uint32 *)(IFXFLASHCSRM_CMD_BASE_ADDRESS | 0xaa50);
    volatile uint32 *addr2 = (volatile uint32 *)(IFXFLASHCSRM_CMD_BASE_ADDRESS | 0xaa58);
    volatile uint32 *addr3 = (volatile uint32 *)(IFXFLASHCSRM_CMD_BASE_ADDRESS | 0xaaa8);
    volatile uint32 *addr4 = (volatile uint32 *)(IFXFLASHCSRM_CMD_BASE_ADDRESS | 0xaaa8);

    *addr1 = wordAddr;
    *addr2 = 0x00;
    *addr3 = 0x60;
    *addr4 = 0x14;

    __dsync();
}


IFX_INLINE void IfxFlashCsrm_userMarginCount(uint32 wordAddr)
{
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (IfxFlashCsrm_isAddressBelongToCsrmBank(wordAddr) == IfxFlashCsrm_Status_success));

    volatile uint32 *addr1 = (volatile uint32 *)(IFXFLASHCSRM_CMD_BASE_ADDRESS | 0xaa50);
    volatile uint32 *addr2 = (volatile uint32 *)(IFXFLASHCSRM_CMD_BASE_ADDRESS | 0xaa58);
    volatile uint32 *addr3 = (volatile uint32 *)(IFXFLASHCSRM_CMD_BASE_ADDRESS | 0xaaa8);
    volatile uint32 *addr4 = (volatile uint32 *)(IFXFLASHCSRM_CMD_BASE_ADDRESS | 0xaaa8);

    *addr1 = wordAddr;
    *addr2 = 0x00;
    *addr3 = 0x60;
    *addr4 = 0x11;

    __dsync();
}


IFX_INLINE void IfxFlashCsrm_userVthCount(uint32 wordAddr)
{
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (IfxFlashCsrm_isAddressBelongToCsrmBank(wordAddr) == IfxFlashCsrm_Status_success));

    volatile uint32 *addr1 = (volatile uint32 *)(IFXFLASHCSRM_CMD_BASE_ADDRESS | 0xaa50);
    volatile uint32 *addr2 = (volatile uint32 *)(IFXFLASHCSRM_CMD_BASE_ADDRESS | 0xaa58);
    volatile uint32 *addr3 = (volatile uint32 *)(IFXFLASHCSRM_CMD_BASE_ADDRESS | 0xaaa8);
    volatile uint32 *addr4 = (volatile uint32 *)(IFXFLASHCSRM_CMD_BASE_ADDRESS | 0xaaa8);

    *addr1 = wordAddr;
    *addr2 = 0x00;
    *addr3 = 0x60;
    *addr4 = 0x12;

    __dsync();
}


IFX_INLINE void IfxFlashCsrm_verifyErasedPage(uint32 pageAddr)
{
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (IfxFlashCsrm_isAddressBelongToCsrmBank(pageAddr) == IfxFlashCsrm_Status_success));

    volatile uint32 *addr1 = (volatile uint32 *)(IFXFLASHCSRM_CMD_BASE_ADDRESS | 0xaa50);
    volatile uint32 *addr2 = (volatile uint32 *)(IFXFLASHCSRM_CMD_BASE_ADDRESS | 0xaa58);
    volatile uint32 *addr3 = (volatile uint32 *)(IFXFLASHCSRM_CMD_BASE_ADDRESS | 0xaaa8);
    volatile uint32 *addr4 = (volatile uint32 *)(IFXFLASHCSRM_CMD_BASE_ADDRESS | 0xaaa8);

    *addr1 = pageAddr;
    *addr2 = 00;
    *addr3 = 0x80;
    *addr4 = 0x56;

    __dsync();
}


IFX_INLINE void IfxFlashCsrm_verifyErasedWordLine(uint32 wordLineAddr)
{
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (IfxFlashCsrm_isAddressBelongToCsrmBank(wordLineAddr) == IfxFlashCsrm_Status_success));

    volatile uint32 *addr1 = (volatile uint32 *)(IFXFLASHCSRM_CMD_BASE_ADDRESS | 0xaa50);
    volatile uint32 *addr2 = (volatile uint32 *)(IFXFLASHCSRM_CMD_BASE_ADDRESS | 0xaa58);
    volatile uint32 *addr3 = (volatile uint32 *)(IFXFLASHCSRM_CMD_BASE_ADDRESS | 0xaaa8);
    volatile uint32 *addr4 = (volatile uint32 *)(IFXFLASHCSRM_CMD_BASE_ADDRESS | 0xaaa8);

    *addr1 = wordLineAddr;
    *addr2 = 00;
    *addr3 = 0x80;
    *addr4 = 0x58;

    __dsync();
}


IFX_INLINE void IfxFlashCsrm_writeBurst(uint32 pageAddr)
{
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (IfxFlashCsrm_isAddressBelongToCsrmBank(pageAddr) == IfxFlashCsrm_Status_success));

    volatile uint32 *addr1 = (volatile uint32 *)(IFXFLASHCSRM_CMD_BASE_ADDRESS | 0xaa50);
    volatile uint32 *addr2 = (volatile uint32 *)(IFXFLASHCSRM_CMD_BASE_ADDRESS | 0xaa58);
    volatile uint32 *addr3 = (volatile uint32 *)(IFXFLASHCSRM_CMD_BASE_ADDRESS | 0xaaa8);
    volatile uint32 *addr4 = (volatile uint32 *)(IFXFLASHCSRM_CMD_BASE_ADDRESS | 0xaaa8);

    *addr1 = pageAddr;
    *addr2 = 0x00;
    *addr3 = 0xa0;
    *addr4 = 0xa6;

    __dsync();
}


IFX_INLINE void IfxFlashCsrm_writeBurstOnce(uint32 pageAddr)
{
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (IfxFlashCsrm_isAddressBelongToCsrmBank(pageAddr) == IfxFlashCsrm_Status_success));

    volatile uint32 *addr1 = (volatile uint32 *)(IFXFLASHCSRM_CMD_BASE_ADDRESS | 0xaa50);
    volatile uint32 *addr2 = (volatile uint32 *)(IFXFLASHCSRM_CMD_BASE_ADDRESS | 0xaa58);
    volatile uint32 *addr3 = (volatile uint32 *)(IFXFLASHCSRM_CMD_BASE_ADDRESS | 0xaaa8);
    volatile uint32 *addr4 = (volatile uint32 *)(IFXFLASHCSRM_CMD_BASE_ADDRESS | 0xaaa8);

    *addr1 = pageAddr;
    *addr2 = 0x00;
    *addr3 = 0xa0;
    *addr4 = 0xa4;

    __dsync();
}


IFX_INLINE void IfxFlashCsrm_writePage(uint32 pageAddr)
{
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (IfxFlashCsrm_isAddressBelongToCsrmBank(pageAddr) == IfxFlashCsrm_Status_success));

    volatile uint32 *addr1 = (volatile uint32 *)(IFXFLASHCSRM_CMD_BASE_ADDRESS | 0xaa50);
    volatile uint32 *addr2 = (volatile uint32 *)(IFXFLASHCSRM_CMD_BASE_ADDRESS | 0xaa58);
    volatile uint32 *addr3 = (volatile uint32 *)(IFXFLASHCSRM_CMD_BASE_ADDRESS | 0xaaa8);
    volatile uint32 *addr4 = (volatile uint32 *)(IFXFLASHCSRM_CMD_BASE_ADDRESS | 0xaaa8);

    *addr1 = pageAddr;
    *addr2 = 0x00;
    *addr3 = 0xa0;
    *addr4 = 0xaa;

    __dsync();
}


IFX_INLINE void IfxFlashCsrm_writePageOnce(uint32 pageAddr)
{
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (IfxFlashCsrm_isAddressBelongToCsrmBank(pageAddr) == IfxFlashCsrm_Status_success));

    volatile uint32 *addr1 = (volatile uint32 *)(IFXFLASHCSRM_CMD_BASE_ADDRESS | 0xaa50);
    volatile uint32 *addr2 = (volatile uint32 *)(IFXFLASHCSRM_CMD_BASE_ADDRESS | 0xaa58);
    volatile uint32 *addr3 = (volatile uint32 *)(IFXFLASHCSRM_CMD_BASE_ADDRESS | 0xaaa8);
    volatile uint32 *addr4 = (volatile uint32 *)(IFXFLASHCSRM_CMD_BASE_ADDRESS | 0xaaa8);

    *addr1 = pageAddr;
    *addr2 = 0x00;
    *addr3 = 0xa0;
    *addr4 = 0xa8;

    __dsync();
}


IFX_INLINE void IfxFlashCsrm_replaceLogicalSector(uint32 pageAddr)
{
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (IfxFlashCsrm_isAddressBelongToCsrmBank(pageAddr) == IfxFlashCsrm_Status_success));

    volatile uint32 *addr1 = (volatile uint32 *)(IFXFLASHCSRM_CMD_BASE_ADDRESS | 0xaa50);
    volatile uint32 *addr2 = (volatile uint32 *)(IFXFLASHCSRM_CMD_BASE_ADDRESS | 0xaa58);
    volatile uint32 *addr3 = (volatile uint32 *)(IFXFLASHCSRM_CMD_BASE_ADDRESS | 0xaaa8);
    volatile uint32 *addr4 = (volatile uint32 *)(IFXFLASHCSRM_CMD_BASE_ADDRESS | 0xaaa8);

    *addr1 = pageAddr;
    *addr2 = 0x00;
    *addr3 = 0xa0;
    *addr4 = 0xac;

    __dsync();
}


IFX_INLINE uint8 IfxFlashCsrm_countFreeRedundantSector(IfxFlashCsrm_FlashType flashType)
{
    uint32           bankSel = (1u << flashType);
    volatile uint32 *addr1   = (volatile uint32 *)(IFXFLASHCSRM_CMD_BASE_ADDRESS | 0xaaC0);

    *addr1 = bankSel;

    __dsync();

    return (uint8)MODULE_FSI_CSRM.COMM0.U;
}


IFX_INLINE void IfxFlashCsrm_sleepBank(uint32 bankselect)
{
    volatile uint32 *addr1 = (volatile uint32 *)(IFXFLASHCSRM_CMD_BASE_ADDRESS | 0xaa00);

    *addr1 = bankselect;

    __dsync();
}


IFX_INLINE void IfxFlashCsrm_wakeupBank(uint32 bankselect)
{
    volatile uint32 *addr1 = (volatile uint32 *)(IFXFLASHCSRM_CMD_BASE_ADDRESS | 0xaaF0);

    *addr1 = bankselect;

    __dsync();
}


IFX_INLINE void IfxFlashCsrm_reallocateBank(uint32 bankselect)
{
    volatile uint32 *addr1 = (volatile uint32 *)(IFXFLASHCSRM_CMD_BASE_ADDRESS | 0xaa90);

    *addr1 = bankselect;

    __dsync();
}


IFX_INLINE uint8 IfxFlashCsrm_waitUnbusy(uint32 flash, IfxFlashCsrm_FlashType flashType)
{
    if (flash == 0)
    {
        while (DMU_CSCI_STATUS.U & (1 << flashType))
        {}
    }
    else
    {
        return 1;    /*invalid flash selected */
    }

    __dsync();
    return 0; /* finished */
}


IFX_INLINE IfxFlashCsrm_Status IfxFlashCsrm_isBankAllocatedToCsrm(IfxFlashCsrm_FlashType flash)
{
    return (MODULE_DMU.GP.BKALLOC.U & (1U << flash)) ? IfxFlashCsrm_Status_success : IfxFlashCsrm_Status_failure;
}


IFX_INLINE IfxFlashCsrm_FlashType IfxFlashCsrm_getBankFromAddress(uint32 address)
{
    IfxFlashCsrm_FlashType flash = IfxFlashCsrm_FlashType_Invalid;
    uint8                  index = 0U;
    uint32                 localPageAddr;
    uint32                 size  = 0u;

    if ((address >= IFXFLASHCSRM_PFLASH_START) && (address <= IFXFLASHCSRM_PFLASH_END)) //CSRM PFLASH
    {
        flash = IfxFlashCsrm_FlashType_PCsrm;
    }
    else if (((address >= IFXFLASH_PFLASH_P00_START) && (address <= IFXFLASH_PFLASH_P51_END))) /* Host PFlash */
    {
        localPageAddr = address - IFXFLASH_PFLASH_P00_START;

        for (index = 1U; index <= IFXFLASH_PFLASH_BANKS; index++)
        {
            size += IfxFlash_flashSize[index - 1U];

            if (localPageAddr < size)
            {
                flash = (IfxFlashCsrm_FlashType)(index - 1U);
                break;
            }
        }
    }
    else if (((address >= IFXFLASHCSRM_DFLASH_START) && (address <= IFXFLASHCSRM_DFLASH_END)) || \
             ((address >= IFXFLASHCSRM_UCB1_START) && (address <= IFXFLASHCSRM_UCB1_END)))
    {
        flash = IfxFlashCsrm_FlashType_DCsrm;
    }
    else if (((address >= IFXFLASH_DFLASH_START) && (address <= IFXFLASH_DFLASH_END)) || \
             ((address >= IFXFLASH_UCB0_START) && (address <= IFXFLASH_UCB0_END))) //Host data flash
    {
        flash = IfxFlashCsrm_FlashType_DHost;
    }
    else
    {
        flash = IfxFlashCsrm_FlashType_Invalid;
    }

    return flash;
}


IFX_INLINE IfxFlashCsrm_Status IfxFlashCsrm_isAddressBelongToCsrmBank(uint32 pageAddr)
{
    IfxFlashCsrm_Status    status = IfxFlashCsrm_Status_failure;
    IfxFlashCsrm_FlashType flash  = IfxFlashCsrm_getBankFromAddress(pageAddr);

    if (flash != IfxFlashCsrm_FlashType_Invalid)
    {
        status = IfxFlashCsrm_isBankAllocatedToCsrm(flash);
    }

    return status;
}


IFX_INLINE boolean IfxFlashCsrm_isPflashInPageMode(void)
{
    return (boolean)MODULE_DMU.CSCI.STATUS.B.PFPAGE;
}


IFX_INLINE boolean IfxFlashCsrm_isDflashInPageMode(void)
{
    return (boolean)MODULE_DMU.CSCI.STATUS.B.DFPAGE;
}


IFX_INLINE boolean IfxFlashCsrm_isErrorDetected(IfxFlashCsrm_Error error)
{
    boolean errStatus = FALSE;

    if (((MODULE_DMU.CSCI.ERR.U >> error) & 0x1) != 0u)
    {
        errStatus = TRUE;
    }

    return errStatus;
}


IFX_INLINE boolean IfxFlashCsrm_isRequestReceived(void)
{
    return (boolean)MODULE_DMU.CSCI.STATUS.B.REQACK;
}


IFX_INLINE boolean IfxFlashCsrm_isRequestExecuted(void)
{
    return (boolean)MODULE_DMU.CSCI.STATUS.B.REQDONE;
}


IFX_INLINE uint32 IfxFlashCsrm_getCommandInterfaceError(void)
{
    return MODULE_DMU.CSCI.ERR.U;
}


#endif /* IFXFLASHCSRM_H */
