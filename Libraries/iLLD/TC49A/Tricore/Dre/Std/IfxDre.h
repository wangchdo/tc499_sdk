/**
 * \file IfxDre.h
 * \brief DRE  basic functionality
 * \ingroup IfxLld_Dre
 *
 * \version iLLD_2_0_1_2_19
 * \copyright Copyright (c) 2022 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 *
 * \defgroup IfxLld_Dre_Std_Enumerations Enumerations
 * \ingroup IfxLld_Dre_Std
 * \defgroup IfxLld_Dre_Std_Data_Structures Data Structures
 * \ingroup IfxLld_Dre_Std
 * \defgroup IfxLld_Dre_Std_Functions Functions
 * \ingroup IfxLld_Dre_Std
 * \defgroup IfxLld_Dre_Std_Data_Structures_Group_1 Data_Structures_Group_1
 * \ingroup IfxLld_Dre_Std
 * \defgroup IfxLld_Dre_Std_Data_Structures_Group_2 Data_Structures_Group_2
 * \ingroup IfxLld_Dre_Std
 */

#ifndef IFXDRE_H
#define IFXDRE_H 1

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "_Impl/IfxDre_cfg.h"
#include "Cpu/Std/IfxCpu_Intrinsics.h"
#include "Src/Std/IfxSrc.h"
#include "Clock/Std/IfxClock.h"
#include "Can/Std/IfxCan.h"

/******************************************************************************/
/*--------------------------------Enumerations--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Dre_Std_Enumerations
 * \{ */
/** \brief CAD CAN Index. Refer to Figure 1: CAN Address Database RAM structure
 */
typedef enum
{
    IfxDre_CAD_Index_0  = 0,   /**< \brief Index of CAN0 element in CAD */
    IfxDre_CAD_Index_1  = 1,   /**< \brief Index of CAN1 element in CAD */
    IfxDre_CAD_Index_2  = 2,   /**< \brief Index of CAN2 element in CAD */
    IfxDre_CAD_Index_3  = 3,   /**< \brief Index of CAN3 element in CAD */
    IfxDre_CAD_Index_4  = 4,   /**< \brief Index of CAN4 element in CAD */
    IfxDre_CAD_Index_5  = 5,   /**< \brief Index of CAN5 element in CAD */
    IfxDre_CAD_Index_6  = 6,   /**< \brief Index of CAN6 element in CAD */
    IfxDre_CAD_Index_7  = 7,   /**< \brief Index of CAN7 element in CAD */
    IfxDre_CAD_Index_8  = 8,   /**< \brief Index of CAN8 element in CAD */
    IfxDre_CAD_Index_9  = 9,   /**< \brief Index of CAN9 element in CAD */
    IfxDre_CAD_Index_10 = 10,  /**< \brief Index of CAN10 element in CAD */
    IfxDre_CAD_Index_11 = 11,  /**< \brief Index of CAN11 element in CAD */
    IfxDre_CAD_Index_12 = 12,  /**< \brief Index of CAN12 element in CAD */
    IfxDre_CAD_Index_13 = 13,  /**< \brief Index of CAN13 element in CAD */
    IfxDre_CAD_Index_14 = 14,  /**< \brief Index of CAN14 element in CAD */
    IfxDre_CAD_Index_15 = 15,  /**< \brief Index of CAN15 element in CAD */
    IfxDre_CAD_Index_16 = 16,  /**< \brief Index of CAN16 element in CAD */
    IfxDre_CAD_Index_17 = 17,  /**< \brief Index of CAN17 element in CAD */
    IfxDre_CAD_Index_18 = 18,  /**< \brief Index of CAN18 element in CAD */
    IfxDre_CAD_Index_19 = 19   /**< \brief Index of CAN19 element in CAD */
} IfxDre_CAD_Index;

/** \brief DRE DMEM Interrupt Line Index
 * Valid values are 0 - 7, 8 - 15 are reserved and considered as 0
 * Interrupts of 28 DMEM blocks can be mapped to any of the 8 DRE DMEM Interrupt Lines.
 * INTSIG.INTi and DMEMj_CONFIG.INP
 */
typedef enum
{
    IfxDre_DMemInterruptLine_0 = 0,  /**< \brief DMEM Interrupt Line 0 */
    IfxDre_DMemInterruptLine_1 = 1,  /**< \brief DMEM Interrupt Line 1 */
    IfxDre_DMemInterruptLine_2 = 2,  /**< \brief DMEM Interrupt Line 2 */
    IfxDre_DMemInterruptLine_3 = 3,  /**< \brief DMEM Interrupt Line 3 */
    IfxDre_DMemInterruptLine_4 = 4,  /**< \brief DMEM Interrupt Line 4 */
    IfxDre_DMemInterruptLine_5 = 5,  /**< \brief DMEM Interrupt Line 5 */
    IfxDre_DMemInterruptLine_6 = 6,  /**< \brief DMEM Interrupt Line 6 */
    IfxDre_DMemInterruptLine_7 = 7   /**< \brief DMEM Interrupt Line 7 */
} IfxDre_DMemInterruptLine;

/** \brief Data Field Size
 * Definition in CIBL_CONFIG, COBL_CONFIG
 * IFX_CFG_TC49A_DELTA: Only valid config option is 64 bytes of data field
 */
typedef enum
{
    IfxDre_DataFieldSize_8  = 0,  /**< \brief 8 bytes of data field */
    IfxDre_DataFieldSize_16 = 1,  /**< \brief 16 bytes of data field */
    IfxDre_DataFieldSize_24 = 2,  /**< \brief 24 bytes of data field */
    IfxDre_DataFieldSize_32 = 3,  /**< \brief 32 bytes of data field */
    IfxDre_DataFieldSize_48 = 5,  /**< \brief 48 bytes of data field */
    IfxDre_DataFieldSize_64 = 7   /**< \brief 64 bytes of data field */
} IfxDre_DataFieldSize;

/** \brief CAN Filter Mode, refer to CIDFC.MODE
 */
typedef enum
{
    IfxDre_FilterMode_classic = 0,  /**< \brief Classic filter: CAN ID1 = filter, CAN ID2 = mask, IFX_CFG_TC49A_DELTA H/W Descoped Feature, CIDFC.MODE field is ignored and by default only classic filter is supported. */
    IfxDre_FilterMode_dualId  = 1,  /**< \brief Dual ID filter for CAN ID1 or CAN ID2, IFX_CFG_TC49A_DELTA H/W Descoped Feature */
    IfxDre_FilterMode_range   = 2   /**< \brief Range filter from CAN ID1 to CAN ID2 (CAN ID1 is less than CAN ID2), IFX_CFG_TC49A_DELTA H/W Descoped Feature */
} IfxDre_FilterMode;

/** \brief DRE Interrupt Line Index
 */
typedef enum
{
    IfxDre_InterruptLine_0  = 0,   /**< \brief Interrupt Line 0. DMEM Line option 0 */
    IfxDre_InterruptLine_1  = 1,   /**< \brief Interrupt Line 1. DMEM Line option 1 */
    IfxDre_InterruptLine_2  = 2,   /**< \brief Interrupt Line 2. DMEM Line option 2 */
    IfxDre_InterruptLine_3  = 3,   /**< \brief Interrupt Line 3. DMEM Line option 3 */
    IfxDre_InterruptLine_4  = 4,   /**< \brief Interrupt Line 4. DMEM Line option 4 */
    IfxDre_InterruptLine_5  = 5,   /**< \brief Interrupt Line 5. DMEM Line option 5 */
    IfxDre_InterruptLine_6  = 6,   /**< \brief Interrupt Line 6. DMEM Line option 6 */
    IfxDre_InterruptLine_7  = 7,   /**< \brief Interrupt Line 7. DMEM Line option 7 */
    IfxDre_InterruptLine_8  = 8,   /**< \brief Interrupt Line 8. CAN Input buffer full interrupt (CIBL_STATUS.BF) */
    IfxDre_InterruptLine_9  = 9,   /**< \brief Interrupt Line 9. CAN Output buffer full interrupt (COBL_STATUS.BF) */
    IfxDre_InterruptLine_10 = 10,  /**< \brief Interrupt Line 10. EIBUF Frame Error interrupt (EIBUF0 & 1_STATUS.FE) */
    IfxDre_InterruptLine_11 = 11,  /**< \brief Interrupt Line 11. ACF CAN Frame Error Interrupt (EIBUF0 &1_STATUS.CFE, RFE) */
    IfxDre_InterruptLine_12 = 12,  /**< \brief Interrupt Line 12. Routing Table error interrupt (RS.IRT and NMFE) */
    IfxDre_InterruptLine_13 = 13,  /**< \brief Interrupt Line 13. ME Routing Transaction lost interrupt - (ME_STATE.DBOE, SRIBE, SPBBE, IRDE) */
    IfxDre_InterruptLine_14 = 14,  /**< \brief Interrupt Line 14. EIBUF frame complete interrupt (EIBUF0&1_STATUS.FC) */
    IfxDre_InterruptLine_15 = 15   /**< \brief Interrupt Line 15. EOBUF Transmit request interrupt (EOBUF0&1_STATUS.TXREQ) */
} IfxDre_InterruptLine;

/** \brief Type of Routing Rule
 */
typedef enum
{
    IfxDre_RoutingType_unicast   = 0, /**< \brief Unicast Routing Rule */
    IfxDre_RoutingType_multicast = 1  /**< \brief Multicast Routing Rule. IFX_CFG_TC49A_DELTA Feature */
} IfxDre_RoutingType;

/** \brief DRE SIDF FC Source ID
 */
typedef enum
{
    IfxDre_SIDF_FC_SourceId_1 = 24,  /**< \brief Source ID_1 = 0x18 */
    IfxDre_SIDF_FC_SourceId_2 = 25   /**< \brief Source ID_1 = 0x19 */
} IfxDre_SIDF_FC_SourceId;

/** \brief Stream Filter Mode, refer to SIDF_FC.MODE
 */
typedef enum
{
    IfxDre_StreamFilterMode_classic = 0,  /**< \brief Classic filter: Stream Filter 1 = filter, Stream Filter 2 = mask */
    IfxDre_StreamFilterMode_range   = 1   /**< \brief Range Filter from Stream Filter 1 to Stream Filter 2 */
} IfxDre_StreamFilterMode;

/** \brief Clock Source for Timed Trigger, refer to TTC.CLKSEL
 */
typedef enum
{
    IfxDre_TriggerClock_none = 0,  /**< \brief Timer is disabled */
    IfxDre_TriggerClock_fSRI = 1,  /**< \brief fSRI is used as clock source */
    IfxDre_TriggerClock_fSPB = 2   /**< \brief fSPB is used as clock source */
} IfxDre_TriggerClock;

/** \brief Transmit Trigger Mode, refer to EOBUF.TTM
 */
typedef enum
{
    IfxDre_TriggerMode_software        = 0,  /**< \brief Software Trigger */
    IfxDre_TriggerMode_frameCount      = 1,  /**< \brief Configured number of CAN frames */
    IfxDre_TriggerMode_bufferFillLevel = 2,  /**< \brief Fill size of the EOBUF */
    IfxDre_TriggerMode_timeTriggered   = 3   /**< \brief Time Triggered Transmit Mode. IFX_CFG_TC49A_DELTA H/W Descoped Feature */
} IfxDre_TriggerMode;

/** \} */

/******************************************************************************/
/*-----------------------------Data Structures--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Dre_Std_Data_Structures_Group_1
 * \{ */
/** \brief Configuration for Timed Trigger Transmit of Ethernet Fames. Refer to EOBUF0/1.TTC.CLKSEL, EOBUF0/1.TTC.TP and EOBUF0/1.TTS.B.TRV
 */
typedef struct
{
    IfxDre_TriggerClock clock;                  /**< \brief clock source for the timer */
    uint8               timerPrescalar;         /**< \brief prescalar for timer */
    uint16              timerReloadValue;       /**< \brief reload value for timer */
} IfxDre_TimerConfig;

/** \} */

/** \addtogroup IfxLld_Dre_Std_Data_Structures_Group_1
 * \{ */
/** \brief PROT and APU configuration
 */
typedef struct
{
    IfxApProt_ProtConfig proteConfig;        /**< \brief PROTE configuration */
    IfxApProt_ProtConfig protseConfig;       /**< \brief PROTSE Configuration */
    IfxApApu_ApuConfig   apuConfig;          /**< \brief APU Configurations */
} IfxDre_ApConfig;

/** \} */

/** \addtogroup IfxLld_Dre_Std_Data_Structures_Group_2
 * \{ */
/** \brief Configuration Structure of Ethernet Input Buffer
 */
typedef struct
{
    uint16  bufferStartAddress;            /**< \brief Start address of EIBUF. Refer to EIBUF_SA.ADR */
    uint16  ntscfStartAddress;             /**< \brief Offset address from EIBUF_SA.ADR at which the NTSCF header starts. Refer to EIBUF_CONFIG.NTSCF_SA. IFX_CFG_TC49A_DELTA H/W Limited Feature: Valid values are limited to 128, 512 and 1484 bytes only. */
    uint16  bufferSize;                    /**< \brief 0:Buffer is disabled, 1500:Max. Refer to EIBUF_CONFIG.SIZE */
    boolean enableRejectRemoteFrame;       /**< \brief enable(1)/disable(0) remote frame rejection */
} IfxDre_EthernetInputBufConfig;

/** \brief Flags to store EIBUF status
 */
typedef struct
{
    boolean bufferPendingRequest;          /**< \brief status flag for BPR */
    boolean ethernetFrameError;            /**< \brief status flag for FE */
    boolean invalidFrameType;              /**< \brief status flag for IFT */
    boolean invalidStreamId;               /**< \brief status flag for ISID */
    boolean avtpLengthMismatchError;       /**< \brief status flag for LME */
    boolean canFormatError;                /**< \brief status flag for CFE */
    boolean remoteFrameError;              /**< \brief status flag for RFE */
    boolean ethernetFrameComplete;         /**< \brief status flag for FC */
} IfxDre_EthernetInputBufStatus;

/** \brief Configuration Structure of Ethernet Output Buffer
 */
typedef struct
{
    uint16               startAddress;                 /**< \brief address of EOBUF. Refer to EOBUF0/1.SA */
    uint16               payloadLength;                /**< \brief ACF Payload Length in bytes. 0:Buffer is disabled, Min:8 bytes, Max:1484 bytes, must also be multiple of 32-bit. (Refer EOBUF_CONFIG.PL), IFX_CFG_TC49A_DELTA H/W Limited Feature: Valid values are limited to 128, 512 and 1484 bytes only. */
    IfxCan_DestinationId destinationId;                /**< \brief Only Ethernet IDs to be used. IfxCan_DestinationId_Ethernet1/2. */
    boolean              headerEnable;                 /**< \brief Enable/Disable Ethernet Header. */
    IfxDre_TriggerMode   triggerMode;                  /**< \brief Ethernet Frame Transmit Trigger Mode */
    uint16               macDestinationAddress0;       /**< \brief 16 bit Destination Address 0. Refer H0 */
    uint32               macDestinationAddress1;       /**< \brief 32 bit Destination Address 1. Refer H1 */
    uint32               macSourceAddress0;            /**< \brief 32 bit Source Address 0. Refer H2 */
    uint16               macSourceAddress1;            /**< \brief 16 bit Source Address 1. Refer H3 */
    uint16               tpId;                         /**< \brief 16 bit Tagged Protocol Identifier. It is configured to a value of 8100h for tagged ethernet frames, as required by IEEE Std. 802.1Q */
    uint16               vlanTag;                      /**< \brief 16 bit VLAN Tag. The VLAT tag contains PCP (3 bits), DEI (1 bit) & VID (12 bits). */
    uint16               avtpEtherType;                /**< \brief 16 bit AVTP EtherType, 0x22F0 for AVTP Frames */
    boolean              isStreamIdValid;              /**< \brief sets the validity of Stream ID field */
    uint8                ntscfSequenceNumber;          /**< \brief NTSCF Header Sequence Number */
    uint32               streamIdLower;                /**< \brief Lower 32-bits of 64-bit Stream ID */
    uint32               streamIdHigher;               /**< \brief Higher 32-bits of 64-bit Stream ID */
    uint16               bufferThreshold;              /**< \brief Threshold size of the EOBUF ACF Payload, when Trigger Mode = IfxDre_TriggerMode_bufferFillLevel */
    uint8                triggerFillLevel;             /**< \brief Threshold for number of CAN frames in an EOBUF for transmit trigger condition, when Trigger Mode = IfxDre_TriggerMode_frameCount */
    IfxDre_TimerConfig   timer;                        /**< \brief Timer Trigger Configuration */
} IfxDre_EthernetOutputBufConfig;

/** \brief Interrupt configuration
 */
typedef struct
{
    boolean      enable;              /**< \brief Set as TRUE to configure the Interrupt Node */
    Ifx_Priority priority;            /**< \brief Priority of the interrupt */
    IfxSrc_Tos   typeOfService;       /**< \brief Type of Service */
    IfxSrc_VmId  vmId;                /**< \brief Virtual Machine Number */
} IfxDre_InterruptConfig;

/** \brief ACF CAN Frame Error Interrupt Status (Interrupt Line 11)
 */
typedef struct
{
    uint32 EIBUF0_CFE : 1;       /**< \brief EIBUF0 CAN Format Error Status */
    uint32 EIBUF0_RFE : 1;       /**< \brief EIBUF0 Remote Format Error Status */
    uint32 EIBUF1_CFE : 1;       /**< \brief EIBUF1 CAN Format Error Status */
    uint32 EIBUF1_RFE : 1;       /**< \brief EIBUF1 Remote Format Error Status */
} IfxDre_Interrupt_Line11_Status;

/** \brief Routing Table Error Interrupt Status (Interrupt Line 12)
 */
typedef struct
{
    uint32 RS_IRT : 1;        /**< \brief In-Valid Routing Table Status */
    uint32 RS_NMFE : 1;       /**< \brief Non-Matching Filter Element Error Status */
} IfxDre_Interrupt_Line12_Status;

/** \brief ME Routing Transaction Lost interrupt Status (Interrupt Line 13)
 */
typedef struct
{
    uint32 SPBBE : 1;       /**< \brief SPB Bus Transaction Error Status */
    uint32 SRIBE : 1;       /**< \brief SRI Bus Error Status */
    uint32 DBOE : 1;        /**< \brief Destination Buffer Overflow Error Status */
    uint32 IRDE : 1;        /**< \brief Invalid Routing Destination Error Status */
} IfxDre_Interrupt_Line13_Status;

/** \brief Configuration Structure for Destination Memory
 */
typedef struct
{
    boolean                  enable;                       /**< \brief configure the corresponding memory element if set */
    uint32                   address;                      /**< \brief 64 bit aligned, 32 bit start address of Destination Memory Element */
    uint8                    resourcePartitionIndex;       /**< \brief The RP allocated to memory destination */
    boolean                  addressIncrement;             /**< \brief specifies whether the address is incremented or decremented with the specified offset size */
    boolean                  appendStatus;                 /**< \brief enables/disables the append of status along with the CAN message at the destination */
    boolean                  appendTiming;                 /**< \brief enables/disables the append of timing header along with the CAN message at the destination */
    IfxDre_DMemInterruptLine interruptNodePointer;         /**< \brief interrupt line to be triggered in case of a Watermark or Address Wraparound event */
    uint8                    offsetAddress;                /**< \brief 32 bit aligned offset address by which the destination address is incremented or decremented after every routing operation to the destination memory. IFX_CFG_TC49A_DELTA: Valid values are 32 (0x20) bytes for Classical CAN frames and 82 (0x58) bytes for CAN FD frames */
    uint8                    waterMarkLevel;               /**< \brief (optional) number of routing transfers after which watermark interrupt is triggered */
    uint8                    wrapAroundLevel;              /**< \brief number of routing transfers after which the address is set back to the start address of the destination memory. Interrupts are also triggered upon wrap around event. */
} IfxDre_MemoryConfig;

/** \brief Routing Table Configurations. Refer to RT[i].SA and RT[i].CONFIG.
 */
typedef struct
{
    uint16 address;       /**< \brief Start address offset of Routing Table from DRE RAM (64 bit aligned) */
    uint8  size;          /**< \brief Number of Routing Rules (0-128), 0:Disabled, 128: Max */
} IfxDre_RoutingTableConfig;

/** \brief Configuration Structure for Stream ID Filter
 */
typedef struct
{
    boolean                 enable;                  /**< \brief enable/disable the filter */
    IfxDre_StreamFilterMode mode;                    /**< \brief Stream ID Filter Mode */
    uint8                   routingTableIndex;       /**< \brief Index of the Routing Table to be used by CAN Transmit Routing Engine */
    uint32                  filter1LowerId;          /**< \brief Lower 32 bit of Stream ID Filter 1 */
    uint32                  filter1HigherId;         /**< \brief Higher 32 bit of Stream ID Filter 1 */
    uint32                  filter2LowerId;          /**< \brief Lower 32 bit of Stream ID Filter 2 */
    uint32                  filter2HigherId;         /**< \brief Higher 32 bit of Stream ID Filter 2 */
    IfxDre_SIDF_FC_SourceId sourceId;                /**< \brief Source ID */
} IfxDre_StreamIdConfig;

/** \} */

/** \addtogroup IfxLld_Dre_Std_Functions
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Returns the status of module (enabled or disabled)
 * \param dre Specifies the pointer to the DRE registers
 * \return Status TRUE: Enabled / FALSE: Disabled
 */
IFX_INLINE boolean IfxDre_isModuleEnabled(Ifx_DRE *dre);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Resets DRE kernel
 * \param dre Specifies the pointer to the DRE registers
 * \return None
 */
IFX_EXTERN void IfxDre_resetModule(Ifx_DRE *dre);

/** \brief Disables the module (sets the disable request)
 * \param dre Specifies the pointer to the DRE registers
 * \return None
 */
IFX_EXTERN void IfxDre_disableModule(Ifx_DRE *dre);

/** \brief Enables the module (clears the disable request)
 * \param dre Specifies the pointer to the DRE registers
 * \return None
 */
IFX_EXTERN void IfxDre_enableModule(Ifx_DRE *dre);

/** \brief Gets the various flags of EIBUF_STATUS register
 * \param dre Specifies the pointer to the DRE registers
 * \param bufferIndex Index of Ethernet Input Buffer (0/1)
 * \param status Specifies the pointer to the software flags
 * \return None
 */
IFX_EXTERN void IfxDre_getEibufStatusFlags(Ifx_DRE *dre, uint8 bufferIndex, IfxDre_EthernetInputBufStatus *status);

/** \brief Sets the buffer pending request in EIBUF_STATUS register. H/w clears it after extracting all CAN frames.
 * \param dre Specifies the pointer to the DRE registers
 * \param bufferIndex Index of Ethernet Input Buffer (0/1)
 * \return None
 */
IFX_EXTERN void IfxDre_setEibufNewEthernetFrameRequest(Ifx_DRE *dre, uint8 bufferIndex);

/** \brief Clear the EIBUF Buffer Pending Request Flag (To be updated for Silver)
 * \param dre Specifies the pointer to the DRE registers
 * \param bufferIndex index of EIBUF
 * \return None
 */
IFX_EXTERN void IfxDre_clearEibufNewEthernetFrameRequest(Ifx_DRE *dre, uint8 bufferIndex);

/** \brief Gets the status of corresponding Ethernet Input Buffer's Buffer Pending Request
 * \param dre Specifies the pointer to the DRE registers
 * \param bufferIndex index of EIBUF
 * \return status of Buffer Pending Request (1 means pending), cleared by H/w
 */
IFX_EXTERN boolean IfxDre_getEibufPendingRequest(Ifx_DRE *dre, uint8 bufferIndex);
#ifdef IFX_CFG_TC49A_DELTA
/** \brief Initialize the PROTs and APU with default configuration
 * \param config Configuration pointer for the Access Protection
 * \return None
 */
IFX_EXTERN void IfxDre_initApConfig(IfxDre_ApConfig *config);

/** \brief Initialize the PORTs and APU register set
 * \param dre DRE module pointer
 * \param config Configuration pointer to the AP Config structure
 * \return None
 */
IFX_EXTERN void IfxDre_initAp(Ifx_DRE *dre, IfxDre_ApConfig *config);
#endif

/** \brief Enable or Disable the DRE Interrupt Enable Bits
 * \param dre DRE module pointer
 * \param enable TRUE: Enable the Interrupt Line. FALSE: Disable the Interrupt Line.
 * \param index Interrupt Line Index
 * \return None
 */
IFX_EXTERN void IfxDre_setInterruptEnable(Ifx_DRE *dre, boolean enable, IfxDre_InterruptLine index);

/** \brief Returns the DRE Interrupt Line status
 * \param dre DRE module pointer
 * \param index Interrupt Line Index
 * \return interrupt flag status
 */
IFX_EXTERN boolean IfxDre_getInterruptLineStatusFlag(Ifx_DRE *dre, IfxDre_InterruptLine index);

/** \brief Returns the DMEM Water Mark Flag Status
 * \param dre DRE module pointer
 * \param index DMEM Index
 * \return Water Mark Flag Status
 */
IFX_EXTERN boolean IfxDre_getDMemWaterMarkFlag(Ifx_DRE *dre, uint8 index);

/** \brief Returns the DMEM Warp Around Flag Status
 * \param dre DRE module pointer
 * \param index DMEM Index
 * \return Warp Around Flag Status
 */
IFX_EXTERN boolean IfxDre_getDMemWrapAroundFlag(Ifx_DRE *dre, uint8 index);

/** \brief Clears the DMEM Water Mark Flag Status
 * \param dre DRE module pointer
 * \param index DMEM Index
 * \return None
 */
IFX_EXTERN void IfxDre_clearDMemWaterMarkFlag(Ifx_DRE *dre, uint8 index);

/** \brief Clears the DMEM Wrap Around Flag Status
 * \param dre DRE module pointer
 * \param index DMEM Index
 * \return None
 */
IFX_EXTERN void IfxDre_clearDMemWrapAroundFlag(Ifx_DRE *dre, uint8 index);

/** \brief Returns the status of Buffer Full Flag in CAN Input Buffer List Status register
 * \param dre DRE module pointer
 * \return Buffer Full Flag Status
 */
IFX_EXTERN boolean IfxDre_get_CIBL_Status_BufferFullFlag(Ifx_DRE *dre);

/** \brief Returns the status of Buffer Full Flag in CAN Output Buffer List Status register
 * \param dre DRE module pointer
 * \return Buffer Full Flag Status
 */
IFX_EXTERN boolean IfxDre_get_COBL_Status_BufferFullFlag(Ifx_DRE *dre);

/** \brief Returns the status of Ethernet Frame Error Flag in Ethernet Input Buffer Status register
 * \param dre DRE module pointer
 * \param index EIBUF index
 * \return Frame Error Flag Status
 */
IFX_EXTERN boolean IfxDre_get_EIBUF_Status_EthernetFrameErrorFlag(Ifx_DRE *dre, uint8 index);

/** \brief Clears the status of Ethernet Frame Error Flag in Ethernet Input Buffer Status register
 * \param dre DRE module pointer
 * \param index EIBUF index
 * \return None
 */
IFX_EXTERN void IfxDre_clear_EIBUF_Status_EthernetFrameErrorFlag(Ifx_DRE *dre, uint8 index);

/** \brief Returns the status of Transmit Request Flag in Ethernet Output Buffer Status register
 * \param dre DRE module pointer
 * \param index EOBUF index
 * \return TXREQ Flag Status
 */
IFX_EXTERN boolean IfxDre_get_EOBUF_Status_TxRequestFlag(Ifx_DRE *dre, uint8 index);

/** \brief Clears the status of Transmit Request Flag in Ethernet Output Buffer Status register
 * \param dre DRE module pointer
 * \param index EOBUF index
 * \return None
 */
IFX_EXTERN void IfxDre_clear_EOBUF_Status_TxRequestFlag(Ifx_DRE *dre, uint8 index);

/** \brief Returns the status of Frame Complete Flag in Ethernet Input Buffer Status register
 * \param dre DRE module pointer
 * \param index EIBUF index
 * \return FC Flag Status
 */
IFX_EXTERN boolean IfxDre_get_EIBUF_Status_EthernetFrameCompleteFlag(Ifx_DRE *dre, uint8 index);

/** \brief Clears the status of Frame Complete Flag in Ethernet Input Buffer Status register
 * \param dre DRE module pointer
 * \param index EOBUF index
 * \return None
 */
IFX_EXTERN void IfxDre_clear_EIBUF_Status_EthernetFrameCompleteFlag(Ifx_DRE *dre, uint8 index);

/** \brief Gets and Clears the Flags linked to Interrupt Line 11
 * \param dre DRE module pointer
 * \param status pointer to structure containing interrupt line 11 flags
 * \return None
 */
IFX_EXTERN void IfxDre_getAndClearInterruptLine11Status(Ifx_DRE *dre, IfxDre_Interrupt_Line11_Status *status);

/** \brief Gets and Clears the Flags linked to Interrupt Line 12
 * \param dre DRE module pointer
 * \param status pointer to structure containing interrupt line 12 flags
 * \return None
 */
IFX_EXTERN void IfxDre_getAndClearInterruptLine12Status(Ifx_DRE *dre, IfxDre_Interrupt_Line12_Status *status);

/** \brief Gets and Clears the Flags linked to Interrupt Line 13
 * \param dre DRE module pointer
 * \param status pointer to structure containing interrupt line 13 flags
 * \return None
 */
IFX_EXTERN void IfxDre_getAndClearInterruptLine13Status(Ifx_DRE *dre, IfxDre_Interrupt_Line13_Status *status);

/** \brief Returns the SRC pointer for corresponding line
 * \param index index of interrupt line
 * \return address of SRC register
 */
IFX_EXTERN volatile Ifx_SRC_SRCR *IfxDre_getSrcAddress(IfxDre_InterruptLine index);

/** \brief Configures access to all masters to all the DRE in the device
 * \param apConfig pointer to configuration structure.
 * \return None
 */
IFX_EXTERN void IfxDre_configureAccessToDre(IfxApApu_ApuConfig *apConfig);

/** \} */

/******************************************************************************/
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE boolean IfxDre_isModuleEnabled(Ifx_DRE *dre)
{
    return dre->CLC.B.DISS == 0;
}


#endif /* IFXDRE_H */
