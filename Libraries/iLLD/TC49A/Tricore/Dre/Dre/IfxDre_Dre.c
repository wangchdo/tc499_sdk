/**
 * \file IfxDre_Dre.c
 * \brief DRE DRE details
 *
 * \version iLLD_2_0_1_2_19
 * \copyright Copyright (c) 2022 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 *
 */

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "IfxDre_Dre.h"

/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxDre_Dre_initModule(IfxDre_Dre *dre, IfxDre_Dre_Config *config)
{
    Ifx_DRE *dreSFR = config->dre;
    dre->dre = dreSFR;

    /* if module is not enabled*/
    if (IfxDre_isModuleEnabled(dreSFR) != TRUE)
    {
        /* Enable module, disregard Sleep Mode request*/
        IfxDre_enableModule(dreSFR);
    }

    /*CIBUF Config*/
    dreSFR->CIBL.SA.U = (config->canInputBufferStartAddress & 0xFFF8);

    Ifx_DRE_CIBL_CONFIG ciblConfig;
#ifdef IFX_CFG_TC49A_DELTA
    ciblConfig.B.NCIB = config->numberOfCanInputBuffers;
#else
    ciblConfig.B.NCIB = 32;
#endif

#ifdef IFX_CFG_TC49A_DELTA
    ciblConfig.B.DFS = config->inputDataSize;
#else
    ciblConfig.B.DFS = IfxDre_DataFieldSize_64;
#endif

    dreSFR->CIBL.CONFIG.U = ciblConfig.U;

    /*COBUF Config*/
    dreSFR->COBL.SA.U = (config->canOutputBufferStartAddress & 0xFFF8);
    Ifx_DRE_COBL_CONFIG coblConfig;
#ifdef IFX_CFG_TC49A_DELTA
    coblConfig.B.NCOB = config->numberOfCanOutputBuffers;
#else
    coblConfig.B.NCOB = 64;
#endif

#ifdef IFX_CFG_TC49A_DELTA
    coblConfig.B.DFS = config->outputDataSize;
#else
    coblConfig.B.DFS = IfxDre_DataFieldSize_64;
#endif

    dreSFR->COBL.CONFIG.U = coblConfig.U;

    /*Routing Table Config*/
    dreSFR->RT[0].SA.U     = (config->rt0Config.address & 0xFFF8);
    dreSFR->RT[0].CONFIG.U = config->rt0Config.size;

#ifdef IFX_CFG_TC49A_DELTA

    dreSFR->RT[1].SA.U     = (config->rt1Config.address & 0xFFF8);
    dreSFR->RT[1].CONFIG.U = config->rt1Config.size;
    dreSFR->RT[2].SA.U     = (config->rt2Config.address & 0xFFF8);
    dreSFR->RT[2].CONFIG.U = config->rt2Config.size;
    dreSFR->RT[3].SA.U     = (config->rt3Config.address & 0xFFF8);
    dreSFR->RT[3].CONFIG.U = config->rt3Config.size;

#endif

    uint8                  i = 0;

#ifdef IFX_CFG_TC49A_DELTA
    /*Stream ID Filter Configurations*/
    Ifx_DRE_SIDF          *sidf = &(dreSFR->SIDF[0]);
    Ifx_DRE_SIDF_FC        streamFilter;
    streamFilter.U = 0;
    IfxDre_StreamIdConfig *streamFilterCfgPtr = &(config->streamFilter0);

    for (i = 0; i < IFXDRE_NUM_STREAM_ID_FILTERS; i++)
    {
        streamFilter.B.FE = streamFilterCfgPtr->enable;

        if (streamFilterCfgPtr->enable)
        {
            streamFilter.B.MODE = streamFilterCfgPtr->mode;
            streamFilter.B.RTI  = streamFilterCfgPtr->routingTableIndex;
            streamFilter.B.SID  = streamFilterCfgPtr->sourceId;
            sidf->FC.U          = streamFilter.U;
            sidf->FIL1.L.U      = streamFilterCfgPtr->filter1LowerId;
            sidf->FIL1.H.U      = streamFilterCfgPtr->filter1HigherId;
            sidf->FIL2.L.U      = streamFilterCfgPtr->filter2LowerId;
            sidf->FIL2.H.U      = streamFilterCfgPtr->filter2HigherId;
        }

        sidf++;
        streamFilterCfgPtr++;
    }

#endif

    /*Destination Memory Configurations*/
    Ifx_DRE_DMEM        *dMemPtr   = &(dreSFR->DMEM[0]);
    IfxDre_MemoryConfig *memCfgPtr = &(config->mem0Cfg);
    Ifx_DRE_DMEM_CONFIG  dMemCfgSfrVar;
    dMemCfgSfrVar.U = 0;

    for (i = 0; i < IFXDRE_NUM_DMEM; i++)
    {
        if (memCfgPtr->enable)
        {
            dMemPtr->SA.U       = memCfgPtr->address;
            dMemPtr->RP.U       = (memCfgPtr->resourcePartitionIndex & 0x7);

            dMemCfgSfrVar.B.EN  = 1;
            dMemCfgSfrVar.B.AST = memCfgPtr->appendStatus;
            dMemCfgSfrVar.B.ATH = memCfgPtr->appendTiming;
            dMemCfgSfrVar.B.INP = memCfgPtr->interruptNodePointer; /*Valid values are 0 - 7, 8 - 15 are reserved and considered as 0*/
            dMemCfgSfrVar.B.OA  = memCfgPtr->offsetAddress;        /* IFX_CFG_TC49A_DELTA: Valid values are 32 (0x20) bytes for Classical CAN frames and 82 (0x58) bytes for CAN FD frames */
            dMemCfgSfrVar.B.WML = memCfgPtr->waterMarkLevel;
            dMemCfgSfrVar.B.WAL = memCfgPtr->wrapAroundLevel;

            dMemPtr->CONFIG.U   = dMemCfgSfrVar.U;

            /*S/w write with 1/non zero will reset the bits.*/
            dMemPtr->STATUS.U = IFXDRE_DMEM_STATUS_CLEAR;
        }

        dMemPtr++;
        memCfgPtr++;
    }

    /*EOBUF Config*/
    /*Buffer 0 Config*/
    Ifx_DRE_EOBUF       *eobuf0 = &(dreSFR->EOBUF[0]);
    eobuf0->SA.U = (config->ethernetOutputBuffer0.startAddress & 0xFFF8);

    Ifx_DRE_EOBUF_CONFIG eobufConfig;
    eobufConfig.U     = 0;
    /*ACF Payload Length: Original Range is 8-1484 bytes, value must also be a multiple of 32-bit.
     * IFX_CFG_TC49A_DELTA H/W Limited Feature: Valid values are limited to 128, 512 and 1484 bytes only. */
    eobufConfig.B.PL  = config->ethernetOutputBuffer0.payloadLength;
    /*Valid values are IfxCan_DestinationId_Ethernet1 or IfxCan_DestinationId_Ethernet2*/
    eobufConfig.B.DID = config->ethernetOutputBuffer0.destinationId;
    eobufConfig.B.HE  = config->ethernetOutputBuffer0.headerEnable;
    eobufConfig.B.TTM = config->ethernetOutputBuffer0.triggerMode;
    eobuf0->CONFIG.U  = eobufConfig.U;

    /*MAC Configurations*/
    Ifx_DRE_EOBUF_MAC *mac0 = &(eobuf0->MAC);
    mac0->H0.B.DA0 = config->ethernetOutputBuffer0.macDestinationAddress0;
    mac0->H1.U     = config->ethernetOutputBuffer0.macDestinationAddress1;
    mac0->H2.U     = config->ethernetOutputBuffer0.macSourceAddress0;
    mac0->H3.U     = (config->ethernetOutputBuffer0.macSourceAddress1 + (config->ethernetOutputBuffer0.tpId << 16));

    Ifx_DRE_EOBUF_MAC_H4 h4;
    h4.U          = 0;
    h4.B.VTAG_L   = (config->ethernetOutputBuffer0.vlanTag & 0x00FF);
    h4.B.VTAG_H   = (config->ethernetOutputBuffer0.vlanTag >> 8);
    h4.B.AVTPET_L = (config->ethernetOutputBuffer0.avtpEtherType & 0x00FF);
    h4.B.AVTPET_H = (config->ethernetOutputBuffer0.avtpEtherType >> 8);
    mac0->H4.U    = h4.U;

    /*NTSCF and STREAM ID Configurations*/
    Ifx_DRE_EOBUF_NTSCF *ntscf0 = &(eobuf0->NTSCF);
    ntscf0->H0.B.SV = config->ethernetOutputBuffer0.isStreamIdValid;
    ntscf0->H0.B.SN = config->ethernetOutputBuffer0.ntscfSequenceNumber;

    if (config->ethernetOutputBuffer0.isStreamIdValid)
    {
        ntscf0->STREAM0_ID.B.ID0 = ((config->ethernetOutputBuffer0.streamIdHigher & 0xFF000000) >> 24); /* Stream ID [63:54] */
        ntscf0->STREAM0_ID.B.ID1 = ((config->ethernetOutputBuffer0.streamIdHigher & 0x00FF0000) >> 16); /* Stream ID [53:48] */
        ntscf0->STREAM0_ID.B.ID2 = ((config->ethernetOutputBuffer0.streamIdHigher & 0x0000FF00) >> 8);  /* Stream ID [47:40] */
        ntscf0->STREAM0_ID.B.ID3 = ((config->ethernetOutputBuffer0.streamIdHigher & 0x000000FF));       /* Stream ID [39:32] */

        ntscf0->STREAM1_ID.B.ID4 = ((config->ethernetOutputBuffer0.streamIdLower & 0xFF000000) >> 24);  /* Stream ID [31:24] */
        ntscf0->STREAM1_ID.B.ID5 = ((config->ethernetOutputBuffer0.streamIdLower & 0x00FF0000) >> 16);  /* Stream ID [23:16] */
        ntscf0->STREAM1_ID.B.ID6 = ((config->ethernetOutputBuffer0.streamIdLower & 0x0000FF00) >> 8);   /* Stream ID [15:8] */
        ntscf0->STREAM1_ID.B.ID7 = ((config->ethernetOutputBuffer0.streamIdLower & 0x000000FF));        /* Stream ID [7:0] */
    }

    /*Clear Status bit*/
    eobuf0->STATUS.B.TXREQ = 1; /*Write of 1 clears the bit set by H/w*/
    eobuf0->STATUS.B.BF    = 1;
    eobuf0->STATUS.B.TTL   = 1;

    /*Transmit Trigger Configurations*/
    Ifx_DRE_EOBUF_TTC ttc;
    ttc.U = 0;

    if (config->ethernetOutputBuffer0.triggerMode == IfxDre_TriggerMode_bufferFillLevel)
    {
        ttc.B.BUFT = config->ethernetOutputBuffer0.bufferThreshold; /*Must be less than max ACF Payload*/
    }
    else if (config->ethernetOutputBuffer0.triggerMode == IfxDre_TriggerMode_frameCount)
    {
        ttc.B.TFL = config->ethernetOutputBuffer0.triggerFillLevel;
    }
    else if (config->ethernetOutputBuffer0.triggerMode == IfxDre_TriggerMode_timeTriggered)
    {
        ttc.B.CLKSEL      = config->ethernetOutputBuffer0.timer.clock;
        ttc.B.TP          = config->ethernetOutputBuffer0.timer.timerPrescalar;
        eobuf0->TTS.B.TRV = config->ethernetOutputBuffer0.timer.timerReloadValue;
    }

    eobuf0->TTC.U = ttc.U;

    /*Buffer 1 Config*/
    Ifx_DRE_EOBUF *eobuf1 = &(dreSFR->EOBUF[1]);
    eobuf1->SA.U  = (config->ethernetOutputBuffer1.startAddress & 0xFFF8);

    eobufConfig.U = 0;

    /*ACF Payload Length: Valid Range is 8-1484 bytes, value must also be a multiple of 32-bit.
     * IFX_CFG_TC49A_DELTA H/W Limited Feature: Valid values are limited to 128, 512 and 1484 bytes only. */
    eobufConfig.B.PL  = config->ethernetOutputBuffer1.payloadLength;
    /*Valid values are IfxCan_DestinationId_Ethernet1 or IfxCan_DestinationId_Ethernet2*/
    eobufConfig.B.DID = config->ethernetOutputBuffer1.destinationId;
    eobufConfig.B.HE  = config->ethernetOutputBuffer1.headerEnable;
    eobufConfig.B.TTM = config->ethernetOutputBuffer1.triggerMode;
    eobuf1->CONFIG.U  = eobufConfig.U;

    /*MAC Configurations*/
    Ifx_DRE_EOBUF_MAC *mac1 = &(eobuf1->MAC);
    mac1->H0.B.DA0 = config->ethernetOutputBuffer1.macDestinationAddress0;
    mac1->H1.U     = config->ethernetOutputBuffer1.macDestinationAddress1;
    mac1->H2.U     = config->ethernetOutputBuffer1.macSourceAddress0;
    mac1->H3.U     = (config->ethernetOutputBuffer1.macSourceAddress1 + (config->ethernetOutputBuffer1.tpId << 16));

    h4.U           = 0;
    h4.B.VTAG_L    = (config->ethernetOutputBuffer1.vlanTag & 0x00FF);
    h4.B.VTAG_H    = (config->ethernetOutputBuffer1.vlanTag >> 8);
    h4.B.AVTPET_L  = (config->ethernetOutputBuffer1.avtpEtherType & 0x00FF);
    h4.B.AVTPET_H  = (config->ethernetOutputBuffer1.avtpEtherType >> 8);
    mac1->H4.U     = h4.U;

    /*NTSCF and STREAM ID Configurations*/
    Ifx_DRE_EOBUF_NTSCF *ntscf1 = &(eobuf1->NTSCF);
    ntscf1->H0.B.SV = config->ethernetOutputBuffer1.isStreamIdValid;
    ntscf1->H0.B.SN = config->ethernetOutputBuffer1.ntscfSequenceNumber;

    if (config->ethernetOutputBuffer1.isStreamIdValid)
    {
        ntscf1->STREAM0_ID.B.ID0 = ((config->ethernetOutputBuffer1.streamIdHigher & 0xFF000000) >> 24); /* Stream ID [63:54] */
        ntscf1->STREAM0_ID.B.ID1 = ((config->ethernetOutputBuffer1.streamIdHigher & 0x00FF0000) >> 16); /* Stream ID [53:48] */
        ntscf1->STREAM0_ID.B.ID2 = ((config->ethernetOutputBuffer1.streamIdHigher & 0x0000FF00) >> 8);  /* Stream ID [47:40] */
        ntscf1->STREAM0_ID.B.ID3 = ((config->ethernetOutputBuffer1.streamIdHigher & 0x000000FF));       /* Stream ID [39:32] */

        ntscf1->STREAM1_ID.B.ID4 = ((config->ethernetOutputBuffer1.streamIdLower & 0xFF000000) >> 24);  /* Stream ID [31:24] */
        ntscf1->STREAM1_ID.B.ID5 = ((config->ethernetOutputBuffer1.streamIdLower & 0x00FF0000) >> 16);  /* Stream ID [23:16] */
        ntscf1->STREAM1_ID.B.ID6 = ((config->ethernetOutputBuffer1.streamIdLower & 0x0000FF00) >> 8);   /* Stream ID [15:8] */
        ntscf1->STREAM1_ID.B.ID7 = ((config->ethernetOutputBuffer1.streamIdLower & 0x000000FF));        /* Stream ID [7:0] */
    }

    /*Clear Status bit*/
    eobuf1->STATUS.B.TXREQ = 1; /*Write of 1 clears the bit set by H/w*/
    eobuf1->STATUS.B.BF    = 1;
    eobuf1->STATUS.B.TTL   = 1;

    /*Transmit Trigger Configurations*/
    ttc.U = 0;

    if (config->ethernetOutputBuffer1.triggerMode == IfxDre_TriggerMode_bufferFillLevel)
    {
        ttc.B.BUFT = config->ethernetOutputBuffer1.bufferThreshold; /*Must be less than max ACF Payload*/
    }
    else if (config->ethernetOutputBuffer1.triggerMode == IfxDre_TriggerMode_frameCount)
    {
        ttc.B.TFL = config->ethernetOutputBuffer1.triggerFillLevel;
    }
    else if (config->ethernetOutputBuffer1.triggerMode == IfxDre_TriggerMode_timeTriggered)
    {
        ttc.B.CLKSEL      = config->ethernetOutputBuffer1.timer.clock;
        ttc.B.TP          = config->ethernetOutputBuffer1.timer.timerPrescalar;
        eobuf1->TTS.B.TRV = config->ethernetOutputBuffer1.timer.timerReloadValue;
    }

    eobuf1->TTC.U = ttc.U;

    /*EIBUF Config*/
    /*Buffer 0*/
    Ifx_DRE_EIBUF       *eibuf0 = &(dreSFR->EIBUF[0]);
    eibuf0->SA.U = (config->ethernetInputBuffer0.bufferStartAddress & 0xFFF8);

    Ifx_DRE_EIBUF_CONFIG eibufConfig;
    eibufConfig.U          = 0;
    eibufConfig.B.NTSCF_SA = (config->ethernetInputBuffer0.ntscfStartAddress & 0xFFFC);
    eibufConfig.B.SIZE     = config->ethernetInputBuffer0.bufferSize;
    eibufConfig.B.RRF      = config->ethernetInputBuffer0.enableRejectRemoteFrame;
    eibuf0->CONFIG.U       = eibufConfig.U;

    eibuf0->STATUS.B.BPRC  = 1;  /*Clear Pending Request*/

    /*Buffer 1*/
    Ifx_DRE_EIBUF *eibuf1 = &(dreSFR->EIBUF[1]);
    eibuf1->SA.U           = (config->ethernetInputBuffer1.bufferStartAddress & 0xFFF8);

    eibufConfig.U          = 0;
    eibufConfig.B.NTSCF_SA = (config->ethernetInputBuffer1.ntscfStartAddress & 0xFFFC);
    eibufConfig.B.SIZE     = config->ethernetInputBuffer1.bufferSize;
    eibufConfig.B.RRF      = config->ethernetInputBuffer1.enableRejectRemoteFrame;
    eibuf1->CONFIG.U       = eibufConfig.U;

    eibuf1->STATUS.B.BPRC  = 1;  /*Clear Pending Request*/

    /*Interrupt Configurations*/
    /*Clear All Interrupt Enable Bits*/
    dreSFR->IE.U = 0;

    volatile Ifx_SRC_SRCR *src;

    IfxDre_InterruptLine   index = IfxDre_InterruptLine_0;

    for (index = IfxDre_InterruptLine_0; index <= IfxDre_InterruptLine_15; index++)
    {
        if (config->interruptCfg[index].enable)
        {
            src = (volatile Ifx_SRC_SRCR *)&(MODULE_SRC.DRE[index]);
            IfxSrc_init(src, config->interruptCfg[index].typeOfService, config->interruptCfg[index].priority, config->interruptCfg[index].vmId);
            IfxSrc_enable(src);
            IfxDre_setInterruptEnable(dreSFR, TRUE, index);
        }
    }
}


void IfxDre_Dre_initModuleConfig(IfxDre_Dre_Config *config, Ifx_DRE *dre)
{
    const IfxDre_Dre_Config defaultConfig = {
        .dre                         = NULL_PTR,
        .canInputBufferStartAddress  = 0,
        .numberOfCanInputBuffers     = 32,
        .inputDataSize               = IfxDre_DataFieldSize_64,
        .canOutputBufferStartAddress = 0,
        .numberOfCanOutputBuffers    = 64,
        .outputDataSize              = IfxDre_DataFieldSize_64,

        .rt0Config                   = {
            .address = 0,
            .size    = 0
        },

#ifdef IFX_CFG_TC49A_DELTA

        .rt1Config                   = {
            .address = 0,
            .size    = 0
        },
        .rt2Config                   = {
            .address = 0,
            .size    = 0
        },
        .rt3Config                   = {
            .address = 0,
            .size    = 0
        },

#endif

#ifdef IFX_CFG_TC49A_DELTA
        .streamFilter0               = {
            .enable            = FALSE,
            .mode              = IfxDre_StreamFilterMode_classic,
            .routingTableIndex = 0,
            .filter1LowerId    = 0,
            .filter1HigherId   = 0,
            .filter2LowerId    = 0,
            .filter2HigherId   = 0,
            .sourceId          = IfxDre_SIDF_FC_SourceId_1
        },
        .streamFilter1               = {
            .enable            = FALSE,
            .mode              = IfxDre_StreamFilterMode_classic,
            .routingTableIndex = 0,
            .filter1LowerId    = 0,
            .filter1HigherId   = 0,
            .filter2LowerId    = 0,
            .filter2HigherId   = 0,
            .sourceId          = IfxDre_SIDF_FC_SourceId_1
        },
        .streamFilter2               = {
            .enable            = FALSE,
            .mode              = IfxDre_StreamFilterMode_classic,
            .routingTableIndex = 0,
            .filter1LowerId    = 0,
            .filter1HigherId   = 0,
            .filter2LowerId    = 0,
            .filter2HigherId   = 0,
            .sourceId          = IfxDre_SIDF_FC_SourceId_1
        },
        .streamFilter3               = {
            .enable            = FALSE,
            .mode              = IfxDre_StreamFilterMode_classic,
            .routingTableIndex = 0,
            .filter1LowerId    = 0,
            .filter1HigherId   = 0,
            .filter2LowerId    = 0,
            .filter2HigherId   = 0,
            .sourceId          = IfxDre_SIDF_FC_SourceId_1
        },
        .streamFilter4               = {
            .enable            = FALSE,
            .mode              = IfxDre_StreamFilterMode_classic,
            .routingTableIndex = 0,
            .filter1LowerId    = 0,
            .filter1HigherId   = 0,
            .filter2LowerId    = 0,
            .filter2HigherId   = 0,
            .sourceId          = IfxDre_SIDF_FC_SourceId_1
        },
        .streamFilter5               = {
            .enable            = FALSE,
            .mode              = IfxDre_StreamFilterMode_classic,
            .routingTableIndex = 0,
            .filter1LowerId    = 0,
            .filter1HigherId   = 0,
            .filter2LowerId    = 0,
            .filter2HigherId   = 0,
            .sourceId          = IfxDre_SIDF_FC_SourceId_1
        },
        .streamFilter6               = {
            .enable            = FALSE,
            .mode              = IfxDre_StreamFilterMode_classic,
            .routingTableIndex = 0,
            .filter1LowerId    = 0,
            .filter1HigherId   = 0,
            .filter2LowerId    = 0,
            .filter2HigherId   = 0,
            .sourceId          = IfxDre_SIDF_FC_SourceId_1
        },
        .streamFilter7               = {
            .enable            = FALSE,
            .mode              = IfxDre_StreamFilterMode_classic,
            .routingTableIndex = 0,
            .filter1LowerId    = 0,
            .filter1HigherId   = 0,
            .filter2LowerId    = 0,
            .filter2HigherId   = 0,
            .sourceId          = IfxDre_SIDF_FC_SourceId_1
        },
#endif
        .mem0Cfg                     = {
            .enable                 = FALSE,
            .address                = 0,
            .resourcePartitionIndex = 0,
            .appendStatus           = 0,
            .appendTiming           = 0,
            .interruptNodePointer   = IfxDre_DMemInterruptLine_0,
            .offsetAddress          = 0,
            .waterMarkLevel         = 0,
            .wrapAroundLevel        = 0
        },

        .mem1Cfg                     = {
            .enable                 = FALSE,
            .address                = 0,
            .resourcePartitionIndex = 0,
            .appendStatus           = 0,
            .appendTiming           = 0,
            .interruptNodePointer   = IfxDre_DMemInterruptLine_0,
            .offsetAddress          = 0,
            .waterMarkLevel         = 0,
            .wrapAroundLevel        = 0
        },

        .mem2Cfg                     = {
            .enable                 = FALSE,
            .address                = 0,
            .resourcePartitionIndex = 0,
            .appendStatus           = 0,
            .appendTiming           = 0,
            .interruptNodePointer   = IfxDre_DMemInterruptLine_0,
            .offsetAddress          = 0,
            .waterMarkLevel         = 0,
            .wrapAroundLevel        = 0
        },

        .mem3Cfg                     = {
            .enable                 = FALSE,
            .address                = 0,
            .resourcePartitionIndex = 0,
            .appendStatus           = 0,
            .appendTiming           = 0,
            .interruptNodePointer   = IfxDre_DMemInterruptLine_0,
            .offsetAddress          = 0,
            .waterMarkLevel         = 0,
            .wrapAroundLevel        = 0
        },

        .mem4Cfg                     = {
            .enable                 = FALSE,
            .address                = 0,
            .resourcePartitionIndex = 0,
            .appendStatus           = 0,
            .appendTiming           = 0,
            .interruptNodePointer   = IfxDre_DMemInterruptLine_0,
            .offsetAddress          = 0,
            .waterMarkLevel         = 0,
            .wrapAroundLevel        = 0
        },

        .mem5Cfg                     = {
            .enable                 = FALSE,
            .address                = 0,
            .resourcePartitionIndex = 0,
            .appendStatus           = 0,
            .appendTiming           = 0,
            .interruptNodePointer   = IfxDre_DMemInterruptLine_0,
            .offsetAddress          = 0,
            .waterMarkLevel         = 0,
            .wrapAroundLevel        = 0
        },

        .mem6Cfg                     = {
            .enable                 = FALSE,
            .address                = 0,
            .resourcePartitionIndex = 0,
            .appendStatus           = 0,
            .appendTiming           = 0,
            .interruptNodePointer   = IfxDre_DMemInterruptLine_0,
            .offsetAddress          = 0,
            .waterMarkLevel         = 0,
            .wrapAroundLevel        = 0
        },

        .mem7Cfg                     = {
            .enable                 = FALSE,
            .address                = 0,
            .resourcePartitionIndex = 0,
            .appendStatus           = 0,
            .appendTiming           = 0,
            .interruptNodePointer   = IfxDre_DMemInterruptLine_0,
            .offsetAddress          = 0,
            .waterMarkLevel         = 0,
            .wrapAroundLevel        = 0
        },

        .mem8Cfg                     = {
            .enable                 = FALSE,
            .address                = 0,
            .resourcePartitionIndex = 0,
            .appendStatus           = 0,
            .appendTiming           = 0,
            .interruptNodePointer   = IfxDre_DMemInterruptLine_0,
            .offsetAddress          = 0,
            .waterMarkLevel         = 0,
            .wrapAroundLevel        = 0
        },

        .mem9Cfg                     = {
            .enable                 = FALSE,
            .address                = 0,
            .resourcePartitionIndex = 0,
            .appendStatus           = 0,
            .appendTiming           = 0,
            .interruptNodePointer   = IfxDre_DMemInterruptLine_0,
            .offsetAddress          = 0,
            .waterMarkLevel         = 0,
            .wrapAroundLevel        = 0
        },

        .mem10Cfg                    = {
            .enable                 = FALSE,
            .address                = 0,
            .resourcePartitionIndex = 0,
            .appendStatus           = 0,
            .appendTiming           = 0,
            .interruptNodePointer   = IfxDre_DMemInterruptLine_0,
            .offsetAddress          = 0,
            .waterMarkLevel         = 0,
            .wrapAroundLevel        = 0
        },

        .mem11Cfg                    = {
            .enable                 = FALSE,
            .address                = 0,
            .resourcePartitionIndex = 0,
            .appendStatus           = 0,
            .appendTiming           = 0,
            .interruptNodePointer   = IfxDre_DMemInterruptLine_0,
            .offsetAddress          = 0,
            .waterMarkLevel         = 0,
            .wrapAroundLevel        = 0
        },

        .mem12Cfg                    = {
            .enable                 = FALSE,
            .address                = 0,
            .resourcePartitionIndex = 0,
            .appendStatus           = 0,
            .appendTiming           = 0,
            .interruptNodePointer   = IfxDre_DMemInterruptLine_0,
            .offsetAddress          = 0,
            .waterMarkLevel         = 0,
            .wrapAroundLevel        = 0
        },

        .mem13Cfg                    = {
            .enable                 = FALSE,
            .address                = 0,
            .resourcePartitionIndex = 0,
            .appendStatus           = 0,
            .appendTiming           = 0,
            .interruptNodePointer   = IfxDre_DMemInterruptLine_0,
            .offsetAddress          = 0,
            .waterMarkLevel         = 0,
            .wrapAroundLevel        = 0
        },

        .mem14Cfg                    = {
            .enable                 = FALSE,
            .address                = 0,
            .resourcePartitionIndex = 0,
            .appendStatus           = 0,
            .appendTiming           = 0,
            .interruptNodePointer   = IfxDre_DMemInterruptLine_0,
            .offsetAddress          = 0,
            .waterMarkLevel         = 0,
            .wrapAroundLevel        = 0
        },

        .mem15Cfg                    = {
            .enable                 = FALSE,
            .address                = 0,
            .resourcePartitionIndex = 0,
            .appendStatus           = 0,
            .appendTiming           = 0,
            .interruptNodePointer   = IfxDre_DMemInterruptLine_0,
            .offsetAddress          = 0,
            .waterMarkLevel         = 0,
            .wrapAroundLevel        = 0
        },

        .mem16Cfg                    = {
            .enable                 = FALSE,
            .address                = 0,
            .resourcePartitionIndex = 0,
            .appendStatus           = 0,
            .appendTiming           = 0,
            .interruptNodePointer   = IfxDre_DMemInterruptLine_0,
            .offsetAddress          = 0,
            .waterMarkLevel         = 0,
            .wrapAroundLevel        = 0
        },

        .mem17Cfg                    = {
            .enable                 = FALSE,
            .address                = 0,
            .resourcePartitionIndex = 0,
            .appendStatus           = 0,
            .appendTiming           = 0,
            .interruptNodePointer   = IfxDre_DMemInterruptLine_0,
            .offsetAddress          = 0,
            .waterMarkLevel         = 0,
            .wrapAroundLevel        = 0
        },

        .mem18Cfg                    = {
            .enable                 = FALSE,
            .address                = 0,
            .resourcePartitionIndex = 0,
            .appendStatus           = 0,
            .appendTiming           = 0,
            .interruptNodePointer   = IfxDre_DMemInterruptLine_0,
            .offsetAddress          = 0,
            .waterMarkLevel         = 0,
            .wrapAroundLevel        = 0
        },

        .mem19Cfg                    = {
            .enable                 = FALSE,
            .address                = 0,
            .resourcePartitionIndex = 0,
            .appendStatus           = 0,
            .appendTiming           = 0,
            .interruptNodePointer   = IfxDre_DMemInterruptLine_0,
            .offsetAddress          = 0,
            .waterMarkLevel         = 0,
            .wrapAroundLevel        = 0
        },

        .mem20Cfg                    = {
            .enable                 = FALSE,
            .address                = 0,
            .resourcePartitionIndex = 0,
            .appendStatus           = 0,
            .appendTiming           = 0,
            .interruptNodePointer   = IfxDre_DMemInterruptLine_0,
            .offsetAddress          = 0,
            .waterMarkLevel         = 0,
            .wrapAroundLevel        = 0
        },

        .mem21Cfg                    = {
            .enable                 = FALSE,
            .address                = 0,
            .resourcePartitionIndex = 0,
            .appendStatus           = 0,
            .appendTiming           = 0,
            .interruptNodePointer   = IfxDre_DMemInterruptLine_0,
            .offsetAddress          = 0,
            .waterMarkLevel         = 0,
            .wrapAroundLevel        = 0
        },

        .mem22Cfg                    = {
            .enable                 = FALSE,
            .address                = 0,
            .resourcePartitionIndex = 0,
            .appendStatus           = 0,
            .appendTiming           = 0,
            .interruptNodePointer   = IfxDre_DMemInterruptLine_0,
            .offsetAddress          = 0,
            .waterMarkLevel         = 0,
            .wrapAroundLevel        = 0
        },

        .mem23Cfg                    = {
            .enable                 = FALSE,
            .address                = 0,
            .resourcePartitionIndex = 0,
            .appendStatus           = 0,
            .appendTiming           = 0,
            .interruptNodePointer   = IfxDre_DMemInterruptLine_0,
            .offsetAddress          = 0,
            .waterMarkLevel         = 0,
            .wrapAroundLevel        = 0
        },

        .mem24Cfg                    = {
            .enable                 = FALSE,
            .address                = 0,
            .resourcePartitionIndex = 0,
            .appendStatus           = 0,
            .appendTiming           = 0,
            .interruptNodePointer   = IfxDre_DMemInterruptLine_0,
            .offsetAddress          = 0,
            .waterMarkLevel         = 0,
            .wrapAroundLevel        = 0
        },

        .mem25Cfg                    = {
            .enable                 = FALSE,
            .address                = 0,
            .resourcePartitionIndex = 0,
            .appendStatus           = 0,
            .appendTiming           = 0,
            .interruptNodePointer   = IfxDre_DMemInterruptLine_0,
            .offsetAddress          = 0,
            .waterMarkLevel         = 0,
            .wrapAroundLevel        = 0
        },

        .mem26Cfg                    = {
            .enable                 = FALSE,
            .address                = 0,
            .resourcePartitionIndex = 0,
            .appendStatus           = 0,
            .appendTiming           = 0,
            .interruptNodePointer   = IfxDre_DMemInterruptLine_0,
            .offsetAddress          = 0,
            .waterMarkLevel         = 0,
            .wrapAroundLevel        = 0
        },

        .mem27Cfg                    = {
            .enable                 = FALSE,
            .address                = 0,
            .resourcePartitionIndex = 0,
            .appendStatus           = 0,
            .appendTiming           = 0,
            .interruptNodePointer   = IfxDre_DMemInterruptLine_0,
            .offsetAddress          = 0,
            .waterMarkLevel         = 0,
            .wrapAroundLevel        = 0
        },

        .ethernetOutputBuffer0       = {
            .startAddress           = 0,
            .payloadLength          = 0,
            .destinationId          = IfxCan_DestinationId_Ethernet1,
            .headerEnable           = FALSE,
            .triggerMode            = IfxDre_TriggerMode_frameCount,
            .macDestinationAddress0 = 0,
            .macDestinationAddress1 = 0,
            .macSourceAddress0      = 0,
            .macSourceAddress1      = 0,
            .tpId                   = 0, /*0x8100 for tagged ethernet frames*/
            .vlanTag                = 0,
            .avtpEtherType          = 0, /*0x22F0 for AVTP frames */
            .isStreamIdValid        = FALSE,
            .ntscfSequenceNumber    = 0,
            .streamIdLower          = 0,
            .streamIdHigher         = 0,
            .bufferThreshold        = 0,
            .triggerFillLevel       = 0,
            .timer                  = {
                .clock            = IfxDre_TriggerClock_none,
                .timerPrescalar   = 0,
                .timerReloadValue = 0
            }
        },

        .ethernetOutputBuffer1       = {
            .startAddress           = 0,
            .payloadLength          = 0,
            .destinationId          = IfxCan_DestinationId_none,
            .headerEnable           = FALSE,
            .triggerMode            = IfxDre_TriggerMode_frameCount,
            .macDestinationAddress0 = 0,
            .macDestinationAddress1 = 0,
            .macSourceAddress0      = 0,
            .macSourceAddress1      = 0,
            .tpId                   = 0, /*0x8100 for tagged ethernet frames*/
            .vlanTag                = 0,
            .avtpEtherType          = 0, /*0x22F0 for AVTP frames */
            .isStreamIdValid        = FALSE,
            .ntscfSequenceNumber    = 0,
            .streamIdLower          = 0,
            .streamIdHigher         = 0,
            .bufferThreshold        = 0,
            .triggerFillLevel       = 0,
            .timer                  = {
                .clock            = IfxDre_TriggerClock_none,
                .timerPrescalar   = 0,
                .timerReloadValue = 0
            }
        },

        .ethernetInputBuffer0        = {
            .bufferStartAddress      = 0,
            .ntscfStartAddress       = 0,
            .bufferSize              = 0,
            .enableRejectRemoteFrame = 0
        },

        .ethernetInputBuffer1        = {
            .bufferStartAddress      = 0,
            .ntscfStartAddress       = 0,
            .bufferSize              = 0,
            .enableRejectRemoteFrame = 0
        },

        .interruptCfg                = {
            {
                .enable        = FALSE,
                .priority      = 0,
                .typeOfService = IfxSrc_Tos_cpu0,
                .vmId          = IfxSrc_VmId_0
            },
            {
                .enable        = FALSE,
                .priority      = 0,
                .typeOfService = IfxSrc_Tos_cpu0,
                .vmId          = IfxSrc_VmId_0
            },
            {
                .enable        = FALSE,
                .priority      = 0,
                .typeOfService = IfxSrc_Tos_cpu0,
                .vmId          = IfxSrc_VmId_0
            },
            {
                .enable        = FALSE,
                .priority      = 0,
                .typeOfService = IfxSrc_Tos_cpu0,
                .vmId          = IfxSrc_VmId_0
            },
            {
                .enable        = FALSE,
                .priority      = 0,
                .typeOfService = IfxSrc_Tos_cpu0,
                .vmId          = IfxSrc_VmId_0
            },
            {
                .enable        = FALSE,
                .priority      = 0,
                .typeOfService = IfxSrc_Tos_cpu0,
                .vmId          = IfxSrc_VmId_0
            },
            {
                .enable        = FALSE,
                .priority      = 0,
                .typeOfService = IfxSrc_Tos_cpu0,
                .vmId          = IfxSrc_VmId_0
            },
            {
                .enable        = FALSE,
                .priority      = 0,
                .typeOfService = IfxSrc_Tos_cpu0,
                .vmId          = IfxSrc_VmId_0
            },
            {
                .enable        = FALSE,
                .priority      = 0,
                .typeOfService = IfxSrc_Tos_cpu0,
                .vmId          = IfxSrc_VmId_0
            },
            {
                .enable        = FALSE,
                .priority      = 0,
                .typeOfService = IfxSrc_Tos_cpu0,
                .vmId          = IfxSrc_VmId_0
            },
            {
                .enable        = FALSE,
                .priority      = 0,
                .typeOfService = IfxSrc_Tos_cpu0,
                .vmId          = IfxSrc_VmId_0
            },
            {
                .enable        = FALSE,
                .priority      = 0,
                .typeOfService = IfxSrc_Tos_cpu0,
                .vmId          = IfxSrc_VmId_0
            },
            {
                .enable        = FALSE,
                .priority      = 0,
                .typeOfService = IfxSrc_Tos_cpu0,
                .vmId          = IfxSrc_VmId_0
            },
            {
                .enable        = FALSE,
                .priority      = 0,
                .typeOfService = IfxSrc_Tos_cpu0,
                .vmId          = IfxSrc_VmId_0
            },
            {
                .enable        = FALSE,
                .priority      = 0,
                .typeOfService = IfxSrc_Tos_cpu0,
                .vmId          = IfxSrc_VmId_0
            },
            {
                .enable        = FALSE,
                .priority      = 0,
                .typeOfService = IfxSrc_Tos_cpu0,
                .vmId          = IfxSrc_VmId_0
            }
        }
    };

    /* Default Configuration */
    *config = defaultConfig;

    /* take over module pointer */
    config->dre = dre;
}


void IfxDre_Dre_setSoftwareTrigger(IfxDre_Dre *dre, uint8 bufferIndex)
{
    Ifx_DRE_EOBUF *eobuf = &(dre->dre->EOBUF[bufferIndex]);
    eobuf->STATUS.B.TXRDY = 1;

    /*Wait till H/w clears the TXRDY flag when the Transmit Ethernet frame is prepared. */
    while (eobuf->STATUS.B.TXRDY == 1)
    {}
}


void IfxDre_Dre_setFilterAndRoutingElement(IfxDre_Dre *dre, uint8 tableIndex, uint8 elementIndex, IfxDre_Dre_RoutingConfig *config)
{
    /*Compute Address*/
    uint32            elementOffset       = elementIndex * 8;                                                                                           /*Size of Ifx_DRE_RT_RR is 8 bytes*/
    uint32            address             = (((uint32)&MODULE_DRE + 0x8000) + (dre->dre->RT[tableIndex].SA.U & IFX_DRE_RT_SA_ADR_MSK) + elementOffset); /*RAM address + RT Offset + Element Offset*/

    Ifx_Strict_64Bit *rountingRule64Ptr   = (Ifx_Strict_64Bit *)address;
    uint64            destinationConfig64 = 0;

    /*Configure the filter and destination configurations*/
    if (config->routingType == IfxDre_RoutingType_unicast)
    {
        /*Destination Configurations*/
        Ifx_DRE_RT_RE_UCR destinationConfig;

        /*Only CAN Destinations should be configured
         * because this routing is for CAN messages coming from Ethernet packet*/
        destinationConfig.B.DID  = config->destinationId1;
        destinationConfig.B.SID  = config->sourceId;
        destinationConfig.B.MODE = 0;

        destinationConfig64      = destinationConfig.U;
    }

#ifdef IFX_CFG_TC49A_DELTA
    else if (config->routingType == IfxDre_RoutingType_multicast)
    {
        /*Destination Configurations*/
        Ifx_DRE_RT_RE_MCR destinationConfig;

        /*Only CAN or Memory Destinations should be configured
         * because this routing is for CAN messages coming from Ethernet packet*/
        destinationConfig.B.DID0 = config->destinationId1;
        destinationConfig.B.DID1 = config->destinationId2;
        destinationConfig.B.DID2 = config->destinationId3;
        destinationConfig.B.DID3 = config->destinationId4;

        destinationConfig.B.SID  = config->sourceId;
        destinationConfig.B.MODE = 1;

        destinationConfig64      = destinationConfig.U;
    }
#endif
    /*CAN Acceptance Filter. Destination is taken from the RR element whose filter matches first.*/
    Ifx_DRE_RT_RE_CIDFC filter;

    filter.B.MODE   = config->filterMode;      /*IFX_CFG_TC49A_DELTA H/W Descoped Feature: Field is ignored and only classic filter mode is supported by default*/
    filter.B.CANID1 = config->canId1;
    filter.B.CANID2 = config->canId2;

#ifdef IFX_CFG_TC49A_DELTA
    filter.B.IDS = config->xtdShiftLength;
#else
    filter.B.IDS = 0;         /*IFX_CFG_TC49A_DELTA H/W Descoped Feature. To do: Recheck needed. RTL is implemented and Verification is pending*/
#endif

    *rountingRule64Ptr = ((destinationConfig64 << 32) + (filter.U));
}


void IfxDre_Dre_setCanAddressDatabaseElement(IfxDre_Dre *dre, IfxDre_Dre_CADConfig *config)
{
    /*Compute Address*/
    uint32             elementOffset = config->elementIndex * IFXDRE_CAD_CAN_OFFSET;           /*Size of Ifx_DRE_RT_RR is 8 bytes*/
    uint32             address       = (((uint32)&MODULE_DRE + 0x8000) + elementOffset);       /*RAM address + Element Offset*/

    Ifx_Strict_64Bit  *database64Ptr = (Ifx_Strict_64Bit *)address;
    uint64             lengthCfg64   = 0;

    Ifx_DRE_CAD_CAN_LC lengthCfg;
    lengthCfg.U = 0;

    /*Support only for Dynamic mode (IFX_CFG_TC49A_DELTA: Static mode descoped in HW)*/
    lengthCfg.B.RH0LM = 1;
    lengthCfg.B.RH1LM = 1;
    lengthCfg.B.THLM  = 1;
    lengthCfg64       = (uint64)lengthCfg.U;

    *database64Ptr    = ((lengthCfg64 << 32) + (config->creStartAddress));
}
