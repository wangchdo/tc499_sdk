/**
 * \file IfxI2c.c
 * \brief I2C  basic functionality
 *
 * \version iLLD_2_0_1_2_19
 * \copyright Copyright (c) 2023 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 */

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "IfxI2c.h"

/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxI2c_configureAsMaster(Ifx_I2C *i2c)
{
    // enter config Mode
    IfxI2c_stop(i2c);

    i2c->ADDRCFG.U      = 0;
    i2c->ADDRCFG.B.MNS  = 1; // master mode
    i2c->ADDRCFG.B.SONA = 0; // don't release the bus on NACK
    i2c->ADDRCFG.B.SOPE = 0; // after transfer go into master restart state
    i2c->ADDRCFG.B.TBAM = 0; // 7 bit address mode
    i2c->FIFOCFG.U      = 0;
    i2c->FIFOCFG.B.TXFC = 1; // FIFO as flow controller
    i2c->FIFOCFG.B.RXFC = 1; // FIFO as flow controller
    i2c->FIFOCFG.B.TXBS = 0; // Burst size 1 word
    i2c->FIFOCFG.B.RXBS = 0; // Burst size 1 word
    i2c->FIFOCFG.B.TXFA = 0; // fifo is byte aligned
    i2c->FIFOCFG.B.RXFA = 0; // fifo is byte aligned
}


void IfxI2c_disableModule(Ifx_I2C *i2c)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&i2c->PROTE, IfxApProt_State_config);

#endif

    i2c->CLC.B.DISR = 1;

    while (i2c->CLC.B.DISS == 0)
    {}

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&i2c->PROTE, IfxApProt_State_run);
#endif
}


void IfxI2c_enableDtrInterrupt(Ifx_I2C *i2c, IfxSrc_Tos typeOfService, uint16 priority, IfxSrc_VmId vmId)
{
    volatile Ifx_SRC_SRCR *src;
    src = IfxI2c_getDtrSrcPointer(i2c);
    IfxSrc_init(src, typeOfService, priority, vmId);
    IfxSrc_enable(src);
}


void IfxI2c_enableErrorInterrupt(Ifx_I2C *i2c, IfxSrc_Tos typeOfService, uint16 priority, IfxSrc_VmId vmId)
{
    volatile Ifx_SRC_SRCR *src;
    src = IfxI2c_getErrorSrcPointer(i2c);
    IfxSrc_init(src, typeOfService, priority, vmId);
    IfxSrc_enable(src);
}


void IfxI2c_enableModule(Ifx_I2C *i2c)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&i2c->PROTE, IfxApProt_State_config);
#endif

    i2c->CLC.B.DISR = 0U;

    while (i2c->CLC.B.DISS == 1U)
    {}

    i2c->CLC1.B.RMC = 1U;

    while (i2c->CLC1.B.RMC != 1U)
    {}

    i2c->CLC1.B.DISR = 0U;

    while (i2c->CLC1.B.DISS == 1U)
    {}

    // disable all interrupts
    i2c->ERRIRQSM.U = 0x00;
    i2c->PIRQSM.U   = 0x00;
    i2c->IMSC.U     = 0x00;

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&i2c->PROTE, IfxApProt_State_run);
#endif
}


void IfxI2c_enableProtocolInterrupt(void *i2c, IfxSrc_Tos typeOfService, uint16 priority, IfxSrc_VmId vmId)
{
    volatile Ifx_SRC_SRCR *src;
    src = IfxI2c_getProtocolSrcPointer(i2c);
    IfxSrc_init(src, typeOfService, priority, vmId);
    IfxSrc_enable(src);
}


Ifx_I2C *IfxI2c_getAddress(IfxI2c_Index i2c)
{
    Ifx_I2C *module;

    if (i2c < IFXI2C_NUM_MODULES)
    {
        module = (Ifx_I2C *)IfxI2c_cfg_indexMap[i2c].module;
    }
    else
    {
        module = NULL_PTR;
    }

    return module;
}


float32 IfxI2c_getBaudrate(Ifx_I2C *i2c)
{
    uint8  rmc     = i2c->CLC1.B.RMC;
#ifdef IFX_CFG_AURIX_SCUCCU_USED
    uint32 fKernel = IfxClock_getBaud1Frequency();
#else
    uint32 fKernel = IfxClock_getI2cFrequency();
#endif

    if (0 == i2c->FDIVHIGHCFG.U)
    {
        uint8  inc = i2c->FDIVCFG.B.INC;
        uint16 dec = i2c->FDIVCFG.B.DEC;
        return (float)(fKernel / rmc) / ((2 * dec / inc) + 3);
    }
    else
    {
        uint8  inc = i2c->FDIVHIGHCFG.B.INC;
        uint16 dec = i2c->FDIVHIGHCFG.B.DEC;
        return (float)(fKernel / rmc) / ((dec / inc * 5) + 2);
    }
}


IfxI2c_Index IfxI2c_getIndex(Ifx_I2C *i2c)
{
    uint32       index;
    IfxI2c_Index result;

    result = IfxI2c_Index_none;

    for (index = 0; index < IFXI2C_NUM_MODULES; index++)
    {
        if (IfxI2c_cfg_indexMap[index].module == i2c)
        {
            result = (IfxI2c_Index)IfxI2c_cfg_indexMap[index].index;
            break;
        }
    }

    return result;
}


void IfxI2c_initSclSdaPin(const IfxI2c_Scl_InOut *scl, const IfxI2c_Sda_InOut *sda, IfxPort_PadDriver padDriver)
{
    IfxPort_OutputMode mode = (IfxPort_OutputMode)IfxPort_Mode_outputOpenDrainGeneral;
    IfxPort_setPinModeOutput(scl->pin.port, scl->pin.pinIndex, mode, scl->outSelect);
    IfxPort_setPinModeOutput(sda->pin.port, sda->pin.pinIndex, mode, sda->outSelect);
    IfxPort_setPinPadDriver(scl->pin.port, scl->pin.pinIndex, padDriver);
    IfxPort_setPinPadDriver(sda->pin.port, sda->pin.pinIndex, padDriver);
    IfxI2c_setPinSelection(scl->module, (IfxI2c_PinSelect)scl->inSelect); // note: uses the same PISEL register like SDA
}


void IfxI2c_releaseBus(Ifx_I2C *i2c)
{
    // only set the set end of transmisson bit if bus is not free
    if (i2c->BUSSTAT.B.BS != IfxI2c_BusStatus_idle)
    {
        i2c->ENDDCTRL.B.SETEND = 1;

        // wait until bus is free
        while (IfxI2c_getProtocolInterruptSourceStatus(i2c, IfxI2c_ProtocolInterruptSource_transmissionEnd) == FALSE)
        {}

        IfxI2c_clearProtocolInterruptSource(i2c, IfxI2c_ProtocolInterruptSource_transmissionEnd);
    }
}


void IfxI2c_resetFifo(Ifx_I2C *i2c)
{
    /* reset FIFO */
    i2c->FIFOCFG.U      = 0x0;
    i2c->FIFOCFG.B.TXFC = 0U;
    i2c->FIFOCFG.B.RXFC = 0U;
    i2c->FIFOCFG.B.TXBS = 0U;
    i2c->FIFOCFG.B.RXBS = 0U;
    i2c->FIFOCFG.B.TXFA = 0U;
    i2c->FIFOCFG.B.RXFA = 0U;
}


void IfxI2c_resetModule(Ifx_I2C *i2c)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&i2c->PROTE, IfxApProt_State_config);
#endif

    i2c->RST.CTRLA.B.KRST = 1;           /* Only if both Kernel reset bits are set a reset is executed */
    i2c->RST.CTRLB.B.KRST = 1;
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&i2c->PROTE, IfxApProt_State_run);

#endif

    while (0 == i2c->RST.STAT.B.KRST)   /* Wait until reset is executed */

    {}

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&i2c->PROTE, IfxApProt_State_config);

#endif
    i2c->RST.CTRLB.B.STATCLR = 1;       /* Clear Kernel reset status bit */

    while (i2c->RST.STAT.B.KRST == 1)   /* Wait until KRST is cleared, only after this reset sequence is completed */
    {}

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&i2c->PROTE, IfxApProt_State_run);
#endif
}


void IfxI2c_setBaudrate(Ifx_I2C *i2c, float32 baudrate)
{
    uint32  fKernel = IfxClock_getI2cFrequency();
    uint8   rmc     = i2c->CLC1.B.RMC;
    float32 dec;

    if (baudrate > 400000)                              // for High Speed mode
    {
        dec = ((((fKernel / baudrate) * 46) - 92) / 5); // always: Inc = 46
    }
    else                                                // for Standard and fast mode
    {
        dec = (((fKernel / rmc) / baudrate) - 3) / 2;   // always: Inc = 1
    }

    // dec:inc must be at least 6
    if (dec < 6)
    {
        dec = 6;
    }
    else if (dec > (1 << IFX_I2C_FDIVCFG_DEC_LEN) - 1)
    {
        dec = (1 << IFX_I2C_FDIVCFG_DEC_LEN) - 1;
    }

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&i2c->PROTE, IfxApProt_State_config);

#endif

    /* Baudrate configuration */
    if (baudrate > 400000)
    {
        i2c->FDIVCFG.B.INC     = 5;
        i2c->FDIVCFG.B.DEC     = 0x1D2;

        i2c->FDIVHIGHCFG.B.INC = 46;
        i2c->FDIVHIGHCFG.B.DEC = (uint16)(dec + 0.5f);
    }
    else
    {
        i2c->FDIVCFG.B.INC = 1;
        i2c->FDIVCFG.B.DEC = (uint16)(dec + 0.5f);
    }

    i2c->TIMCFG.B.SDA_DEL_HD_DAT = 0x3F;
    i2c->TIMCFG.B.FS_SCL_LOW     = 1;
    i2c->TIMCFG.B.EN_SCL_LOW_LEN = 1;
    i2c->TIMCFG.B.SCL_LOW_LEN    = 0x20;

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&i2c->PROTE, IfxApProt_State_run);
#endif
}


void IfxI2c_configureHighSpeedMode(Ifx_I2C *i2c)
{
    // enter config Mode
    IfxI2c_stop(i2c);

    i2c->ADDRCFG.B.MCE  = 1; // master code enable
    i2c->ADDRCFG.B.SONA = 1;
    i2c->ADDRCFG.B.SOPE = 1;

    IfxI2c_run(i2c);
    IfxI2c_setTransmitPacketSize(i2c, 1);
    IfxI2c_writeFifo(i2c, IFXI2C_HIGHSPEED_MASTER_CODE); // Send the Master code to switch to high speed mode

    while (!(IfxI2c_getProtocolInterruptSourceStatus(i2c, IfxI2c_ProtocolInterruptSource_transmissionEnd)))
    {}

    IfxI2c_clearAllDtrInterruptSources(i2c);
    IfxI2c_clearAllProtocolInterruptSources(i2c);

    IfxI2c_stop(i2c);

    while (IfxI2c_getBusStatus(i2c) != 0U)
    {}
}


void IfxI2c_initApConfig(IfxI2c_ApConfig *config)
{
    IfxApProt_initConfig(&config->proteConfig);
    IfxApProt_initConfig(&config->protseConfig);
    IfxApApu_initConfig(&config->apuConfig);
}


void IfxI2c_initAp(Ifx_I2C *i2c, IfxI2c_ApConfig *config)
{
    /* Initialize the PROTs */
    IfxApProt_init((Ifx_PROT_PROT *)&i2c->PROTE, &config->proteConfig);
    IfxApProt_init((Ifx_PROT_PROT *)&i2c->PROTSE, &config->protseConfig);

    /* Change the state to CONFIG, Configure APU and set PROT state back to RUN */
    /* Initialize the APU */
    IfxApProt_setState((Ifx_PROT_PROT *)&i2c->PROTSE, IfxApProt_State_config);
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&i2c->ACCEN, &config->apuConfig);
    IfxApProt_setState((Ifx_PROT_PROT *)&i2c->PROTSE, IfxApProt_State_run);
}


IfxI2c_Status IfxI2c_read(IfxI2c_I2cStdDevice *i2cDevice, volatile uint8 *data, Ifx_SizeT size)
{
    IfxI2c_Status volatile status      = IfxI2c_Status_ok;
    Ifx_I2C               *i2c         = i2cDevice->i2c->i2c;
    uint32                 packet;
    uint16                 slAddr      = i2cDevice->deviceAddress;
    IfxI2c_AddressMode     addressMode = i2cDevice->addressMode;

    union data
    {
        uint32 packet;
        uint8  packetbyte[4];
    }      rxdata;

    rxdata.packet = 0;

    sint32 bytesToReceive = size;
    uint32 bytes;

    // bus free?
    if (IfxI2c_busIsFree(i2c) == FALSE)
    {
        status                    = IfxI2c_Status_busNotFree;
        i2cDevice->i2c->busStatus = IfxI2c_getBusStatus(i2c);
        i2cDevice->i2c->status    = status;
        return status;
    }

    IfxI2c_clearAllProtocolInterruptSources(i2c);
    IfxI2c_clearAllErrorInterruptSources(i2c);

    /* switch to highspeed mode if needed */
    if (i2cDevice->speedMode == IfxI2c_Mode_HighSpeed)
    {
        IfxI2c_setTransmitPacketSize(i2c, 1);
        IfxI2c_writeFifo(i2c, IFXI2C_HIGHSPEED_MASTER_CODE | 0x1); // Send the Master code to switch to high speed mode
#if !defined(IFX_CFG_VP_PLATFORM)

        // wait until packet is sent
        while (IfxI2c_getProtocolInterruptSourceStatus(i2c, IfxI2c_ProtocolInterruptSource_transmissionEnd) == FALSE)
        {}

        // check status
        if (IfxI2c_getProtocolInterruptSourceStatus(i2c, IfxI2c_ProtocolInterruptSource_notAcknowledgeReceived) == FALSE)
        {
            // the MASTER_CODE should not be responded, must be always shows a NAK
            IfxI2c_clearAllProtocolInterruptSources(i2c);
            status                    = IfxI2c_Status_error;
            IfxI2c_releaseBus(i2c);
            i2cDevice->i2c->busStatus = IfxI2c_getBusStatus(i2c);
            i2cDevice->i2c->status    = status;
            return status;
        }

#endif
        IfxI2c_clearAllProtocolInterruptSources(i2c);
        IfxI2c_clearAllDtrInterruptSources(i2c);
    }

    // send device address with RnW bit set
    if (addressMode == IfxI2c_AddressMode_10Bit)                                         /* for 10 bit slave address */
    {
        packet = ((0xF000) | ((slAddr & (0x3 << 8)) << 9) | (1 << 8) | (slAddr & 0xFF)); /* the first 3 parts of the RHS makes
                                                                                          * most significant 8 bits of the address and last(4th) part of RHS
                                                                                          * makes least significant 8 bits of the address*/
        IfxI2c_setTransmitPacketSize(i2c, 2);
    }
    else                                                                                 /* for 7 bit slave address */
    {
        packet = slAddr | 1;                                                             // set read bit
        IfxI2c_setTransmitPacketSize(i2c, 1);
    }

    IfxI2c_setReceivePacketSize(i2c, size); // set number of bytes to reveive
    IfxI2c_writeFifo(i2c, packet);

    /* Poll until aribtration lost, nack, or rx mode flag is reset */
    while ((i2c->PIRQSS.U & ((1 << IFX_I2C_PIRQSS_AL_OFF) | (1 << IFX_I2C_PIRQSM_TX_END_OFF) | (1 << IFX_I2C_PIRQSS_RX_OFF))) == FALSE)
    {}

    IfxI2c_clearAllDtrInterruptSources(i2c);

    /* check status*/
    if (i2c->ERRIRQSS.U)
    {
        IfxI2c_clearAllErrorInterruptSources(i2c);
        status = IfxI2c_Status_error;
    }

#if !defined(IFX_CFG_VP_PLATFORM)
    /*Check Arbitration Lost in Protocol Interrupts*/
    else if (i2c->PIRQSS.U & (1 << IFX_I2C_PIRQSS_AL_OFF))
    {
        i2c->PIRQSC.U = (1 << IFX_I2C_PIRQSS_AL_OFF);
        status        = IfxI2c_Status_al;
    }
    /*Check NACK in Protocol Interrupts*/
    else if (i2c->PIRQSS.U & (1 << IFX_I2C_PIRQSS_NACK_OFF))
    {
        i2c->PIRQSC.U = (1 << IFX_I2C_PIRQSS_NACK_OFF);
        status        = IfxI2c_Status_nak;
    }
#endif
    else if (size > 0)                                       // required to poll for nak

    {
        if (size > 32)                                       // if fifo is too small => disable global interrupts!
        {                                                    // assumes TC is faster than i2c and therefor a fifo overflow is not possible
            boolean intEnabled = IfxCpu_disableInterrupts(); // disable global interrupts to prevent fifo overflow
            uint32  i;

            for (i = 0; i < (uint32)size; i += 4)
            {
                if (bytesToReceive >= 4)
                {
                    bytes           = 4;
                    bytesToReceive -= 4;
                }
                else
                {
                    bytes          = bytesToReceive;
                    bytesToReceive = 0;
                }

                uint32 ris = 0;

                while (!(ris = i2c->RIS.U)) // wait for fifo request or error

                {}

                // check request flags
                if (ris & ((1 << IFX_I2C_RIS_LSREQ_INT_OFF) | (1 << IFX_I2C_RIS_SREQ_INT_OFF) | (1 << IFX_I2C_RIS_LBREQ_INT_OFF) | (1 << IFX_I2C_RIS_BREQ_INT_OFF)))
                {
                    rxdata.packet = i2c->RXD.U;
                    uint32 k;

                    for (k = 0; k < bytes; k++)
                    {
                        data[i + k] = rxdata.packetbyte[k];
                    }

                    IfxI2c_clearAllDtrInterruptSources(i2c);
                }

#if !defined(IFX_CFG_VP_PLATFORM)

                /* check errors. Must have enabled corresponding bits in Mask registers*/
                if (ris & (1 << IFX_I2C_RIS_I2C_ERR_INT_OFF)) // error flags
                {
                    IfxI2c_clearAllErrorInterruptSources(i2c);
                    status = IfxI2c_Status_error;
                    break;
                }

                /* check protocol interrupts. Must have enabled corresponding bits in Mask registers*/
                if (ris & (1 << IFX_I2C_RIS_I2C_P_INT_OFF)) // check protocol flags
                {
                    /*Check Arbitration Lost*/
                    if (i2c->PIRQSS.U & (1 << IFX_I2C_PIRQSS_AL_OFF))
                    {
                        i2c->PIRQSC.U = (1 << IFX_I2C_PIRQSS_AL_OFF);
                        status        = IfxI2c_Status_al;
                        break;
                    }

                    /*Check NACK*/
                    else if (i2c->PIRQSS.U & (1 << IFX_I2C_PIRQSS_NACK_OFF))
                    {
                        i2c->PIRQSC.U = (1 << IFX_I2C_PIRQSS_NACK_OFF);
                        status        = IfxI2c_Status_nak;
                        break;
                    }

                    /*Check TX_END*/
                    if (i2c->PIRQSS.U & (1 << IFX_I2C_PIRQSS_TX_END_OFF))
                    {
                        /*Should not be cleared here, otherwise it will cause infinite while loop*/
                        status = IfxI2c_Status_ok; //Default value of status. Still kept for readability*/
                    }

                    /*Check and clear Address Match, General Call, Master Code and Receive Mode*/
                    if (i2c->PIRQSS.U & ((1 << IFX_I2C_PIRQSS_AM_OFF) | (1 << IFX_I2C_PIRQSS_GC_OFF) | (1 << IFX_I2C_PIRQSS_MC_OFF) | (1 << IFX_I2C_PIRQSS_RX_OFF)))
                    {
                        /*Just clearing the bits. Status need not be updated*/
                        i2c->PIRQSC.U = ((1 << IFX_I2C_PIRQSS_AM_OFF) | (1 << IFX_I2C_PIRQSS_GC_OFF) | (1 << IFX_I2C_PIRQSS_MC_OFF) | (1 << IFX_I2C_PIRQSS_RX_OFF));
                    }
                }

#endif
            }

            IfxCpu_restoreInterrupts(intEnabled); // (re-) enable global interrupts

            // TX_END: transmission finished
            while (IfxI2c_getProtocolInterruptSourceStatus(i2c, IfxI2c_ProtocolInterruptSource_transmissionEnd) == FALSE)
            {}

            IfxI2c_clearProtocolInterruptSource(i2c, IfxI2c_ProtocolInterruptSource_transmissionEnd);
        }
        else
        {
            // wait until all bytes are received
            while (IfxI2c_getProtocolInterruptSourceStatus(i2c, IfxI2c_ProtocolInterruptSource_transmissionEnd) == FALSE)
            {}

            IfxI2c_clearProtocolInterruptSource(i2c, IfxI2c_ProtocolInterruptSource_transmissionEnd);

#if !defined(IFX_CFG_VP_PLATFORM)
            // check errors
            uint32 ris;
            ris = i2c->RIS.U;

            if (ris & (1 << IFX_I2C_RIS_I2C_ERR_INT_OFF)) // error flags
            {
                IfxI2c_clearAllErrorInterruptSources(i2c);
                status = IfxI2c_Status_error;
            }

            else if (ris & (1 << IFX_I2C_RIS_I2C_P_INT_OFF)) // check protocol flags
            {
                if (i2c->PIRQSS.U & (1 << IFX_I2C_PIRQSS_AL_OFF))
                {
                    i2c->PIRQSC.U = (1 << IFX_I2C_PIRQSS_AL_OFF);
                    status        = IfxI2c_Status_al;
                }

                else if (i2c->PIRQSS.U & (1 << IFX_I2C_PIRQSS_NACK_OFF))
                {
                    i2c->PIRQSC.U = (1 << IFX_I2C_PIRQSS_NACK_OFF);
                    status        = IfxI2c_Status_nak;
                }

                /*Clear remaining flags*/
                /*	Check and clear Address Match, General Call, Master Code, Transmission End and Receive Mode*/
                if (i2c->PIRQSS.U & ((1 << IFX_I2C_PIRQSS_AM_OFF) | (1 << IFX_I2C_PIRQSS_GC_OFF) | (1 << IFX_I2C_PIRQSS_MC_OFF) | (1 << IFX_I2C_PIRQSS_TX_END_OFF) | (1 << IFX_I2C_PIRQSS_RX_OFF)))
                {
                    /*Just clearing the bits. Status need not be updated*/
                    i2c->PIRQSC.U = ((1 << IFX_I2C_PIRQSS_AM_OFF) | (1 << IFX_I2C_PIRQSS_GC_OFF) | (1 << IFX_I2C_PIRQSS_MC_OFF) | (1 << IFX_I2C_PIRQSS_TX_END_OFF) | (1 << IFX_I2C_PIRQSS_RX_OFF));
                }
            }

#endif

            if ((status != IfxI2c_Status_error) && (status != IfxI2c_Status_al) && (status != IfxI2c_Status_nak))
            {
                // read fifo
                uint32 i;

                for (i = 0; i < (uint32)size; i += 4)
                {
                    if (bytesToReceive >= 4)
                    {
                        bytes           = 4;
                        bytesToReceive -= 4;
                    }
                    else
                    {
                        bytes          = bytesToReceive;
                        bytesToReceive = 0;
                    }

                    uint32 k;
                    rxdata.packet = i2c->RXD.U;
                    IfxI2c_clearAllDtrInterruptSources(i2c);

                    for (k = 0; k < bytes; k++)
                    {
                        data[i + k] = rxdata.packetbyte[k];
                    }
                }
            }
        }
    }

    IfxI2c_clearAllErrorInterruptSources(i2c);
    IfxI2c_clearAllProtocolInterruptSources(i2c);

    if (!i2cDevice->enableRepeatedStart)
    {
        IfxI2c_releaseBus(i2c);
    }
    else
    {
        //wait until bus is free
        while (IfxI2c_getProtocolInterruptSourceStatus(i2c, IfxI2c_ProtocolInterruptSource_transmissionEnd) == FALSE)
        {}

        IfxI2c_clearProtocolInterruptSource(i2c, IfxI2c_ProtocolInterruptSource_transmissionEnd);
    }

    i2cDevice->i2c->busStatus = IfxI2c_getBusStatus(i2c);
    i2cDevice->i2c->status    = status;
    return status;
}


IfxI2c_Status IfxI2c_write(IfxI2c_I2cStdDevice *i2cDevice, volatile uint8 *data, Ifx_SizeT size)
{
    IfxI2c_Status      status      = IfxI2c_Status_ok;
    Ifx_I2C           *i2c         = i2cDevice->i2c->i2c;
    uint16             addr        = i2cDevice->deviceAddress;
    uint16             slAddr;
    IfxI2c_AddressMode addressMode = i2cDevice->addressMode;
    union data
    {
        uint32 packet;
        uint8  packetbyte[4];
    }      txdata;

    sint32 bytesToSend = size + 1; // +1 slave device address
    uint32 bytes;

    if (IfxI2c_busIsFree(i2c) == FALSE)
    {
        status                    = IfxI2c_Status_busNotFree;
        i2cDevice->i2c->busStatus = IfxI2c_getBusStatus(i2c);
        i2cDevice->i2c->status    = status;
        return status;
    }

    IfxI2c_clearAllProtocolInterruptSources(i2c);
    IfxI2c_clearAllErrorInterruptSources(i2c);

    /* switch to highspeed mode if needed */
    if (i2cDevice->speedMode == IfxI2c_Mode_HighSpeed)
    {
        IfxI2c_setTransmitPacketSize(i2c, 1);
        IfxI2c_writeFifo(i2c, IFXI2C_HIGHSPEED_MASTER_CODE); // Send the Master code to switch to high speed mode

        // wait until packet is sent
        while (IfxI2c_getProtocolInterruptSourceStatus(i2c, IfxI2c_ProtocolInterruptSource_transmissionEnd) == FALSE)
        {}

        // check status
#if !defined(IFX_CFG_VP_PLATFORM)

        if (IfxI2c_getProtocolInterruptSourceStatus(i2c, IfxI2c_ProtocolInterruptSource_notAcknowledgeReceived) == FALSE)
        {
            // the MASTER_CODE should not be responded, must be always shows a NAK
            IfxI2c_clearAllProtocolInterruptSources(i2c);
            status                    = IfxI2c_Status_error;
            IfxI2c_releaseBus(i2c);
            i2cDevice->i2c->busStatus = IfxI2c_getBusStatus(i2c);
            i2cDevice->i2c->status    = status;
            return status;
        }

#endif
        IfxI2c_clearAllProtocolInterruptSources(i2c);
        IfxI2c_clearAllDtrInterruptSources(i2c);
    }

    // try to seize control, if not return
    if (addressMode == IfxI2c_AddressMode_10Bit)                                                /* for 10 bit slave address */
    {
        slAddr = (uint16)((0xF000) | ((addr & (0x3 << 8)) << 9) | (~(1 << 8)) | (addr & 0xFF)); /* the first 3 parts of the RHS makes
                                                                                                 * most significant 8 bits of the address and last(4th) part of RHS
                                                                                                 * makes least significant 8 bits of the address*/
    }
    else                                                                                        /* for 7 bit slave address */
    {
        slAddr = (uint16)(addr & 0xfe);
    }

    if (size > 0)   // write i2c device

    {
        uint32  i, j = 0;

        // assumes TC is faster then i2c and therefor a fifo underflow is not possible
        boolean intEnabled = IfxCpu_disableInterrupts(); // disable global interrupts to prevent FIFO underflow
        IfxI2c_setTransmitPacketSize(i2c, size + 1);

        for (i = 0; i < (uint32)(size + 1); i += 4)
        {
            if (bytesToSend >= 4)
            {
                bytes        = 4;
                bytesToSend -= 4;
            }
            else
            {
                bytes       = bytesToSend;
                bytesToSend = 0;
            }

            txdata.packet = 0;

            for (j = 0; j < bytes; j++)
            {
                if (addressMode == IfxI2c_AddressMode_10Bit)
                {
                    if ((i == 0) && (j < 2))
                    {
                        if (j == 0)
                        {
                            txdata.packetbyte[j] = (uint8)((slAddr & 0xff00) >> 8);
                        }
                        else
                        {
                            txdata.packetbyte[j] = (uint8)(slAddr & 0x00ff);
                        }
                    }
                    else
                    {
                        txdata.packetbyte[j] = (uint8)data[i + j - 1];
                    }
                }

                else
                {
                    if ((i == 0) && (j == 0))
                    {
                        txdata.packetbyte[j] = (uint8)slAddr;
                    }

                    else
                    {
                        txdata.packetbyte[j] = (uint8)data[i + j - 1];
                    }
                }
            }

#if !defined(IFX_CFG_VP_PLATFORM)

            do
            {
                // check errors
                uint32 ris;
                ris = i2c->RIS.U;

                if (ris & (1 << IFX_I2C_RIS_I2C_P_INT_OFF)) // check protocol flags
                {
                    IfxI2c_clearAllProtocolInterruptSources(i2c);
                    status = IfxI2c_Status_error;
                }

                if (ris & (1 << IFX_I2C_RIS_I2C_ERR_INT_OFF)) // error flags
                {
                    IfxI2c_clearAllErrorInterruptSources(i2c);
                    status = IfxI2c_Status_error;
                }
            } while (i2c->FFSSTAT.B.FFS == 8 && status != IfxI2c_Status_error); // wait to prevent FIFO overflow

            if (status == IfxI2c_Status_error)
            {
                break;
            }

#endif
            IfxI2c_writeFifo(i2c, txdata.packet);

            /* our write to FIFO will trigger any of the request source, we wait for it */
            while (!(i2c->RIS.U)) // wait for fifo request or error
            {}

            IfxI2c_clearAllDtrInterruptSources(i2c);
        }

        IfxCpu_restoreInterrupts(intEnabled); // (re-) enable global interrupts

        // wait until all bytes are sent
        while (IfxI2c_getProtocolInterruptSourceStatus(i2c, IfxI2c_ProtocolInterruptSource_transmissionEnd) == FALSE)
        {}

        IfxI2c_clearProtocolInterruptSource(i2c, IfxI2c_ProtocolInterruptSource_transmissionEnd);
#if !defined(IFX_CFG_VP_PLATFORM)
        // finally check errors
        uint32 ris;
        ris = i2c->RIS.U;

        if (ris & (1 << IFX_I2C_RIS_I2C_P_INT_OFF)) // check protocol flags
        {
            IfxI2c_clearAllProtocolInterruptSources(i2c);
            status = IfxI2c_Status_error;
        }

        if (ris & (1 << IFX_I2C_RIS_I2C_ERR_INT_OFF)) // error flags
        {
            IfxI2c_clearAllErrorInterruptSources(i2c);
            status = IfxI2c_Status_error;
        }

#endif
    }

    if (!i2cDevice->enableRepeatedStart)
    {
        IfxI2c_releaseBus(i2c);
    }
    else
    {
        //wait until bus is free
        while (IfxI2c_getProtocolInterruptSourceStatus(i2c, IfxI2c_ProtocolInterruptSource_transmissionEnd) == FALSE)
        {}

        IfxI2c_clearProtocolInterruptSource(i2c, IfxI2c_ProtocolInterruptSource_transmissionEnd);
    }

    i2cDevice->i2c->busStatus = IfxI2c_getBusStatus(i2c);
    i2cDevice->i2c->status    = status;
    return status;
}


void IfxI2c_configureAccessToI2cs(IfxApApu_ApuConfig *apConfig)
{
    uint8 index;

    for (index = 0; index < IFXI2C_NUM_MODULES; index++)
    {
        Ifx_I2C *i2c = (Ifx_I2C *)(((uint32)&MODULE_I2C0) + index * ((uint32)&MODULE_I2C1 - (uint32)&MODULE_I2C0));
        IfxApApu_init((Ifx_ACCEN_ACCEN *)&i2c->ACCEN, apConfig);
    }
}


void IfxI2c_configureAsSlave(Ifx_I2C *i2c)
{
    i2c->ADDRCFG.B.MNS = 0;  // slave mode
}


void IfxI2c_configureAddrFifo(Ifx_I2C *i2c, const IfxI2c_Config *config)
{
    // Note: I2C should not be running. Use IfxI2c_stop() before calling this api.

    i2c->ADDRCFG.B.ADR  = config->addressConfig.slaveAddress;
    i2c->ADDRCFG.B.GCE  = config->addressConfig.generalCallEnable;
    i2c->ADDRCFG.B.MCE  = config->addressConfig.masterCodeEnable;
    i2c->ADDRCFG.B.SONA = config->addressConfig.stopOnNotAcknowledge;
    i2c->ADDRCFG.B.SOPE = config->addressConfig.stopOnPacketEnd;
    i2c->ADDRCFG.B.TBAM = config->addressConfig.addressMode;

    i2c->FIFOCFG.B.TXFC = config->fifoConfig.txFifoFlowControl;
    i2c->FIFOCFG.B.RXFC = config->fifoConfig.rxFifoFlowControl;
    i2c->FIFOCFG.B.TXBS = config->fifoConfig.txBurstSize;
    i2c->FIFOCFG.B.RXBS = config->fifoConfig.rxBurstSize;
    i2c->FIFOCFG.B.TXFA = config->fifoConfig.txFifoAlignment;
    i2c->FIFOCFG.B.RXFA = config->fifoConfig.rxFifoAlignment;
}
