/**
 * \file IfxXspi_Spi.c
 * \brief XSPI SPI details
 *
 * \version iLLD_2_0_1_2_19
 * \copyright Copyright (c) 2023 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 */

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "IfxXspi_Spi.h"

/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

IfxXspi_Status IfxXspi_Spi_initModule(IfxXspi_Spi *xspi, const IfxXspi_Spi_Config *config)
{
    Ifx_XSPI      *xspiSFR = config->xspi;                      /* pointer to XSPI Registers*/
    IfxXspi_Status status  = IfxXspi_Status_noError;

    xspi->xspi = xspiSFR;                                       /* adding register pointer to module handler*/

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&xspiSFR->PROTE, IfxApProt_State_config);
#endif
    xspiSFR->CLC.B.DISR = 0;
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&xspiSFR->PROTE, IfxApProt_State_run);
#endif

    xspiSFR->SSIENR.B.SSIC_EN = IfxXspi_Dwc_Mode_Disable;       /* Disable DWC_SSI*/

    /* Configuring Control Register 0 */
    {
        Ifx_XSPI_CTRLR0 ctrlr0;
        ctrlr0.U                 = xspiSFR->CTRLR0.U;

        ctrlr0.B.FRF             = 0;                                       /* Selects which serial protocol transfers the data 0:spi */
        ctrlr0.B.CFS             = config->control.controlFrameSize;        /* Control Frame Size*/
        ctrlr0.B.SPI_FRF         = config->control.spiFrameFormat;          /* Frame Format for Transmission */
        ctrlr0.B.TMOD            = config->control.transferMode;            /* TMOD (Selects the mode of transfer for serial communication)*/
        ctrlr0.B.SPI_HYPERBUS_EN = config->control.hyperbusEnable;          /* Hyperbus*/
        ctrlr0.B.DFS             = config->control.dataFrameSize;           /* Data Frame Size*/
        ctrlr0.B.SRL             = config->control.loopBack;                /* Shift Register Loop (LoopBack)*/
        ctrlr0.B.SSTE            = config->control.slaveSelectToggle;       /* Slave Select Toggle*/
        ctrlr0.B.SCPOL           = config->control.clockPolarity;           /* ClockPolarity*/
        ctrlr0.B.SCPH            = config->control.clockPhase;              /* ClockPhase*/

        xspiSFR->CTRLR0.U        = ctrlr0.U;
    }
    xspiSFR->CTRLR1.B.NDF = config->control.numberOfDataFrames;

    /* Configuring SPI_CTRLR0 - SPI Control Register */
    {
        Ifx_XSPI_SPI_CTRLR0 spi_ctrlr0;
        spi_ctrlr0.U                  = xspiSFR->SPI_CTRLR0.U;

        spi_ctrlr0.B.CLK_STRETCH_EN   = config->enhancedControl.clockStretchEnable;         /* Clock Stretching */
        spi_ctrlr0.B.SPI_RXDS_EN      = config->enhancedControl.spiRxdsEnable;              /* rxds signaling during address and command phase of Hypebus transfer */
        spi_ctrlr0.B.SPI_DM_EN        = config->enhancedControl.spiDataMaskEnable;          /* SPI data mask enable */
        spi_ctrlr0.B.SPI_RXDS_EN      = config->enhancedControl.spiRxdsEnable;              /* Read data strobe enable */
        spi_ctrlr0.B.INST_DDR_EN      = config->enhancedControl.instDdrEnable;              /* Instruction DDR Enable(enable Dual-data rate transfer for Instruction phase) */
        spi_ctrlr0.B.SPI_DDR_EN       = config->enhancedControl.spiDdrEnable;               /* SPI DDR Enable(enable Dual-data rate transfers) */
        spi_ctrlr0.B.WAIT_CYCLES      = config->enhancedControl.waitCycles;                 /* Wait cycles in Dual/Quad/Octal mode */
        spi_ctrlr0.B.INST_L           = config->enhancedControl.instLength;                 /* Length of Instruction */
        spi_ctrlr0.B.ADDR_L           = config->enhancedControl.addressLength;              /* Length of Address */
        spi_ctrlr0.B.TRANS_TYPE       = config->enhancedControl.transferFormat;             /* Address and instruction transfer format */

        xspiSFR->SPI_CTRLR0.U         = spi_ctrlr0.U;

        xspiSFR->DDR_DRIVE_EDGE.B.TDE = config->enhancedControl.ddrTxDriveEdge;     /* DDR Transmit Drive Edge */
    }

    {
        // Fsclk_out =	Fssi_clk/SCKDVwhere SCKDV is any even value between 2 and 65534
        xspiSFR->BAUDR.B.SCKDV = (IfxClock_getXspiFrequency() / config->timing.baudrate);   /* Configuring Baud Rate Select */

        /* Configuring RX Sample Delay Register */
        //xspiSFR->RX_SAMPLE_DELAY.U.RSD    = config.baudrate.rxDataSampleDelay;	/* Receive Data (rxd) Sample Delay */
        //xspiSFR->RX_SAMPLE_DELAY.B.SE     = config.baudrate.rxeDataSamplingEdge;	/* Receive Data (rxd) Sampling Edge */
    }

    {
        /* Configuring Transmit FIFO Threshold Level */
        xspiSFR->TXFTLR.B.TXFTHR = config->fifoControl.transferStartFifoLevel;      /* Transfer start FIFO level */
        xspiSFR->TXFTLR.B.TFT    = config->fifoControl.txFifoThreshold;             /* Transmit Fifo Bus Threshold */

        /* Configuring Receive FIFO Threshold Level */
        xspiSFR->RXFTLR.B.RFT = config->fifoControl.rxFifoThreshold;
    }

    {
        /* Configuring Interrupt Mask Register */
        Ifx_XSPI_IMR imr;
        imr.U          = xspiSFR->IMR.U;

        imr.B.DONEM    = config->interruptConfig.interruptMask.doneInterruptMask;                   /**<\Done Interrupt Mask*/
        imr.B.TXUIM    = config->interruptConfig.interruptMask.txFifoUnderFlowInterruptMask;        /**<\Transmit FIFO Underflow Interrupt Mask*/
        imr.B.RXFIM    = config->interruptConfig.interruptMask.rxFifoFullInterruptMask;             /**<\Receive FIFO Full Interrupt Mask*/
        imr.B.RXOIM    = config->interruptConfig.interruptMask.rxFifoOverFlowInterruptMask;         /**<\Receive FIFO Overflow Interrupt Mask*/
        imr.B.RXUIM    = config->interruptConfig.interruptMask.rxFifoUnderFlowInterruptMask;        /**<\Receive FIFO Underflow Interrupt Mask*/
        imr.B.TXOIM    = config->interruptConfig.interruptMask.txFifoOverFlowInterruptMask;         /**<\Transmit FIFO Overflow Interrupt Mask*/
        imr.B.TXEIM    = config->interruptConfig.interruptMask.txFifoEmptyInterruptMask;            /**<\Transmit FIFO Empty Interrupt Mask*/

        xspiSFR->IMR.U = imr.U;
    }

    {
        /* Configuring DMA */

        Ifx_XSPI_DMACR dmacr;
        dmacr.U          = xspiSFR->DMACR.U;

        dmacr.B.IDMAE    = config->dmaConfig->internalDmaEnable;    /**<\ DMA Enable*/
        dmacr.B.AINC     = config->dmaConfig->addressIncrement;     /**<\ Address Increment (increment the AXI address on every transfer)*/
        dmacr.B.TDMAE    = config->dmaConfig->txFifoDmaEnable;      /**<\ Transmit Fifo DMA Enable*/
        dmacr.B.RDMAE    = config->dmaConfig->rxFifoDmaEnable;      /**<\ Receive Fifo DMA Enable*/
        dmacr.B.ATW      = config->dmaConfig->transferwidth;        /**<\ AXI transfer width for DMA transfers*/
        dmacr.B.ACACHE   = 0;
        dmacr.B.APROT    = 0;
        dmacr.B.AID      = 0;

        xspiSFR->DMACR.U = dmacr.U;

        /* Configuring Source and Destination Burst Length */
        xspiSFR->AXIAWLEN.B.AWLEN = config->dmaConfig->destinationBurstLength;
        xspiSFR->AXIARLEN.B.ARLEN = config->dmaConfig->sourceBurstLength;
    }

    /* initialising the interrupts */
    if ((config->interruptConfig.fifoPriority != 0) || (config->interruptConfig.fifoIntTypeOfService == IfxSrc_Tos_dma0) || (config->interruptConfig.fifoIntTypeOfService == IfxSrc_Tos_dma1))
    {
        volatile Ifx_SRC_SRCR *src = (volatile Ifx_SRC_SRCR *)IfxXspi_getSrcPointerFifo(xspiSFR);
        IfxSrc_init(src, config->interruptConfig.fifoIntTypeOfService, config->interruptConfig.fifoPriority, config->interruptConfig.vmId);
        IfxSrc_enable(src);
    }

    if ((config->interruptConfig.errorPriority != 0))
    {
        volatile Ifx_SRC_SRCR *src = IfxXspi_getSrcPointerError(xspiSFR);
        IfxSrc_init(src, config->interruptConfig.errorIntTypeOfService, config->interruptConfig.errorPriority, config->interruptConfig.vmId);
        IfxSrc_enable(src);
    }

    xspiSFR->SSIENR.B.SSIC_EN = IfxXspi_Dwc_Mode_Enable;        /* Enable DWC_SSI*/
    return status;
}


void IfxXspi_Spi_initModuleConfig(IfxXspi_Spi_Config *config, Ifx_XSPI *xspi)
{
    IfxXspi_Spi_DmaConfig    dmaDefaultConfig = {
        .txFifoDmaEnable        = 0,
        .rxFifoDmaEnable        = 0,
        .internalDmaEnable      = 0,
        .addressIncrement       = 0,
        .destinationBurstLength = 0,
        .sourceBurstLength      = 0,
        .dmaTxDataLevel         = 0,
        .dmaRxDataLevel         = 0,
        .transferwidth          = IfxXspi_TransferWidth_1,
    };
    const IfxXspi_Spi_Config defaultConfig = {
        .xspi    = NULL_PTR,

        .control = {
//					.frameFormat        = 0,										/*Selects which serial protocol transfers the data*/
            .spiFrameFormat     = IfxXspi_SpiFrameFormat_Std,                       /*Frame Format for Transmission */
            .transferMode       = IfxXspi_TransferMode_TxRx,                        /*TMOD (Selects the mode of transfer for serial communication)*/
            .dataFrameSize      = IfxXspi_DataframeSize_32,                         /*Data Frame Size*/
            .controlFrameSize   = 1,                                                /*Control Frame Size*/
            .numberOfDataFrames = 2,                                                /*Number of Data Frames*/
            .loopBack           = IfxXspi_ShiftRegisterLoop_NormalMode,             /*Shift Register Loop (LoopBack)*/
            .slaveSelectToggle  = IfxXspi_SlaveSelectToggle_Disable,                /*Slave Select Toggle*/
            .clockPolarity      = IfxXspi_ClockPolarity_InactiveHigh,               /*ClockPolarity*/
            .clockPhase         = IfxXspi_ClockPhase_StartBit,                      /*ClockPhase*/
            .hyperbusEnable     = IfxXspi_Hyperbus_Disable,                         /*Hyperbus*/
        },

        .timing                                           = {
            .baudrate           = 100000.0f,                /*value of the required baudrate*/
            .rxDataSampleDelay  = 0,                        /*Receive Data (rxd) Sample Delay*/
            .rxDataSamplingEdge = 0                         /*Receive Data (rxd) Sampling Edge*/
        },

        .fifoControl                                      = {
            .transferStartFifoLevel = 1,                    /*Transmit start Fifo Level*/
            .txFifoThreshold        = 1,                    /*Transmit Fifo Bus Threshold*/
            .rxFifoThreshold        = 1,                    /*Receive Fifo Bus Threshold*/
        },

        .interruptConfig                                  = {
            .fifoPriority                                 = 0,               /*xSPI FIFO  Service Request 0*/
            .errorPriority                                = 0,               /*xSPI Interface Error Service Request*/
            .vmId                                         = IfxSrc_VmId_0,   /* vmId index */
            .fifoIntTypeOfService                         = IfxSrc_Tos_cpu0, /* Fifo type of interrupt service */
            .errorIntTypeOfService                        = IfxSrc_Tos_cpu0, /* Error type of interrupt service */
            .interruptMask.doneInterruptMask              = IfxXspi_InterruptMask_UnMask,
            .interruptMask.errorInterruptMask             = IfxXspi_InterruptMask_UnMask,
            .interruptMask.txFifoUnderFlowInterruptMask   = IfxXspi_InterruptMask_UnMask,
            .interruptMask.xipRxFifoOverFlowInterruptMask = IfxXspi_InterruptMask_UnMask,
            .interruptMask.multiMasterInterruptMask       = IfxXspi_InterruptMask_UnMask,
            .interruptMask.rxFifoFullInterruptMask        = IfxXspi_InterruptMask_UnMask,
            .interruptMask.rxFifoOverFlowInterruptMask    = IfxXspi_InterruptMask_UnMask,
            .interruptMask.rxFifoUnderFlowInterruptMask   = IfxXspi_InterruptMask_UnMask,
            .interruptMask.txFifoOverFlowInterruptMask    = IfxXspi_InterruptMask_UnMask,
            .interruptMask.txFifoEmptyInterruptMask       = IfxXspi_InterruptMask_UnMask,
        },

        .dmaConfig       = &dmaDefaultConfig,

        .enhancedControl = {
            .clockStretchEnable  = 1,                                           /*No Clock Stretch Enable */
            .spiRxdsSignalEnable = 0,                                           /*No rxds signaling during address and command phase of Hypebus transfer*/
            .spiDataMaskEnable   = 0,                                           /*No data mask enable bit*/
            .spiRxdsEnable       = 0,                                           /*No Read data strobe bit enable*/
            .instDdrEnable       = 0,                                           /*No Instruction DDR bit Enable*/
            .spiDdrEnable        = 0,                                           /*No SPI DDR Enable*/
            .waitCycles          = 0,                                           /*Wait cycles in Dual/Quad/Octal mode*/
            .ddrTxDriveEdge      = 0,                                           /*DDR Transmit Drive Edge*/
            .instLength          = IfxXspi_InstructionLength_L4,                /*Length of Instruction*/
            .addressLength       = IfxXspi_AddressLength_L4,                    /*Length of Address*/
            .transferFormat      = IfxXspi_TransferFormat_TT0,                  /*Address and instruction transfer format*/
        }
    };

    *config      = defaultConfig; /*Default Config*/
    config->xspi = xspi;          /*Module Pointer*/
}


IfxXspi_Spi_Status IfxXspi_Spi_dmaExchange(IfxXspi_Spi *xspi, IfxXspi_Spi_DmaJobConfig *dmaJob)
{
    IfxXspi_Spi_Status status = {0};

    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, xspi->xspi->CTRLR0.B.SPI_FRF != IfxXspi_SpiFrameFormat_Std);

    if (xspi->transferInProgress == 0)
    {
        xspi->transferInProgress     = 1;                        /* setting transfer in progress status */

        xspi->xspi->SSIENR.B.SSIC_EN = IfxXspi_Dwc_Mode_Disable; /* Enable DWC_SSI*/
        xspi->xspi->CTRLR0.B.TMOD    = dmaJob->transferMode;

        switch (dmaJob->transferMode)
        {
        case IfxXspi_TransferMode_TxRx:
            // DMA transfer not applicable for TX_AND_RX mode.
            break;

        case IfxXspi_TransferMode_Rx:
        case IfxXspi_TransferMode_EepromRead:

            // for Rx only , should we send a dummy byte i.e write dummy byte to DR?
            xspi->xspi->CTRLR1.B.NDF             = dmaJob->numberOfDataFrames;
            xspi->xspi->DMACR.B.AINC             = dmaJob->addressIncrement;
            xspi->xspi->AXIAR0.U                 = (uint32)dmaJob->data;
            xspi->xspi->SPIAR.B.SDAR             = dmaJob->spiDeviceAddress;
            xspi->xspi->SPIDR.B.SPI_INST         = dmaJob->SpiInstruction;
            xspi->xspi->SPI_CTRLR0.B.WAIT_CYCLES = dmaJob->waitCycles;
            xspi->xspi->SPI_CTRLR0.B.ADDR_L      = dmaJob->addressLength;

            // configure intr masks
            xspi->xspi->IMR.B.RXFIM = IfxXspi_InterruptMask_Mask;
            xspi->xspi->IMR.B.RXUIM = IfxXspi_InterruptMask_Mask;
            xspi->xspi->IMR.B.RXOIM = IfxXspi_InterruptMask_Mask;

            xspi->xspi->IMR.B.TXOIM = 0;
            xspi->xspi->IMR.B.TXEIM = 0;
            xspi->xspi->IMR.B.TXUIM = 0;

            break;

        case IfxXspi_TransferMode_Tx:
            xspi->xspi->CTRLR1.B.NDF             = dmaJob->numberOfDataFrames;
            xspi->xspi->DMACR.B.AINC             = dmaJob->addressIncrement;
            xspi->xspi->AXIAR0.U                 = (uint32)dmaJob->data;
            xspi->xspi->SPIAR.B.SDAR             = dmaJob->spiDeviceAddress;
            xspi->xspi->SPIDR.B.SPI_INST         = dmaJob->SpiInstruction;
            xspi->xspi->SPI_CTRLR0.B.WAIT_CYCLES = dmaJob->waitCycles;
            xspi->xspi->SPI_CTRLR0.B.ADDR_L      = dmaJob->addressLength;

            /* Configure interrupts */
            xspi->xspi->IMR.B.TXOIM = IfxXspi_InterruptMask_Mask;
            xspi->xspi->IMR.B.TXEIM = IfxXspi_InterruptMask_Mask;
            xspi->xspi->IMR.B.TXUIM = IfxXspi_InterruptMask_Mask;
            xspi->xspi->IMR.B.RXFIM = 0;
            xspi->xspi->IMR.B.RXUIM = 0;
            xspi->xspi->IMR.B.RXOIM = 0;

            break;
        }

        xspi->xspi->SER.B.SER        = dmaJob->slaveSelectEnable; //slave select
        xspi->xspi->SSIENR.B.SSIC_EN = IfxXspi_Dwc_Mode_Enable;   /* Enable DWC_SSI*/
    }

    return status;
}


void IfxXspi_Spi_fillTxBuffer(IfxXspi_Spi *xspi)
{
    Ifx_XSPI        *xspiSFR    = xspi->xspi;
    IfxXspi_Spi_Job *job        = &xspi->job;
    uint32           i;
    uint32           prev_count = 0;
    uint32           count;

    if (job->txpending)
    {
        if (job->txdata != NULL_PTR)
        {
            //job->txpending = ((job->txpending) - count);
            while (job->txpending != 0)
            {
                if (xspiSFR->SR.B.TFNF == 1)
                {
                    count          = (uint32)(16 - xspiSFR->TXFLR.B.TXTFL);
                    count          = __min(job->txpending, count);
                    job->txpending = job->txpending - count;

                    if (xspiSFR->CTRLR0.B.DFS <= 8)
                    {
                        IfxXspi_write8(xspiSFR, &(((uint8 *)job->txdata)[prev_count]), count);
                    }
                    else if (xspiSFR->CTRLR0.B.DFS <= 16)
                    {
                        IfxXspi_write16(xspiSFR, &(((uint16 *)job->txdata)[prev_count]), count);               /* 16 bit DataframeSize per transfer*/
                    }
                    else
                    {
                        IfxXspi_write32(xspiSFR, &(((uint32 *)job->txdata)[prev_count]), count);               /* 32 bit DataframeSize per transfer*/
                    }

                    prev_count = prev_count + count;
                }
            }
        }
        else
        {
            count = job->txpending;

            for (i = 0; i < count; i++)
            {
                xspiSFR->DR0.U = (~0);
            }
        }

        while ((xspi->xspi->SR.B.TFE == 0) || (xspi->xspi->SR.B.BUSY == 1))
        {}

        if ((xspi->xspi->CTRLR0.B.TMOD == IfxXspi_TransferMode_Tx) && (job->txpending == 0))
        {
            xspiSFR->SSIENR.B.SSIC_EN = IfxXspi_Dwc_Mode_Disable;       /* Disable DWC_SSI for Tx only */
        }
    }
}


boolean IfxXspi_Spi_exchange(IfxXspi_Spi *xspi, IfxXspi_Spi_CpuJobConfig *jobConfig)
{
    boolean status = 0;

    if (xspi->transferInProgress == 0)
    {
        xspi->xspi->SSIENR.B.SSIC_EN = IfxXspi_Dwc_Mode_Disable; /* Disable DWC_SSI*/

        xspi->transferInProgress     = 1;                        /* setting transfer in progress status */
        xspi->job.txdata             = jobConfig->txdata;        /* data to be transmitted */
        xspi->job.txpending          = jobConfig->txcount;       /* count of Tx data */
        xspi->job.rxdata             = jobConfig->rxdata;        /* empty buffer to receive data */
        xspi->job.rxpending          = jobConfig->rxcount;       /* count of Rx data */
        xspi->xspi->CTRLR0.B.TMOD    = jobConfig->transferMode;

        // clear intr on completion A read from this register clears the ssi_txo_intr/ssi_txu_intr interrupt
        {
            status  = xspi->xspi->TXEICR.B.TXEICR; //Clear Transmit FIFO Overflow/Underflow Interrupt.
            status |= xspi->xspi->RXOICR.B.RXOICR;
            status |= xspi->xspi->RXUICR.B.RXUICR;
            status |= xspi->xspi->AXIECR.B.AXIECR; //AXI Master Error Interrupt Clear Register
            status |= xspi->xspi->DONECR.B.DONECR; //Transfer Done Clear Interrupt Clear Register
        }

        switch (jobConfig->transferMode)
        {
        case IfxXspi_TransferMode_TxRx:
            xspi->xspi->IMR.B.RXFIM  = IfxXspi_InterruptMask_Mask;
            xspi->xspi->IMR.B.RXUIM  = IfxXspi_InterruptMask_Mask;
            xspi->xspi->IMR.B.RXOIM  = IfxXspi_InterruptMask_Mask;
            xspi->xspi->IMR.B.TXOIM  = IfxXspi_InterruptMask_Mask;
            xspi->xspi->IMR.B.TXEIM  = IfxXspi_InterruptMask_Mask;
            xspi->xspi->IMR.B.TXUIM  = IfxXspi_InterruptMask_Mask;
            xspi->xspi->CTRLR1.B.NDF = jobConfig->txcount;      //  here both tx and rx count are equal

            break;

        case IfxXspi_TransferMode_Rx:
            xspi->xspi->IMR.B.RXFIM  = IfxXspi_InterruptMask_Mask;
            xspi->xspi->IMR.B.RXUIM  = IfxXspi_InterruptMask_Mask;
            xspi->xspi->IMR.B.RXOIM  = IfxXspi_InterruptMask_Mask;

            xspi->xspi->IMR.B.TXOIM  = 0;
            xspi->xspi->IMR.B.TXEIM  = 0;
            xspi->xspi->IMR.B.TXUIM  = 0;

            xspi->xspi->CTRLR1.B.NDF = jobConfig->rxcount;

            break;

        case IfxXspi_TransferMode_Tx:
            xspi->xspi->IMR.B.TXOIM = IfxXspi_InterruptMask_Mask;
            xspi->xspi->IMR.B.TXEIM = IfxXspi_InterruptMask_Mask;
            xspi->xspi->IMR.B.TXUIM = IfxXspi_InterruptMask_Mask;

            xspi->xspi->IMR.B.RXFIM = 0;
            xspi->xspi->IMR.B.RXUIM = 0;
            xspi->xspi->IMR.B.RXOIM = 0;
            break;

        case IfxXspi_TransferMode_EepromRead:
            //send op code and address (as tx data) + dummy bytes to be added to tx buffer.. TBD
            // First Tx opcode, address and dummy bytes. so enable corresponding intr
            xspi->xspi->IMR.B.TXOIM = IfxXspi_InterruptMask_Mask;
            xspi->xspi->IMR.B.TXEIM = IfxXspi_InterruptMask_Mask;
            xspi->xspi->IMR.B.TXUIM = IfxXspi_InterruptMask_Mask;

#ifdef FOR_XSPI_SILICON
            xspi->xspi->CTRLR1.B.NDF             = jobConfig->rxcount - 1;
            xspi->xspi->SPI_CTRLR0.B.SPI_RXDS_EN = 0;
#else
            xspi->xspi->CTRLR1.B.NDF             = jobConfig->rxcount;
            xspi->xspi->SPI_CTRLR0.B.SPI_RXDS_EN = 1;
#endif

            break;
        }

        /* Enhanced SPI config */
        if (xspi->xspi->CTRLR0.B.SPI_FRF != IfxXspi_SpiFrameFormat_Std)
        {
            xspi->xspi->SPI_CTRLR0.B.WAIT_CYCLES = jobConfig->waitCycles;
            xspi->xspi->SPI_CTRLR0.B.ADDR_L      = jobConfig->addressLength;
            xspi->xspi->SPI_CTRLR0.B.INST_L      = jobConfig->instructionLength;
        }

        xspi->xspi->SSIENR.B.SSIC_EN = IfxXspi_Dwc_Mode_Enable; /* Enable DWC_SSI*/
        xspi->xspi->SER.B.SER        = jobConfig->slaveSelectEnable;

        if (jobConfig->transferMode != IfxXspi_TransferMode_Rx)
        {
            IfxXspi_Spi_fillTxBuffer(xspi);
        }
        else
        {
            xspi->xspi->DR0.U = 0xFFFFFFFFU;
        }
    }
    else
    {
        status = 1;
    }

    return status;
}


void IfxXspi_Spi_read(IfxXspi_Spi *xspi)
{
    Ifx_XSPI        *xspiSFR    = xspi->xspi;                               /* getting the pointer to XSPI registers from module handler */
    IfxXspi_Spi_Job *job        = &xspi->job;                               /* getting the rxJob structure from module handler */
    uint32           prev_count = 0;

    while ((job->rxpending > 0) && (job->rxdata != NULL_PTR))
    {
        if (xspiSFR->SR.B.RFNE == 1)
        {
            uint32 count = (uint32)(xspiSFR->RXFLR.B.RXTFL); /* get the readable count of Rx fifo */
            count          = __min(job->rxpending, count);   /* check for the end of the data */

            job->rxpending = job->rxpending - count;         /* discount the current reading count from job pending */

            /* read data up to the count based on the out width */
            if (xspiSFR->CTRLR0.B.DFS <= 8)
            {
                IfxXspi_read8(xspiSFR, job->rxdata, count);                  /* reading from Rx FIFO */
                job->rxdata = &(((uint8 *)job->rxdata)[prev_count + count]); /* pointing to the remaining data */
            }
            else if (xspiSFR->CTRLR0.B.DFS <= 16)
            {
                IfxXspi_read16(xspiSFR, job->rxdata, count);                  /* reading from Rx FIFO */
                job->rxdata = &(((uint16 *)job->rxdata)[prev_count + count]); /* pointing to the remaining data */
            }
            else
            {
                IfxXspi_read32(xspiSFR, job->rxdata, count);    /* 32 bit DataframeSize per transfer*/
                job->rxdata = &(((uint32 *)job->rxdata)[prev_count + count]);
            }

            prev_count = prev_count + count;
        }
    }

    if (job->rxpending == 0)
    {
        xspi->transferInProgress  = 0;                              /* clearing the transfer in progress status */
        xspi->xspi->SER.B.SER     = IfxXspi_SlaveSelectEnable_none; // disable Slave select
        xspiSFR->SSIENR.B.SSIC_EN = IfxXspi_Dwc_Mode_Disable;       /* disable DWC_SSI*/
    }
}


uint32 IfxXspi_Spi_isrReceive(IfxXspi_Spi *xspi)
{
    volatile uint32 status;
    IfxXspi_Spi_read(xspi);

    // clear intr on completion A read from this register clears the ssi_txo_intr/ssi_txu_intr interrupt
    status  = xspi->xspi->TXEICR.B.TXEICR; //Clear Transmit FIFO Overflow/Underflow Interrupt.
    status |= xspi->xspi->RXOICR.B.RXOICR;
    status |= xspi->xspi->RXUICR.B.RXUICR;
    status |= xspi->xspi->AXIECR.B.AXIECR; //AXI Master Error Interrupt Clear Register
    status |= xspi->xspi->DONECR.B.DONECR; //Transfer Done Clear Interrupt Clear Register

    return status;
}


void IfxXspi_Spi_getRawInterruptStatus(IfxXspi_Spi *xspi, IfxXspi_Spi_RawInterruptStatus *rawInterruptStatus)
{
    rawInterruptStatus->errorInterruptRawStatus             = (IfxXspi_InterruptStatus)xspi->xspi->ISR.B.AXIER;
    rawInterruptStatus->doneInterruptRawStatus              = (IfxXspi_InterruptStatus)xspi->xspi->ISR.B.DONER;
    rawInterruptStatus->txFifoUnderFlowInterruptRawStatus   = (IfxXspi_InterruptStatus)xspi->xspi->ISR.B.TXUIR;
    rawInterruptStatus->xipRxFifoOverFlowInterruptRawStatus = (IfxXspi_InterruptStatus)xspi->xspi->ISR.B.XRXOIS;
    rawInterruptStatus->rxFifoFullInterruptRawStatus        = (IfxXspi_InterruptStatus)xspi->xspi->ISR.B.RXFIS;
    rawInterruptStatus->rxFifoOverFlowInterruptRawStatus    = (IfxXspi_InterruptStatus)xspi->xspi->ISR.B.RXOIS;
    rawInterruptStatus->rxFifoUnderFlowInterruptRawStatus   = (IfxXspi_InterruptStatus)xspi->xspi->ISR.B.RXUIS;
    rawInterruptStatus->txFifoOverFlowInterruptRawStatus    = (IfxXspi_InterruptStatus)xspi->xspi->ISR.B.TXOIS;
    rawInterruptStatus->txFifoEmptyInterruptRawStatus       = (IfxXspi_InterruptStatus)xspi->xspi->ISR.B.TXEIS;
}


void IfxXspi_Spi_isrTransmit(IfxXspi_Spi *xspi)
{
    //transmit FIFO empty interrupt request
    IfxXspi_Spi_fillTxBuffer(xspi);

    if (xspi->xspi->CTRLR0.B.TMOD == IfxXspi_TransferMode_EepromRead)
    {
        // receive intr are enabled, afer transmit of opcode, address and dummy bytes.
        xspi->xspi->IMR.B.RXFIM = IfxXspi_InterruptMask_Mask;
        xspi->xspi->IMR.B.RXUIM = IfxXspi_InterruptMask_Mask;
        xspi->xspi->IMR.B.RXOIM = IfxXspi_InterruptMask_Mask;
    }

    // clear intr on completion on Txonly FIXME tbd
}


uint32 IfxXspi_Spi_isrDmaReceive(IfxXspi_Spi *xspi)
{
    volatile uint32 status = 0;
    xspi->transferInProgress     = 0;                              /* clearing the transfer in progress status */
    xspi->xspi->SER.B.SER        = IfxXspi_SlaveSelectEnable_none; // disable Slave select
    xspi->xspi->SSIENR.B.SSIC_EN = IfxXspi_Dwc_Mode_Disable;       /* disable DWC_SSI*/

    // clear intr on completion A read from this register clears the ssi_txo_intr/ssi_txu_intr interrupt
    status  = xspi->xspi->TXEICR.B.TXEICR;                         //Clear Transmit FIFO Overflow/Underflow Interrupt.
    status |= xspi->xspi->RXOICR.B.RXOICR;
    status |= xspi->xspi->RXUICR.B.RXUICR;
    status |= xspi->xspi->AXIECR.B.AXIECR;                         //AXI Master Error Interrupt Clear Register
    status |= xspi->xspi->DONECR.B.DONECR;                         //Transfer Done Clear Interrupt Clear Register

    return status;
}


void IfxXspi_Spi_isrDmaTransmit(IfxXspi_Spi *xspi)
{
    /* TX only and job complete, disable SSIC  */
    if (xspi->xspi->CTRLR0.B.TMOD == IfxXspi_TransferMode_Tx)
    {
        xspi->xspi->SSIENR.B.SSIC_EN = IfxXspi_Dwc_Mode_Disable;        /* Disable DWC_SSI for Tx only */
    }

    // clear intr on completion FIXME tbd
}


IfxXspi_BusStatus IfxXspi_Spi_getstatus(IfxXspi_Spi *xspi)
{
    IfxXspi_BusStatus status;

    if ((xspi->transferInProgress != 0) && (xspi->xspi->SR.B.BUSY != 0))
    {
        status = IfxXspi_BusStatus_busy;
    }
    else if ((xspi->xspi->SR.B.TXE == 1) || (xspi->xspi->SR.B.DCOL == 1))
    {
        status = IfxXspi_BusStatus_error;
    }
    else
    {
        status = IfxXspi_BusStatus_idle;
    }

    return status;
}


boolean IfxXspi_Spi_triggerXipTransfer(IfxXspi_Spi *xspi, IfxXspi_Spi_XipConfig *config)
{
    Ifx_XSPI       *xspiSFR = xspi->xspi;

    xspiSFR->SSIENR.B.SSIC_EN = IfxXspi_Dwc_Mode_Disable;       /* Disable DWC_SSI*/
    Ifx_XSPI_CTRLR0 ctrlr0;
    ctrlr0.U                  = xspiSFR->CTRLR0.U;

    ctrlr0.B.DFS              = config->dataFrameSize;

    xspiSFR->CTRLR0.U         = ctrlr0.U;

    Ifx_XSPI_SPI_CTRLR0 spi_ctrlr0;
    spi_ctrlr0.U                 = xspiSFR->SPI_CTRLR0.U;
    spi_ctrlr0.B.INST_L          = config->instLength;
    spi_ctrlr0.B.XIP_INST_EN     = config->instructionPhaseEnable;

    spi_ctrlr0.B.XIP_PREFETCH_EN = config->xipPreFetchInstEnable;

    if (config->xipModeBitEnable == TRUE)
    {
        spi_ctrlr0.B.XIP_MD_BIT_EN = config->xipModeBitEnable;
        spi_ctrlr0.B.XIP_MBL       = config->xipModeBitLen;

        Ifx_XSPI_XIP_MODE_BITS xipModeBitReg;
        xipModeBitReg.U             = 0;
        xipModeBitReg.B.XIP_MD_BITS = config->xipModeBitsValue;
        xspiSFR->XIP.MODE_BITS.U    = xipModeBitReg.U;
    }

    xspiSFR->SPI_CTRLR0.U = spi_ctrlr0.U;

    Ifx_XSPI_XIP_WRAP_INST xip_wrap_inst;
    xip_wrap_inst.U           = xspiSFR->XIP.WRAP_INST.U;
    xip_wrap_inst.B.WRAP_INST = config->wrapInstruction;
    xspiSFR->XIP.WRAP_INST.U  = xip_wrap_inst.U;

    Ifx_XSPI_XIP_INCR_INST xip_incr_inst;
    xip_incr_inst.U           = xspiSFR->XIP.INCR_INST.U;
    xip_incr_inst.B.INCR_INST = config->wrapInstruction;
    xspiSFR->XIP.INCR_INST.U  = xip_incr_inst.U;

    if (config->contTransfer == IfxXspi_XipContTransfer_Enable)
    {
        Ifx_XSPI_XIP_CNT_TIME_OUT xip_cnt_time_out;
        xip_cnt_time_out.U                          = xspiSFR->XIP.CNT_TIME_OUT.U;
        xip_cnt_time_out.B.XTOC                     = config->counterTimeOut;
        xspiSFR->XIP.CNT_TIME_OUT.U                 = xip_cnt_time_out.U;

        xspiSFR->SPI_CTRLR0.B.XIP_DFS_HC            = config->xipFixDfs;
        xspiSFR->SPI_CTRLR0.B.SSIC_XIP_CONT_XFER_EN = IfxXspi_XipContTransfer_Enable;
    }

    Ifx_XSPI_SER ser;
    ser.U                     = xspiSFR->SER.U;
    ser.B.SER                 = config->slaveSelectEnable;
    xspiSFR->SER.U            = ser.U;

    xspiSFR->SSIENR.B.SSIC_EN = IfxXspi_Dwc_Mode_Enable;       /* Enable DWC_SSI*/
    return 0;
}


void IfxXspi_Spi_transferInit(Ifx_XSPI *xspi, IfxXspi_Spi_initTransferConfig *config)
{
    Ifx_XSPI *xspiSFR = &MODULE_XSPI0;                                  /* pointer to XSPI Registers*/

    xspiSFR->CLC.B.DISR = 0;

    while (xspiSFR->CLC.B.DISS == 1)                                    /* wait as long disabled */

    {}

    xspiSFR->SSIENR.B.SSIC_EN             = IfxXspi_Dwc_Mode_Disable;   /* Disable DWC_SSI*/

    xspiSFR->BAUDR.B.SCKDV                = config->xspiClkDivder;

    xspiSFR->CTRLR0.B.SPI_HYPERBUS_EN     = config->hyperbusEnable;     /* enable Hyperbus */
    xspiSFR->CTRLR0.B.SPI_FRF             = config->spiFrameFormat;     /* octal frame format */

    xspiSFR->SPI_CTRLR0.B.TRANS_TYPE      = config->transferFormat;     /* Address in octal */
    xspiSFR->SPI_CTRLR0.B.ADDR_L          = config->addrLength;         /* 4?b1100 (address length of 48 bits) */
    xspiSFR->SPI_CTRLR0.B.INST_L          = config->instructionLength;  /* no instruction phase */
    xspiSFR->SPI_CTRLR0.B.SPI_DDR_EN      = config->spiDdrEnable;       /* Address to be sent on octal-DDR mode */

    xspiSFR->SPI_CTRLR0.B.SPI_RXDS_EN     = 1;                          /*  enable read data strobe to sample incoming data */
    xspiSFR->SPI_CTRLR0.B.SPI_RXDS_SIG_EN = 0;

    /* If the SPI_CTRLR0.RXDS_SIG_EN bit is set to 0 or if the rxds level is 0 during CA phase, the number of wait cycles */
    /* Is fixed to the programmed value in the SPI_CTRLR0.WAIT_CYCLES bit-field. */

    xspiSFR->CTRLR0.B.TMOD    = config->transferMode;
    xspiSFR->CTRLR0.B.DFS     = config->dataFrameSize;

    xspiSFR->SER.B.SER        = config->slaveSelectEnable;      /* CS0 gets activated when data transfer is started */

    xspiSFR->SSIENR.B.SSIC_EN = IfxXspi_Dwc_Mode_Enable;        /* Enable DWC_SSI*/
}


boolean IfxXspi_Spi_write_address_data(IfxXspi_Spi_ReadWriteConfig *config, uint32 address, uint16 data)
{
    Ifx_XSPI *xspiSFR = &MODULE_XSPI0;                                /* pointer to XSPI Registers*/
    uint32    Temp_proov;

    xspiSFR->SSIENR.B.SSIC_EN             = IfxXspi_Dwc_Mode_Disable; /* Disable DWC_SSI*/

    xspiSFR->CTRLR0.B.TMOD                = config->transMode;

    xspiSFR->SPI_CTRLR0.B.SPI_RXDS_SIG_EN = config->rxdsEnable;

    xspiSFR->CTRLR1.B.NDF                 = config->numOfDataFrames;
    xspiSFR->SPI_CTRLR0.B.WAIT_CYCLES     = config->waitCycle;       /* Wait cycles depending on memory requirement */

    xspiSFR->SSIENR.B.SSIC_EN             = IfxXspi_Dwc_Mode_Enable; /* Enable DWC_SSI*/
    /* Load FIFO */

    Temp_proov     = IFXXSPI_WRITE_CMD_VALUE | (address & IFXXSPI_WRITE_CMD_MASK) >> IFXXSPI_WRITE_SHIFT;
    xspiSFR->DR0.U = Temp_proov;
    Temp_proov     = IFXXSPI_WRITE_ADDR_VALUE | (address & IFXXSPI_WRITE_ADDR_MASK);
    xspiSFR->DR0.U = Temp_proov;
    xspiSFR->DR0.U = data;

    while ((xspiSFR->SR.B.TFE == 0) || (xspiSFR->SR.B.BUSY == 1))
    {}

    return TRUE;
}


boolean IfxXspi_Spi_read_address_data(IfxXspi_Spi_ReadWriteConfig *config, uint32 address, uint32 *data)
{
    Ifx_XSPI *xspiSFR = &MODULE_XSPI0;                           /* pointer to XSPI Registers*/
    uint32    Temp_proov;
    boolean   status  = TRUE;

    xspiSFR->SSIENR.B.SSIC_EN             = IfxXspi_Dwc_Mode_Disable; /* Disable DWC_SSI*/

    xspiSFR->CTRLR0.B.TMOD                = config->transMode;

    xspiSFR->SPI_CTRLR0.B.SPI_RXDS_SIG_EN = config->rxdsEnable;

    xspiSFR->CTRLR1.B.NDF                 = config->numOfDataFrames; /*  here both tx and rx count are equal */
    xspiSFR->SPI_CTRLR0.B.WAIT_CYCLES     = config->waitCycle;       /* Wait cycles depending on memory requirement */

    xspiSFR->SSIENR.B.SSIC_EN             = IfxXspi_Dwc_Mode_Enable; /* Enable DWC_SSI*/
                                                                     /* Load FIFO  */

    Temp_proov     = IFXXSPI_READ_CMD_VALUE | (address & IFXXSPI_READ_CMD_MASK) >> IFXXSPI_READ_SHIFT;
    xspiSFR->DR0.U = Temp_proov;                                     //0x20000000;

    Temp_proov     = IFXXSPI_READ_ADDR_VALUE | (address & IFXXSPI_READ_ADDR_MASK);
    xspiSFR->DR0.U = Temp_proov;                                     //0x0000 ;

    while ((xspiSFR->SR.B.TFE == 0) || (xspiSFR->SR.B.RFNE == 0))
    {}

    if (xspiSFR->SR.B.RFNE == 1)
    {
        uint32 count = (uint32)(xspiSFR->RXFLR.B.RXTFL);            /* get the readable count of Rx fifo */

        if (count == 0)
        {
            status = FALSE;
        }

        while (count != 0)
        {
            *data++ = xspiSFR->DR0.U & 0xFFFF;
            count--;
        }
    }

    return status;
}
