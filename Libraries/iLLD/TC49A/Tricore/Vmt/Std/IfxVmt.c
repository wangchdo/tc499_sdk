/**
 * \file IfxVmt.c
 * \brief VMT  basic functionality
 *
 * \version iLLD_2_0_1_2_19
 * \copyright Copyright (c) 2023 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 *
 */

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "IfxVmt.h"

/******************************************************************************/
/*----------------------------------Macros------------------------------------*/
/******************************************************************************/

#define IFXVMT_CLEAR_SRAM_MCONTROL_CONFIG (0x4000 | (1U << IFX_VMT_MC_MCONTROL_SRAM_CLR_OFF))

/** \addtogroup IfxLld_Vmt_Std_Operative
 * \{ */

/******************************************************************************/
/*-----------------------Private Function Prototypes--------------------------*/
/******************************************************************************/

/** \brief Run the MBIST on configured Gang configuration
 * \param mbistConfig pointer to the configuration structure for the RAM test
 * \return TRUE: Test is successfully finished; FALSE: Test is not successfully finished.
 */
IFX_STATIC boolean IfxVmt_runMbist(const IfxVmt_MbistConfig *mbistConfig);

/** \brief
 * \param mbistConfig pointer to the configuration structure for the SRAM test
 * \return return the status of mc->MSTATUS.B.DONE
 */
IFX_STATIC boolean IfxVmt_runMbistClearRam(const IfxVmt_MbistConfig *mbistConfig);

/** \brief
 * \param mbistConfig pointer to the configuration structure for the SRAM test
 * \return return the status of MSTATUS.B.DONE and MEMTEST.U
 */
IFX_STATIC boolean IfxVmt_runMbistConfigPatterns(const IfxVmt_MbistConfig *mbistConfig);

/** \brief
 * \param testsDone tests Done status
 * \param mbistConfig pointer to the configuration structure for the SRAM test
 * \return test done status
 */
IFX_STATIC boolean IfxVmt_runMbistEnd(uint32 testsDone, const IfxVmt_MbistConfig *mbistConfig);

/** \} */

/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxVmt_clearErrorTracking(IfxVmt_MbistSel mbistSel)
{
    Ifx_VMT_MC *mc;
    mc          = IfxVmt_getDmtuMcInstancePtr(mbistSel);
    mc->ECCD.U |= (1 << IFX_VMT_MC_ECCD_TRC_OFF);
}


void IfxVmt_clearSram(IfxVmt_MbistSel mbistSel)
{
    Ifx_VMT *dmtuAddress = IfxVmt_getDmtuAddress(mbistSel);

    if (dmtuAddress->CLC.B.DISS == 1)
    {
        IfxVmt_enableModule(dmtuAddress);
    }

    IfxVmt_clearSramStart(mbistSel);

    /* wait for the end of the fill operation */

    while (!IfxVmt_isMbistDone(mbistSel))
    {
        __nop();
    }

    IfxVmt_clearSramContinue(mbistSel);
}


void IfxVmt_clearSramContinue(IfxVmt_MbistSel mbistSel)
{
    /* Before clearing the ECC error flags we've to issue a dummy SRAM access to get a valid memory output */
    IfxVmt_readSramAddress(mbistSel, 0x0000);
    /* Note: a SMU alarm will be flagged HERE if the wrong ECC has been written! */
    IfxVmt_disableMbistShell(mbistSel);

    /* for auto-init memories: wait for the end of the clear operation */
    while (IfxVmt_isAutoInitRunning(mbistSel))
    {}
}


void IfxVmt_clearSramStart(IfxVmt_MbistSel mbistSel)
{
    Ifx_VMT_MC *mc;
    mc = IfxVmt_getDmtuMcInstancePtr(mbistSel);

    IfxVmt_enableMbistShell(mbistSel);

    /* for auto-init memories: wait for the end of the clear operation */
    while (IfxVmt_isAutoInitRunning(mbistSel))
    {}

    /* start init operation */
    uint16 mcontrolMask = 0x4000;                                                                                   /* set USERED flag */
    mc->MCONTROL.U = mcontrolMask | (1 << IFX_VMT_MC_MCONTROL_SRAM_CLR_OFF) | (1 << IFX_VMT_MC_MCONTROL_START_OFF); /* START = SRAM_CLR = 1 */
    mc->MCONTROL.U = mcontrolMask | (1 << IFX_VMT_MC_MCONTROL_SRAM_CLR_OFF);
}


void IfxVmt_enableErrorTracking(IfxVmt_MbistSel mbistSel, boolean enable)
{
    Ifx_VMT_MC *mc;
    mc = IfxVmt_getDmtuMcInstancePtr(mbistSel);

    if (enable == FALSE)
    {
        mc->ECCS.U &= ~(1 << IFX_VMT_MC_ECCS_TRE_OFF);
    }
    else
    {
        mc->ECCS.U |= (1 << IFX_VMT_MC_ECCS_TRE_OFF);
    }
}


uint8 IfxVmt_getTrackedSramAddresses(IfxVmt_MbistSel mbistSel, Ifx_VMT_MC_ETRR *trackedSramAddresses)
{
    Ifx_VMT_MC *mc;
    mc = IfxVmt_getDmtuMcInstancePtr(mbistSel);
    uint8       validFlags          = (mc->ECCD.U >> IFX_VMT_MC_ECCD_VAL_OFF) & IFX_VMT_MC_ECCD_VAL_MSK;
    uint8       numTrackedAddresses = 0;
    int         i;

#if IFX_MC_ECCD_VAL_LEN > IFXVMT_MAX_TRACKED_ADDRESSES
# error "Unexpected size of VAL mask"
#endif

    for (i = 0; i < IFXVMT_MAX_TRACKED_ADDRESSES; ++i)
    {
        if (validFlags & (1 << i))
        {
            trackedSramAddresses[numTrackedAddresses].U = mc->ETRR[i].U;
            ++numTrackedAddresses;
        }
    }

    return numTrackedAddresses;
}


boolean IfxVmt_isTestPass(const IfxVmt_MbistConfig *mbistConfig)
{
    boolean retVal = 1;
    uint32  sshConfigCount;

    for (sshConfigCount = 0; sshConfigCount < mbistConfig->numOfSshConfigurations; sshConfigCount++)
    {
        Ifx_VMT_MC *mc = IfxVmt_getDmtuMcInstancePtr(mbistConfig->sshConfigurations[sshConfigCount].sshSel);

        if (mc->ECCD.U & (uint32)((IFX_VMT_MC_ECCD_EOV_MSK << IFX_VMT_MC_ECCD_EOV_OFF) |   \
                                  (IFX_VMT_MC_ECCD_MERR_MSK << IFX_VMT_MC_ECCD_MERR_OFF) | \
                                  (IFX_VMT_MC_ECCD_UCERR_MSK << IFX_VMT_MC_ECCD_UCERR_OFF)))
        {
            retVal = 0;
        }
    }

    return retVal;
}


void IfxVmt_readSramAddress(IfxVmt_MbistSel mbistSel, uint16 sramAddress)
{
    Ifx_VMT_MC *mc;
    mc = IfxVmt_getDmtuMcInstancePtr(mbistSel);

    /* configure MBIST for single read opeation */
    uint16      mcontrolMask = 0x4000;                                                               /* set USERED flag */
    mc->MCONTROL.U = mcontrolMask | (1 << IFX_VMT_MC_MCONTROL_DIR_OFF);
    mc->CONFIG0.U  = (1 << IFX_VMT_MC_CONFIG0_NUMACCS_OFF) | (1 << IFX_VMT_MC_CONFIG0_ACCSTYPE_OFF); /* 1 read access */
    /* ensure that linear scrambling is used */

    mc->CONFIG1.U = 0;                                                                               /* ensure that linear scrambling is used */

    /* Set the address to be read (RAEN = 0) */
    mc->RANGE.U = sramAddress;

    /* Start operation */
    mc->MCONTROL.U = mcontrolMask | (1 << IFX_VMT_MC_MCONTROL_DIR_OFF) | (1 << IFX_VMT_MC_MCONTROL_START_OFF);
    mc->MCONTROL.U = mcontrolMask | (1 << IFX_VMT_MC_MCONTROL_DIR_OFF);

    /* wait for the end of the fill operation */
    while (!IfxVmt_isMbistDone(mbistSel))
    {
        __nop();
    }
}


uint8 IfxVmt_runCheckerBoardTest(IfxVmt_MbistSel mbistSel, uint8 rangeSel, uint8 rangeAddrUp, uint8 rangeAddrLow, uint16 *errorAddr, uint32 numberRedundancyLines)
{
    /* Select MBIST Memory Controller:
     * Ifx_MC is a type describing structure of MBIST Memory Controller
     * registers defined in IfxMc_regdef.h file - MC object */
    Ifx_VMT_MC *mc;
    mc = IfxVmt_getDmtuMcInstancePtr(mbistSel);

    uint32      configCheckerBoardSequence[4] = {
        0x00001000, //up /lin/w0
        0x00001001, //up /lin/r0
        0x00011000, //down/lin/w1
        0x00011001  //down/lin/r1
    };

    uint8       retVal = 0U;
    uint8       testStep;

    /* Enable MBIST Memory Controller */
    IfxVmt_enableMbistShell(mbistSel);

    /* for auto-init memories: wait for the end of the clear operation */
    while (IfxVmt_isAutoInitRunning(mbistSel))
    {}

    /* Set the range register */
    mc->RANGE.U = (rangeSel << 15) | (rangeAddrUp << 7) | (rangeAddrLow << 0);

    /* Run the test */
    for (testStep = 0; testStep < 4; ++testStep)
    {
        mc->CONFIG0.U = configCheckerBoardSequence[testStep] & 0x0000FFFF;
        mc->CONFIG1.U = (configCheckerBoardSequence[testStep] & 0xFFFF0000) >> 16;

        if (testStep < 2)
        {
            mc->MCONTROL.U = numberRedundancyLines ? 0x40c9 : 0x00c9; // bit and row toggle
            mc->MCONTROL.U = numberRedundancyLines ? 0x40c8 : 0x00c8; // MCONTROL.B.START will generate a RMW which is too long for small SRAMs!
        }
        else
        {
            mc->MCONTROL.U = numberRedundancyLines ? 0x40c1 : 0x00c1; // bit and row toggle
            mc->MCONTROL.U = numberRedundancyLines ? 0x40c0 : 0x00c0; // MCONTROL.B.START will generate a RMW which is too long for small SRAMs!
        }

        /* wait for the end of the fill operation */

        while (!IfxVmt_isMbistDone(mbistSel))
        {
            __nop();
        }

        /* Check the Fail Status */
        if (mc->MSTATUS.B.FAIL)
        {
            /* Read Error tracking register if FAILDMP is set*/
            if (mc->MCONTROL.B.FAILDMP)
            {
                *errorAddr = (uint16)mc->ETRR[0].U;
            }

            /* Return as failed */
            retVal = 1U;
            break;
        }
    }

    /* Disable Memory Controller */

    IfxVmt_disableMbistShell(mbistSel);

    while (IfxVmt_isAutoInitRunning(mbistSel))
    {}

    return retVal;
}


uint8 IfxVmt_runMarchUTest(IfxVmt_MbistSel mbistSel, uint8 rangeSel, uint8 rangeAddrUp, uint8 rangeAddrLow, uint16 *errorAddr)
{
    /* Select MBIST Memory Controller:
     * Ifx_MC is a type describing structure of MBIST Memory Controller
     * registers defined in IfxMc_regdef.h file - MC object */
    Ifx_VMT_MC *mc;
    mc = IfxVmt_getDmtuMcInstancePtr(mbistSel);

    uint32      configMarchUSequence[6] = {
        0x08001000, //up /lin/w0
        0x08064005, //up /lin/r0->w1->r1->w0
        0x08022001, //up /lin/r0->w1
        0x00094005, //down/lin/r1->w0->r0->w1
        0x00012001, //down/lin/r1->w0
        0x00001001
    };              //down/lin/r0

    uint8       retVal = 0U;
    uint8       testStep;

    /* Enable MBIST Memory Controller */
    IfxVmt_enableMbistShell(mbistSel);

    /* for auto-init memories: wait for the end of the clear operation */
    while (IfxVmt_isAutoInitRunning(mbistSel))
    {}

    /* Set the range register */
    mc->RANGE.U = (rangeSel << 15) | (rangeAddrUp << 7) | (rangeAddrLow << 0);

    /* Run the test */
    for (testStep = 0; testStep < 6; ++testStep)
    {
        mc->CONFIG0.U        = configMarchUSequence[testStep] & 0x0000FFFF;
        mc->CONFIG1.U        = (configMarchUSequence[testStep] & 0xFFFF0000) >> 16;
        mc->MCONTROL.U       = 0x4209;
        mc->MCONTROL.B.START = 0;

        /* wait for the end of the fill operation */

        while (!IfxVmt_isMbistDone(mbistSel))
        {
            __nop();
        }

        /* Check the Fail Status */
        if (mc->MSTATUS.B.FAIL)
        {
            /* Test has failed, check if any un-correctable error */
            if (mc->ECCD.B.UCERR)
            {
                /* Read Error tracking register and return saying test failed */
                *errorAddr = (uint16)mc->ETRR[0].U;
                retVal     = 1U;
                break;
            }
        }
    }

    /* Disable Memory Controller */
    IfxVmt_disableMbistShell(mbistSel);

    /* for auto-init memories: wait for the end of the clear operation */
    while (IfxVmt_isAutoInitRunning(mbistSel))
    {}

    return retVal;
}


uint8 IfxVmt_runNonDestructiveInversionTest(IfxVmt_MbistSel mbistSel, uint8 rangeSel, uint8 rangeAddrUp, uint8 rangeAddrLow, uint16 *errorAddr)
{
    /* Select MBIST Memory Controller:
     * Ifx_MC is a type describing structure of MBIST Memory Controller
     * registers defined in IfxMc_regdef.h file - MC object */
    Ifx_VMT_MC *mc;
    mc = IfxVmt_getDmtuMcInstancePtr(mbistSel);

    uint8       retVal = 0U;

    /* Enable MBIST Memory Controller */
    IfxVmt_enableMbistShell(mbistSel);

    /* for auto-init memories: wait for the end of the clear operation */
    while (IfxVmt_isAutoInitRunning(mbistSel))
    {}

    /* Configure Non-destructive Inversion test */
    mc->CONFIG0.U        = 0x5015; //NUMACCS=5, ACCSTYPE=15
    mc->CONFIG1.U        = 0x5018; //AG_MOD=5
    /* Set the range register */
    mc->RANGE.U          = (rangeSel << 15) | (rangeAddrUp << 7) | (rangeAddrLow << 0);
    /* Run the tests */
    mc->MCONTROL.U       = 0x4009;
    mc->MCONTROL.B.START = 0;

    /* wait for the end of the fill operation */

    while (!IfxVmt_isMbistDone(mbistSel))
    {
        __nop();
    }

    /* Check the Fail Status */
    if (IfxVmt_checkErrorFlags(mbistSel))
    {
        /* Read the Error tracking register and return saying test failed */
        *errorAddr = (uint16)mc->ETRR[0].U;
        retVal     = 1U;
    }

    /* Disable Memory Controller */
    IfxVmt_disableMbistShell(mbistSel);

    /* for auto-init memories: wait for the end of the clear operation */
    while (IfxVmt_isAutoInitRunning(mbistSel))
    {}

    return retVal;
}


void IfxVmt_writeSramAddress(IfxVmt_MbistSel mbistSel, uint16 sramAddress)
{
    Ifx_VMT_MC *mc;
    mc = IfxVmt_getDmtuMcInstancePtr(mbistSel);

    /* configure MBIST for single write opeation */
    uint16      mcontrolMask = 0x4000;                                                               /* set USERED flag */
    mc->MCONTROL.U = mcontrolMask | (1 << IFX_VMT_MC_MCONTROL_DIR_OFF);
    mc->CONFIG0.U  = (1 << IFX_VMT_MC_CONFIG0_NUMACCS_OFF) | (0 << IFX_VMT_MC_CONFIG0_ACCSTYPE_OFF); /* 1 write access */
    /* ensure that linear scrambling is used */

    mc->CONFIG1.U = 0;                                                                               /* ensure that linear scrambling is used */

    /* Set the address to be written (RAEN = 0) */
    mc->RANGE.U = sramAddress;

    /* Start operation */
    mc->MCONTROL.U = mcontrolMask | (1 << IFX_VMT_MC_MCONTROL_DIR_OFF) | (1 << IFX_VMT_MC_MCONTROL_START_OFF);
    mc->MCONTROL.U = mcontrolMask | (1 << IFX_VMT_MC_MCONTROL_DIR_OFF);

    /* Wait for the end of the operation */

    while (!IfxVmt_isMbistDone(mbistSel))
    {
        __nop();
    }
}


void IfxVmt_configureAccessToVmts(IfxApApu_ApuConfig *apConfig)
{
    uint8 index;

    for (index = 0; index < IFXVMT_NUM_DMTU; index++)
    {
        /* Loop through all the instance */
        Ifx_VMT *vmt = (Ifx_VMT *)(((uint32)&MODULE_VMT0) + index * ((uint32)&MODULE_VMT1 - (uint32)&MODULE_VMT0));
        IfxApApu_init((Ifx_ACCEN_ACCEN *)&vmt->ACCENNOM, apConfig);
    }
}


boolean IfxVmt_runMbistAll(const IfxVmt_MbistConfig *const mbistConfig[])
{
    unsigned int gangConfigCount = 0;
    boolean      mBistError      = 0;

    while (mbistConfig[gangConfigCount] != (void *)0)
    {
        if (IfxVmt_runMbist(mbistConfig[gangConfigCount]))
        {
            if (!IfxVmt_isTestPass(mbistConfig[gangConfigCount]))
            {
                mBistError = 1;
            }
        }
        else
        {
            mBistError = 1;
        }

        gangConfigCount++;
    }

    return mBistError;
}


IFX_STATIC boolean IfxVmt_runMbist(const IfxVmt_MbistConfig *mbistConfig)
{
    uint32   count;
    Ifx_VMT *dmtuInstance;
    uint32   mbistStatus;

    for (count = 0; count < mbistConfig->numOfSshConfigurations; count++)
    {
        dmtuInstance = IfxVmt_getDmtuAddress(mbistConfig->sshConfigurations[count].sshSel);

        if (IfxVmt_isModuleEnabled(dmtuInstance) == 0)
        {
            IfxVmt_enableModule(dmtuInstance);                 /* Enable VMT module */
        }

        /*Set MEMTESTx registers for each SSH cell configured*/
        IfxVmt_enableMbistShell(mbistConfig->sshConfigurations[count].sshSel);

        /* for auto-init memories: wait for the end of the clear operation */
        while (IfxVmt_isAutoInitRunning(mbistConfig->sshConfigurations[count].sshSel))
        {}

        /* Clear ECCD and FAULTSTS Registers */

        dmtuInstance->MC->ECCD.U     = 0x10U;
        dmtuInstance->MC->FAULTSTS.U = 0U;
    }

    mbistStatus = IfxVmt_runMbistClearRam(mbistConfig);
    return (boolean)mbistStatus;
}


IFX_STATIC boolean IfxVmt_runMbistClearRam(const IfxVmt_MbistConfig *mbistConfig)
{
    uint32      patternCount;
    uint32      sshConfigCount = 0;
    uint32      status         = 0;
    sint32      count;
    uint32      mbistStatus    = 0;

    /* Get the dMTU pointer for the SSH */
    Ifx_VMT_MC *mc;

    /*Loop through each configuration pattern*/
    for (patternCount = 0; patternCount < mbistConfig->numOfConfigPatterns; patternCount++)
    {
        /** Setup Configuration pattern for each SSH CONFIGx*/

        for (sshConfigCount = 0; sshConfigCount < mbistConfig->numOfSshConfigurations; sshConfigCount++)
        {
            mc = IfxVmt_getDmtuMcInstancePtr(mbistConfig->sshConfigurations[sshConfigCount].sshSel);

            if (mbistConfig->sshConfigurations[sshConfigCount].preClearEnable)
            {
                mc->MCONTROL.U = IFXVMT_CLEAR_SRAM_MCONTROL_CONFIG | (1 << IFX_VMT_MC_MCONTROL_START_OFF); /* Configure the MCONTROL and set Start bit */
                mc->MCONTROL.U = IFXVMT_CLEAR_SRAM_MCONTROL_CONFIG;                                        /* Reset the start bit */
            }
        }

        count = IFXVMT_WAIT_TIMEOUTCOUNT;

        do
        {
            status = 1;

            for (sshConfigCount = 0; sshConfigCount < mbistConfig->numOfSshConfigurations; sshConfigCount++)
            {
                mc = IfxVmt_getDmtuMcInstancePtr(mbistConfig->sshConfigurations[sshConfigCount].sshSel);

                if (mbistConfig->sshConfigurations[sshConfigCount].preClearEnable)
                {
                    status &= (mc->MSTATUS.B.DONE);
                }
            }

            if ((--count) <= 0)
            {
                IfxVmt_runMbistEnd(status, mbistConfig);
            }
        } while (status == 0);
    }

    mbistStatus  = IfxVmt_runMbistConfigPatterns(mbistConfig);
    mbistStatus |= status;
    return (boolean)mbistStatus;
}


IFX_STATIC boolean IfxVmt_runMbistConfigPatterns(const IfxVmt_MbistConfig *mbistConfig)
{
    uint32      patternCount;
    uint32      sshConfigCount;
    uint32      status      = 0;
    sint32      count;
    uint32      mbistStatus = 0;

    /* Get the dMTU pointer for that SSH */
    Ifx_VMT_MC *mc;

    /*Loop through each configuration pattern*/
    for (patternCount = 0; patternCount < mbistConfig->numOfConfigPatterns; patternCount++)
    {
        /** Setup Configuration pattern for each SSH CONFIGx*/
        for (sshConfigCount = 0; sshConfigCount < mbistConfig->numOfSshConfigurations; sshConfigCount++)
        {
            mc            = IfxVmt_getDmtuMcInstancePtr(mbistConfig->sshConfigurations[sshConfigCount].sshSel);
            mc->CONFIG0.U = mbistConfig->configPatterns[patternCount].config0.U; /* Set the CONFIG0 register */
            mc->CONFIG1.U = mbistConfig->configPatterns[patternCount].config1.U; /* Set the CONFIG1 register */
        }

        /* Start memory test for each SSH CONFIGx*/
        for (sshConfigCount = 0; sshConfigCount < mbistConfig->numOfSshConfigurations; sshConfigCount++)
        {
            mc             = IfxVmt_getDmtuMcInstancePtr(mbistConfig->sshConfigurations[sshConfigCount].sshSel);
            mc->MCONTROL.U = mbistConfig->mcontrol.U | 1; // Configure the MCONTROL and set Start bit

            mc->MCONTROL.U = mbistConfig->mcontrol.U;     //Reset the start bit
        }

        count = IFXVMT_WAIT_TIMEOUTCOUNT;

        do
        {
            status = 1;

            for (sshConfigCount = 0; sshConfigCount < mbistConfig->numOfSshConfigurations; sshConfigCount++)
            {
                mc      = IfxVmt_getDmtuMcInstancePtr(mbistConfig->sshConfigurations[sshConfigCount].sshSel);
                status &= ((mc->MSTATUS.B.DONE | mc->MSTATUS.B.FAIL));
            }

            if ((--count) <= 0)
            {
                IfxVmt_runMbistEnd(status, mbistConfig);
            }
        } while (status == 0);
    }

    mbistStatus  = IfxVmt_runMbistEnd(status, mbistConfig);
    mbistStatus |= status;
    return (boolean)status;
}


IFX_STATIC boolean IfxVmt_runMbistEnd(uint32 testsDone, const IfxVmt_MbistConfig *mbistConfig)
{
    uint32   count;
    uint32   mbistStatus = 0;

    /* Get the dMTU pointer for the SSH */

    Ifx_VMT *dmtuInstance;

    /*Reset MEMTESTx registers for each SSH cell configured*/
    for (count = 0; count < mbistConfig->numOfSshConfigurations; count++)
    {
        /* Disable MEMTEST for each SSH */
        IfxVmt_disableMbistShell(mbistConfig->sshConfigurations[count].sshSel);
    }

    for (count = 0; count < mbistConfig->numOfSshConfigurations; count++)
    {
        dmtuInstance = IfxVmt_getDmtuAddress(mbistConfig->sshConfigurations[count].sshSel);
        mbistStatus |= dmtuInstance->MEMTEST.U;
    }

    return (boolean)mbistStatus;
}
