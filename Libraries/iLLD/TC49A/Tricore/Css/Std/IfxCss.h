/**
 * \file IfxCss.h
 * \brief CSS  basic functionality
 * \ingroup IfxLld_Css
 *
 * \version iLLD_2_0_1_2_19
 * \copyright Copyright (c) 2023 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 *
 * \defgroup IfxLld_Css_Std_Module_functions Module functions
 * \ingroup IfxLld_Css_Std
 * \defgroup IfxLld_Css_Std_Structures Structures
 * \ingroup IfxLld_Css_Std
 * \defgroup IfxLld_Css_Std_Channel_functions Channel functions
 * \ingroup IfxLld_Css_Std
 * \defgroup IfxLld_Css_Std_Enumerations Enumerations
 * \ingroup IfxLld_Css_Std
 */

#ifndef IFXCSS_H
#define IFXCSS_H 1

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "_Impl/IfxCss_cfg.h"
#include "IfxCss_reg.h"
#include "IfxCss_bf.h"
#include "Src/Std/IfxSrc.h"
#include "_Utilities/Ifx_Assert.h"

/******************************************************************************/
/*-----------------------------------Macros-----------------------------------*/
/******************************************************************************/

/** \brief Macro that accepts the WRSTAT register word and returns if a write operation is currently in operation.
 */
#define IFXCSS_CHECK_OP_BUSY(x)         ((x & (uint32)(IFX_CSS_KEY_WRSTAT_BUSY_MSK << IFX_CSS_KEY_WRSTAT_BUSY_OFF)) != (uint32)0)

/** \brief Macro that accepts the OPSTAT register word and returns if a write operation is currently in operation.
 */
#define IFXCSS_CHECK_CH_INUSE(x)        ((x & (uint32)(IFX_CSS_CH_STAT_OP_INIT_MSK << IFX_CSS_CH_STAT_OP_INIT_OFF)) == (uint32)0)

/** \brief Macro that accepts the OPSTAT register word and returns if a MAC generation is completed
 */
#define IFXCSS_CHECK_MACGEN_COMPLETE(x) ((x & (uint32)(IFX_CSS_CH_STAT_OP_MACGEN_MSK << IFX_CSS_CH_STAT_OP_MACGEN_OFF)) != (uint32)0)

/** \brief Macro that accepts the OPSTAT register word and returns if MAC verification is completed
 */
#define IFXCSS_CHECK_MACVER_COMPLETE(x) ((x & (uint32)(IFX_CSS_CH_STAT_OP_MACVER_MSK << IFX_CSS_CH_STAT_OP_MACVER_OFF)) != (uint32)0)

/** \brief Macro that accepts the AUTHRES register word and returns if MAC verification result is OK
 */
#define IFXCSS_CHECK_MAC_RESULT(x)                                            \
    ((x & (uint32)(IFX_CSS_CH_AUTHRES_RES_MSK << IFX_CSS_CH_AUTHRES_RES_OFF)) \
     && !(x & (uint32)(IFX_CSS_CH_AUTHRES_INVRES_MSK << IFX_CSS_CH_AUTHRES_INVRES_OFF)))

/** \brief mask to check for any errors in the WRSTAT register.
 */
#define IFXCSS_WRSTAT_ERRORMASK   ((uint32)(0xFFFFFFFF >> (32 - (IFX_CSS_KEY_WRSTAT_NOCMD_OFF + 1))))

/** \brief checks the WRSTAT register word and returns TRUE if there is error.
 */
#define IFXCSS_CHECK_KEYIVWRITE_ERROR(x) ((x & IFXCSS_WRSTAT_ERRORMASK) != (uint32)0)

/** \brief Mask to update any errors in the OPERR register.
 */
#define IFXCSS_OP_ERRORMASK       ((uint32)(0xFFFFFFFF >> (32 - (IFX_CSS_CH_STAT_OPERR_NOIV_OFF + 1))))

/** \brief Mask to update any errors in the OP register.
 */
#define IFXCSS_OP_STATUSERRORMASK ((uint32)((0xFFFFFFFF >> (32 - (IFX_CSS_CH_STAT_OP_DOUTUFL_OFF + 1))) & 0xB0))

/** \brief Mask to update any errors in the KEYERR register
 */
#define IFXCSS_KEYERR_ERRORMASK   ((uint32)(0xFFFFFFFF >> (32 - (IFX_CSS_CH_CLR_KEYERR_IVSEL_OFF + 1))))

/** \brief Macro that accepts the OPSTAT register word and returns if channel is busy
 */
#define IFXCSS_CHECK_CH_BUSY(x) ((x & (uint32)(IFX_CSS_CH_STAT_OP_CHBUSY_MSK << IFX_CSS_CH_STAT_OP_CHBUSY_OFF)) != (uint32)0)

/** \brief Macro that changes status to failure once timeout occurs
 */
#define IFXCSS_CHECK_TIMEOUT(counter, status) \
    if (--counter <= 0)                       \
    {                                         \
        status = IfxCss_status_failure;       \
        break;                                \
    }

/******************************************************************************/
/*--------------------------------Enumerations--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Css_Std_Enumerations
 * \{ */
/** \brief Enumeration holding the threshold for authentication alarms
 * Defines how many authentications can fail until an alarm is triggered
 */
typedef enum
{
    IfxCss_channelAuthAlarmThres_0   = 0,  /**< \brief off - no alarm will be generated independently how many authentications fail */
    IfxCss_channelAuthAlarmThres_1   = 1,  /**< \brief 1 fail(s) trigger an alarm */
    IfxCss_channelAuthAlarmThres_2   = 2,  /**< \brief 2 fail(s) trigger an alarm */
    IfxCss_channelAuthAlarmThres_4   = 3,  /**< \brief 4 fail(s) trigger an alarm */
    IfxCss_channelAuthAlarmThres_8   = 4,  /**< \brief 8 fail(s) trigger an alarm */
    IfxCss_channelAuthAlarmThres_16  = 5,  /**< \brief 16 fail(s) trigger an alarm */
    IfxCss_channelAuthAlarmThres_32  = 6,  /**< \brief 32 fail(s) trigger an alarm */
    IfxCss_channelAuthAlarmThres_64  = 7,  /**< \brief 64 fail(s) trigger an alarm */
    IfxCss_channelAuthAlarmThres_128 = 8,  /**< \brief 128 fail(s) trigger an alarm */
    IfxCss_channelAuthAlarmThres_256 = 9   /**< \brief 256 fail(s) trigger an alarm */
} IfxCss_channelAuthAlarmThres;

/** \brief Enumeration describing lock enable of alarm threshold
 */
typedef enum
{
    IfxCss_channelAuthThresLock_lock   = 0, /**< \brief Lock the authentication alarm threshold */
    IfxCss_channelAuthThresLock_unlock = 1  /**< \brief Unlock the authentication alarm threshold */
} IfxCss_channelAuthThresLock;

/** \brief Enumeration holding the channel Id's
 */
typedef enum
{
    IfxCss_channelId_0 = 0,  /**< \brief Channel 0 */
    IfxCss_channelId_1,      /**< \brief Channel 1 */
    IfxCss_channelId_2,      /**< \brief Channel 2 */
    IfxCss_channelId_3,      /**< \brief Channel 3 */
    IfxCss_channelId_4,      /**< \brief Channel 4 */
    IfxCss_channelId_5,      /**< \brief Channel 5 */
    IfxCss_channelId_6,      /**< \brief Channel 6 */
    IfxCss_channelId_7,      /**< \brief Channel 7 */
    IfxCss_channelId_8,      /**< \brief Channel 8 */
    IfxCss_channelId_9,      /**< \brief Channel 9 */
    IfxCss_channelId_10,     /**< \brief Channel 10 */
    IfxCss_channelId_11,     /**< \brief Channel 11 */
    IfxCss_channelId_12,     /**< \brief Channel 12 */
    IfxCss_channelId_13,     /**< \brief Channel 13 */
    IfxCss_channelId_14,     /**< \brief Channel 14 */
    IfxCss_channelId_15,     /**< \brief Channel 15 */
    IfxCss_channelId_16,     /**< \brief Channel 16 */
    IfxCss_channelId_17,     /**< \brief Channel 17 */
    IfxCss_channelId_18,     /**< \brief Channel 18 */
    IfxCss_channelId_19,     /**< \brief Channel 19 */
    IfxCss_channelId_20      /**< \brief Channel 20 */
} IfxCss_channelId;

/** \brief Enumeration describing the priority of the channel (normal/high)
 */
typedef enum
{
    IfxCss_channelPriority_normal = 0,  /**< \brief normal priority */
    IfxCss_channelPriority_high   = 1   /**< \brief high priority */
} IfxCss_channelPriority;

/** \brief Enumeration describing the hardware engine configuration for crypto
 */
typedef enum
{
    IfxCss_cryptoHwCfg_singleAes = 0,  /**< \brief Single AES engine is used */
    IfxCss_cryptoHwCfg_lockStep  = 1,  /**< \brief Lock Step AES mode */
    IfxCss_cryptoHwCfg_perfMode1 = 2   /**< \brief Performance mode 1 */
} IfxCss_cryptoHwCfg;

/** \brief Enumeration describing HW padding modes during crypto operation
 */
typedef enum
{
    IfxCss_cryptoHwPad_default  = 0,  /**< \brief default padding mode */
    IfxCss_cryptoHwPad_oneZeros = 1,  /**< \brief single 1 followed by 0s */
    IfxCss_cryptoHwPad_pkcs7    = 2,  /**< \brief PKCS7 padding */
    IfxCss_cryptoHwPad_zeros    = 3   /**< \brief pad only zeros */
} IfxCss_cryptoHwPad;

/** \brief Enumeration describing the Crypto operation modes
 */
typedef enum
{
    IfxCss_cryptoOpMode_none       = 0,   /**< \brief No encryption / decryption operation */
    IfxCss_cryptoOpMode_aesEcb     = 1,   /**< \brief AES-ECB mode - block size 128 bit */
    IfxCss_cryptoOpMode_aesCBC     = 2,   /**< \brief AES-CBC mode - block size 128 bit */
    IfxCss_cryptoOpMode_aesCTR     = 3,   /**< \brief AES-CTR mode - block size 128 bit */
    IfxCss_cryptoOpMode_aesOFB     = 4,   /**< \brief AES-OFB mode - block size 128 bit */
    IfxCss_cryptoOpMode_aesCFB     = 5,   /**< \brief AES-CFB mode - block size 128 bit */
    IfxCss_cryptoOpMode_aesXTS     = 6,   /**< \brief AES-XTS mode - block size 128 bit */
    IfxCss_cryptoOpMode_aesGCM     = 7,   /**< \brief AES-GCM mode - block size 128 bit */
    IfxCss_cryptoOpMode_aesGCM_SIV = 8,   /**< \brief AES-GCM-SIV mode - block size 128 bit */
    IfxCss_cryptoOpMode_aesCCM     = 9,   /**< \brief AES-CCM mode - block size 128 bit */
    IfxCss_cryptoOpMode_aesCMAC    = 11,  /**< \brief AES-CMAC mode - block size 128 bit */
    IfxCss_cryptoOpMode_aesGMAC    = 12,  /**< \brief AES-GMAC mode - block size 128 bit */
    IfxCss_cryptoOpMode_aesGHASH   = 13,  /**< \brief AES-GHASH mode - block size 128 bit */
    IfxCss_cryptoOpMode_chacha20   = 14,  /**< \brief Chacha20 mode - block size 512 bit */
    IfxCss_cryptoOpMode_sm4ECB     = 17,  /**< \brief SM4-ECB mode - block size 128 bit */
    IfxCss_cryptoOpMode_sm4CBC     = 18,  /**< \brief SM4-CBC mode - block size 128 bit */
    IfxCss_cryptoOpMode_sm4CTR     = 19,  /**< \brief SM4-CTR mode - block size 128 bit */
    IfxCss_cryptoOpMode_sm4OFB     = 20,  /**< \brief SM4-OFB mode - block size 128 bit */
    IfxCss_cryptoOpMode_sm4CFB     = 21,  /**< \brief SM4-CFB mode - block size 128 bit */
    IfxCss_cryptoOpMode_sm4XTS     = 22,  /**< \brief SM4-XTS mode - block size 128 bit */
    IfxCss_cryptoOpMode_sm4GCM     = 23,  /**< \brief SM4-GCM mode - block size 128 bit */
    IfxCss_cryptoOpMode_sm4GCM_SIV = 24,  /**< \brief SM4-GCM-SIV mode */
    IfxCss_cryptoOpMode_sm4CCM     = 25,  /**< \brief SM4-CCM mode - block size 128 bit */
    IfxCss_cryptoOpMode_sm4CMAC    = 27,  /**< \brief SM4-CMAC mode - block size 128 bit */
    IfxCss_cryptoOpMode_sm4GMAC    = 28,  /**< \brief SM4-GMAC mode - block size 128 bit */
    IfxCss_cryptoOpMode_sm4GHASH   = 29   /**< \brief SM4-GHASH mode - block size 128 bit */
} IfxCss_cryptoOpMode;

/** \brief Enumeration to select Encryption / Decryption operation
 */
typedef enum
{
    IfxCss_encryptOp_decryption = 0,  /**< \brief Perform Decryption */
    IfxCss_encryptOp_encrypt    = 1   /**< \brief Perform encryption */
} IfxCss_encryptOp;

/** \brief Enumeration used to enable/disable feature is CSS (oneBit)
 */
typedef enum
{
    IfxCss_featureSet_disable,  /**< \brief Disable the 1 Bit feature in CSS */
    IfxCss_featureSet_enable    /**< \brief enable the 1 Bit feature in CSS */
} IfxCss_featureSet;

/** \brief Enumeration holding ordering of input data for Hashing
 */
typedef enum
{
    IfxCss_hashDataIn_useAESinputData  = 0, /**< \brief Use AES input data for HASH */
    IfxCss_hashDataIn_useAESoutputData = 1  /**< \brief Use AES output data as input */
} IfxCss_hashDataIn;

/** \brief Enumeration holding the HASH operation modes supported
 */
typedef enum
{
    IfxCss_hashOpMode_none         = 0,  /**< \brief No operation will be performed using the Hash modules */
    IfxCss_hashOpMode_SHA1         = 1,  /**< \brief SHA1 - block size 512 bit */
    IfxCss_hashOpMode_SHA2_224     = 2,  /**< \brief SHA2-224 - block size 512 bit */
    IfxCss_hashOpMode_SHA2_256     = 3,  /**< \brief SHA2-256 - block size 512 bit */
    IfxCss_hashOpMode_SHA2_384     = 4,  /**< \brief SHA2-384 - block size 1024 bit */
    IfxCss_hashOpMode_SHA2_512     = 5,  /**< \brief SHA2-512 - block size 1024 bit */
    IfxCss_hashOpMode_SHA2_512_224 = 6,  /**< \brief SHA2-512/224 - block size 1024 bit */
    IfxCss_hashOpMode_SHA2_512_256 = 7,  /**< \brief SHA2-512/256 - block size 1024 bit */
    IfxCss_hashOpMode_SHA3_224     = 8,  /**< \brief SHA3-224 - block size 1152 bit */
    IfxCss_hashOpMode_SHA3_256     = 9,  /**< \brief SHA3-256 - block size 1088 bit */
    IfxCss_hashOpMode_SHA3_384     = 10, /**< \brief SHA3-384 - block size 832 bit */
    IfxCss_hashOpMode_SHA3_512     = 11, /**< \brief SHA3-512 - block size 576 bit */
    IfxCss_hashOpMode_SHAKE128     = 12, /**< \brief SHAKE128 - block size 1344 bit */
    IfxCss_hashOpMode_SHAKE256     = 13, /**< \brief SHAKE256 - block size 1088 bit */
    IfxCss_hashOpMode_SM3          = 14, /**< \brief SM3 - block size 512 bit */
    IfxCss_hashOpMode_MD5          = 15, /**< \brief MD5 - block size 512 bit */
    IfxCss_hashOpMode_Poly1305     = 16, /**< \brief Poly1305 - block size 512 bit */
    IfxCss_hashOpMode_SipHash24    = 17, /**< \brief SipHash-2-4 - block size 64 bit */
    IfxCss_hashOpMode_SipHash48    = 18, /**< \brief SipHash-4-8 - block size 64 bit */
    IfxCss_hashOpMode_SWMAC        = 31  /**< \brief Only the MAC comparison of CHx_MAC_VALUEi with SWMAC_VALUEi */
} IfxCss_hashOpMode;

/** \brief Enumeration holding capability of key for various operations
 */
typedef enum
{
    IfxCss_keyCapability_notCapable = 0,  /**< \brief Key is not capable for operation */
    IfxCss_keyCapability_capable          /**< \brief Key is capable for operation */
} IfxCss_keyCapability;

/** \brief Enumeration describing Key usability during Debug mode
 */
typedef enum
{
    IfxCss_keyDebugUsage_allowed,    /**< \brief Key can be used for debug */
    IfxCss_keyDebugUsage_notAllowed  /**< \brief Key usage not allowed during debug */
} IfxCss_keyDebugUsage;

/** \brief Enumeration describing length of key
 */
typedef enum
{
    IfxCss_keyLength_invalid,  /**< \brief Key is invalid */
    IfxCss_keyLength_128Bit,   /**< \brief Key length is 128Bit */
    IfxCss_keyLength_192Bit,   /**< \brief Key length is 128Bit */
    IfxCss_keyLength_256Bit    /**< \brief Key length is 256Bit */
} IfxCss_keyLength;

/** \brief Enumeration describing Lock status of key
 */
typedef enum
{
    IfxCss_keyLock_unlocked,  /**< \brief Key is unlocked and can be overwritten */
    IfxCss_keyLock_locked     /**< \brief Key is locked and cannot be written */
} IfxCss_keyLock;

#ifdef IFX_CFG_VP_PLATFORM
/** \brief minimum size of the MAC/HASH that can be verified using a key
 */
typedef enum
{
    IfxCss_keyMacSize_unlimited = 0,  /**< \brief MAC size for verification is unlimited */
    IfxCss_keyMacSize_1Bit      = 1,  /**< \brief MAC size 1Bit(s)  */
    IfxCss_keyMacSize_2Bit,           /**< \brief MAC size 2Bit(s)  */
    IfxCss_keyMacSize_3Bit,           /**< \brief MAC size 3Bit(s)  */
    IfxCss_keyMacSize_4Bit,           /**< \brief MAC size 4Bit(s)  */
    IfxCss_keyMacSize_5Bit,           /**< \brief MAC size 5Bit(s)  */
    IfxCss_keyMacSize_6Bit,           /**< \brief MAC size 6Bit(s)  */
    IfxCss_keyMacSize_7Bit,           /**< \brief MAC size 7Bit(s)  */
    IfxCss_keyMacSize_8Bit,           /**< \brief MAC size 8Bit(s)  */
    IfxCss_keyMacSize_9Bit,           /**< \brief MAC size 9Bit(s)  */
    IfxCss_keyMacSize_10Bit,          /**< \brief MAC size 10Bit(s)  */
    IfxCss_keyMacSize_11Bit,          /**< \brief MAC size 11Bit(s)  */
    IfxCss_keyMacSize_12Bit,          /**< \brief MAC size 12Bit(s)  */
    IfxCss_keyMacSize_13Bit,          /**< \brief MAC size 13Bit(s)  */
    IfxCss_keyMacSize_14Bit,          /**< \brief MAC size 14Bit(s)  */
    IfxCss_keyMacSize_15Bit,          /**< \brief MAC size 15Bit(s)  */
    IfxCss_keyMacSize_16Bit,          /**< \brief MAC size 16Bit(s)  */
    IfxCss_keyMacSize_17Bit,          /**< \brief MAC size 17Bit(s)  */
    IfxCss_keyMacSize_18Bit,          /**< \brief MAC size 18Bit(s)  */
    IfxCss_keyMacSize_19Bit,          /**< \brief MAC size 19Bit(s)  */
    IfxCss_keyMacSize_20Bit,          /**< \brief MAC size 20Bit(s)  */
    IfxCss_keyMacSize_21Bit,          /**< \brief MAC size 21Bit(s)  */
    IfxCss_keyMacSize_22Bit,          /**< \brief MAC size 22Bit(s)  */
    IfxCss_keyMacSize_23Bit,          /**< \brief MAC size 23Bit(s)  */
    IfxCss_keyMacSize_24Bit,          /**< \brief MAC size 24Bit(s)  */
    IfxCss_keyMacSize_25Bit,          /**< \brief MAC size 25Bit(s)  */
    IfxCss_keyMacSize_26Bit,          /**< \brief MAC size 26Bit(s)  */
    IfxCss_keyMacSize_27Bit,          /**< \brief MAC size 27Bit(s)  */
    IfxCss_keyMacSize_28Bit,          /**< \brief MAC size 28Bit(s)  */
    IfxCss_keyMacSize_29Bit,          /**< \brief MAC size 29Bit(s)  */
    IfxCss_keyMacSize_30Bit,          /**< \brief MAC size 30Bit(s)  */
    IfxCss_keyMacSize_31Bit,          /**< \brief MAC size 31Bit(s)  */
    IfxCss_keyMacSize_32Bit,          /**< \brief MAC size 32Bit(s)  */
    IfxCss_keyMacSize_33Bit,          /**< \brief MAC size 33Bit(s)  */
    IfxCss_keyMacSize_34Bit,          /**< \brief MAC size 34Bit(s)  */
    IfxCss_keyMacSize_35Bit,          /**< \brief MAC size 35Bit(s)  */
    IfxCss_keyMacSize_36Bit,          /**< \brief MAC size 36Bit(s)  */
    IfxCss_keyMacSize_37Bit,          /**< \brief MAC size 37Bit(s)  */
    IfxCss_keyMacSize_38Bit,          /**< \brief MAC size 38Bit(s)  */
    IfxCss_keyMacSize_39Bit,          /**< \brief MAC size 39Bit(s)  */
    IfxCss_keyMacSize_40Bit,          /**< \brief MAC size 40Bit(s)  */
    IfxCss_keyMacSize_41Bit,          /**< \brief MAC size 41Bit(s)  */
    IfxCss_keyMacSize_42Bit,          /**< \brief MAC size 42Bit(s)  */
    IfxCss_keyMacSize_43Bit,          /**< \brief MAC size 43Bit(s)  */
    IfxCss_keyMacSize_44Bit,          /**< \brief MAC size 44Bit(s)  */
    IfxCss_keyMacSize_45Bit,          /**< \brief MAC size 45Bit(s)  */
    IfxCss_keyMacSize_46Bit,          /**< \brief MAC size 46Bit(s)  */
    IfxCss_keyMacSize_47Bit,          /**< \brief MAC size 47Bit(s)  */
    IfxCss_keyMacSize_48Bit,          /**< \brief MAC size 48Bit(s)  */
    IfxCss_keyMacSize_49Bit,          /**< \brief MAC size 49Bit(s)  */
    IfxCss_keyMacSize_50Bit,          /**< \brief MAC size 50Bit(s)  */
    IfxCss_keyMacSize_51Bit,          /**< \brief MAC size 51Bit(s)  */
    IfxCss_keyMacSize_52Bit,          /**< \brief MAC size 52Bit(s)  */
    IfxCss_keyMacSize_53Bit,          /**< \brief MAC size 53Bit(s)  */
    IfxCss_keyMacSize_54Bit,          /**< \brief MAC size 54Bit(s)  */
    IfxCss_keyMacSize_55Bit,          /**< \brief MAC size 55Bit(s)  */
    IfxCss_keyMacSize_56Bit,          /**< \brief MAC size 56Bit(s)  */
    IfxCss_keyMacSize_57Bit,          /**< \brief MAC size 57Bit(s)  */
    IfxCss_keyMacSize_58Bit,          /**< \brief MAC size 58Bit(s)  */
    IfxCss_keyMacSize_59Bit,          /**< \brief MAC size 59Bit(s)  */
    IfxCss_keyMacSize_60Bit,          /**< \brief MAC size 60Bit(s)  */
    IfxCss_keyMacSize_61Bit,          /**< \brief MAC size 61Bit(s)  */
    IfxCss_keyMacSize_62Bit,          /**< \brief MAC size 62Bit(s)  */
    IfxCss_keyMacSize_63Bit,          /**< \brief MAC size 63Bit(s)  */
    IfxCss_keyMacSize_64Bit,          /**< \brief MAC size 64Bit(s)  */
    IfxCss_keyMacSize_65Bit,          /**< \brief MAC size 65Bit(s)  */
    IfxCss_keyMacSize_66Bit,          /**< \brief MAC size 66Bit(s)  */
    IfxCss_keyMacSize_67Bit,          /**< \brief MAC size 67Bit(s)  */
    IfxCss_keyMacSize_68Bit,          /**< \brief MAC size 68Bit(s)  */
    IfxCss_keyMacSize_69Bit,          /**< \brief MAC size 69Bit(s)  */
    IfxCss_keyMacSize_70Bit,          /**< \brief MAC size 70Bit(s)  */
    IfxCss_keyMacSize_71Bit,          /**< \brief MAC size 71Bit(s)  */
    IfxCss_keyMacSize_72Bit,          /**< \brief MAC size 72Bit(s)  */
    IfxCss_keyMacSize_73Bit,          /**< \brief MAC size 73Bit(s)  */
    IfxCss_keyMacSize_74Bit,          /**< \brief MAC size 74Bit(s)  */
    IfxCss_keyMacSize_75Bit,          /**< \brief MAC size 75Bit(s)  */
    IfxCss_keyMacSize_76Bit,          /**< \brief MAC size 76Bit(s)  */
    IfxCss_keyMacSize_77Bit,          /**< \brief MAC size 77Bit(s)  */
    IfxCss_keyMacSize_78Bit,          /**< \brief MAC size 78Bit(s)  */
    IfxCss_keyMacSize_79Bit,          /**< \brief MAC size 79Bit(s)  */
    IfxCss_keyMacSize_80Bit,          /**< \brief MAC size 80Bit(s)  */
    IfxCss_keyMacSize_81Bit,          /**< \brief MAC size 81Bit(s)  */
    IfxCss_keyMacSize_82Bit,          /**< \brief MAC size 82Bit(s)  */
    IfxCss_keyMacSize_83Bit,          /**< \brief MAC size 83Bit(s)  */
    IfxCss_keyMacSize_84Bit,          /**< \brief MAC size 84Bit(s)  */
    IfxCss_keyMacSize_85Bit,          /**< \brief MAC size 85Bit(s)  */
    IfxCss_keyMacSize_86Bit,          /**< \brief MAC size 86Bit(s)  */
    IfxCss_keyMacSize_87Bit,          /**< \brief MAC size 87Bit(s)  */
    IfxCss_keyMacSize_88Bit,          /**< \brief MAC size 88Bit(s)  */
    IfxCss_keyMacSize_89Bit,          /**< \brief MAC size 89Bit(s)  */
    IfxCss_keyMacSize_90Bit,          /**< \brief MAC size 90Bit(s)  */
    IfxCss_keyMacSize_91Bit,          /**< \brief MAC size 91Bit(s)  */
    IfxCss_keyMacSize_92Bit,          /**< \brief MAC size 92Bit(s)  */
    IfxCss_keyMacSize_93Bit,          /**< \brief MAC size 93Bit(s)  */
    IfxCss_keyMacSize_94Bit,          /**< \brief MAC size 94Bit(s)  */
    IfxCss_keyMacSize_95Bit,          /**< \brief MAC size 95Bit(s)  */
    IfxCss_keyMacSize_96Bit,          /**< \brief MAC size 96Bit(s)  */
    IfxCss_keyMacSize_97Bit,          /**< \brief MAC size 97Bit(s)  */
    IfxCss_keyMacSize_98Bit,          /**< \brief MAC size 98Bit(s)  */
    IfxCss_keyMacSize_99Bit,          /**< \brief MAC size 99Bit(s)  */
    IfxCss_keyMacSize_100Bit,         /**< \brief MAC size 100Bit(s)  */
    IfxCss_keyMacSize_101Bit,         /**< \brief MAC size 101Bit(s)  */
    IfxCss_keyMacSize_102Bit,         /**< \brief MAC size 102Bit(s)  */
    IfxCss_keyMacSize_103Bit,         /**< \brief MAC size 103Bit(s)  */
    IfxCss_keyMacSize_104Bit,         /**< \brief MAC size 104Bit(s)  */
    IfxCss_keyMacSize_105Bit,         /**< \brief MAC size 105Bit(s)  */
    IfxCss_keyMacSize_106Bit,         /**< \brief MAC size 106Bit(s)  */
    IfxCss_keyMacSize_107Bit,         /**< \brief MAC size 107Bit(s)  */
    IfxCss_keyMacSize_108Bit,         /**< \brief MAC size 108Bit(s)  */
    IfxCss_keyMacSize_109Bit,         /**< \brief MAC size 109Bit(s)  */
    IfxCss_keyMacSize_110Bit,         /**< \brief MAC size 110Bit(s)  */
    IfxCss_keyMacSize_111Bit,         /**< \brief MAC size 111Bit(s)  */
    IfxCss_keyMacSize_112Bit,         /**< \brief MAC size 112Bit(s)  */
    IfxCss_keyMacSize_113Bit,         /**< \brief MAC size 113Bit(s)  */
    IfxCss_keyMacSize_114Bit,         /**< \brief MAC size 114Bit(s)  */
    IfxCss_keyMacSize_115Bit,         /**< \brief MAC size 115Bit(s)  */
    IfxCss_keyMacSize_116Bit,         /**< \brief MAC size 116Bit(s)  */
    IfxCss_keyMacSize_117Bit,         /**< \brief MAC size 117Bit(s)  */
    IfxCss_keyMacSize_118Bit,         /**< \brief MAC size 118Bit(s)  */
    IfxCss_keyMacSize_119Bit,         /**< \brief MAC size 119Bit(s)  */
    IfxCss_keyMacSize_120Bit,         /**< \brief MAC size 120Bit(s)  */
    IfxCss_keyMacSize_121Bit,         /**< \brief MAC size 121Bit(s)  */
    IfxCss_keyMacSize_122Bit,         /**< \brief MAC size 122Bit(s)  */
    IfxCss_keyMacSize_123Bit,         /**< \brief MAC size 123Bit(s)  */
    IfxCss_keyMacSize_124Bit,         /**< \brief MAC size 124Bit(s)  */
    IfxCss_keyMacSize_125Bit,         /**< \brief MAC size 125Bit(s)  */
    IfxCss_keyMacSize_126Bit,         /**< \brief MAC size 126Bit(s)  */
    IfxCss_keyMacSize_127Bit,         /**< \brief MAC size 127Bit(s)  */
    IfxCss_keyMacSize_128Bit,         /**< \brief MAC size 128Bit(s)  */
    IfxCss_keyMacSize_224Bit,         /**< \brief Mac Size 224Bits */
    IfxCss_keyMacSize_256Bit,         /**< \brief MAC size 256Bits */
    IfxCss_keyMacSize_384Bit,         /**< \brief MAC size 384Bits */
    IfxCss_keyMacSize_digestSize      /**< \brief MAC size as per digest size */
} IfxCss_keyMacSize;
#endif

/** \brief Enumeration describing write action of key
 */
typedef enum
{
    IfxCss_keyWrite_attributeOnly,  /**< \brief Write only attributes */
    IfxCss_keyWrite_wholeKey        /**< \brief Write whole key */
} IfxCss_keyWrite;

/** \brief Enumeration holding Service Request Nodes of CSS
 */
typedef enum
{
    IfxCss_serviceRequestNode_none = -1,  /**< \brief Not Selected */
    IfxCss_serviceRequestNode_0    = 0,   /**< \brief service request node 0  */
    IfxCss_serviceRequestNode_1,          /**< \brief service request node 1  */
    IfxCss_serviceRequestNode_2,          /**< \brief service request node 2  */
    IfxCss_serviceRequestNode_3,          /**< \brief service request node 3  */
    IfxCss_serviceRequestNode_4,          /**< \brief service request node 4  */
    IfxCss_serviceRequestNode_5,          /**< \brief service request node 5  */
    IfxCss_serviceRequestNode_6,          /**< \brief service request node 6  */
    IfxCss_serviceRequestNode_7,          /**< \brief service request node 7  */
    IfxCss_serviceRequestNode_8,          /**< \brief service request node 8  */
    IfxCss_serviceRequestNode_9,          /**< \brief service request node 9  */
    IfxCss_serviceRequestNode_10,         /**< \brief service request node 10  */
    IfxCss_serviceRequestNode_11,         /**< \brief service request node 11  */
    IfxCss_serviceRequestNode_12,         /**< \brief service request node 12  */
    IfxCss_serviceRequestNode_13,         /**< \brief service request node 13  */
    IfxCss_serviceRequestNode_14,         /**< \brief service request node 14  */
    IfxCss_serviceRequestNode_15,         /**< \brief service request node 15  */
    IfxCss_serviceRequestNode_16,         /**< \brief service request node 16  */
    IfxCss_serviceRequestNode_17,         /**< \brief service request node 17  */
    IfxCss_serviceRequestNode_18,         /**< \brief service request node 18  */
    IfxCss_serviceRequestNode_19,         /**< \brief service request node 19  */
    IfxCss_serviceRequestNode_20,         /**< \brief service request node 20  */
    IfxCss_serviceRequestNode_21,         /**< \brief service request node 21  */
    IfxCss_serviceRequestNode_22,         /**< \brief service request node 22  */
    IfxCss_serviceRequestNode_23,         /**< \brief service request node 23  */
    IfxCss_serviceRequestNode_24,         /**< \brief service request node 24  */
    IfxCss_serviceRequestNode_25,         /**< \brief service request node 25  */
    IfxCss_serviceRequestNode_26,         /**< \brief service request node 26  */
    IfxCss_serviceRequestNode_27,         /**< \brief service request node 27  */
    IfxCss_serviceRequestNode_28,         /**< \brief service request node 28  */
    IfxCss_serviceRequestNode_29,         /**< \brief service request node 29  */
    IfxCss_serviceRequestNode_30,         /**< \brief service request node 30  */
    IfxCss_serviceRequestNode_31,         /**< \brief service request node 31  */
    IfxCss_serviceRequestNode_count       /**< \brief Number of service request nodes */
} IfxCss_serviceRequestNode;

/** \brief Enumeration listing the status of an operation
 */
typedef enum
{
    IfxCss_status_success,  /**< \brief operation successful */
    IfxCss_status_failure   /**< \brief operation failed */
} IfxCss_status;

/** \} */

#ifndef IFX_CFG_VP_PLATFORM
/** \brief minimum size of the MAC/HASH that can be verified using a key
 */
typedef enum
{
    IfxCss_keyMacSize_unlimited = 0,  /**< \brief MAC size for verification is unlimited */
    IfxCss_keyMacSize_4Bit      = 1,  /**< \brief MAC size 4Bits */
    IfxCss_keyMacSize_8Bit,           /**< \brief MAC size 8Bits */
    IfxCss_keyMacSize_12Bit,          /**< \brief MAC size 12Bits */
    IfxCss_keyMacSize_16Bit,          /**< \brief MAC size 16Bits */
    IfxCss_keyMacSize_20Bit,          /**< \brief MAC size 20Bits */
    IfxCss_keyMacSize_24Bit,          /**< \brief MAC size 24Bits */
    IfxCss_keyMacSize_28Bit,          /**< \brief MAC size 28Bits */
    IfxCss_keyMacSize_32Bit,          /**< \brief MAC size 32Bits */
    IfxCss_keyMacSize_36Bit,          /**< \brief MAC size 36Bits */
    IfxCss_keyMacSize_40Bit,          /**< \brief MAC size 40Bits */
    IfxCss_keyMacSize_44Bit,          /**< \brief MAC size 44Bits */
    IfxCss_keyMacSize_48Bit,          /**< \brief MAC size 48Bits */
    IfxCss_keyMacSize_52Bit,          /**< \brief MAC size 52Bits */
    IfxCss_keyMacSize_56Bit,          /**< \brief MAC size 56Bits */
    IfxCss_keyMacSize_60Bit,          /**< \brief MAC size 60Bits */
    IfxCss_keyMacSize_64Bit,          /**< \brief MAC size 64Bits */
    IfxCss_keyMacSize_68Bit,          /**< \brief MAC size 68Bits */
    IfxCss_keyMacSize_72Bit,          /**< \brief MAC size 72Bits */
    IfxCss_keyMacSize_76Bit,          /**< \brief MAC size 76Bits */
    IfxCss_keyMacSize_80Bit,          /**< \brief MAC size 80Bits */
    IfxCss_keyMacSize_84Bit,          /**< \brief MAC size 84Bits */
    IfxCss_keyMacSize_88Bit,          /**< \brief MAC size 88Bits */
    IfxCss_keyMacSize_92Bit,          /**< \brief MAC size 92Bits */
    IfxCss_keyMacSize_96Bit,          /**< \brief MAC size 96Bits */
    IfxCss_keyMacSize_100Bit,         /**< \brief MAC size 100Bits */
    IfxCss_keyMacSize_104Bit,         /**< \brief MAC size 104Bits */
    IfxCss_keyMacSize_108Bit,         /**< \brief MAC size 108Bits */
    IfxCss_keyMacSize_112Bit,         /**< \brief MAC size 112Bits */
    IfxCss_keyMacSize_116Bit,         /**< \brief MAC size 116Bits */
    IfxCss_keyMacSize_120Bit,         /**< \brief MAC size 120Bits */
    IfxCss_keyMacSize_124Bit,         /**< \brief MAC size 124Bits */
    IfxCss_keyMacSize_128Bit,         /**< \brief MAC size 128Bits */
    IfxCss_keyMacSize_224Bit,         /**< \brief Mac Size 224Bits */
    IfxCss_keyMacSize_256Bit,         /**< \brief MAC size 256Bits */
    IfxCss_keyMacSize_384Bit,         /**< \brief MAC size 384Bits */
    IfxCss_keyMacSize_512Bit,         /**< \brief MAC size 512Bits */
    IfxCss_keyMacSize_digestSize      /**< \brief MAC size as per digest size */
} IfxCss_keyMacSize;
#endif

/******************************************************************************/
/*-----------------------------Data Structures--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Css_Std_Structures
 * \{ */
/** \brief Structure holding the attributes of a key
 */
typedef struct
{
    uint32            address;                  /**< \brief address of Globaly key / ID of channel key */
    IfxCss_featureSet macVerCapability;         /**< \brief MAC Verfication capability of key. */
    IfxCss_featureSet macGenCapability;         /**< \brief MAC generation capability of Key */
    IfxCss_featureSet cipherCapability;         /**< \brief Encryption/Decryption capability of key */
    IfxCss_keyMacSize macSize;                  /**< \brief MAC size supported by key */
    IfxCss_featureSet debugRestrict;            /**< \brief If enabled, Debug usage is restricted for the key */
    IfxCss_featureSet keyLock;                  /**< \brief If enabled, Key is locked and cannot be modified */
    IfxCss_keyLength  keyLength;                /**< \brief Length of key */
    IfxCss_featureSet fromOut;                  /**< \brief If enabled, the key will be used from Data Out of Private channel */
    IfxCss_featureSet xorEnable;                /**< \brief if enabled, Key will be XORed with the current key at address. */
    IfxCss_keyWrite   keyWrite;                 /**< \brief Write action of key */
    boolean           secureBootRestrict;       /**< \brief Restrict usage if secure boot failed */
} IfxCss_KeyAttributes;

/** \brief contains the key/IV write status of a particular key that is written.
 * All Bits may not be applicable for channel Keys / IV writes.
 */
typedef struct
{
    uint32 illegalLength : 1;      /**< \brief key length is not allowed */
    uint32 noInput : 1;            /**< \brief No key input provided to KEY_VALUE */
    uint32 illegalLoc : 1;         /**< \brief Illegal location : write in between keys */
    uint32 locked : 1;             /**< \brief Key was locked. */
    uint32 illegalXor : 1;         /**< \brief illegal XOR operation */
    uint32 illegalAddrId : 1;      /**< \brief illegal address / ID of write */
    uint32 noWriteAccess : 1;      /**< \brief No write access allowed */
    uint32 noUpdate : 1;           /**< \brief No valid address - no write */
    uint32 occupied : 1;           /**< \brief Key location is occupied by another task */
    uint32 noCommand : 1;          /**< \brief Write operation without command */
    uint32 busy : 1;               /**< \brief address is currently being written to. */
    uint32 softwareError : 1;      /**< \brief Error bit that holds any any key errors detected by driver. */
} IfxCss_KeyIvWriteStatusBits;

/** \brief Bitfield Structure holding the key usage error bits
 */
typedef struct
{
    uint32 illegalID : 1;           /**< \brief illegal key ID */
    uint32 illegalKey : 1;          /**< \brief illegal Key Selection */
    uint32 illegalCiph : 1;         /**< \brief illegal Cipher operation (Enc/Dec) */
    uint32 illegalMacGen : 1;       /**< \brief illegal MAC generation operation */
    uint32 illegalMacVer;           /**< \brief illegal MAC verification operation */
    uint32 illegalDebug : 1;        /**< \brief illegal use of key during Debug */
    uint32 notInitialized : 1;      /**< \brief Key is not initialized. */
    uint32 sizeError : 1;           /**< \brief Key has the wrong size for operation */
    uint32 ivSelected : 1;          /**< \brief IV is selected instead of key */
} IfxCss_KeyUseErrorBits;

/** \brief Bitfield structure holding the error status bits
 */
typedef struct
{
    uint32 illegalOp : 1;           /**< \brief illegal cypto operatoin error */
    uint32 illegalIv : 1;           /**< \brief illegal IV used */
    uint32 illegalLength : 1;       /**< \brief Data length is illegal */
    uint32 illegalMacVer : 1;       /**< \brief illegal verification of MAC operation */
    uint32 noIv : 1;                /**< \brief No valid IV for operation */
    uint32 fifoOverflow : 1;        /**< \brief FIFO overflow */
    uint32 ignoredConfig : 1;       /**< \brief Config write ignored */
    uint32 softwareError : 1;       /**< \brief Software Error reported by driver */
    uint32 fifoUnderflow : 1;       /**< \brief FIFO underflow */
} IfxCss_opErrorStatusBits;

/** \} */

/** \addtogroup IfxLld_Css_Std_Structures
 * \{ */
/** \brief Interrupt node configuration of a channel
 */
typedef struct
{
    IfxCss_serviceRequestNode dataInNode;        /**< \brief SRN for data input event */
    IfxCss_serviceRequestNode dataOutNode;       /**< \brief SRN for data out event */
    IfxCss_serviceRequestNode macNode;           /**< \brief SRN for mac event */
    IfxCss_serviceRequestNode errorNode;         /**< \brief SRN for error event */
} IfxCss_ChannelInterruptNodeCfg;

/** \brief Initialization Vector section mapping configuration of channel
 */
typedef struct
{
    uint32 size;       /**< \brief Size of the IV section allocated to channel. */
    uint32 base;       /**< \brief Base address of the IV section of the channel */
} IfxCss_ChannelIvCfg;

/** \brief Key section mapping configuration of channel
 */
typedef struct
{
    uint32 size;       /**< \brief Size of key section assigned to channel. */
    uint32 base;       /**< \brief Base address of key section mapped to channel */
} IfxCss_ChannelKeyCfg;

typedef struct
{
    uint8  ID;             /**< \brief ID of the IV in memory */
    uint32 value[4];       /**< \brief Array holding IV value */
} IfxCss_Iv;

/** \brief Data structure defining a key for CSS operations
 */
typedef struct
{
    uint32               value[8];         /**< \brief key value. (8 words for 256 Bit key) */
    IfxCss_KeyAttributes attributes;       /**< \brief Attributes of the key */
} IfxCss_Key;

/** \brief Union holding the key/IV write status bits
 */
typedef union
{
    IfxCss_KeyIvWriteStatusBits Bits;       /**< \brief Structure of status bits */
    uint32                      Word;       /**< \brief Word holding write status bits */
} IfxCss_KeyIvWriteStatus;

/** \brief Union holding the key usage error information
 */
typedef union
{
    IfxCss_KeyUseErrorBits Bits;       /**< \brief Bitfield information of key use errors */
    uint32                 Word;       /**< \brief consolidated key use error information */
} IfxCss_KeyUseError;

/** \brief Union holding the operation error status of a channel
 */
typedef union
{
    IfxCss_opErrorStatusBits Bits;       /**< \brief Bitfield holding specific error information */
    uint32                   Word;       /**< \brief Word holding consolidated operation error status */
} IfxCss_opErrorStatus;

/** \} */

/** \addtogroup IfxLld_Css_Std_Module_functions
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Function that checks if the key is invalid and should not be written.
 * \param keyPtr Pointer to the key being tested
 * \return returns TRUE: key is invalid for write
 * return FALSE: key is valid for write
 */
IFX_INLINE boolean IfxCss_isGlobalKeyInvalid(const IfxCss_Key *keyPtr);

/** \brief Writes the WRCMD register with the input key attributes
 * \param cssSFR pointer to the CSS SFR block
 * \param keyPtr Pointer to the key to be written
 * \return None
 */
IFX_INLINE void IfxCss_writeKeyCommand(Ifx_CSS *cssSFR, const IfxCss_Key *keyPtr);

/** \brief Writes the key value into the KEYVALUE registers
 * \param cssSFR pointer to the CSS SFR block
 * \param keyPtr Pointer to the key to be written
 * \return None
 */
IFX_INLINE void IfxCss_writeKeyInput(Ifx_CSS *cssSFR, const IfxCss_Key *keyPtr);

/** \brief Updates the write status with current write errors in WRSTAT.
 * Clears the WRSTAT after read
 * \param cssSFR pointer to the CSS SFR block
 * \param writeStatus Write status of key write.
 * \return None
 */
IFX_INLINE void IfxCss_updateAndClearWriteError(Ifx_CSS *cssSFR, IfxCss_KeyIvWriteStatus *writeStatus);

/** \brief get SRC pointer to the SRN node register
 * \return SRC pointer to the SRN node register
 */
IFX_INLINE volatile Ifx_SRC_SRCR *IfxCss_getSrcPointer(IfxCss_serviceRequestNode node);

/** \} */

/** \addtogroup IfxLld_Css_Std_Channel_functions
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Function to reset the channel
 * \param chPtr Pointer to the channel SFR
 * \return None
 */
IFX_INLINE void IfxCss_Ch_resetChannel(Ifx_CSS_CH *chPtr);

/**
 * \param chSFR Pointer to the channel SFR
 * \return TRUE: Channel can write keys
 * FALSE: Channel cannot write keys
 */
IFX_INLINE boolean IfxCss_Ch_isKeyWriteEnabled(Ifx_CSS_CH *chSFR);

/** \brief Returns the number of key slots available for the channel
 * \return Number of key Slots
 */
IFX_INLINE uint8 IfxCss_Ch_getKeySlots(Ifx_CSS_CH *chSFR);

/** \brief Returns the number of IV slots available for channel
 * \param chSFR Pointer to the channel SFR set
 * \return Number of IV slots
 */
IFX_INLINE uint8 IfxCss_Ch_getIvSlots(Ifx_CSS_CH *chSFR);

/** \brief Writes the key value into the channel KEYVALUE registers
 * \param chSFR pointer to the CSS SFR block
 * \param keyPtr Pointer to the key to be written
 * \return None
 */
IFX_INLINE void IfxCss_Ch_writeKeyInput(Ifx_CSS_CH *chSFR, IfxCss_Key *keyPtr);

/** \brief Writes the IV value into the channel IVVALUE registers
 * \param chSFR Pointer to the channel SFR set
 * \param ivPtr Pointer to the IV to be written
 * \return None
 */
IFX_INLINE void IfxCss_Ch_writeIvInput(Ifx_CSS_CH *chSFR, IfxCss_Iv *ivPtr);

/** \brief Writes the WRCMD register with the input key attributes
 * \param chSFR pointer to the CSS SFR block
 * \param keyPtr Pointer to the key to be written
 * \return None
 */
IFX_INLINE void IfxCss_Ch_writeKeyCommand(Ifx_CSS_CH *chSFR, IfxCss_Key *keyPtr);

/** \brief Writes the WRCMD register with the input IV attributes
 * \param chSFR pointer to the CSS SFR block
 * \param ivPtr Pointer to the IV to be written
 * \return None
 */
IFX_INLINE void IfxCss_Ch_writeIvCommand(Ifx_CSS_CH *chSFR, IfxCss_Iv *ivPtr);

/** \brief Function that checks if the key is invalid and should not be written.
 * \param keyPtr Pointer to the key being tested
 * \return returns TRUE: key is invalid for write
 * return FALSE: key is valid for write
 */
IFX_INLINE boolean IfxCss_Ch_isKeyInvalid(IfxCss_Key *keyPtr);

/** \brief Updates the write status with current write errors in WRSTAT.
 * Clears the WRSTAT after read
 * \param chSFR pointer to the CSS SFR block
 * \param writeStatus Write status of key write.
 * \return None
 */
IFX_INLINE void IfxCss_Ch_updateAndClearKeyWriteError(Ifx_CSS_CH *chSFR, IfxCss_KeyIvWriteStatus *writeStatus);

/** \brief Updates the write status with current write errors in WRSTAT.
 * Clears the WRSTAT after read
 * \param chSFR pointer to the CSS SFR block
 * \param writeStatus Write status of key write.
 * \return None
 */
IFX_INLINE void IfxCss_Ch_updateAndClearIvWriteError(Ifx_CSS_CH *chSFR, IfxCss_KeyIvWriteStatus *writeStatus);

/** \brief Returns TRUE: if channel is busy with another operation
 * \param chSFR Pointer to the channel SFR
 * \return Channel Busy Status
 */
IFX_INLINE boolean IfxCss_Ch_isChannelBusy(Ifx_CSS_CH *chSFR);

/** \brief Function to update the PC length for crypto operations
 * \param chSFR Pointer to the Channel SFR
 * \param length Length of PC in bytes
 * \param singleCall If TRUE, then the operation is single call
 * \return None
 */
IFX_INLINE void IfxCss_Ch_updatePcLength(Ifx_CSS_CH *chSFR, uint32 length, boolean singleCall);

/** \brief Function to update the PC length for crypto operations
 * \param chSFR Pointer to the Channel SFR
 * \param length Length of AAD in bytes
 * \param singleCall If TRUE, then the operation is single call
 * \return None
 */
IFX_INLINE void IfxCss_Ch_updateAadLength(Ifx_CSS_CH *chSFR, uint32 length, boolean singleCall);

/** \brief Select the Crypto engine
 * \param opCtrl Pointer to the opctrl word
 * \param algo Crypto algorithm selection
 * \return None
 */
IFX_INLINE void IfxCss_Ch_selectCryptoAlgo(uint32 *opCtrl, IfxCss_cryptoOpMode algo);

/** \brief Select the Hash Engine
 * \param opCtrl Pointer to the opCtrl word
 * \param algo Crypto algorithm selection
 * \return None
 */
IFX_INLINE void IfxCss_Ch_selectHashAlgo(uint32 *opCtrl, IfxCss_hashOpMode algo);

/** \brief Write OP CTRL
 * \param chSFR Pointer to the channel SFR
 * \param opCtrl word
 * \return None
 */
IFX_INLINE void IfxCss_Ch_writeOpCtrl(Ifx_CSS_CH *chSFR, uint32 opCtrl);

/** \brief returns TRUE is the channel is in error state
 * \param chSFR Pointer to the channel SFR
 * \return channel in error State
 */
IFX_INLINE boolean IfxCss_Ch_getErrorStatus(Ifx_CSS_CH *chSFR);

/** \brief Returns the number of bytes in the output FIFO of channel
 * \param chSFR Pointer to the channel SFR
 * \return output Data in bytes
 */
IFX_INLINE uint16 IfxCss_Ch_getOutputDataCount(Ifx_CSS_CH *chSFR);

/** \brief Returns the number of free entries in Input FIFO
 * \param chSFR Pointer to the channel SFR
 * \return free entries in Input FIFO
 */
IFX_INLINE uint16 IfxCss_Ch_getInFifoFreeCount(Ifx_CSS_CH *chSFR);

/** \brief returns TRUE if MAC generation is completed
 * \param chSFR Pointer to the channel SFR
 * \return TRUE: MAC generation is completed
 */
IFX_INLINE boolean IfxCss_Ch_isMacGenComplete(Ifx_CSS_CH *chSFR);

/** \brief returns TRUE if MAC verification is completed
 * \param chSFR Pointer to the channel SFR
 * \return TRUE: MAC verification is completed
 */
IFX_INLINE boolean IfxCss_Ch_isMacVerComplete(Ifx_CSS_CH *chSFR);

/** \brief returns TRUE if MAC verification is OK
 * \param chSFR Pointer to the channel SFR
 * \return TRUE: MAC verification is OK
 */
IFX_INLINE boolean IfxCss_Ch_checkMacCompareResult(Ifx_CSS_CH *chSFR);

/** \brief return TRUE if channel is in use for a message operation.
 * \param chSFR Pointer to the channel SFR
 * \return channel in use
 */
IFX_INLINE boolean IfxCss_Ch_isChannelInUse(Ifx_CSS_CH *chSFR);

/** \brief Function to enable the Data in event for CSS channel
 * \return None
 */
IFX_INLINE void IfxCss_Ch_enableDataInEvent(Ifx_CSS_CH *chSFR);

/** \brief Function to disable the Data in event for CSS channel
 * \return None
 */
IFX_INLINE void IfxCss_Ch_disableDataInEvent(Ifx_CSS_CH *chSFR);

/** \brief Function to get input fifo size for specified channel
 * \return FIFO size in bytes
 */
IFX_INLINE uint16 IfxCss_Ch_getInFifoSizeBytes(IfxCss_channelId channel);

/** \brief Function to get output fifo size for specified channel
 * \return FIFO size in bytes
 */
IFX_INLINE uint16 IfxCss_Ch_getOutFifoSizeBytes(IfxCss_channelId channel);

/** \} */

/******************************************************************************/
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE boolean IfxCss_isGlobalKeyInvalid(const IfxCss_Key *keyPtr)
{
    const IfxCss_KeyAttributes *attr = &(keyPtr->attributes);

    return attr->keyLength == IfxCss_keyLength_invalid;
}


IFX_INLINE void IfxCss_writeKeyCommand(Ifx_CSS *cssSFR, const IfxCss_Key *keyPtr)
{
    /* TODO: assert here for null key pointer */
    Ifx_CSS_KEY_WRCMD           wrcmd;
    const IfxCss_KeyAttributes *attr = &(keyPtr->attributes);

    wrcmd.U             = cssSFR->KEY.WRCMD.U; /* read in the value  of register */

    wrcmd.B.ADDR        = attr->address;
    wrcmd.B.VER         = (uint32)attr->macVerCapability;
    wrcmd.B.MACSIZE     = (uint32)attr->macSize;
    wrcmd.B.GEN         = (uint32)attr->macGenCapability;
    wrcmd.B.CIPH        = (uint32)attr->cipherCapability;
    wrcmd.B.DBG         = (uint32)attr->debugRestrict;
    wrcmd.B.WRP         = (uint32)attr->keyLock;
    wrcmd.B.KEYSIZE     = (uint32)attr->keyLength;
    wrcmd.B.FROMOUT     = (uint32)attr->fromOut;
    wrcmd.B.XORKEY      = (uint32)attr->xorEnable;
    wrcmd.B.WR          = (uint32)attr->keyWrite;
    wrcmd.B.SECBTRES    = (uint32)attr->secureBootRestrict;

    cssSFR->KEY.WRCMD.U = wrcmd.U;
}


IFX_INLINE void IfxCss_writeKeyInput(Ifx_CSS *cssSFR, const IfxCss_Key *keyPtr)
{
    volatile Ifx_CSS_KEY_VALUE *keyVal    = &(cssSFR->KEY.VALUE[0]);
    uint8                       index;
    uint8                       writeSize = (uint8)0;
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, keyPtr != NULL_PTR);

    switch (keyPtr->attributes.keyLength & (uint32)3)
    {
    case (1):
        writeSize = (uint8)4;
        break;
    case (2):
        writeSize = (uint8)6;
        break;
    case (3):
        writeSize = (uint8)8;
        break;
    default:
        IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, FALSE);
        break;
    }

    for (index = 0; index < writeSize; index++)
    {
        keyVal[index].U = keyPtr->value[index];
    }
}


IFX_INLINE void IfxCss_updateAndClearWriteError(Ifx_CSS *cssSFR, IfxCss_KeyIvWriteStatus *writeStatus)
{
    Ifx_CSS_KEY_WRSTAT wrStat;

    wrStat.U             = cssSFR->KEY.WRSTAT.U;                   /* Read in the status register */
    writeStatus->Word   |= (wrStat.U & (IFXCSS_WRSTAT_ERRORMASK)); /* read in any new errors */

    cssSFR->KEY.WRSTAT.U = (uint32)0;                              /* clear the errors */
}


IFX_INLINE void IfxCss_Ch_resetChannel(Ifx_CSS_CH *chPtr)
{
    chPtr->TRGRES.B.TRGRES = (uint32)1;
}


IFX_INLINE boolean IfxCss_Ch_isKeyWriteEnabled(Ifx_CSS_CH *chSFR)
{
    return chSFR->STAT.KEYIV.B.WRKEY == (uint32)1;
}


IFX_INLINE uint8 IfxCss_Ch_getKeySlots(Ifx_CSS_CH *chSFR)
{
    return (uint8)(chSFR->STAT.KEYIV.B.KEYNUM);
}


IFX_INLINE uint8 IfxCss_Ch_getIvSlots(Ifx_CSS_CH *chSFR)
{
    return (uint8)(chSFR->STAT.KEYIV.B.IVNUM);
}


IFX_INLINE void IfxCss_Ch_writeKeyInput(Ifx_CSS_CH *chSFR, IfxCss_Key *keyPtr)
{
    volatile Ifx_CSS_CH_KEY_VALUE *keyVal    = &(chSFR->KEY.VALUE[0]);
    uint8                          index;
    uint8                          writeSize = (uint8)0;
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, keyPtr != NULL_PTR);

    switch (keyPtr->attributes.keyLength & (uint32)3)
    {
    case (1):
        writeSize = (uint8)4;
        break;
    case (2):
        writeSize = (uint8)6;
        break;
    case (3):
        writeSize = (uint8)8;
        break;
    default:
        IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, FALSE);
        break;
    }

    for (index = 0; index < writeSize; index++)
    {
        keyVal[index].U = keyPtr->value[index];
    }
}


IFX_INLINE void IfxCss_Ch_writeIvInput(Ifx_CSS_CH *chSFR, IfxCss_Iv *ivPtr)
{
    volatile Ifx_CSS_CH_IV_VALUE *ivVal = &(chSFR->IV.VALUE[0]);
    uint8                         index;

    for (index = 0; index < 4; index++)
    {
        ivVal[index].U = ivPtr->value[index];
    }
}


IFX_INLINE void IfxCss_Ch_writeKeyCommand(Ifx_CSS_CH *chSFR, IfxCss_Key *keyPtr)
{
    Ifx_CSS_CH_KEY_WRCMD  wrcmd;
    IfxCss_KeyAttributes *attr = &(keyPtr->attributes);

    wrcmd.U            = chSFR->KEY.WRCMD.U; /* read in the value  of register */

    wrcmd.B.ID         = attr->address;
    wrcmd.B.VER        = (uint32)attr->macVerCapability;
    wrcmd.B.MACSIZE    = (uint32)attr->macSize;
    wrcmd.B.GEN        = (uint32)attr->macGenCapability;
    wrcmd.B.CIPH       = (uint32)attr->cipherCapability;
    wrcmd.B.DBG        = (uint32)attr->debugRestrict;
    wrcmd.B.WRP        = (uint32)attr->keyLock;
    wrcmd.B.KEYSIZE    = (uint32)attr->keyLength;
    wrcmd.B.FROMOUT    = (uint32)attr->fromOut;
    wrcmd.B.XORKEY     = (uint32)attr->xorEnable;
    wrcmd.B.WR         = (uint32)attr->keyWrite;
    wrcmd.B.SECBTRES   = (uint32)attr->secureBootRestrict;

    chSFR->KEY.WRCMD.U = wrcmd.U;
}


IFX_INLINE void IfxCss_Ch_writeIvCommand(Ifx_CSS_CH *chSFR, IfxCss_Iv *ivPtr)
{
    Ifx_CSS_CH_IV_WRCMD wrcmd;
    uint8               id = ivPtr->ID;

    wrcmd.U           = chSFR->IV.WRCMD.U;  /* read in the value  of register */
    wrcmd.B.ID        = id;
    chSFR->IV.WRCMD.U = wrcmd.U;
}


IFX_INLINE boolean IfxCss_Ch_isKeyInvalid(IfxCss_Key *keyPtr)
{
    /* TODO: more checks to ensure Channel key validity */
    IfxCss_KeyAttributes *attr = &(keyPtr->attributes);

    return attr->keyLength == IfxCss_keyLength_invalid;
}


IFX_INLINE void IfxCss_Ch_updateAndClearKeyWriteError(Ifx_CSS_CH *chSFR, IfxCss_KeyIvWriteStatus *writeStatus)
{
    Ifx_CSS_CH_KEY_WRSTAT wrStat;

    wrStat.U            = chSFR->KEY.WRSTAT.U;                    /* Read in the status register */
    writeStatus->Word  |= (wrStat.U & (IFXCSS_WRSTAT_ERRORMASK)); /* read in any new errors */

    chSFR->KEY.WRSTAT.U = (uint32)0;                              /* clear the errors */
}


IFX_INLINE void IfxCss_Ch_updateAndClearIvWriteError(Ifx_CSS_CH *chSFR, IfxCss_KeyIvWriteStatus *writeStatus)
{
    Ifx_CSS_CH_IV_WRSTAT wrStat;

    wrStat.U           = chSFR->IV.WRSTAT.U;                     /* Read in the status register */
    writeStatus->Word |= (wrStat.U & (IFXCSS_WRSTAT_ERRORMASK)); /* read in any new errors */

    chSFR->IV.WRSTAT.U = (uint32)0;                              /* clear the errors */
}


IFX_INLINE boolean IfxCss_Ch_isChannelBusy(Ifx_CSS_CH *chSFR)
{
    Ifx_CSS_CH_STAT_OP opStatReg;
    opStatReg.U = chSFR->STAT.OP.U;

    return IFXCSS_CHECK_CH_BUSY(opStatReg.U);
}


IFX_INLINE void IfxCss_Ch_updatePcLength(Ifx_CSS_CH *chSFR, uint32 length, boolean singleCall)
{
    Ifx_CSS_CH_LEN_PC pcLengthReg;
    pcLengthReg.U       = 0u;              /* Initialize to zero */

    pcLengthReg.B.LEN   = length << 3u;    /* Convert bytes to bits */
    pcLengthReg.B.FINAL = (uint32)singleCall;

    chSFR->LEN.PC.U     = pcLengthReg.U;   /* Write back */
}


IFX_INLINE void IfxCss_Ch_updateAadLength(Ifx_CSS_CH *chSFR, uint32 length, boolean singleCall)
{
    Ifx_CSS_CH_LEN_AAD aadLengthReg;
    aadLengthReg.U       = 0u;                 /* Initialize to zero */

    aadLengthReg.B.LEN   = length << 3u;       /* Convert bytes to bits */
    aadLengthReg.B.FINAL = (uint32)singleCall;

    chSFR->LEN.AAD.U     = aadLengthReg.U;     /* Write back */
}


IFX_INLINE void IfxCss_Ch_selectCryptoAlgo(uint32 *opCtrl, IfxCss_cryptoOpMode algo)
{
    Ifx_CSS_CH_OPCTRL opctrlReg;
    opctrlReg.U       = *opCtrl; /* initialize to passed value */

    opctrlReg.B.CRYPT = (uint32)algo;

    *opCtrl           = opctrlReg.U;
}


IFX_INLINE void IfxCss_Ch_selectHashAlgo(uint32 *opCtrl, IfxCss_hashOpMode algo)
{
    Ifx_CSS_CH_OPCTRL opctrlReg;
    opctrlReg.U      = *opCtrl; /* initialize to passed value */

    opctrlReg.B.HASH = (uint32)algo;

    *opCtrl          = opctrlReg.U;
}


IFX_INLINE void IfxCss_Ch_writeOpCtrl(Ifx_CSS_CH *chSFR, uint32 opCtrl)
{
    chSFR->OPCTRL.U = opCtrl;
}


IFX_INLINE boolean IfxCss_Ch_getErrorStatus(Ifx_CSS_CH *chSFR)
{
    return chSFR->STAT.OP.B.ERR == 1U;
}


IFX_INLINE uint16 IfxCss_Ch_getOutputDataCount(Ifx_CSS_CH *chSFR)
{
    return (uint16)(chSFR->STAT.OP.B.OUTCNT);
}


IFX_INLINE uint16 IfxCss_Ch_getInFifoFreeCount(Ifx_CSS_CH *chSFR)
{
    return (uint16)(chSFR->STAT.OP.B.INCNT);
}


IFX_INLINE boolean IfxCss_Ch_isMacGenComplete(Ifx_CSS_CH *chSFR)
{
    Ifx_CSS_CH_STAT_OP opStatReg;
    opStatReg.U = chSFR->STAT.OP.U;

    return IFXCSS_CHECK_MACGEN_COMPLETE(opStatReg.U);
}


IFX_INLINE boolean IfxCss_Ch_isMacVerComplete(Ifx_CSS_CH *chSFR)
{
    Ifx_CSS_CH_STAT_OP opStatReg;
    opStatReg.U = chSFR->STAT.OP.U;

    return IFXCSS_CHECK_MACVER_COMPLETE(opStatReg.U);
}


IFX_INLINE boolean IfxCss_Ch_checkMacCompareResult(Ifx_CSS_CH *chSFR)
{
    Ifx_CSS_CH_AUTHRES authRes;
    authRes.U = chSFR->AUTHRES.U;

    return IFXCSS_CHECK_MAC_RESULT(authRes.U);
}


IFX_INLINE boolean IfxCss_Ch_isChannelInUse(Ifx_CSS_CH *chSFR)
{
    Ifx_CSS_CH_STAT_OP opStatReg;
    opStatReg.U = chSFR->STAT.OP.U;

    return IFXCSS_CHECK_CH_INUSE(opStatReg.U);
}


IFX_INLINE volatile Ifx_SRC_SRCR *IfxCss_getSrcPointer(IfxCss_serviceRequestNode node)
{
    return &(MODULE_SRC.CSS[0].SR[node]);
}


IFX_INLINE void IfxCss_Ch_enableDataInEvent(Ifx_CSS_CH *chSFR)
{
    chSFR->INTR.CFG.B.DIN = (uint32)1;
}


IFX_INLINE void IfxCss_Ch_disableDataInEvent(Ifx_CSS_CH *chSFR)
{
    chSFR->INTR.CFG.B.DIN = (uint32)0;
}


IFX_INLINE uint16 IfxCss_Ch_getInFifoSizeBytes(IfxCss_channelId channel)
{
    uint16 fifoSize = 0u;

    if (channel == IfxCss_channelId_0)
    {
        fifoSize = IFXCSS_CHANNEL0_INPUTFIFOSIZE_BYTES;
    }
    else if ((channel == IfxCss_channelId_1) || (channel == IfxCss_channelId_2))
    {
        fifoSize = IFXCSS_CHANNEL1TO2_INPUTFIFOSIZE_BYTES;
    }
    else
    {
        fifoSize = IFXCSS_CHANNEL3TO20_INPUTFIFOSIZE_BYTES;
    }

    return fifoSize;
}


IFX_INLINE uint16 IfxCss_Ch_getOutFifoSizeBytes(IfxCss_channelId channel)
{
    uint16 fifoSize = 0u;

    if (channel == IfxCss_channelId_0)
    {
        fifoSize = IFXCSS_CHANNEL0_OUTPUTFIFOSIZE_BYTES;
    }
    else if ((channel == IfxCss_channelId_1) || (channel == IfxCss_channelId_2))
    {
        fifoSize = IFXCSS_CHANNEL1TO2_OUTPUTFIFOSIZE_BYTES;
    }
    else
    {
        fifoSize = IFXCSS_CHANNEL3TO20_OUTPUTFIFOSIZE_BYTES;
    }

    return fifoSize;
}


#endif /* IFXCSS_H */
