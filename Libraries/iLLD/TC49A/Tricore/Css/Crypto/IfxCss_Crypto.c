/**
 * \file IfxCss_Crypto.c
 * \brief CSS CRYPTO details
 *
 * \version iLLD_2_0_1_2_19
 * \copyright Copyright (c) 2023 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 *
 */

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "IfxCss_Crypto.h"

/** \addtogroup IfxLld_Css_Crypto_Private_functions
 * \{ */
/******************************************************************************/
/*------------------------Inline Function Prototypes--------------------------*/
/******************************************************************************/

/** \brief Gets and clears all errors in operation.
 * Also returns fail if some error is present in channel.
 * \param channel Pointer to the channel handle
 * \return error failure
 */
IFX_INLINE IfxCss_status IfxCss_Crypto_updateMessageError(IfxCss_Crypto_Channel *channel);

/******************************************************************************/
/*-----------------------Private Function Prototypes--------------------------*/
/******************************************************************************/

/** \brief Configure the Crypto operation
 * \param channel Pointer to the channel handle
 * \param cryptoCfg Pointer to Crypto configuration
 * \return None
 */
IFX_STATIC void IfxCss_Crypto_configureCrypto(IfxCss_Crypto_Channel *channel, IfxCss_Crypto_CryptoConfig *cryptoCfg);

/** \brief Configure the Hashing function
 * \param channel Pointer to the channel handle
 * \param hashCfg Pointer to the Hash Configuration
 * \return None
 */
IFX_STATIC void IfxCss_Crypto_configureHash(IfxCss_Crypto_Channel *channel, IfxCss_Crypto_HashConfig *hashCfg);

/** \brief Perform crypto operation with simulatneous write and read operations from FIFO
 * \param channel Pointer to the channel handle
 * \return Status of operation
 */
IFX_STATIC IfxCss_status IfxCss_Crypto_performCryptoOp(IfxCss_Crypto_Channel *channel);

/** \brief Read the output from output FIFO
 * \param channel Pointer to the channel handle
 * \param destPtr Pointer to the destination of output data
 * \param words Number of words to read
 * \return Number of words that could not be read from the FIFO
 * This could happen if number of words to be read is larger than the content of output FIFO
 */
IFX_STATIC uint32 IfxCss_Crypto_readOutputFifo(IfxCss_Crypto_Channel *channel, uint32 *destPtr, uint32 words);

/** \} */

/******************************************************************************/
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE IfxCss_status IfxCss_Crypto_updateMessageError(IfxCss_Crypto_Channel *channel)
{
    IfxCss_status return_status = IfxCss_status_success;

    if (IfxCss_Ch_getErrorStatus(channel->chSFR) == TRUE)
    {
        return_status = IfxCss_status_failure;
        (void)IfxCss_Crypto_getAndClearOperationError(channel);
        (void)IfxCss_Crypto_getAndClearKeyUseError(channel);
    }

    return return_status;
}


/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxCss_Crypto_initChannelConfig(Ifx_CSS *cssSFR, IfxCss_Crypto_ChannelConfig *config)
{
    const IfxCss_Crypto_ChannelConfig defaultConfig = {
        .id              = IfxCss_channelId_1,
        .channelSFR      = NULL_PTR,
        .interrupt       = NULL_PTR,
        .underflowEnable = IfxCss_featureSet_disable,
        .macToDataOut    = IfxCss_featureSet_disable,
        .keys            = NULL_PTR,
        .numKeys         = (uint8)0,
        .burstTransfer   = FALSE,
        .burstMacRead    = FALSE
    };

    *config            = defaultConfig;

    config->channelSFR = &(cssSFR->CH[config->id]);
}


IfxCss_status IfxCss_Crypto_initChannel(IfxCss_Crypto_Channel *channel, IfxCss_Crypto_ChannelConfig *config)
{
    IfxCss_status status = IfxCss_status_success;
    Ifx_CSS_CH   *chSFR  = config->channelSFR;

    if (IfxCss_Ch_isChannelBusy(chSFR) != TRUE) /* If channel is in use, exit */
    {
        /* Update handle with initial values */
        channel->id                         = config->id;
        channel->chSFR                      = config->channelSFR;
        channel->state                      = IfxCss_Crypto_channelState_unknown;
        channel->expectedOutWords           = 0U;
        channel->burstTransfer              = config->burstTransfer;
        channel->burstMacRead               = config->burstMacRead;
        channel->macRedir                   = config->macToDataOut;
        channel->msgStream.streamInProgress = FALSE;
        channel->errors.ivWriteError.Word   = 0u;
        channel->errors.keyUseError.Word    = 0u;
        channel->errors.keyWriteError.Word  = 0u;
        channel->errors.opError.Word        = 0u;
        channel->inFifoSizeBytes            = IfxCss_Ch_getInFifoSizeBytes(channel->id);
        channel->outFifoSizeBytes           = IfxCss_Ch_getOutFifoSizeBytes(channel->id);

        /* Step 1: Reset channel */
#if (IFXCSS_RESET_CHANNEL_IN_INIT == TRUE)
        IfxCss_Ch_resetChannel(chSFR);

        /* Wait in a loop until channel is freshly initialized */
        while (IfxCss_Ch_isChannelInUse(chSFR))
        {}

        channel->state = IfxCss_Crypto_channelState_reset;
#endif

        /* Step 2: Write channel configuration */
        Ifx_CSS_CH_CFG cfg;
        cfg.U          = chSFR->CFG.U;

        cfg.B.UFLEN    = (uint32)config->underflowEnable;
        cfg.B.MACREDIR = (uint32)config->macToDataOut;
        /* TODO: MAC REDIR required later (B step) */
        /* TODO: AES mapping configuration */

        chSFR->CFG.U   = cfg.U;

        channel->state = IfxCss_Crypto_channelState_initialize;

        /* Step 3: Write the keys of the channel */
        if (config->numKeys > 0u)
        {
            status = IfxCss_Crypto_loadStaticKeys(channel, config->keys, config->numKeys);
        }

        /* Step 4: Update key attributes of channel [TODO] */

        /* Step 5: Configure interrupts */
        if ((config->interrupt != NULL_PTR) && (status == IfxCss_status_success))
        {
            IfxCss_Crypto_ChannelInterruptCfg *intCfg = config->interrupt;
            Ifx_CSS_CH_INTR_CFG                intSfr;

            intSfr.U          = chSFR->INTR.CFG.U;

            intSfr.B.DINLVL   = (intCfg->dataInLevel <= channel->inFifoSizeBytes) ? IFXCSS_CRYPTO_GETINTLEVEL(intCfg->dataInLevel) : IFXCSS_CRYPTO_GETINTLEVEL(channel->inFifoSizeBytes);
            intSfr.B.DINQUANT = (intCfg->dataInQuant <= channel->inFifoSizeBytes && intCfg->dataInQuant > 0U) ? IFXCSS_CRYPTO_GETINTLEVEL(intCfg->dataInQuant) : IFXCSS_CRYPTO_GETINTLEVEL(channel->inFifoSizeBytes);
            intSfr.B.DOUTLVL  = (intCfg->dataOutLevel <= channel->outFifoSizeBytes && intCfg->dataOutLevel > 0U) ? IFXCSS_CRYPTO_GETINTLEVEL(intCfg->dataOutLevel) : IFXCSS_CRYPTO_GETINTLEVEL(channel->outFifoSizeBytes);

            /* Enable all events. */
            if (channel->burstTransfer)
            {
                intSfr.B.DIN = (uint32)1;
            }

            intSfr.B.DOUT     = (uint32)intCfg->dataOutEvent;
            intSfr.B.MAC      = (uint32)intCfg->macGenEvent;
            intSfr.B.ERR      = (uint32)intCfg->errorEvent;
            intSfr.B.OUTMODE  = (uint32)intCfg->useBatchModePlus;

            chSFR->INTR.CFG.U = intSfr.U; /* write back */
        }

        /* Update handle to ready state */
        if (status == IfxCss_status_success)
        {
            channel->state = IfxCss_Crypto_channelState_ready;
        }
    }
    else /* Channel is busy */
    {
        /* Return busy state and failure */
        channel->state = IfxCss_Crypto_channelState_opBusy;
        status         = IfxCss_status_failure;
    }

    return status;
}


IfxCss_status IfxCss_Crypto_loadStaticKeys(IfxCss_Crypto_Channel *channel, IfxCss_Key *keyList, uint8 numKeys)
{
    IfxCss_status           status = IfxCss_status_success; /* initialize the status to success */
    uint8                   key_index;
    IfxCss_KeyIvWriteStatus wr_status;
    wr_status.Word = (uint32)0;

    uint8                   keySlots = IfxCss_Ch_getKeySlots(channel->chSFR);

    /* TODO: loop through all keys, and check if keyNum * keySize still matches KEYCFG.size */
    /* TODO: allow for dynamic allocation of ID for a channel key? */

    if ((keySlots >= numKeys) && (IfxCss_Ch_isKeyWriteEnabled(channel->chSFR)))
    {
        for (key_index = (uint8)0; key_index < numKeys; key_index++)
        {
            wr_status = IfxCss_Crypto_loadChannelKey(channel, &(keyList[key_index]));

            if (wr_status.Word != (uint32)0)
            {
                status = IfxCss_status_failure;
                break;
            }
        }
    }
    else
    {
        status                       = IfxCss_status_failure; /* Number of key sections not matching */
        wr_status.Bits.softwareError = (uint32)1;
    }

    channel->errors.keyWriteError.Word |= wr_status.Word;
    return status;
}


IfxCss_KeyIvWriteStatus IfxCss_Crypto_loadChannelKey(IfxCss_Crypto_Channel *channel, IfxCss_Key *keyPtr)
{
    Ifx_CSS_CH                     *chSFR     = channel->chSFR;
    IfxCss_KeyIvWriteStatus         writeStatus;
    volatile Ifx_CSS_CH_KEY_WRSTAT *wrstatReg = &(chSFR->KEY.WRSTAT);

    writeStatus.Word = (uint32)0; /* Initialize the write status to clean first */

    if ((IFXCSS_CHECK_OP_BUSY(wrstatReg->U) == FALSE) && ((IfxCss_Ch_isKeyInvalid(keyPtr)) == FALSE))
    {
        IfxCss_Ch_writeKeyCommand(chSFR, keyPtr);                 /* write the command register */

        if (keyPtr->attributes.fromOut == IfxCss_featureSet_disable)
        {
            IfxCss_Ch_writeKeyInput(chSFR, keyPtr);               /* Write keyvalue first before command */
        }

        if (IFXCSS_CHECK_KEYIVWRITE_ERROR(wrstatReg->U) == FALSE) /* check for write access and other errors */
        {
            while (IFXCSS_CHECK_OP_BUSY(wrstatReg->U))            /* wait until the write is completed */
            {
                /* TODO: timeout? */
            }
        }
        else
        /*  Update write errors and clear status register */
        {
            IfxCss_Ch_updateAndClearKeyWriteError(chSFR, &writeStatus);
        }
    }
    else /* channel key write busy / key invalid */
    {
        writeStatus.Bits.softwareError = (uint32)1;
    }

    return writeStatus;
}


IfxCss_status IfxCss_Crypto_singleCallImmediate(IfxCss_Crypto_Channel *channel, IfxCss_Crypto_message *message)
{
    IfxCss_status status = IfxCss_status_failure; /* Initialize status to failure */

    /* Step 1: Initialize the channel with message specific configurations */
    status = IfxCss_Crypto_initMessage(channel, message, TRUE);

    if (status == IfxCss_status_success)
    {
        /* Step 2: Transfer PC/MAC to and from CSS engine */

        /* Perform simultaneous read and write in case of cryptographic operation where we expect PC as output.
         * This is because if input is larger than FIFO size, we also need to read the output after filling output FIFO
         * before we give more input otherwise data in output FIFO will be overwritten.
         */
        if ((message->operation <= IfxCss_Crypto_operation_cryptoWithHash) && (channel->burstTransfer == FALSE))
        {
            status = IfxCss_Crypto_performCryptoOp(channel);
        }
        /* In other cases, for e.g. Hash/MAC generation, first write all data (any size smaller or larger than FIFO size)
         * and then read the Hash/MAC.
         */
        else
        {
            /* 2.1: Transfer Input Data */
            status = IfxCss_Crypto_transferInputData(channel);

            /* 2.2: Poll and read results */
            if (status == IfxCss_status_success)
            {
                status = IfxCss_Crypto_pollReadResults(channel);
            }
        }

        /* Step 3: Wait here until channel is free */
        if (status == IfxCss_status_success)
        {
            uint32 timeoutCounter = IFXCSS_TIMEOUT_COUNT;

            while (IfxCss_Ch_isChannelBusy(channel->chSFR))
            {
                /* Break out of while loop if error is present or timeout occurs */
                if ((IfxCss_Crypto_updateMessageError(channel) != IfxCss_status_success) || (--timeoutCounter <= 0))
                {
                    status = IfxCss_status_failure;
                    break;
                }
            }
        }

        /* Step 4: Read leftover data in output FIFO if available */
        if ((status == IfxCss_status_success) && (channel->expectedOutWords > 0u))
        {
            uint32 **destPtr          = (message->crypto.encryptOp == IfxCss_encryptOp_encrypt) ? &message->cipherTextPtr : &message->plainTextPtr;
            uint32   originalDestAddr = (uint32)*destPtr;

            *destPtr += (IFXCSS_CRYPTO_CALCWORDS_FROMBYTES(message->pcLength) - channel->expectedOutWords);

            while (channel->expectedOutWords > 0u)
            {
                status = IfxCss_Crypto_pollReadResults(channel);

                if (status == IfxCss_status_failure)
                {
                    break;
                }
            }

            /* Restore pointer */
            *destPtr = (uint32 *)originalDestAddr;
        }

        /* Step 5: Update channel state */
        if (status == IfxCss_status_success)
        {
            channel->state = IfxCss_Crypto_channelState_messageInit; /* Back to message Ready state */
        }
        else
        {
            (void)IfxCss_Crypto_updateMessageError(channel);
            channel->state = IfxCss_Crypto_channelState_error; /* Error has occurred */
        }
    }

    return status;
}


IfxCss_status IfxCss_Crypto_initMessage(IfxCss_Crypto_Channel *channel, IfxCss_Crypto_message *message, boolean singleCall)
{
    IfxCss_status return_status = IfxCss_status_failure; /* Initialize return status as failed */
    uint32        opCtrl        = 0u;                    /* Operation Control register value */

    if (message != NULL_PTR)                             /* Pre-check: message is valid */
    {
        /* Step 1: If channel is not ready, then exit! */
        if ((channel->state == IfxCss_Crypto_channelState_ready) || (channel->state == IfxCss_Crypto_channelState_messageInit))
        {
            channel->state      = IfxCss_Crypto_channelState_messageCfg; /* message Configuration is going on  */
            channel->messagePtr = message;                               /* update message handle to channel */

            /* Step 2: Load the message IV's */
            if (message->numIv > 0u)
            {
                return_status = IfxCss_Crypto_loadMessageIv(channel, message->ivPtr, message->numIv);
            }
            else
            {
                return_status = IfxCss_status_success;
            }

            if (return_status == IfxCss_status_success)
            {
#ifndef IFX_CFG_VP_PLATFORM

                if (singleCall)
                {
                    /* Step 3: Configure the length of data */
                    if (message->operation >= IfxCss_Crypto_operation_cryptoWithAEAD)
                    {
                        IfxCss_Ch_updateAadLength(channel->chSFR, message->aadLength, TRUE);
                    }

                    if (message->operation <= IfxCss_Crypto_operation_cryptoWithHash)
                    {
                        IfxCss_Ch_updatePcLength(channel->chSFR, message->pcLength, TRUE);
                    }
                }
                else
                {
                    /* Will update length in streaming function */
                }

#endif

                /* Step 4,5: configure the Crypto, Hash, select algorithm */
                if (message->crypto.mode > IfxCss_cryptoOpMode_none)
                {
                    IfxCss_Crypto_configureCrypto(channel, &(message->crypto));
                    IfxCss_Ch_selectCryptoAlgo(&opCtrl, message->crypto.mode);
                }

                if (message->hash.mode > IfxCss_hashOpMode_none)
                {
                    IfxCss_Crypto_configureHash(channel, &(message->hash));
                    IfxCss_Ch_selectHashAlgo(&opCtrl, message->hash.mode);
                }

#ifdef IFX_CFG_VP_PLATFORM

                /* VP behavior : expects hash POLY mode in OPCTRL when CHACHA is used */
                if ((message->crypto.mode == IfxCss_cryptoOpMode_chacha20) && (message->hash.mode == IfxCss_hashOpMode_none))
                {
                    IfxCss_Ch_selectHashAlgo(&opCtrl, IfxCss_hashOpMode_Poly1305);
                }

#endif

                /* Write OPCTRL now, with full word */
                IfxCss_Ch_writeOpCtrl(channel->chSFR, opCtrl);

#ifdef IFX_CFG_VP_PLATFORM

                if (singleCall)
                {
                    /* Step 3: Configure the length of data */
                    if (message->operation >= IfxCss_Crypto_operation_cryptoWithAEAD)
                    {
                        IfxCss_Ch_updateAadLength(channel->chSFR, message->aadLength, TRUE);
                    }

                    if (message->operation <= IfxCss_Crypto_operation_cryptoWithHash)
                    {
                        IfxCss_Ch_updatePcLength(channel->chSFR, message->pcLength, TRUE);
                    }
                }
                else
                {
                    /* Will update length in streaming function */
                }

#endif

                /* Step 6 Update any errors. */
                if (IfxCss_Crypto_updateMessageError(channel) == IfxCss_status_success)
                {
                    return_status  = IfxCss_status_success;                  /* No errors. Initialization successful */
                    channel->state = IfxCss_Crypto_channelState_messageInit; /* Message is initialized */
                }
                else /* Errors in operation */
                {
                    return_status  = IfxCss_status_failure;
                    channel->state = IfxCss_Crypto_channelState_error;
                }
            }
            else /* IV write not successful */
            {
                channel->state = IfxCss_Crypto_channelState_error;
            }
        }
    }

    return return_status;
}


IfxCss_status IfxCss_Crypto_loadMessageIv(IfxCss_Crypto_Channel *channel, IfxCss_Iv *ivList, uint8 numIv)
{
    IfxCss_status           status = IfxCss_status_success; /* initialize the status to success */
    uint8                   iv_index;
    IfxCss_KeyIvWriteStatus wr_status;
    wr_status.Word = (uint32)0;

    uint8                   ivSlots = IfxCss_Ch_getIvSlots(channel->chSFR);

    if ((ivSlots >= numIv) && (ivList != NULL_PTR))
    {
        for (iv_index = (uint8)0; iv_index < numIv; iv_index++)
        {
            wr_status = IfxCss_Crypto_loadChannelIv(channel, &(ivList[iv_index]));

            if (wr_status.Word != (uint32)0)
            {
                status = IfxCss_status_failure;
                break;
            }
        }
    }
    else
    {
        status                       = IfxCss_status_failure; /* no. of IV slots not matching */
        wr_status.Bits.softwareError = (uint32)1;
    }

    channel->errors.ivWriteError.Word |= wr_status.Word;

    return status;
}


IfxCss_KeyIvWriteStatus IfxCss_Crypto_loadChannelIv(IfxCss_Crypto_Channel *channel, IfxCss_Iv *ivPtr)
{
    Ifx_CSS_CH                    *chSFR          = channel->chSFR;
    IfxCss_KeyIvWriteStatus        writeStatus;
    volatile Ifx_CSS_CH_IV_WRSTAT *wrstatReg      = &(chSFR->IV.WRSTAT);
    uint32                         timeoutCounter = IFXCSS_TIMEOUT_COUNT;

    writeStatus.Word = (uint32)0; /* Initialize the write status to clean first */

    if (IFXCSS_CHECK_OP_BUSY(wrstatReg->U) == FALSE)
    {
        IfxCss_Ch_writeIvCommand(chSFR, ivPtr);                   /* write the command register */
        IfxCss_Ch_writeIvInput(chSFR, ivPtr);                     /* write IV Value */

        if (IFXCSS_CHECK_KEYIVWRITE_ERROR(wrstatReg->U) == FALSE) /* check for write access and other errors */
        {
            while (IFXCSS_CHECK_OP_BUSY(wrstatReg->U))            /* wait until the write is completed */
            {
                if (--timeoutCounter <= 0)
                {
                    writeStatus.Bits.busy = 1;
                }
            }
        }
        else
        /*  Update write errors and clear status register */
        {
            IfxCss_Ch_updateAndClearIvWriteError(chSFR, &writeStatus);
        }
    }
    else /* channel key write busy / key invalid */
    {
        writeStatus.Bits.softwareError = (uint32)1;
    }

    return writeStatus;
}


IFX_STATIC void IfxCss_Crypto_configureCrypto(IfxCss_Crypto_Channel *channel, IfxCss_Crypto_CryptoConfig *cryptoCfg)
{
    /* 1. Check if Crypto operation is required */
    if (cryptoCfg->mode != IfxCss_cryptoOpMode_none)
    {
        /* 2. Configure the Cryto operations first */
        volatile Ifx_CSS_CH_CRYPT_CFG *cryptRegPtr = &(channel->chSFR->CRYPT.CFG);
        Ifx_CSS_CH_CRYPT_CFG           cryptRegVal;
        cryptRegVal.U        = cryptRegPtr->U; /* Read the configuration register */

        cryptRegVal.B.ENC    = (uint32)cryptoCfg->encryptOp;
        cryptRegVal.B.HWPAD  = (uint32)cryptoCfg->hwPadding;
        cryptRegVal.B.HWCFG  = (uint32)cryptoCfg->hwConfig;
        cryptRegVal.B.MACLEN = (uint32)cryptoCfg->macConfig.macLengthBits;
        cryptRegVal.B.MACVER = (uint32)cryptoCfg->macConfig.verEnable;

        /* 3. Select the Keys */
        volatile Ifx_CSS_CH_CRYPT_KEYSEL *keySelPtr = &(channel->chSFR->CRYPT.KEYSEL);
        Ifx_CSS_CH_CRYPT_KEYSEL           keySelVal;
        keySelVal.U      = keySelPtr->U; /* Read */

        keySelVal.B.KEY1 = cryptoCfg->primaryKeyId;
        keySelVal.B.KEY2 = cryptoCfg->secondaryKeyId;
        keySelVal.B.IV   = cryptoCfg->ivId;

        /* Final Step: Write back */
        keySelPtr->U   = keySelVal.U;
        cryptRegPtr->U = cryptRegVal.U;
    }
}


IFX_STATIC void IfxCss_Crypto_configureHash(IfxCss_Crypto_Channel *channel, IfxCss_Crypto_HashConfig *hashCfg)
{
    /* 1. Check if Hash Configuration is required */
    if (hashCfg->mode != IfxCss_hashOpMode_none)
    {
        /* 2. Perform Hash Configuration */
        volatile Ifx_CSS_CH_HASH_CFG *hashRegPtr = &(channel->chSFR->HASH.CFG);
        Ifx_CSS_CH_HASH_CFG           hashRegVal;
        hashRegVal.U          = hashRegPtr->U; /* Read the configuration register */

        hashRegVal.B.HASHIN   = (uint32)hashCfg->dataInSel;
        hashRegVal.B.HASHLEN  = (uint32)hashCfg->hashLengthBits;
        hashRegVal.B.HASHVER  = (uint32)hashCfg->macVer;
        hashRegVal.B.HMACEN   = (uint32)hashCfg->macGen;
        hashRegVal.B.HMACKLEN = (uint32)hashCfg->macKeyLength;

        /* 3. Perform key selection */
        volatile Ifx_CSS_CH_HASH_KEYSEL *keySelPtr = &(channel->chSFR->HASH.KEYSEL);
        Ifx_CSS_CH_HASH_KEYSEL           keySelVal;
        keySelVal.U      = keySelPtr->U; /* Read */

        keySelVal.B.KEY1 = hashCfg->keyId;
        keySelVal.B.IV   = hashCfg->ivId;

        /* Final step: Write back */
        hashRegPtr->U = hashRegVal.U;
        keySelPtr->U  = keySelVal.U;
    }
}


IFX_STATIC IfxCss_status IfxCss_Crypto_performCryptoOp(IfxCss_Crypto_Channel *channel)
{
    IfxCss_status           status = IfxCss_status_success;          /* Initialize status to success */
    IfxCss_Crypto_message  *msg    = channel->messagePtr;
    IfxCss_Crypto_operation op     = msg->operation;

    channel->state = IfxCss_Crypto_channelState_opBusy; /* Go to busy state */

    /* Write all of AAD */
    if ((op >= IfxCss_Crypto_operation_cryptoWithAEAD)) /* Check if authentication data is required to be written */
    {
        /* Check number of AAD words */
        uint32 numAadWords = IFXCSS_CRYPTO_CALCWORDS_FROMBYTES(msg->aadLength);

        if (numAadWords > 0)
        {
            status = IfxCss_Crypto_feedInputFifo(channel, msg->aadPtr, numAadWords);
        }
    }

    /* Write/Read PC/MAC */
    if ((status == IfxCss_status_success) && (op <= IfxCss_Crypto_operation_cryptoWithHash))
    {
        uint32   numWordsToWrite, numWordsToRead, minFifoValue;
        uint32   outFifoFreeCountWords, inFifoFreeCountWords;
        uint32  *sourcePtr        = (msg->crypto.encryptOp == IfxCss_encryptOp_encrypt) ? msg->plainTextPtr : msg->cipherTextPtr;
        uint32 **destPtr          = (msg->crypto.encryptOp == IfxCss_encryptOp_encrypt) ? &msg->cipherTextPtr : &msg->plainTextPtr;
        uint32   originalDestAddr = (uint32)*destPtr;
        uint32   outFifoSizeWords = IFXCSS_CRYPTO_CALCWORDS_FROMBYTES(channel->outFifoSizeBytes);
        uint32   remainingWords   = IFXCSS_CRYPTO_CALCWORDS_FROMBYTES(msg->pcLength);

        /* Feed reference MAC if needed and MAC is not already written */
        if (((msg->crypto.macConfig.verEnable == TRUE) || (msg->hash.macVer == IfxCss_featureSet_enable)) &&
            (channel->chSFR->MAC.STAT.U == 0u))
        {
            status = IfxCss_Crypto_feedReferenceMAC(channel);
        }

        while (remainingWords > 0u)
        {
            outFifoFreeCountWords      = outFifoSizeWords - IFXCSS_CRYPTO_CALCWORDS_FROMBYTES(IfxCss_Ch_getOutputDataCount(channel->chSFR));
            inFifoFreeCountWords       = IFXCSS_CRYPTO_CALCWORDS_FROMBYTES(IfxCss_Ch_getInFifoFreeCount(channel->chSFR));
            minFifoValue               = (outFifoFreeCountWords > inFifoFreeCountWords) ? inFifoFreeCountWords : outFifoFreeCountWords;

            numWordsToWrite            = (remainingWords > minFifoValue) ? minFifoValue : remainingWords;
            remainingWords            -= numWordsToWrite;
            channel->expectedOutWords += numWordsToWrite;          /* Store this for future polling */

            /* TC49x workaround */
            if ((remainingWords == 0) && (channel->expectedOutWords > outFifoSizeWords))
            {
                /* Leave space for RAM buffer if expectedwords > fifo size  */
                remainingWords             = (numWordsToWrite >> 1);
                numWordsToWrite           -= remainingWords;
                channel->expectedOutWords -= remainingWords;
            }

            /* 2: Transfer Input Data */
            status = IfxCss_Crypto_feedInputFifo(channel, sourcePtr, numWordsToWrite);

            /* 3: Write MAC if applicable */
            if (remainingWords == 0)
            {
                channel->readMAC = TRUE;
            }

            /* 4: Poll results */
            numWordsToRead = channel->expectedOutWords;

            if (status == IfxCss_status_success)
            {
                status = IfxCss_Crypto_pollReadResults(channel);
            }

            /* 5: Break out of while if feeding/polling failed */
            if (status == IfxCss_status_failure)
            {
                break;
            }

            /* Increment pointers */
            sourcePtr += numWordsToWrite;
            *destPtr  += (numWordsToRead - channel->expectedOutWords);
        }

        /* Restore pointer */
        *destPtr = (uint32 *)originalDestAddr;
    }

    return status;
}


IfxCss_status IfxCss_Crypto_transferInputData(IfxCss_Crypto_Channel *channel)
{
    IfxCss_status          status       = IfxCss_status_success;
    IfxCss_Crypto_message *msg          = channel->messagePtr;
    uint32                *sourcePtr;
    uint32                 numTextWords = 0U;
    uint32                 numAadWords  = 0U;
    uint32                 numOutWords  = 0U;

    if ((channel->msgStream.streamInProgress == TRUE) && (channel->expectedOutWords != 0U))
    {
        /* Do nothing */
    }
    else
    {
        channel->expectedOutWords = 0U; /* Initialize the expected words to 0 */
    }

    IfxCss_Crypto_operation op = msg->operation;

    channel->state = IfxCss_Crypto_channelState_opBusy;

    /* Feed reference MAC if needed and MAC is not already written */
    if (((msg->crypto.macConfig.verEnable == TRUE) || (msg->hash.macVer == IfxCss_featureSet_enable)) &&
        (channel->chSFR->MAC.STAT.U == 0u))
    {
        status = IfxCss_Crypto_feedReferenceMAC(channel);
    }

    if (channel->burstTransfer == FALSE)
    {
        numAadWords  = IFXCSS_CRYPTO_CALCWORDS_FROMBYTES(msg->aadLength);
        numTextWords = IFXCSS_CRYPTO_CALCWORDS_FROMBYTES(msg->pcLength);

        if ((op >= IfxCss_Crypto_operation_cryptoWithAEAD) && (numAadWords > 0u)) /* check if authentication data exists */
        {
            sourcePtr = msg->aadPtr;
            status    = IfxCss_Crypto_feedInputFifo(channel, sourcePtr, numAadWords);
        }

        if ((op <= IfxCss_Crypto_operation_cryptoWithHash) && (numTextWords > 0u)) /* check if crypto data exists */
        {
            numOutWords               += numTextWords;
            channel->expectedOutWords += (numOutWords);                            /* store this for future polling */
            sourcePtr                  = (msg->crypto.encryptOp == IfxCss_encryptOp_encrypt) ? msg->plainTextPtr : msg->cipherTextPtr;
            status                     = IfxCss_Crypto_feedInputFifo(channel, sourcePtr, numTextWords);
        }
    }

    channel->readMAC = TRUE;

    return status;
}


IfxCss_status IfxCss_Crypto_feedInputFifo(IfxCss_Crypto_Channel *channel, uint32 *sourcePtr, uint32 words)
{
    IfxCss_status            status = IfxCss_status_success;
    volatile Ifx_UReg_32Bit *chFifoPtr;
    volatile Ifx_UReg_64Bit *chFifoPtr64;
    uint32                   remainingWords, numWords, index, inFifoFreeCountWords, timeoutCounter;
    uint64                  *sourcePtr64;
    uint64                   numWordPairs;

    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, sourcePtr != NULL_PTR);

    chFifoPtr   = &(channel->chSFR->DATA.A[0].U);
    chFifoPtr64 = (Ifx_UReg_64Bit *)&(channel->chSFR->DATA.A[0].U);

    /* Begin the write operation here */
    remainingWords = words;

    while (remainingWords > 0)
    {
#ifdef IFX_CFG_VP_PLATFORM

        for (int i = 0; i < 0xFF; i++)
        {
            /* Delay loop for making FIFO free */
        }

#else

        timeoutCounter = IFXCSS_TIMEOUT_COUNT;

        /* Step 1: poll until  we have free words in Input Fifo */
        while (IfxCss_Ch_getInFifoFreeCount(channel->chSFR) == 0)
        {
            /* Break out of while loop if error is present or timeout occurs */
            if ((IfxCss_Crypto_updateMessageError(channel) != IfxCss_status_success) || (--timeoutCounter <= 0))
            {
                status = IfxCss_status_failure;
                break;
            }
        }

#endif
        /* Step 2: Get number of words to be written in this iteration */
        inFifoFreeCountWords = IFXCSS_CRYPTO_CALCWORDS_FROMBYTES(IfxCss_Ch_getInFifoFreeCount(channel->chSFR)); /* Get free count of input FIFO */
        numWords             = (remainingWords > inFifoFreeCountWords) ? inFifoFreeCountWords : remainingWords;

        index                = 0U;                                                                              /* Clear index : new iteration */

        /* Step 3: Start data transfer */
        if (numWords > 5U)                                                                                      /* 128/64 bits copy at a time */
        {
            if (IFXCSS_CRYPTO_CHECK128BITALIGNMENT(sourcePtr) == TRUE)
            {
                uint32 numQuadWords = numWords >> 2u;

                /* Copy 128 bits at a time */
                for (index = 0u; index < numQuadWords; index++)
                {
                    Ifx__copyDoubleDouble((volatile uint32 *)sourcePtr, (volatile uint32 *)chFifoPtr);
                    sourcePtr = sourcePtr + 0x4u;   /* Increment 4 words */
                }

                /* Copy remaining words */
                index = 0u;
                IFXCSS_CRYPTO_COPYTOFIFO(sourcePtr, chFifoPtr, index, (numWords & 0x3u));
            }
            /* Write 64 bits at a time */
            else
            {
                /* 64 bit Misaligned */
                if (IFXCSS_CRYPTO_CHECK64BITALIGNMENT(sourcePtr) == FALSE)
                {
                    /* even number of words */
                    if ((numWords & 1U) == 0U)
                    {
                        /* write one word */
                        *chFifoPtr = *sourcePtr;
                        /* write (numWords - 2) words */
                        sourcePtr++;
                        sourcePtr64  = (uint64 *)sourcePtr;
                        numWordPairs = (numWords - 2U) >> 1U;

                        IFXCSS_CRYPTO_COPYTOFIFO(sourcePtr64, chFifoPtr64, index, numWordPairs);

                        /* write one word */
                        sourcePtr  = (uint32 *)sourcePtr64;
                        *chFifoPtr = *sourcePtr;
                        sourcePtr++;
                    }
                    /* odd number of words */
                    else
                    {
                        /* write one word */
                        *chFifoPtr = *sourcePtr;
                        /* write (numWords - 1) words */
                        sourcePtr++;
                        sourcePtr64  = (uint64 *)sourcePtr;
                        numWordPairs = (numWords - 1U) >> 1U;

                        IFXCSS_CRYPTO_COPYTOFIFO(sourcePtr64, chFifoPtr64, index, numWordPairs);

                        sourcePtr = (uint32 *)sourcePtr64;
                    }
                }
                /* 64 bit Aligned */
                else
                {
                    /* even number of words */
                    if ((numWords & 1U) == 0U)
                    {
                        /* write (numWords) words */
                        sourcePtr64  = (uint64 *)sourcePtr;
                        numWordPairs = (numWords) >> 1U;

                        IFXCSS_CRYPTO_COPYTOFIFO(sourcePtr64, chFifoPtr64, index, numWordPairs);

                        sourcePtr = (uint32 *)sourcePtr64;
                    }
                    /* odd number of words */
                    else
                    {
                        /* write (numWords - 1) words */
                        sourcePtr64  = (uint64 *)sourcePtr;
                        numWordPairs = (numWords - 1U) >> 1U;

                        IFXCSS_CRYPTO_COPYTOFIFO(sourcePtr64, chFifoPtr64, index, numWordPairs);

                        /* write one word */
                        sourcePtr  = (uint32 *)sourcePtr64;
                        *chFifoPtr = *sourcePtr;
                        sourcePtr++;
                    }
                }
            }
        }
        /* Write 32 bits at a time */
        else
        {
            IFXCSS_CRYPTO_COPYTOFIFO(sourcePtr, chFifoPtr, index, numWords);
        }

        remainingWords = remainingWords - numWords; /* update remaining words */
    }

    return status;
}


IFX_STATIC uint32 IfxCss_Crypto_readOutputFifo(IfxCss_Crypto_Channel *channel, uint32 *destPtr, uint32 words)
{
    volatile Ifx_UReg_32Bit *chFifoPtr   = &(channel->chSFR->DATA.A[0].U);
    volatile Ifx_UReg_64Bit *chFifoPtr64 = (uint64 *)&(channel->chSFR->DATA.A[0].U);
    uint32                   remainingWords, numWords, index, outputDataCountWords;
    uint64                  *destPtr64;
    uint64                   numWordPairs;
    uint32                   timeoutCounter = IFXCSS_TIMEOUT_COUNT;

    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, destPtr != NULL_PTR);

    /* Begin the read operation here */
    remainingWords = words;

    /* Step: poll until  we have words in output Fifo */
    while (IfxCss_Ch_getOutputDataCount(channel->chSFR) == 0)
    {
        /* Break out of while loop if error is present or timeout occurs */
        if ((IfxCss_Crypto_updateMessageError(channel) != IfxCss_status_success) || (--timeoutCounter == 0))
        {
            break;
        }
    }

    /* Loop through while data is present in output FIFO */
    while (remainingWords > 0 && IfxCss_Ch_getOutputDataCount(channel->chSFR) > 0)
    {
        /* Step 1: Calculate number of words to be read in this iteration */
        outputDataCountWords = IFXCSS_CRYPTO_CALCWORDS_FROMBYTES(IfxCss_Ch_getOutputDataCount(channel->chSFR));
        numWords             = (remainingWords > outputDataCountWords) ? outputDataCountWords : remainingWords;

        index                = 0U; /* Clear index : new iteration */

        /* Step 2: Perform read operation from output FIFO now */
        if (numWords > 5U)         /* 128/64 bits copy at a time */
        {
            if (IFXCSS_CRYPTO_CHECK128BITALIGNMENT(destPtr) == TRUE)
            {
                uint32 numQuadWords = numWords >> 2u;

                /* Copy 128 bits at a time */
                for (index = 0u; index < numQuadWords; index++)
                {
                    Ifx__copyDoubleDouble((volatile uint32 *)chFifoPtr, (volatile uint32 *)destPtr);
                    destPtr = destPtr + 0x4u;   /* Increment 4 words */
                }

                /* Copy remaining words */
                index = 0u;
                IFXCSS_CRYPTO_COPYFROMFIFO(chFifoPtr, destPtr, index, (numWords & 0x3u));
            }
            /* Write 64 bits at a time */
            else
            {
                /* 64 bit Misaligned */
                if (IFXCSS_CRYPTO_CHECK64BITALIGNMENT(destPtr) == FALSE)
                {
                    /* even number of words */
                    if ((numWords & 1U) == 0U)
                    {
                        /* write one word */
                        *destPtr = *chFifoPtr;
                        /* write (numWords - 2) words */
                        destPtr++;
                        destPtr64    = (uint64 *)destPtr;
                        numWordPairs = (numWords - 2U) >> 1U;

                        IFXCSS_CRYPTO_COPYFROMFIFO(chFifoPtr64, destPtr64, index, numWordPairs);

                        /* write one word */
                        destPtr  = (uint32 *)destPtr64;
                        *destPtr = *chFifoPtr;
                        destPtr++;
                    }
                    /* odd number of words */
                    else
                    {
                        /* write one word */
                        *destPtr = *chFifoPtr;
                        /* write (numWords - 1) words */
                        destPtr++;
                        destPtr64    = (uint64 *)destPtr;
                        numWordPairs = (numWords - 1U) >> 1U;

                        IFXCSS_CRYPTO_COPYFROMFIFO(chFifoPtr64, destPtr64, index, numWordPairs);

                        destPtr = (uint32 *)destPtr64;
                    }
                }
                /* 64 bit Aligned */
                else
                {
                    /* even number of words */
                    if ((numWords & 1U) == 0U)
                    {
                        /* write (numWords) words */
                        destPtr64    = (uint64 *)destPtr;
                        numWordPairs = (numWords) >> 1U;

                        IFXCSS_CRYPTO_COPYFROMFIFO(chFifoPtr64, destPtr64, index, numWordPairs);

                        destPtr = (uint32 *)destPtr64;
                    }
                    /* odd number of words */
                    else
                    {
                        /* write (numWords - 1) words */
                        destPtr64    = (uint64 *)destPtr;
                        numWordPairs = (numWords - 1U) >> 1U;

                        IFXCSS_CRYPTO_COPYFROMFIFO(chFifoPtr64, destPtr64, index, numWordPairs);

                        /* write one word */
                        destPtr  = (uint32 *)destPtr64;
                        *destPtr = *chFifoPtr;
                        destPtr++;
                    }
                }
            }
        }
        /* Write 32 bits at a time */
        else
        {
            IFXCSS_CRYPTO_COPYFROMFIFO(chFifoPtr, destPtr, index, numWords);
        }

        remainingWords = remainingWords - numWords; /* update remaining words */
    }

    return remainingWords;
}


IfxCss_status IfxCss_Crypto_feedReferenceMAC(IfxCss_Crypto_Channel *channel)
{
    IfxCss_status          return_status = IfxCss_status_success;
    IfxCss_Crypto_message *msg           = channel->messagePtr;
    uint8                  index         = 0U;
    uint8                  macWords      = (uint8)IfxCss_Crypto_getMacLengthInWords(msg, msg->operation);
    uint32                *macPtr        = msg->verMacPtr;

    if (macWords > 0U)
    {
        for (index = 0; index < macWords; index++)
        {
            channel->chSFR->MAC.VALUE[index].U = macPtr[index];
        }
    }
    else
    {
        return_status = IfxCss_status_failure;
    }

    return return_status;
}


IfxCss_status IfxCss_Crypto_readGeneratedMAC(IfxCss_Crypto_Channel *channel)
{
    IfxCss_status status   = IfxCss_status_success;
    uint32       *macPtr   = channel->messagePtr->genMacPtr;
    uint32        macWords = IfxCss_Crypto_getMacLengthInWords(channel->messagePtr, channel->messagePtr->operation);
    uint32        index;

    if (macWords > 0u)
    {
        // TODO: also check for macredir
        if (macWords <= 16U)  /* MAC.VALUE can hold only max 16 words */
        {
            for (index = 0; index < macWords; index++)
            {
                macPtr[index] = channel->chSFR->MAC.VALUE[index].U;
            }
        }
        else /* This condition can also hold for AAD forward */
        {
            IfxCss_Crypto_readOutputFifo(channel, macPtr, macWords);
        }
    }
    else
    {
        status = IfxCss_status_failure;
    }

    return status;
}


IfxCss_status IfxCss_Crypto_pollReadResults(IfxCss_Crypto_Channel *channel)
{
    IfxCss_status           return_status = IfxCss_status_success;
    IfxCss_Crypto_message  *msg           = channel->messagePtr;
    uint32                 *destPtr;
    uint32                  remainingWords, numWords;
    IfxCss_Crypto_operation op             = msg->operation;
    uint32                  timeoutCounter = IFXCSS_TIMEOUT_COUNT;

    /* Before we poll for results, check for error and return failure if any error occurs */
    return_status = IfxCss_Crypto_updateMessageError(channel);

    /* Read data from Output FIFO */
    if ((return_status == IfxCss_status_success) && (channel->expectedOutWords > 0U))
    {
        /* Perform CPU read */
        if (channel->burstTransfer != TRUE)
        {
            /* Step 1: Get pointer to destination */
            if (channel->msgStream.streamInProgress)
            {
                destPtr = channel->msgStream.resultPtr;
            }
            else
            {
                destPtr = (msg->crypto.encryptOp == IfxCss_encryptOp_encrypt) ? msg->cipherTextPtr : msg->plainTextPtr;
            }

            /* Step 2: Read from FIFO */
            numWords       = channel->expectedOutWords;
            remainingWords = IfxCss_Crypto_readOutputFifo(channel, destPtr, numWords);

            /* Step 3: Update handle */
            if (channel->msgStream.streamInProgress)
            {
                channel->msgStream.resultPtr = destPtr + (numWords - remainingWords);  /* Write back destination pointer */
            }

            channel->expectedOutWords = remainingWords;
        }
        else
        {
            /* TODO: wait for DMA to finish reading? */
        }
    }

    boolean readMAC;

    if (channel->msgStream.streamInProgress == TRUE)
    {
        readMAC = channel->msgStream.final;
    }
    else
    {
        readMAC = channel->readMAC;
    }

    /* Possibility of a MAC read */
    if ((return_status == IfxCss_status_success) && (readMAC == TRUE))
    {
        channel->readMAC = FALSE;

        /* Verify the MAC */
        if ((msg->crypto.macConfig.verEnable == TRUE) || (msg->hash.macVer == IfxCss_featureSet_enable))
        {
            msg->macResult = IfxCss_Crypto_verifyMACResult(channel);
            return_status  = msg->macResult;
        }
        /* Read the MAC */
        else
        {
            if (channel->burstMacRead != TRUE)
            {
                /* MAC generation : MAC value expected in register */
                if ((op >= IfxCss_Crypto_operation_cryptoWithAEAD) && (op <= IfxCss_Crypto_operation_hashMacGeneration))
                {
                    timeoutCounter = IFXCSS_TIMEOUT_COUNT;

                    while (IfxCss_Ch_isMacGenComplete(channel->chSFR) == FALSE)
                    {
                        IFXCSS_CHECK_TIMEOUT(timeoutCounter, return_status);
                    }

                    if (return_status == IfxCss_status_success)
                    {
                        IfxCss_Crypto_readGeneratedMAC(channel);
                    }
                }
            }
            else
            {
                /* TODO: wait for DMA To read? */
            }
        }
    }

    return return_status;
}


IfxCss_status IfxCss_Crypto_verifyMACResult(IfxCss_Crypto_Channel *channel)
{
    IfxCss_status mac_result     = IfxCss_status_failure;
    uint32        timeoutCounter = IFXCSS_TIMEOUT_COUNT;

    /* MAC Verification : MAC compare expected to occur */
    while ((IfxCss_Ch_isMacVerComplete(channel->chSFR) == FALSE) && (--timeoutCounter > 0))
    {}

    if (IfxCss_Ch_checkMacCompareResult(channel->chSFR) != TRUE)
    {
        mac_result = IfxCss_status_failure;
    }
    else
    {
        mac_result = IfxCss_status_success;
    }

    return mac_result;
}


IfxCss_status IfxCss_Crypto_streamMessage(IfxCss_Crypto_Channel *channel, IfxCss_Crypto_message *message, boolean final, boolean readResult)
{
    static IfxCss_Crypto_StreamState streamState = IfxCss_Crypto_StreamState_reset; /* initialize the state machine to reset */
    IfxCss_Crypto_messageStream     *msgStream   = &(channel->msgStream);
    boolean                          aadFinal    = final;
    boolean                          pcFinal     = final;
    Ifx_CSS_CH                      *chSFR       = channel->chSFR;
    IfxCss_status                    status      = IfxCss_status_success; /* Initialize status to success */

    /* 0.1 Update handle */
    msgStream->streamState = &streamState;
    msgStream->final       = final;

    /* 0.2 Handle AAD FINAL bit for combined mode */
    if ((message->operation == IfxCss_Crypto_operation_cryptoWithAEAD) || (message->operation == IfxCss_Crypto_operation_cryptoWithHash))
    {
        if (message->pcLength > 0u) /* Combined mode with PC length available */
        {
            aadFinal = TRUE;
            pcFinal  = final;
        }
    }

    switch (streamState)
    {
    case IfxCss_Crypto_StreamState_reset:
    {
        /* Step 1.1: Return failure if stream is already in progress and stream state is in reset */
        if (msgStream->streamInProgress == TRUE)
        {
            status = IfxCss_status_failure;
            break;
        }
        else
        {
            msgStream->streamInProgress = TRUE;
        }

        /* Step 1.2: Initialize the message with the channel */
        status |= IfxCss_Crypto_initMessage(channel, message, FALSE);

        /* Step 1.3: Update AAD and PC length */
        if (message->operation >= IfxCss_Crypto_operation_cryptoWithAEAD)
        {
            IfxCss_Ch_updateAadLength(channel->chSFR, message->aadLength, aadFinal);
        }

        boolean updatePcLength = (message->pcLength > 0u) ? TRUE : pcFinal;

        if ((message->operation <= IfxCss_Crypto_operation_cryptoWithHash) &&   /* Operation needs PC length */
            (updatePcLength == TRUE))                                           /* PC length needs to be written */
        {
            IfxCss_Ch_updatePcLength(channel->chSFR, message->pcLength, pcFinal);
        }

        /* Step 1.4: Clear operation error */
        status |= IfxCss_Crypto_getAndClearOperationError(channel);

        /* Step 1.5: Change Message stream to started */
        if (status == IfxCss_status_success)
        {
            streamState = IfxCss_Crypto_StreamState_started;
        }
        else
        {
            status = IfxCss_status_failure;
            break;
        }
    }   /* No break at the end of this case */
    case IfxCss_Crypto_StreamState_started:
    {
        /* Step 2.1: Update destination/result pointer */
        msgStream->resultPtr = (message->crypto.encryptOp == IfxCss_encryptOp_encrypt) ? message->cipherTextPtr : message->plainTextPtr;

        /* Step 2.2: Perform data transfer */
        if ((message->operation <= IfxCss_Crypto_operation_cryptoWithHash) &&
            (channel->burstTransfer == FALSE) &&
            (message->pcLength > 0u))  /* If operation is related to crypto then feed input and poll output */
        {
            status |= IfxCss_Crypto_performCryptoOp(channel);
        }
        else /* Else only feed input */
        {
            status |= IfxCss_Crypto_transferInputData(channel);         /* If burst transfer is used, this function returns success */
        }

        /* Step 2.3: Get and clear operation error */
        status |= IfxCss_Crypto_getAndClearOperationError(channel);

        /* Step 2.4: Update stream state */
        if (status == IfxCss_status_success)
        {
            streamState = (final == TRUE) ? IfxCss_Crypto_StreamState_final : IfxCss_Crypto_StreamState_update;
        }
        else
        {
            status = IfxCss_status_failure;
        }

        break;
    }
    case IfxCss_Crypto_StreamState_update:
    {
        /* Step 3.1: Return failure if channel is not busy */
        if (IfxCss_Ch_isChannelBusy(chSFR) != TRUE)
        {
            channel->errors.opError.Bits.softwareError = TRUE;
            status                                     = IfxCss_status_failure;
            break;
        }
        else
        {
            /* Step 3.2: Update AAD and PC length */
            /* Update length only if FINAL is not set. Otherwise write is ignored by hardware. */
            if ((message->operation >= IfxCss_Crypto_operation_cryptoWithAEAD) && (chSFR->LEN.AAD.B.FINAL == FALSE))
            {
                IfxCss_Ch_updateAadLength(channel->chSFR, message->aadLength, aadFinal);
            }

            boolean updatePcLength = (message->pcLength > 0u) ? TRUE : pcFinal;

            if ((message->operation <= IfxCss_Crypto_operation_cryptoWithHash) &&   /* Operation needs PC length */
                (updatePcLength == TRUE))                                           /* PC length needs to be written */
            {
                IfxCss_Ch_updatePcLength(channel->chSFR, message->pcLength, pcFinal);
            }

            /* Step 3.3: Perform data transfer */
            if ((message->operation <= IfxCss_Crypto_operation_cryptoWithHash) &&
                (channel->burstTransfer == FALSE) &&
                (message->pcLength > 0u)) /* If operation is related to crypto then feed input and poll output */
            {
                status    |= IfxCss_Crypto_performCryptoOp(channel);
                readResult = FALSE;       /* Result already polled */
            }
            else /* Else only feed input */
            {
                status |= IfxCss_Crypto_transferInputData(channel);         /* If burst transfer is used, this function returns success */
            }

            /* Step 3.4: Get and clear operation error */
            status |= IfxCss_Crypto_getAndClearOperationError(channel);

            /* Step 3.5: Update stream state */
            if (status == IfxCss_status_success)
            {
                streamState = (final) ? IfxCss_Crypto_StreamState_final : IfxCss_Crypto_StreamState_update;
            }
            else
            {
                status = IfxCss_status_failure;
                break;
            }

            /* If stream state is Update then exit from switch, else continue */
            if (streamState == IfxCss_Crypto_StreamState_update)
            {
                break;
            }
        }
    }   /* No break at the end of this case */
    case IfxCss_Crypto_StreamState_final:
    {
        uint32 timeoutCounter = IFXCSS_TIMEOUT_COUNT;

        /* Step 4.1: Wait here until channel is free */
        while (IfxCss_Ch_isChannelBusy(chSFR))
        {
            /* Break out of while loop if error is present or timeout occurs */
            if ((IfxCss_Crypto_updateMessageError(channel) != IfxCss_status_success) || (--timeoutCounter == 0u))
            {
                break;
            }
        }

        /* Step 4.2: Read errors */
        if (IfxCss_Crypto_getAndClearOperationError(channel) == IfxCss_status_success)
        {
            /* Step 4.3: Poll result if needed */
            if (readResult)
            {
                status = IfxCss_Crypto_pollReadResults(channel);
            }

            /* Step 4.4: Read leftover data in output FIFO if available */
            if ((status == IfxCss_status_success) && (channel->expectedOutWords > 0u))
            {
                uint32 **destPtr          = (message->crypto.encryptOp == IfxCss_encryptOp_encrypt) ? &message->cipherTextPtr : &message->plainTextPtr;
                uint32   originalDestAddr = (uint32)*destPtr;

                *destPtr += (IFXCSS_CRYPTO_CALCWORDS_FROMBYTES(message->pcLength) - channel->expectedOutWords);

                while (channel->expectedOutWords > 0u)
                {
                    status = IfxCss_Crypto_pollReadResults(channel);

                    if (status == IfxCss_status_failure)
                    {
                        break;
                    }
                }

                /* Restore pointer */
                *destPtr = (uint32 *)originalDestAddr;
            }

            /* Step 4.5: Reset handle values */
            if (status == IfxCss_status_success)
            {
                channel->state              = IfxCss_Crypto_channelState_messageInit; /* Back to message Ready state */
                streamState                 = IfxCss_Crypto_StreamState_reset;
                msgStream->streamInProgress = FALSE;
            }
        }
        else
        {
            status = IfxCss_status_failure;
        }

        break;
    }
    default:
    {
        status                                     = IfxCss_status_failure;
        channel->errors.opError.Bits.softwareError = TRUE;
        break;
    }
    }

    streamState = (status == IfxCss_status_failure) ? IfxCss_Crypto_StreamState_error : streamState;

    return status;
}
