/**
 * \file IfxCss_Crypto.h
 * \brief CSS CRYPTO details
 * \ingroup IfxLld_Css
 *
 * \version iLLD_2_0_1_2_19
 * \copyright Copyright (c) 2023 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 *
 * \defgroup IfxLld_Css_Crypto_Usage How to use the Crypto Driver?
 * \ingroup IfxLld_Css_Crypto
 *
 * \section IfxLld_Css_Crypto_Overview Overview:
 * This driver module is used for performing cryptographic operations using the resources provided by the Cyber Security Satellite(CSS) module.
 * This driver is meant to be used by the channel master.
 * Before using this driver, the secure master MUST initialize the CSS and it's channels.
 *
 * Functionality provided:
 *  1. Initialization of crypto channel for cryptographic operation
 *  2. Initialization of message configuration
 *  3. Performing cryptographic operations
 *  4. Reading results of cryptographic operations
 *
 * The driver supports 64 / 32 bit write operations to DATARAM
 *
 *
 * \section IfxLld_Css_Crypto_Steps Steps to use the Crypto driver
 *
 * \subsection IfxLld_Css_Crypto_Step1 STEP 1 Initialise the channel:
 *
 *  1. Access pre-configured channel configuration pointer for the channel that needs to be used
 *
 *  2. Access pre-configured channel handle for the channel that needs to be used
 *
 *  3. Initialize channel
 *
 *  \code
 *  // Access channel configuration
 *  myChannelCfg = &myChannelCfgTable[0];
 *
 *  // Access channel
 *  myChannel = &myChannelTable[0];
 *
 *  IfxCss_status status = IfxCss_status_failure;
 *  // Initialize channel
 *  status = IfxCss_Crypto_initChannel(myChannel, myChannelCfg);
 *  \endcode
 *
 * \subsection IfxLld_Css_Crypto_Step2 STEP 2 Initialize the message:
 *
 *  \code
 *  // Initialise message configuration
 *  IfxCss_Crypto_message myMsgConfig;
 *
 *  // Write message configuration with required values
 *  // To avoid passing garbage values, all fields should be initialized.
 *  myMsgConfig.crypto.mode                    = IfxCss_cryptoOpMode_aesCMAC;  // Mode of cryptographic operation
 *  myMsgConfig.crypto.hwConfig                 = IfxCss_cryptoHwCfg_singleAes; // Engine Configuration for Crypto
 *  myMsgConfig.crypto.encryptOp               = IfxCss_encryptOp_encrypt;     // Encryption / Decryption Select
 *  myMsgConfig.crypto.macConfig.verEnable      = FALSE;                        // MAC verification to be performed
 *  myMsgConfig.crypto.macConfig.macLengthBits  = 128;                          // Length of MAC to be verified
 *  myMsgConfig.crypto.hwPadding               = IfxCss_cryptoHwPad_default;   // Zero padding configuration
 *  myMsgConfig.crypto.primaryKeyId            = 0;                            // Primary Key ID
 *  myMsgConfig.crypto.secondaryKeyId          = 1;                            // Secondary Key ID
 *  myMsgConfig.crypto.tertiaryKeyId           = 2;                            // Tertiary Key ID
 *  myMsgConfig.crypto.ivId                    = 0;                         // ID of the IV
 *  myMsgConfig.hash.mode                      = IfxCss_hashOpMode_none;
 *
 *  // Change the location / values at location according to need
 *  uint32  aad_inputArray[16];
 *  uint32* MacGenBuffer;
 *
 *  myMsgConfig.operation = IfxCss_Crypto_operation_cryptoMacGeneration; // Operation to be performed by channel
 *  myMsgConfig.aadLength = 64;                                          // Length of AAD in bytes
 *  myMsgConfig.aadPtr    = &aad_inputArray[0];                          // Pointer to the AAD header data
 *  myMsgConfig.genMacPtr = &MacGenBuffer;                               // Location of generated MAC storage
 *  myMsgConfig.numIv     = 0;                                           // number of IVs used for this message
 *
 *  \endcode
 *
 * \subsection IfxLld_Css_Crypto_Step3 STEP 3 Message Transfer:
 *  In this step, the user has two options for performing cryptographic operation: single call and streaming mode.
 *  The user must choose either one of them. Example use case of both operations can be seen below:
 *
 *  1.  Single Call mode:\n
 *      The single call mode is used in case the whole message length is known in the beginning.\n
 *      In single call mode the length of the data (additional authenticated data and plain or cipher text) needs to be
 *      known and configured before the engine starts computing.\n
 *
 *      \code
 *
 *      status = IfxCss_Crypto_singleCallImmediate(myChannel, myMsgConfig);
 *
 *      \endcode
 *
 *  2.  Streaming mode:\n
 *      The streaming mode is used in case the whole message length is not known in the beginning.\n
 *      Thus the engine can start computing even when the overall message length is not yet known.\n
 *      The length of the transferred data (additional authenticated data or plain or cipher text) needs to be
 *      configured for each data stream transfer.
 *
 *      \code
 *      boolean final         = FALSE; // final if TRUE, indicates final part of message
 *      boolean readResult   = FALSE; // readResult if TRUE, function will poll and read result
 *      myMsgConfig.aadLength = 32;    // 1st part length of AAD split into 2 parts
 *
 *      status = IfxCss_Crypto_streamMessage(myChannel, &myMsgConfig, final, readResult);
 *
 *      if (status == IfxCss_status_success)
 *      {
 *      myMsgConfig.aadPtr        = &aad_inputArray[8]; // Shift pointer to read next 8 words
 *      myMsgConfig.aadLength     = 32;                 // Length of 2nd part of AAD
 *      final                     = TRUE;
 *      readResult               = TRUE;
 *
 *      status = IfxCss_Crypto_streamMessage(myChannel, &myMsgConfig, final, readResult);
 *      }
 *      \endcode
 *
 *
 *
 * \subsection IfxLld_Css_Crypto_Step4 STEP 4 Check the result of cryptographic operation:
 *
 *  1. Access different types of results available after the cryptographic operation depending on the original configuration.
 *  Example:
 *
 *  \code
 *  // Access pointer of generated MAC
 *  uint32 genMacPtr*;
 *  genMacPtr = *myChannel->messagePtr->genMacPtr;
 *  \endcode
 *
 * \n
 *
 * \defgroup IfxLld_Css_Crypto CRYPTO
 * \ingroup IfxLld_Css
 * \defgroup IfxLld_Css_Crypto_Public_functions Public functions
 * \ingroup IfxLld_Css_Crypto
 * \defgroup IfxLld_Css_Crypto_Private_functions Private functions
 * \ingroup IfxLld_Css_Crypto
 * \defgroup IfxLld_Css_Crypto_Structures Structures
 * \ingroup IfxLld_Css_Crypto
 * \defgroup IfxLld_Css_Crypto_Enumerations Enumerations
 * \ingroup IfxLld_Css_Crypto
 */

#ifndef IFXCSS_CRYPTO_H
#define IFXCSS_CRYPTO_H 1

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "Css/Std/IfxCss.h"

/******************************************************************************/
/*-----------------------------------Macros-----------------------------------*/
/******************************************************************************/

/** \brief Macro that checks 32 bit multiplicity of input data byte size
 */
#define IFXCSS_CRYPTO_CHECKINPUTBYTESIZE(x)   (((x & (uint32)(4 - 1)) == (uint32)0))

/** \brief Macro that checks 32 bit multiplicity of input data bit size
 */
#define IFXCSS_CRYPTO_CHECKINPUTBITSIZE(x)    (((x & (uint32)(32 - 1)) == (uint32)0))

/** \brief Macro that calculates 32 bit  memory words from input data bit size
 */
#define IFXCSS_CRYPTO_CALCWORDS_FROMBITS(x)   (IFXCSS_CRYPTO_CHECKINPUTBITSIZE(x) ? (uint32)(x >> 5U) : (uint32)((x >> 5U) + 1U))

/** \brief Macro that calculates 32 bit  memory words from input Byte size.
 */
#define IFXCSS_CRYPTO_CALCWORDS_FROMBYTES(x)  (IFXCSS_CRYPTO_CHECKINPUTBYTESIZE(x) ? (uint32)(x >> 2U) : (uint32)((x >> 2U) + 1U))

/** \brief Macro that gets interrupt threshold reg entry from (x) bytes.
 */
#define IFXCSS_CRYPTO_GETINTLEVEL(x)          ((uint32)(x >> 4U))

/** \brief Macro that accepts an address and checks whether it is 64 bit aligned
 */
#define IFXCSS_CRYPTO_CHECK64BITALIGNMENT(x)  (((uint32)x & 7U) == 0U)

/** \brief Macro that accepts an address and checks whether it is 128 bit aligned
 */
#define IFXCSS_CRYPTO_CHECK128BITALIGNMENT(x) (((uint32)x & 15U) == 0U)

/** \brief Macro that copies data to channel FIFO
 */
#define IFXCSS_CRYPTO_COPYTOFIFO(src, dst, idx, numIters) \
    while (idx < numIters)                                \
    {                                                     \
        *dst = *src;                                      \
        idx++;                                            \
        src++;                                            \
    }

/** \brief Macro that copies data from channel FIFO
 */
#define IFXCSS_CRYPTO_COPYFROMFIFO(src, dst, idx, numIters) \
    while (idx < numIters)                                  \
    {                                                       \
        *dst = *src;                                        \
        idx++;                                              \
        dst++;                                              \
    }

/******************************************************************************/
/*--------------------------------Enumerations--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Css_Crypto_Enumerations
 * \{ */
/** \brief Enumeration describing the states of streaming machine
 */
typedef enum
{
    IfxCss_Crypto_StreamState_reset   = 0,  /**< \brief Streaming not started */
    IfxCss_Crypto_StreamState_started = 1,  /**< \brief Streaming started */
    IfxCss_Crypto_StreamState_update  = 2,  /**< \brief Update in progress */
    IfxCss_Crypto_StreamState_final   = 3,  /**< \brief Streaming finished */
    IfxCss_Crypto_StreamState_error   = 4   /**< \brief Stream State Error */
} IfxCss_Crypto_StreamState;

/** \brief State of CSS channel
 */
typedef enum
{
    IfxCss_Crypto_channelState_unknown     = -1, /**< \brief state is unknown */
    IfxCss_Crypto_channelState_reset       = 0,  /**< \brief channel is reset */
    IfxCss_Crypto_channelState_initialize  = 1,  /**< \brief channel is being initialized */
    IfxCss_Crypto_channelState_ready       = 2,  /**< \brief channel is ready for operation */
    IfxCss_Crypto_channelState_messageCfg  = 3,
    IfxCss_Crypto_channelState_messageInit = 4,  /**< \brief message is configured */
    IfxCss_Crypto_channelState_opBusy      = 5,  /**< \brief channel is busy with task */
    IfxCss_Crypto_channelState_error       = 6   /**< \brief channel has an error */
} IfxCss_Crypto_channelState;

/** \brief Enumeration describing which operation should be done by channel
 */
typedef enum
{
    IfxCss_Crypto_operation_pureCrypto            = 0,  /**< \brief Pure Crypto operation */
    IfxCss_Crypto_operation_cryptoWithAEAD        = 1,  /**< \brief Crypto with Authentication using CRYPTO engine */
    IfxCss_Crypto_operation_cryptoWithHash        = 2,  /**< \brief Crypto with Hash Authentication */
    IfxCss_Crypto_operation_cryptoMacGeneration   = 3,  /**< \brief Perform only MAC generation with CRYPTO engine */
    IfxCss_Crypto_operation_hashMacGeneration     = 4,  /**< \brief Perform only MAC generation with HASH engine */
    IfxCss_Crypto_operation_cryptoMacVerification = 5,  /**< \brief perform only MAC verification with CRYPTO engine */
    IfxCss_Crypto_operation_hashMacVerification   = 6   /**< \brief perform only MAC verification with HASH engine */
} IfxCss_Crypto_operation;

/** \} */

/******************************************************************************/
/*-----------------------------Data Structures--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Css_Crypto_Structures
 * \{ */
/** \brief Data structure holding the MAC configuration
 */
typedef struct
{
    boolean verEnable;           /**< \brief MAC verification to be performed */
    uint8   macLengthBits;       /**< \brief Length of MAC to be verified */
} IfxCss_Crypto_MacConfig;

/** \} */

/** \addtogroup IfxLld_Css_Crypto_Structures
 * \{ */
/** \brief Data Structure holding the Cryptographic configuration
 */
typedef struct
{
    IfxCss_cryptoOpMode     mode;                 /**< \brief Mode of cryptographic operation */
    IfxCss_cryptoHwCfg      hwConfig;             /**< \brief Engine Configuration for Crypto */
    IfxCss_encryptOp        encryptOp;            /**< \brief Encryption / Decryption Select */
    IfxCss_Crypto_MacConfig macConfig;            /**< \brief MAC configuration for Crypto. Ignored in case HASH is used in combined mode. */
    IfxCss_cryptoHwPad      hwPadding;            /**< \brief Zero padding configuration */
    uint8                   primaryKeyId;         /**< \brief Primary Key ID */
    uint8                   secondaryKeyId;       /**< \brief Secondary Key ID */
    uint8                   tertiaryKeyId;        /**< \brief Tertiary Key ID */
    uint8                   ivId;                 /**< \brief ID of the IV */
} IfxCss_Crypto_CryptoConfig;

/** \brief Data Structure holding the HASH configuration of the message
 */
typedef struct
{
    IfxCss_hashOpMode mode;                 /**< \brief Mode of operation of HASH function */
    IfxCss_hashDataIn dataInSel;            /**< \brief Mode of data input for Hash */
    IfxCss_featureSet macGen;               /**< \brief Enable/Disable MAC generation */
    IfxCss_featureSet macVer;               /**< \brief Enable/Disable MAC verification */
    uint16            hashLengthBits;       /**< \brief Length of HASH */
    uint8             macKeyLength;         /**< \brief Length of key used for MAC generation */
    uint8             keyId;                /**< \brief ID of key used for Hashing */
    uint8             ivId;                 /**< \brief ID of IV used */
} IfxCss_Crypto_HashConfig;

/** \} */

/** \addtogroup IfxLld_Css_Crypto_Structures
 * \{ */
/** \brief Structure holding the Errors of a channel
 */
typedef struct
{
    IfxCss_KeyIvWriteStatus keyWriteError;       /**< \brief union containing the key write errors. */
    IfxCss_KeyIvWriteStatus ivWriteError;        /**< \brief Union holding the IV write error */
    IfxCss_opErrorStatus    opError;             /**< \brief Operation Error status */
    IfxCss_KeyUseError      keyUseError;         /**< \brief Key usage error information */
} IfxCss_Crypto_ChannelError;

/** \brief Interrupt configuration
 */
typedef struct
{
    boolean dataInEvent;            /**< \brief if TRUE, data in event triggers Interrupt */
    boolean dataOutEvent;           /**< \brief if TRUE, data out event triggers Interrupt */
    boolean macGenEvent;            /**< \brief if TRUE, mac Gen event triggers Interrupt */
    boolean errorEvent;             /**< \brief if TRUE, error event triggers Interrupt */
    boolean useBatchModePlus;       /**< \brief if TRUE, OUTMODE will be set to batch move plus */
    uint16  dataOutLevel;           /**< \brief output FIFO level (bytes) for data Out event */
    uint16  dataInLevel;            /**< \brief Input FIFO level (bytes) for Data in event */
    uint16  dataInQuant;            /**< \brief Data write Quantity (bytes) for data in event */
} IfxCss_Crypto_ChannelInterruptCfg;

/** \brief Data Structure holding a message for crypto/authentication operation
 */
typedef struct
{
    IfxCss_Crypto_CryptoConfig crypto;              /**< \brief Crypto operation configuration */
    IfxCss_Crypto_HashConfig   hash;                /**< \brief Hashing operation configuration */
    IfxCss_Crypto_operation    operation;
    uint32                     pcLength;            /**< \brief length of Plain/Cipher Text in bytes */
    uint32                     aadLength;           /**< \brief Length of AAD in bytes */
    uint32                    *plainTextPtr;        /**< \brief Pointer to the plain text Data */
    uint32                    *cipherTextPtr;       /**< \brief Pointer to the cipher text */
    uint32                    *aadPtr;              /**< \brief Pointer to the AAD header data */
    uint32                    *verMacPtr;           /**< \brief Pointer to the reference MAC for verification */
    uint32                    *genMacPtr;           /**< \brief Location of generated MAC storage */
    IfxCss_status              macResult;           /**< \brief Success / Failure of MAC verification */
    IfxCss_Iv                 *ivPtr;               /**< \brief Pointer to the list of IV's */
    uint8                      numIv;               /**< \brief number of IV's used for this message */
} IfxCss_Crypto_message;

/** \brief Data Structure holding a streaming message
 */
typedef struct
{
    IfxCss_Crypto_StreamState *streamState;           /**< \brief pointer to streaming state machine */
    uint32                    *resultPtr;             /**< \brief pointer to the result buffer */
    boolean                    final;                 /**< \brief final flag */
    boolean                    streamInProgress;      /**< \brief flag identifying streaming in progress */
} IfxCss_Crypto_messageStream;

/** \} */

/** \addtogroup IfxLld_Css_Crypto_Structures
 * \{ */
/** \brief Handle of a single channel of CSS.
 */
typedef struct
{
    Ifx_CSS_CH                 *chSFR;                  /**< \brief Pointer to the channel SFR */
    IfxCss_channelId            id;                     /**< \brief ID of the channel */
    IfxCss_Crypto_channelState  state;                  /**< \brief state of CSS channel */
    uint16                      keyArea;                /**< \brief size of key area allocated to channel in memory words */
    uint16                      ivArea;                 /**< \brief Number of IV slots allocated to the channel */
    IfxCss_Crypto_ChannelError  errors;                 /**< \brief Structure holding the errors of a channel */
    IfxCss_Crypto_message      *messagePtr;             /**< \brief Pointer to the message object */
    IfxCss_Crypto_messageStream msgStream;              /**< \brief message stream with state info */
    IfxCss_featureSet           macRedir;               /**< \brief if MAC redirect is enabled */
    uint32                      expectedOutWords;       /**< \brief expected number of output words */
    uint16                      inFifoSizeBytes;        /**< \brief Input Fifo size for the channel ID */
    uint16                      outFifoSizeBytes;       /**< \brief Output Fifo size for the channel ID */
    boolean                     burstTransfer;          /**< \brief If TRUE, then DMA is used for RX/TX */
    boolean                     burstMacRead;           /**< \brief If TRUE, then DMA is used for MAC result read */
    boolean                     readMAC;                /**< \brief If TRUE, then MAC is ready to be read */
} IfxCss_Crypto_Channel;

/** \brief data structure describing the configuration of a channel of CSS
 */
typedef struct
{
    IfxCss_channelId                   id;                    /**< \brief ID of the channel */
    Ifx_CSS_CH                        *channelSFR;            /**< \brief pointer to the channel SFR */
    IfxCss_Crypto_ChannelInterruptCfg *interrupt;             /**< \brief Pointer to Interrupt configuration */
    IfxCss_featureSet                  underflowEnable;       /**< \brief underflow of FIFO is enabled */
    IfxCss_featureSet                  macToDataOut;          /**< \brief if Set, MAC will be forwarded to DATA out FIFO */
    IfxCss_Key                        *keys;                  /**< \brief Pointer to the list of keys */
    uint8                              numKeys;               /**< \brief number of keys for this channel */
    boolean                            burstTransfer;         /**< \brief If TRUE, then DMA is used for RX/TX */
    boolean                            burstMacRead;          /**< \brief If TRUE, then DMA is used for MAC result read */
} IfxCss_Crypto_ChannelConfig;

/** \brief data structure describing the interrupt configuration of a channel
 * TODO: update for input and output configurations! clarify with CE.
 */
typedef struct
{
    IfxCss_featureSet dataIn;                 /**< \brief Interrupt is enabled on input data entry in FIFO */
    IfxCss_featureSet dataOut;                /**< \brief Interrupt enabled on output Data in FIFO */
    IfxCss_featureSet macComplete;            /**< \brief Interrupt enabled on MAC complete */
    IfxCss_featureSet error;                  /**< \brief Interrupt enabled on error */
    boolean           enableInterrupts;       /**< \brief master enable of interrupt configuration */
} IfxCss_Crypto_InterruptConfig;

/** \} */

/** \addtogroup IfxLld_Css_Crypto_Public_functions
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Function to get the MAC length in words
 * \param msg Pointer to the message handle
 * \param op Type of operation
 * \return Number of MAC words
 */
IFX_INLINE uint32 IfxCss_Crypto_getMacLengthInWords(IfxCss_Crypto_message *msg, IfxCss_Crypto_operation op);

/** \brief Update Operation Error status in the handle.
 * Clear the operation error in the registers
 * Also returns "failure" if there is any error present.
 * \param channel Pointer to the channel handle
 * \return error failure
 */
IFX_INLINE IfxCss_status IfxCss_Crypto_getAndClearOperationError(IfxCss_Crypto_Channel *channel);

/** \brief Update key use Error status in the handle.
 * Clear the key use error in the registers
 * Also returns "failure" if there is any error present.
 * \param channel Pointer to the channel handle
 * \return error failure
 */
IFX_INLINE IfxCss_status IfxCss_Crypto_getAndClearKeyUseError(IfxCss_Crypto_Channel *channel);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief function to initialize the default setting of channel configuration.
 * \param cssSFR Pointer to the CSS SFR
 * \param config configuration of channel
 * \return None
 */
IFX_EXTERN void IfxCss_Crypto_initChannelConfig(Ifx_CSS *cssSFR, IfxCss_Crypto_ChannelConfig *config);

/** \brief Function to initialize a channel of CSS for a particular task.
 * \param channel pointer ot the channel
 * \param config Configuration of the channel
 * \return status of initialization
 */
IFX_EXTERN IfxCss_status IfxCss_Crypto_initChannel(IfxCss_Crypto_Channel *channel, IfxCss_Crypto_ChannelConfig *config);

/** \brief Load all static keys of a channel to it's corresponding Key area.
 * \param channel pointer to the CSS channel handle
 * \param keyList List of pointers to keys to be written
 * \param numKeys Number of static keys to be loaded
 * \return Write status of the key write operation
 */
IFX_EXTERN IfxCss_status IfxCss_Crypto_loadStaticKeys(IfxCss_Crypto_Channel *channel, IfxCss_Key *keyList, uint8 numKeys);

/** \brief Function to load a channel key
 * \param channel Pointer to the CSS channel handle
 * \param keyPtr Pointer to the key to be written
 * \return Key write status
 */
IFX_EXTERN IfxCss_KeyIvWriteStatus IfxCss_Crypto_loadChannelKey(IfxCss_Crypto_Channel *channel, IfxCss_Key *keyPtr);

/** \brief Function to perform a single call Crypto operation.
 * Polls for the results and reads them back before exit.
 * \param channel Pointer to the CSS channel
 * \param message Pointer to the message handle
 * \return status of operation
 */
IFX_EXTERN IfxCss_status IfxCss_Crypto_singleCallImmediate(IfxCss_Crypto_Channel *channel, IfxCss_Crypto_message *message);

/** \brief Initializes the channel with the required settings for handling the message
 * \param channel Pointer to the CSS channel
 * \param message Pointer to the message handle
 * \param singleCall if TRUE, then operation is a single call operation
 * \return status of operation
 */
IFX_EXTERN IfxCss_status IfxCss_Crypto_initMessage(IfxCss_Crypto_Channel *channel, IfxCss_Crypto_message *message, boolean singleCall);

/** \brief Function to load the IV's required for the message
 * \param channel Pointer to the channel handle
 * \param ivList Pointer to the list of IV's
 * \param numIv Number of IV to be loaded
 * \return status of IV load
 */
IFX_EXTERN IfxCss_status IfxCss_Crypto_loadMessageIv(IfxCss_Crypto_Channel *channel, IfxCss_Iv *ivList, uint8 numIv);

/** \brief Function to load a channel IV
 * \param channel Pointer to the channel handle
 * \param ivPtr Pointer to the IV to be written
 * \return Union holding the KEY/IV write status
 */
IFX_EXTERN IfxCss_KeyIvWriteStatus IfxCss_Crypto_loadChannelIv(IfxCss_Crypto_Channel *channel, IfxCss_Iv *ivPtr);

/** \brief Function to transfer the input data of message to the channel In FIFO.
 * Done by SW - no support from DMA.
 * \param channel pointer to the channel handle
 * \return return status of the operation
 */
IFX_EXTERN IfxCss_status IfxCss_Crypto_transferInputData(IfxCss_Crypto_Channel *channel);

/** \brief Function to feed the input fifo with the required words
 * \param channel Pointer to the CSS channel
 * \param sourcePtr Pointer to the source of input data
 * \param words Number of words to be written
 * \return Return status of operation
 */
IFX_EXTERN IfxCss_status IfxCss_Crypto_feedInputFifo(IfxCss_Crypto_Channel *channel, uint32 *sourcePtr, uint32 words);

/** \brief Function to feed reference MAC value.
 * \param channel Pointer to the channel handle
 * \return status of operation
 */
IFX_EXTERN IfxCss_status IfxCss_Crypto_feedReferenceMAC(IfxCss_Crypto_Channel *channel);

/** \brief Function to read generated MAC value.
 * \param channel Pointer to the channel handle
 * \return status of operation
 */
IFX_EXTERN IfxCss_status IfxCss_Crypto_readGeneratedMAC(IfxCss_Crypto_Channel *channel);

/** \brief Function to poll for output data / MAC verification from channel, and read it.
 * Data is read into the output data pointers in message handle.
 * Returns failure if timeout / any error in read.
 * \param channel pointer to the channel handle
 * \return status of result read
 */
IFX_EXTERN IfxCss_status IfxCss_Crypto_pollReadResults(IfxCss_Crypto_Channel *channel);

/** \brief Function to poll for MAC verification from channel, and read it.
 * Returns failure if timeout / any error in read.
 * \param channel pointer to the channel handle
 * \return status of MAC verification result
 */
IFX_EXTERN IfxCss_status IfxCss_Crypto_verifyMACResult(IfxCss_Crypto_Channel *channel);

/** \brief Function to perform a streaming Crypto operation.
 * Can be used multiple times to stream message parts.
 * \param channel Pointer to the CSS channel
 * \param message Pointer to the message handle
 * \param final if TRUE, indicates final part of message
 * \param readResult if TRUE, function will poll and read result
 * Note: This boolean is only applicable for non-crypto operation modes
 * \return status of operation
 */
IFX_EXTERN IfxCss_status IfxCss_Crypto_streamMessage(IfxCss_Crypto_Channel *channel, IfxCss_Crypto_message *message, boolean final, boolean readResult);

/** \} */

/******************************************************************************/
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE uint32 IfxCss_Crypto_getMacLengthInWords(IfxCss_Crypto_message *msg, IfxCss_Crypto_operation op)
{
    uint32 numWords;

    if ((op == IfxCss_Crypto_operation_cryptoWithHash)
        || (op == IfxCss_Crypto_operation_hashMacGeneration)
        || (op == IfxCss_Crypto_operation_hashMacVerification))
    {
        numWords = IFXCSS_CRYPTO_CALCWORDS_FROMBITS(msg->hash.hashLengthBits);
    }
    else
    {
        numWords = IFXCSS_CRYPTO_CALCWORDS_FROMBITS(msg->crypto.macConfig.macLengthBits);
    }

    return numWords;
}


IFX_INLINE IfxCss_status IfxCss_Crypto_getAndClearOperationError(IfxCss_Crypto_Channel *channel)
{
    IfxCss_status status = IfxCss_status_success;
    uint32        opErrStatus;
    uint32        opStatus;

    opErrStatus = channel->chSFR->STAT.OPERR.U;                    /* Read in the error register */
    opStatus    = channel->chSFR->STAT.OP.U;                       /* Read in the status register */

    if (((opErrStatus & (IFXCSS_OP_ERRORMASK)) != 0U) || ((opStatus & (IFXCSS_OP_STATUSERRORMASK)) != 0U))
    {
        status = IfxCss_status_failure;
    }

    channel->errors.opError.Word |= (opErrStatus & (IFXCSS_OP_ERRORMASK));               /* read in any new errors */
    channel->errors.opError.Word |= ((opErrStatus & (IFXCSS_OP_STATUSERRORMASK)) << 1U); /* read in any new errors */

    channel->chSFR->CLR.OPERR.U   = (uint32)IFXCSS_OP_ERRORMASK;                         /* clear the errors */

    return status;
}


IFX_INLINE IfxCss_status IfxCss_Crypto_getAndClearKeyUseError(IfxCss_Crypto_Channel *channel)
{
    IfxCss_status          status = IfxCss_status_success;
    Ifx_CSS_CH_STAT_KEYERR keyUse;

    keyUse.U = channel->chSFR->STAT.KEYERR.U;                          /* Read in the status register */

    if ((keyUse.U & (IFXCSS_KEYERR_ERRORMASK)) != 0)
    {
        status = IfxCss_status_failure;
    }

    channel->errors.keyUseError.Word |= (keyUse.U & (IFXCSS_KEYERR_ERRORMASK)); /* read in any new errors */

    channel->chSFR->CLR.KEYERR.U      = (uint32)IFXCSS_KEYERR_ERRORMASK;        /* clear the errors */

    return status;
}


#endif /* IFXCSS_CRYPTO_H */
