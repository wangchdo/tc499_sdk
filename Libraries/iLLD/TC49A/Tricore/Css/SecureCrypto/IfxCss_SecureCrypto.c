/**
 * \file IfxCss_SecureCrypto.c
 * \brief CSS SECURECRYPTO details
 *
 * \version iLLD_2_0_1_2_19
 * \copyright Copyright (c) 2023 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 *
 */

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "IfxCss_SecureCrypto.h"

/** \addtogroup IfxLld_Css_SecureCrypto_Private_functions
 * \{ */

/******************************************************************************/
/*-----------------------Private Function Prototypes--------------------------*/
/******************************************************************************/

/** \brief Function to map channel interrupts
 * \param channel channel pointer to the CSS channel handle
 * \param nodeCfg node pointer to channel interrupt node config
 * \return None
 */
IFX_STATIC void IfxCss_SecureCrypto_mapChannelInterrupts(IfxCss_SecureCrypto_CssChannel *channel, IfxCss_ChannelInterruptNodeCfg *nodeCfg);

/** \brief Function to initialize the CSS module
 * \param cfgTable css pointer to the CSS module handle
 * \param numNodes config pointer to module configuration
 * \return None
 */
IFX_STATIC void IfxCss_SecureCrypto_setupInterruptNodes(IfxCss_SecureCrypto_InterruptCfg *cfgTable, uint8 numNodes);

/** \} */

/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

IfxCss_status IfxCss_SecureCrypto_initModule(IfxCss_SecureCrypto_Css *css, const IfxCss_SecureCrypto_ModuleConfig *config)
{
    IfxCss_status status = IfxCss_status_success;

    css->cssSFR = config->cssSFR; /* Initialize the SFR pointer */

    /* 1. Configure the global security event actions */
    IfxCssSecure_configureGlobalSecurity(css->cssSFR, &(config->globalSecCfg));

    /* 2. store the life cycle keys */
    if ((config->numKeys > 0U) && (config->lifeCycleKeys != NULL_PTR))
    {
        css->numKeys = config->numKeys;
        status       = IfxCss_SecureCrypto_loadLifeCycleKeys(css, config->lifeCycleKeys, config->numKeys);
    }

    /* 3. Securely initialize the channels */
    if (status == IfxCss_status_success)
    {
        status = IfxCss_SecureCrypto_initChannels(css->channelPtr, config->channelConfig, config->numChannels);
    }

    /* 4. Configure the Interrupt Nodes */
    if ((status == IfxCss_status_success) && (config->numInterruptNodes > 0U))
    {
        IfxCss_SecureCrypto_setupInterruptNodes(config->interrupt, config->numInterruptNodes);
    }

    return status;
}


IfxCss_status IfxCss_SecureCrypto_initChannels(IfxCss_SecureCrypto_CssChannel *channel, IfxCss_SecureCrypto_ChannelConfig *channelCfg, uint8 numChannels)
{
    uint8                              ch_index;
    IfxCss_channelId                   id;
    uint32                             keyAddr, keySize, ivAddr, ivSize;
    uint32                             prioReg = (uint32)0;
    IfxCss_SecureCrypto_CssChannel    *handle;
    IfxCss_SecureCrypto_ChannelConfig *config;
    Ifx_CSS_CH                        *chPtr;
    IfxCss_status                      status = IfxCss_status_success;

    for (ch_index = 0; ch_index < numChannels; ch_index++)
    {
        handle  = &(channel[ch_index]);
        config  = &(channelCfg[ch_index]);

        keyAddr = config->keyCfg.base;
        keySize = config->keyCfg.size;
        ivAddr  = config->ivCfg.base;
        ivSize  = config->ivCfg.size;
        id      = config->id;
        chPtr   = &(MODULE_CSS0.CH[id]);

        /* 1. Map the ID to the handle */
        handle->id         = config->id;
        handle->chSFR      = chPtr;
        handle->keyWriteEn = config->keyWriteEn;

        /* 2. Store channel sections if applicable */
        if (id > 0)
        {
            if (IfxCssSecure_Ch_checkKeyMapping(keyAddr, keySize, id))
            {
                IfxCssSecure_Ch_writeKeyCfg(chPtr, keyAddr, keySize, handle->keyWriteEn);
            }
            else
            {
                handle->keyAddrInvalid = TRUE;
                status                 = IfxCss_status_failure;
            }

            if (IfxCssSecure_Ch_checkIvMapping(ivAddr, ivSize, id))
            {
                IfxCssSecure_Ch_writeIvCfg(chPtr, ivAddr, ivSize);
            }
            else
            {
                handle->ivAddrInvalid = TRUE;
            }
        }

        /* 3. configure the priority */
        IfxCssSecure_Ch_setChPropTemp(&prioReg, id, (uint32)config->priority);

        /* 4. Configure the authentication config */
        IfxCssSecure_Ch_setAuthCfg(chPtr, &(config->authCfg));

        /* 6: Configure Interrupt nodes */
        IfxCss_SecureCrypto_mapChannelInterrupts(handle, &(config->interruptNodeCfg));
    }

    /* 7. Write into the registers at once for combined regs */
    IfxCssSecure_setGlobalChReg((uint32 *)&(MODULE_CSS0.PRIOCFG.U), prioReg);

    return status;
}


IfxCss_status IfxCss_SecureCrypto_loadLifeCycleKeys(IfxCss_SecureCrypto_Css *css, IfxCss_Key *keyList, uint16 numKeys)
{
    IfxCss_status           status = IfxCss_status_success; /* initialize the status to success */
    uint8                   key_index;
    IfxCss_KeyIvWriteStatus wr_status;
    wr_status.Word = (uint32)0;

    for (key_index = 0; key_index < css->numKeys; key_index++)  /* loop through all keys */
    {
        /* TODO: check for validity of key if applicable */
        wr_status = IfxCss_SecureCrypto_loadGlobalKey(css, &(keyList[key_index]));

        if (wr_status.Word != (uint32)0)
        {
            status                    = IfxCss_status_failure;
            css->keyWriteStatus.Word |= wr_status.Word; /* update the handle with failure */
            break;
        }
    }

    return status;
}


void IfxCss_SecureCrypto_initModuleConfig(Ifx_CSS *css, IfxCss_SecureCrypto_ModuleConfig *moduleConfig)
{
    const IfxCss_SecureCrypto_ModuleConfig defaultConfig = {
        .cssSFR       = NULL_PTR,
        .globalSecCfg = {
            .extSecEventCfg = IfxCssSecure_extSecBlck_disable,
            .intSecEventCfg = IfxCssSecure_intSecBlck_none
        },
        .channelConfig     = NULL_PTR,
        .lifeCycleKeys     = NULL_PTR,
        .interrupt         = NULL_PTR,
        .numInterruptNodes = 0U,
        .numKeys           = (uint32)0,
        .numChannels       = 0U
    };

    *moduleConfig        = defaultConfig;

    moduleConfig->cssSFR = css; /* get pointer to the CSS SFR */
}


void IfxCss_SecureCrypto_initChannelConfig(Ifx_CSS_CH *cssChannel, IfxCss_SecureCrypto_ChannelConfig *config)
{
    const IfxCss_SecureCrypto_ChannelConfig defaultConfig = {
        .channelSFR = NULL_PTR,
        .id         = IfxCss_channelId_1,
        .keyCfg     = {
            .size = 0U,
            .base = 0U
        },
        .ivCfg              = {
            .size = 0U,
            .base = 0U
        },
        .priority = IfxCss_channelPriority_normal,
        .authCfg  = {
            .alarmThreshold = IfxCss_channelAuthAlarmThres_0,
            .thresholdLock  = IfxCss_channelAuthThresLock_unlock,
            .clearCounter   = TRUE
        },
        .interruptNodeCfg   = {
            .dataInNode  = IfxCss_serviceRequestNode_none,
            .dataOutNode = IfxCss_serviceRequestNode_none,
            .macNode     = IfxCss_serviceRequestNode_none,
            .errorNode   = IfxCss_serviceRequestNode_none
        },
        .keyWriteEn         = TRUE
    };

    *config            = defaultConfig;

    config->channelSFR = cssChannel; /* get pointer to the  SFR */
}


IfxCss_KeyIvWriteStatus IfxCss_SecureCrypto_loadGlobalKey(IfxCss_SecureCrypto_Css *css, const IfxCss_Key *keyPtr)
{
    Ifx_CSS                     *cssReg    = css->cssSFR;
    IfxCss_KeyIvWriteStatus      writeStatus;
    volatile Ifx_CSS_KEY_WRSTAT *wrstatReg = &(cssReg->KEY.WRSTAT);

    writeStatus.Word = (uint32)0; /* Initialize the write status to clean first */

    if ((IFXCSS_CHECK_OP_BUSY(wrstatReg->U) == FALSE) && ((IfxCss_isGlobalKeyInvalid(keyPtr)) == FALSE))
    {
        IfxCss_writeKeyCommand(cssReg, keyPtr);    /* write the command register with write enable */

        if (keyPtr->attributes.fromOut == IfxCss_featureSet_disable)
        {
            IfxCss_writeKeyInput(cssReg, keyPtr);                 /* write keyValue inside the register first */
        }

        if (IFXCSS_CHECK_KEYIVWRITE_ERROR(wrstatReg->U) == FALSE) /* check for write access and other errors */
        {
            while (IFXCSS_CHECK_OP_BUSY(wrstatReg->U))            /* wait until the write is completed */
            {
                /* TODO: timeout? */
            }
        }
        else
        /*  Update write errors and clear status register */
        {
            IfxCss_updateAndClearWriteError(cssReg, &writeStatus);
        }
    }
    else /* global key write busy / key invalid */
    {
        writeStatus.Bits.softwareError = (uint32)1;
    }

    return writeStatus;
}


IFX_STATIC void IfxCss_SecureCrypto_mapChannelInterrupts(IfxCss_SecureCrypto_CssChannel *channel, IfxCss_ChannelInterruptNodeCfg *nodeCfg)
{
    Ifx_CSS_CH_INP nodePtr;
    nodePtr.U             = channel->chSFR->INP.U;

    nodePtr.B.DINNODE     = (nodeCfg->dataInNode > IfxCss_serviceRequestNode_none) ? (uint32)nodeCfg->dataInNode : 0U;
    nodePtr.B.DOUTNODE    = (nodeCfg->dataOutNode > IfxCss_serviceRequestNode_none) ? (uint32)nodeCfg->dataOutNode : 0U;
    nodePtr.B.MACNODE     = (nodeCfg->macNode > IfxCss_serviceRequestNode_none) ? (uint32)nodeCfg->macNode : 0U;
    nodePtr.B.ERRNODE     = (nodeCfg->errorNode > IfxCss_serviceRequestNode_none) ? (uint32)nodeCfg->errorNode : 0U;

    channel->chSFR->INP.U = nodePtr.U;
}


IFX_STATIC void IfxCss_SecureCrypto_setupInterruptNodes(IfxCss_SecureCrypto_InterruptCfg *cfgTable, uint8 numNodes)
{
    uint8 index = 0U;

    while (index < numNodes)
    {
        IfxCss_SecureCrypto_InterruptCfg *cfgPtr = &(cfgTable[index]);

        if (cfgPtr->priority > 0U)
        {
            volatile Ifx_SRC_SRCR *src = IfxCss_getSrcPointer(cfgPtr->cssNode);
            IfxSrc_init(src, cfgPtr->typOfService, cfgPtr->priority, cfgPtr->vmId);
            IfxSrc_enable(src);
        }

        index++;
    }
}
