/**
 * \file IfxRng.h
 * \brief RNG  basic functionality
 * \ingroup IfxLld_Rng
 *
 * \version iLLD_2_0_1_2_19
 * \copyright Copyright (c) 2023 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 *
 * \defgroup IfxLld_Rng_Std_Enumerations Enumerations
 * \ingroup IfxLld_Rng_Std
 * \defgroup IfxLld_Rng_Std_Structures Structures
 * \ingroup IfxLld_Rng_Std
 * \defgroup IfxLld_Rng_Std_Functions Functions
 * \ingroup IfxLld_Rng_Std
 */

#ifndef IFXRNG_H
#define IFXRNG_H 1

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "_Impl/IfxRng_cfg.h"
#include "Cpu/Std/Ifx_Types.h"
#include "IfxRng_reg.h"
#include "IfxRng_bf.h"
#include "Src/Std/IfxSrc.h"
#include "Ap/Std/IfxApApu.h"
#include "Ap/Std/IfxApProt.h"
#include "_Utilities/Ifx_Assert.h"

/******************************************************************************/
/*-----------------------------------Macros-----------------------------------*/
/******************************************************************************/

/** \brief Macro that returns a mask of error bits of STAT register
 */
#define IFXRNG_ERRORMASK                                                            \
    ((uint32)                                                                       \
     ((uint32)(IFX_RNG_STAT_ERR_ENTROPY_MSK << IFX_RNG_STAT_ERR_ENTROPY_OFF)) |     \
     ((uint32)(IFX_RNG_STAT_ERR_STATISTIC_MSK << IFX_RNG_STAT_ERR_STATISTIC_OFF)) | \
     ((uint32)(IFX_RNG_STAT_ERR_MAXDATA_MSK << IFX_RNG_STAT_ERR_MAXDATA_OFF)) |     \
     ((uint32)(IFX_RNG_STAT_ERR_SEED_MSK << IFX_RNG_STAT_ERR_SEED_OFF)))

/** \brief Macro that accepts STAT register and returns True if any error bit is set
 */
#define IFXRNG_CHECK_ERRORSTATUS(x) ((uint32)(x & IFXRNG_ERRORMASK) != (uint32)0)

/******************************************************************************/
/*--------------------------------Enumerations--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Rng_Std_Enumerations
 * \{ */
/** \brief Enumeration to select Expansion rate for HRNG mode
 */
typedef enum
{
    IfxRng_expansionRate_1   = 0, /**< \brief E0 / E = 2^0 (1 : 1 expansion rate) */
    IfxRng_expansionRate_16  = 1, /**< \brief E4 / E = 2^4 (16 : 1 expansion rate) */
    IfxRng_expansionRate_4k  = 2, /**< \brief E12 / E = 2^12 (4096 : 1 expansion rate) */
    IfxRng_expansionRate_64k = 3  /**< \brief E16 / E = 2^16 (65536 : 1 expansion rate) */
} IfxRng_expansionRate;

/** \brief Enumeration to select Operation/generator mode of RNG
 */
typedef enum
{
    IfxRng_operationMode_TRNG = 0,  /**< \brief true random number generator */
    IfxRng_operationMode_HRNG = 1,  /**< \brief hybrid random number generator */
    IfxRng_operationMode_DRNG = 2   /**< \brief deterministic random number generator */
} IfxRng_operationMode;

/** \brief Enumeration to select seed length for HRNG/DRNG
 */
typedef enum
{
    IfxRng_seedLength_64Bits  = 0,  /**< \brief seed length 64bits */
    IfxRng_seedLength_96Bits  = 1,  /**< \brief seed length 96bits */
    IfxRng_seedLength_128Bits = 2,  /**< \brief seed length 128bits */
    IfxRng_seedLength_160Bits = 3,  /**< \brief seed length 160bits */
    IfxRng_seedLength_192Bits = 4,  /**< \brief seed length 192bits */
    IfxRng_seedLength_224Bits = 5,  /**< \brief seed length 224bits */
    IfxRng_seedLength_256Bits = 6,  /**< \brief seed length 256bits */
    IfxRng_seedLength_288Bits = 7   /**< \brief seed length 288bits */
} IfxRng_seedLength;

/** \brief Enumeration to select internal/external seeding for HRNG/DRNG
 */
typedef enum
{
    IfxRng_seedType_internal = 0,  /**< \brief Internal Seeding */
    IfxRng_seedType_external = 1   /**< \brief External Seeding */
} IfxRng_seedType;

/** \brief Enumeration to select the state of the module
 */
typedef enum
{
    IfxRng_state_unknown   = -1, /**< \brief state is unknown */
    IfxRng_state_config    = 0,  /**< \brief the module is in configuration mode */
    IfxRng_state_operation = 1   /**< \brief the module is in operational mode */
} IfxRng_state;

/** \brief Enumeration listing the status of an operation
 */
typedef enum
{
    IfxRng_status_success,  /**< \brief Operation successful */
    IfxRng_status_failure   /**< \brief Operation failed */
} IfxRng_status;

/** \} */

/******************************************************************************/
/*-----------------------------Data Structures--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Rng_Std_Structures
 * \{ */
/** \brief Bitfield structure holding the error status bits of module
 */
typedef struct
{
    uint32 entropyError : 1;         /**< \brief Entropy error */
    uint32 statisticError : 1;       /**< \brief Statistic error */
    uint32 maxDataError : 1;         /**< \brief Maximum amount of DRNG output reached */
    uint32 seedingError : 1;         /**< \brief Seeding error */
    uint32 softwareError : 1;        /**< \brief Software Error reported by driver */
    uint32 invalidConfig : 1;        /**< \brief Invalid config given by user */
} IfxRng_ErrorBits;

/** \} */

/** \addtogroup IfxLld_Rng_Std_Structures
 * \{ */
/** \brief PROT and APU Configuration for RNG Module
 */
typedef struct
{
    IfxApProt_ProtConfig proteConfig;        /**< \brief PROTE related configuration */
    IfxApProt_ProtConfig protseConfig;       /**< \brief PROTSE related configuration */
    IfxApApu_ApuConfig   apuConfig;          /**< \brief APU Configuration */
} IfxRng_ApConfig;

/** \brief Union holding the error status of module
 */
typedef union
{
    IfxRng_ErrorBits Bits;       /**< \brief Bitfield holding specific error information */
    uint32           Word;       /**< \brief Word holding consolidated operation error status */
} IfxRng_Error;

/** \} */

/** \addtogroup IfxLld_Rng_Std_Functions
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Function to initialize the PROT and APU Config of RNG Module with default value
 * \param config PROT and APU Config
 * \return None
 */
IFX_INLINE void IfxRng_initApConfig(IfxRng_ApConfig *config);

/** \brief Function to initialize the PROT and APU of RNG Module
 * \param rngSFR Pointer to the RNG SFR
 * \param config PROT and APU Config
 * \return None
 */
IFX_INLINE void IfxRng_initAp(Ifx_RNG *rngSFR, IfxRng_ApConfig *config);

/** \brief Function that requests to enable the module clock
 * \param rngSFR Pointer to the RNG SFR
 * \return None
 */
IFX_INLINE void IfxRng_enableModule(Ifx_RNG *rngSFR);

/** \brief Function that requests to disable the module clock
 * \param rngSFR Pointer to the RNG SFR
 * \return None
 */
IFX_INLINE void IfxRng_disableModule(Ifx_RNG *rngSFR);

/** \brief Function that checks whether the module clock is enabled
 * \param rngSFR Pointer to the RNG SFR
 * \return Returns TRUE: Module clock is enabled
 * returns FALSE: Off, module is not clocked
 */
IFX_INLINE boolean IfxRng_isModuleEnabled(Ifx_RNG *rngSFR);

/** \brief Function that checks whether Sleep Mode Control is possible or not
 * \param rngSFR Pointer to the RNG SFR
 * \return Returns TRUE: Sleep mode request is enabled and functional
 * returns FALSE: Module disregards the sleep mode control signal
 */
IFX_INLINE boolean IfxRng_isSleepModeControlEnabled(Ifx_RNG *rngSFR);

/** \brief Function that enables module to react to sleep mode requests
 * \param rngSFR Pointer to the RNG SFR
 * \return None
 */
IFX_INLINE void IfxRng_enableSleepModeControl(Ifx_RNG *rngSFR);

/** \brief Function that disables the module reaction to sleep mode requests
 * \param rngSFR Pointer to the RNG SFR
 * \return None
 */
IFX_INLINE void IfxRng_disableSleepModeControl(Ifx_RNG *rngSFR);

/** \brief Function that checks whether random data is ready to be read
 * \param rngSFR Pointer to the RNG SFR
 * \return returns TRUE: Data ready for reading
 * returns FALSE: Not ready for reading
 */
IFX_INLINE boolean IfxRng_isRandomDataReady(Ifx_RNG *rngSFR);

/** \brief Function that checks whether External Seed or Extra Input can now be written
 * \param rngSFR Pointer to the RNG SFR
 * \return returns TRUE: Ready for writing
 * returns FALSE: Not Ready for writing
 */
IFX_INLINE boolean IfxRng_isSeedInputReady(Ifx_RNG *rngSFR);

/** \brief Function that checks whether more external seed input is  not required
 * \param rngSFR Pointer to the RNG SFR
 * \return returns TRUE: Finished external seeding / more input not required
 * returns FALSE: More input is expected
 */
IFX_INLINE boolean IfxRng_isExternalSeedingDone(Ifx_RNG *rngSFR);

/** \brief Function that returns the current module state
 * \param rngSFR Pointer to the RNG SFR
 * \return state of the module
 */
IFX_INLINE IfxRng_state IfxRng_getModuleState(Ifx_RNG *rngSFR);

/** \brief Function that sets the module state to Off/Config or Active/Operation
 * \param rngSFR Pointer to the RNG SFR
 * \param state Desired state of the module
 * \return None
 */
IFX_INLINE void IfxRng_setModuleState(Ifx_RNG *rngSFR, IfxRng_state state);

/** \brief Function that returns TRUE if any error bits are set
 * \param rngSFR Pointer to the RNG SFR
 * \return returns TRUE: Any error bit is set
 * returns FALSE: No error bit is set
 */
IFX_INLINE boolean IfxRng_getErrorStatus(Ifx_RNG *rngSFR);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Configures access to all masters to all the RNGs in the device
 * \param apConfig pointer to configuration structure
 * \return None
 */
IFX_EXTERN void IfxRng_configureAccessToRng(IfxApApu_ApuConfig *apConfig);

/** \} */

/******************************************************************************/
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE void IfxRng_initApConfig(IfxRng_ApConfig *config)
{
    IfxApProt_initConfig(&config->proteConfig);
    IfxApProt_initConfig(&config->protseConfig);
    IfxApApu_initConfig(&config->apuConfig);
}


IFX_INLINE void IfxRng_initAp(Ifx_RNG *rngSFR, IfxRng_ApConfig *config)
{
    /* Initialize the PROT */
    IfxApProt_init((Ifx_PROT_PROT *)&rngSFR->PROTE, &config->proteConfig);
    IfxApProt_init((Ifx_PROT_PROT *)&rngSFR->PROTSE, &config->protseConfig);

    /* Change the state to CONFIG, Configure APU and set PROT state back to RUN */
    /* Initialize the APU */
    IfxApProt_setState((Ifx_PROT_PROT *)&rngSFR->PROTSE, IfxApProt_State_config);
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&rngSFR->ACCEN, &config->apuConfig);
    IfxApProt_setState((Ifx_PROT_PROT *)&rngSFR->PROTSE, IfxApProt_State_run);
}


IFX_INLINE void IfxRng_enableModule(Ifx_RNG *rngSFR)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&rngSFR->PROTE, IfxApProt_State_config);
#endif

    rngSFR->CLC.B.DISR = (uint32)0;

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&rngSFR->PROTE, IfxApProt_State_run);
#endif

    while (rngSFR->CLC.B.DISS == (uint32)1)
    {
        /* wait until module is enabled */
    }
}


IFX_INLINE void IfxRng_disableModule(Ifx_RNG *rngSFR)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&rngSFR->PROTE, IfxApProt_State_config);
#endif

    rngSFR->CLC.B.DISR = (uint32)1;

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&rngSFR->PROTE, IfxApProt_State_run);
#endif

    while (rngSFR->CLC.B.DISS == (uint32)0)
    {
        /* wait until module is disabled */
    }
}


IFX_INLINE boolean IfxRng_isModuleEnabled(Ifx_RNG *rngSFR)
{
    boolean return_status = FALSE;
    return_status = (rngSFR->CLC.B.DISS == (uint32)0);
    return return_status;
}


IFX_INLINE boolean IfxRng_isSleepModeControlEnabled(Ifx_RNG *rngSFR)
{
    boolean return_status = FALSE;
    return_status = (rngSFR->CLC.B.EDIS == (uint32)0);
    return return_status;
}


IFX_INLINE void IfxRng_enableSleepModeControl(Ifx_RNG *rngSFR)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&rngSFR->PROTE, IfxApProt_State_config);
#endif

    rngSFR->CLC.B.EDIS = (uint32)0;

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&rngSFR->PROTE, IfxApProt_State_run);
#endif
}


IFX_INLINE void IfxRng_disableSleepModeControl(Ifx_RNG *rngSFR)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&rngSFR->PROTE, IfxApProt_State_config);
#endif

    rngSFR->CLC.B.EDIS = (uint32)1;

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&rngSFR->PROTE, IfxApProt_State_run);
#endif
}


IFX_INLINE boolean IfxRng_isRandomDataReady(Ifx_RNG *rngSFR)
{
    boolean return_status = FALSE;
    return_status = (rngSFR->STAT.B.DATA_RDY == (uint32)1);
    return return_status;
}


IFX_INLINE boolean IfxRng_isSeedInputReady(Ifx_RNG *rngSFR)
{
    boolean return_status = FALSE;
    return_status = (rngSFR->STAT.B.SEED_RDY == (uint32)1);
    return return_status;
}


IFX_INLINE boolean IfxRng_isExternalSeedingDone(Ifx_RNG *rngSFR)
{
    boolean return_status = FALSE;
    return_status = (rngSFR->STAT.B.SEED_DONE == (uint32)1);
    return return_status;
}


IFX_INLINE IfxRng_state IfxRng_getModuleState(Ifx_RNG *rngSFR)
{
    IfxRng_state state;
    state = (IfxRng_state)(rngSFR->STAT.B.STATE);
    return state;
}


IFX_INLINE void IfxRng_setModuleState(Ifx_RNG *rngSFR, IfxRng_state state)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&rngSFR->PROTE, IfxApProt_State_config);
#endif
    rngSFR->CTRL.B.EN = (uint32)state;
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&rngSFR->PROTE, IfxApProt_State_run);
#endif
}


IFX_INLINE boolean IfxRng_getErrorStatus(Ifx_RNG *rngSFR)
{
    Ifx_RNG_STAT statReg;
    boolean      errorStatus;

    statReg.U   = rngSFR->STAT.U;
    errorStatus = IFXRNG_CHECK_ERRORSTATUS(statReg.U);
    return errorStatus;
}


#endif /* IFXRNG_H */
