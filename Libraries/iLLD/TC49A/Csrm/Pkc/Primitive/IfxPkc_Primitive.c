/**
 * \file IfxPkc_Primitive.c
 * \brief PKC PRIMITIVE details
 *
 * \version iLLD_2_0_1_2_19
 * \copyright Copyright (c) 2022 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 */

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "IfxPkc_Primitive.h"

/******************************************************************************/
/*-----------------------Private Function Prototypes--------------------------*/
/******************************************************************************/

/** \brief Function to start the PKC operation and check for timeout / errors.
 * Returns after operation is finished or timeout is reached.
 * \param pkc Pointer to the Handle of PKC Module
 * \return Status of the operation
 */
IFX_STATIC IfxPkc_Status IfxPkc_Primitive_performOperation(IfxPkc_Primitive *pkc);

/** \brief Function to initialize registers and DATARAM for RSA operations
 * \param pkc Pointer to the Handle of PKC Module
 * \return None
 */
IFX_STATIC void IfxPkc_Primitive_initRMOperation(IfxPkc_Primitive *pkc);

/** \brief Function to initialize registers and DATARAM for ECC Primitive operations
 * \param pkc Pointer to the Handle of PKC Module
 * \param ecc ECC algorithm structure
 * \return Status of the operation
 */
IFX_STATIC IfxPkc_Status IfxPkc_Primitive_initEccOperation(IfxPkc_Primitive *pkc, IfxPkc_Primitive_EccAlgorithm *ecc);

/** \brief Function to initialize registers and DATARAM for primtive arithmetic operations
 * \param pkc Pointer to the Handle of PKC Module
 * \param arithmetic Arithmetic algorithm structure
 * \return Status of the operation
 */
IFX_STATIC IfxPkc_Status IfxPkc_Primitive_initArithmeticOperation(IfxPkc_Primitive *pkc, IfxPkc_Primitive_ArithmeticAlgorithm *arithmetic);

/** \brief Function to initialize registers and DATARAM for Montgomery operation
 * \param pkc Pointer to the Handle of PKC Module
 * \param montgomery Montgomery algorithm structure
 * \return Status of the operation
 */
IFX_STATIC IfxPkc_Status IfxPkc_Primitive_initMcOperation(IfxPkc_Primitive *pkc, IfxPkc_Primitive_McAlgorithm *montgomery);

/** \brief Function to initialize registers and DATARAM for EdDsa operation
 * \param pkc Pointer to the Handle of PKC Module
 * \param edDsa EdDsa algorithm structure
 * \return Status of the operation
 */
IFX_STATIC IfxPkc_Status IfxPkc_Primitive_initEdDsaOperation(IfxPkc_Primitive *pkc, IfxPkc_Primitive_EdDsaAlgorithm *edDsa);

/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxPkc_Primitive_initModuleConfig(Ifx_PKC *pkcSFR, IfxPkc_Primitive_ModuleConfig *config)
{
    const IfxPkc_Primitive_ModuleConfig defaultConfig = {
        .pkcSFR = NULL_PTR,
        .endian = IfxPkc_Endian_little
    };

    *config        = defaultConfig;

    config->pkcSFR = pkcSFR;
}


IfxPkc_Status IfxPkc_Primitive_initModule(IfxPkc_Primitive *pkc, IfxPkc_Primitive_ModuleConfig *config)
{
    IfxPkc_Status status = IfxPkc_Status_success;

    /* Check whether module is busy */
    if (IfxPkc_isModuleBusy(config->pkcSFR) != TRUE)
    {
        pkc->state       = IfxPkc_State_unknown;

        pkc->errors.Word = 0U;

        /* Get data from config structure */
        pkc->pkcSFR             = config->pkcSFR;
        pkc->endian             = config->endian;

        pkc->pkcSFR->CMD.B.SWAP = (uint32)(pkc->endian);

        pkc->state              = IfxPkc_State_moduleInitialized;
    }
    else /* Module is busy */
    {
        /* do nothing, return failure */
        status = IfxPkc_Status_failure;
    }

    return status;
}


IfxPkc_Status IfxPkc_Primitive_initOperation(IfxPkc_Primitive *pkc, IfxPkc_Primitive_Operation *operation)
{
    IfxPkc_Status status = IfxPkc_Status_success;

    /* Check whether module is in correct state */
    if ((pkc->state >= IfxPkc_State_moduleInitialized) && (pkc->state < IfxPkc_State_opBusy))
    {
        Ifx_PKC             *pkcSFR        = pkc->pkcSFR;
        IfxPkc_OperationType operationType = operation->operationType;
        uint32               dataSizeWords = IFXPKC_CALCWORDS_FROMBYTES((operation->dataSize));

        /* clear all errors in handle */
        pkc->errors.Word   = 0U;
        pkc->operationType = operationType;
        pkc->algoMechanism = operation->algoMechanism;

        /* Check that dataSize configured by user is valid */
        if (dataSizeWords <= IFXPKC_MAX_DATASIZE_WORDS)
        {
            pkc->dataSize = operation->dataSize;
        }
        else /* Invalid dataSize */
        {
            status |= IfxPkc_Status_failure;
        }

        /* Step 1. Clear DATARAM */
        status |= IfxPkc_clearDataram(pkc->pkcSFR);

        if (status == IfxPkc_Status_success)
        {
            /* Step 2: Write operation independent configuration */
            Ifx_PKC_CMD cfg;
            cfg.U = pkcSFR->CMD.U;

            /* Operand size = Number of bytes - 1 */
            cfg.B.SIZE    = (uint32)((uint32)(operation->dataSize) - (uint32)1);

            pkcSFR->CMD.U = cfg.U;

            /* Step 3: Do rest of the initialization depending on operation type */
            /* Configure for Rabin Miller */
            if (operationType == IfxPkc_OperationType_RABINMILLER)
            {
                IfxPkc_Primitive_initRMOperation(pkc);
            }
            /* Configure for ECC operations and JPAKE 3 Point Addition */
            else if (((operationType >= IfxPkc_OperationType_PDBL) && (operationType <= IfxPkc_OperationType_YRECOVER)) || (operationType == IfxPkc_OperationType_JPAKE3PADD))
            {
                status = IfxPkc_Primitive_initEccOperation(pkc, (IfxPkc_Primitive_EccAlgorithm *)operation->algoMechanism);
            }
            /* Configure for Arithmetic operations */
            else if (((operationType >= IfxPkc_OperationType_ADDN) && (operationType <= IfxPkc_OperationType_RED2)) || (operationType == IfxPkc_OperationType_EXP))
            {
                status = IfxPkc_Primitive_initArithmeticOperation(pkc, (IfxPkc_Primitive_ArithmeticAlgorithm *)operation->algoMechanism);
            }
            /* Configure for Montgomery operation */
            else if (operationType == IfxPkc_OperationType_SMULT25519)
            {
                status = IfxPkc_Primitive_initMcOperation(pkc, (IfxPkc_Primitive_McAlgorithm *)operation->algoMechanism);
            }
            /* Configure for EdDsa operation */
            else if (operationType == IfxPkc_OperationType_EDDSASMULT)
            {
                status = IfxPkc_Primitive_initEdDsaOperation(pkc, (IfxPkc_Primitive_EdDsaAlgorithm *)operation->algoMechanism);
            }
            /* Unsupported operation type */
            else
            {
                status = IfxPkc_Status_failure;
            }
        }
    }
    else /* Module is not in correct state */
    {
        /* do nothing, return failure */
        status = IfxPkc_Status_failure;
    }

    if (status == IfxPkc_Status_success)
    {
        pkc->state = IfxPkc_State_operationInitialized;
    }

    return status;
}


IfxPkc_Status IfxPkc_Primitive_writeToDataram(IfxPkc_Primitive *pkc, uint32 *sourcePtr, uint32 numWords, IfxPkc_MemLocation memLocation)
{
    IfxPkc_Status status = IfxPkc_Status_success;
    uint32       *destPtr;
    /* Max operand size in words */
    uint32        operandSizeWords = IFXPKC_CALCWORDS_FROMBYTES((pkc->dataSize));

    /* Check for NULL pointer */
    if (sourcePtr == NULL_PTR)
    {
        pkc->errors.Bits.nullPointer = 1u;
        status                       = IfxPkc_Status_failure;
    }

    /* Check if number of words satisfy range constraints */
    if ((status == IfxPkc_Status_success) && (numWords <= operandSizeWords))
    {
        /* Get the pointer to destination */
        destPtr = IfxPkc_getDataramPointer(pkc->pkcSFR, memLocation);
        IfxPkc_performDataramOp(IfxPkc_DataramOp_write, sourcePtr, destPtr, numWords, operandSizeWords, pkc->endian);
    }
    else /* Num words is out of range */
    {
        status = IfxPkc_Status_failure;
    }

    return status;
}


IfxPkc_Status IfxPkc_Primitive_readFromDataram(IfxPkc_Primitive *pkc, uint32 *destPtr, uint32 numWords, IfxPkc_MemLocation memLocation)
{
    IfxPkc_Status status = IfxPkc_Status_success;
    uint32       *sourcePtr;
    /* Max operand size in words */
    uint32        operandSizeWords = IFXPKC_CALCWORDS_FROMBYTES((pkc->dataSize));

    /* Check for NULL pointer */
    if (destPtr == NULL_PTR)
    {
        pkc->errors.Bits.nullPointer = 1u;
        status                       = IfxPkc_Status_failure;
    }

    /* Check if number of words satisfy range constraints */
    if ((status == IfxPkc_Status_success) && (numWords <= operandSizeWords))
    {
        /* Get the pointer to source data */
        sourcePtr = IfxPkc_getDataramPointer(pkc->pkcSFR, memLocation);
        IfxPkc_performDataramOp(IfxPkc_DataramOp_read, sourcePtr, destPtr, numWords, operandSizeWords, pkc->endian);
    }
    else  /* Num words is out of range */
    {
        status = IfxPkc_Status_failure;
    }

    return status;
}


IFX_STATIC IfxPkc_Status IfxPkc_Primitive_performOperation(IfxPkc_Primitive *pkc)
{
    IfxPkc_Status status       = IfxPkc_Status_success;
    uint32        timeoutCount = IFXPKC_TIMEOUT_COUNT;
    boolean       algoErrorStatus;

    /* 1. Start the operation */
    IfxPkc_startOperation(pkc->pkcSFR);
    pkc->state = IfxPkc_State_opBusy;

    /* 2. Wait for the module to complete the operation */
    while ((IfxPkc_isModuleBusy(pkc->pkcSFR)) && (timeoutCount > 0))
    {
        timeoutCount--;
    }

    /* 3. Update error bits in handle
     * Check the error bits for the operation just performed */
    pkc->errors     = IfxPkc_getErrors(pkc->pkcSFR);
    algoErrorStatus = IfxPkc_getAlgoErrorStatus(pkc->pkcSFR, pkc->operationType);

    /* 4. Check for error / timeout */
    if ((algoErrorStatus == TRUE) || (timeoutCount <= 0))
    {
        status     = IfxPkc_Status_failure;
        /* Update to error state */
        pkc->state = IfxPkc_State_error;
    }
    else
    {
        /* 5. Restore to operation initialized state */
        pkc->state = IfxPkc_State_operationInitialized;
    }

    return status;
}


IFX_STATIC void IfxPkc_Primitive_initRMOperation(IfxPkc_Primitive *pkc)
{
    /* Configure CMD register */
    Ifx_PKC_CMD cfg;
    cfg.U              = pkc->pkcSFR->CMD.U;

    cfg.B.TYPE         = (uint32)pkc->operationType;
    cfg.B.FIELD        = (uint32)IfxPkc_Field_GFP;
    cfg.B.SELCURVE     = (uint32)IfxPkc_Acceleration_none;

    pkc->pkcSFR->CMD.U = cfg.U;
}


IFX_STATIC IfxPkc_Status IfxPkc_Primitive_initEccOperation(IfxPkc_Primitive *pkc, IfxPkc_Primitive_EccAlgorithm *ecc)
{
    IfxPkc_Status        status        = IfxPkc_Status_success;
    IfxPkc_Parameter     parameter;
    IfxPkc_OperationType operationType = pkc->operationType;

    /* 1. Perform necessary checks */
    /* ECC point decompression does not support GF(2M) field or Edwards */
    if ((operationType == IfxPkc_OperationType_YRECOVER) && ((ecc->field == IfxPkc_Field_GF2M) || (ecc->enableEdwards == TRUE)))
    {
        status = IfxPkc_Status_failure;
    }
    /* Edwards only applicable for GF(p) */
    else if ((ecc->field == IfxPkc_Field_GF2M) && (ecc->enableEdwards == TRUE))
    {
        status = IfxPkc_Status_failure;
    }
    else
    {
        /* 2. Configure CMD register */
        Ifx_PKC_CMD cfg;
        cfg.U              = pkc->pkcSFR->CMD.U;

        cfg.B.TYPE         = (uint32)operationType;
        cfg.B.FIELD        = (uint32)(ecc->field);
        cfg.B.SELCURVE     = (uint32)(ecc->curveAcceleration);
        cfg.B.EDWARDS      = (uint32)(ecc->enableEdwards);

        pkc->pkcSFR->CMD.U = cfg.U;

        /* 3. Write operand location to pointer register */
        IfxPkc_setOperandPointers(pkc->pkcSFR, operationType);

        /* 4. Write static parameters to DATARAM */
        parameter = ecc->eccParameters.p;
        status   |= IfxPkc_Primitive_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EccParamLocation_p);

        switch (operationType)
        {
        case IfxPkc_OperationType_SMULT:
        case IfxPkc_OperationType_JPAKE3PADD:
        {
            parameter = ecc->eccParameters.n;
            status   |= IfxPkc_Primitive_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EccParamLocation_n);
        }
        /* No break at the end of this case */
        case IfxPkc_OperationType_YRECOVER:
        case IfxPkc_OperationType_PDBL:
        case IfxPkc_OperationType_PADD:
        case IfxPkc_OperationType_CHECKPOC:
        {
            parameter = ecc->eccParameters.a;
            status   |= IfxPkc_Primitive_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EccParamLocation_a);

            /* Edwards only needs parameter d (here a) */
            if (ecc->enableEdwards == FALSE)
            {
                parameter = ecc->eccParameters.b;
                status   |= IfxPkc_Primitive_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EccParamLocation_b);
            }

            break;
        }
        default:
            break;
        }
    }

    return status;
}


IFX_STATIC IfxPkc_Status IfxPkc_Primitive_initArithmeticOperation(IfxPkc_Primitive *pkc, IfxPkc_Primitive_ArithmeticAlgorithm *arithmetic)
{
    IfxPkc_Parameter     parameter;
    IfxPkc_Status        status        = IfxPkc_Status_success;
    IfxPkc_OperationType operationType = pkc->operationType;

    /* 1. Check if operation is compatible with field type */
    if ((arithmetic->field == IfxPkc_Field_GF2M) &&
        ((operationType == IfxPkc_OperationType_SQRTN) || (operationType == IfxPkc_OperationType_INV2) ||
         (operationType == IfxPkc_OperationType_RED2) || (operationType == IfxPkc_OperationType_EXP)))
    {
        status = IfxPkc_Status_failure;
    }
    else
    {
        /* 2. Configure CMD register */
        Ifx_PKC_CMD cfg;
        cfg.U              = pkc->pkcSFR->CMD.U;

        cfg.B.TYPE         = (uint32)operationType;
        cfg.B.FIELD        = (uint32)(arithmetic->field);
        cfg.B.SELCURVE     = (uint32)0;

        pkc->pkcSFR->CMD.U = cfg.U;

        /* 3. Write operand location to pointer register */
        IfxPkc_setOperandPointers(pkc->pkcSFR, operationType);

        /* 4. Write static parameters to DATARAM */
        if (operationType != IfxPkc_OperationType_MULT)
        {
            parameter = arithmetic->modulus;
            status    = IfxPkc_Primitive_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_ArithmeticParamLocation_n);
        }

        /* 5. (Re)Calculate R^2 mod N when new modulus is programmed for following operations as clarified by CE
         * - 0x03: Modular multiplication
         * - 0x04: Modular reduction
         * - 0x10: Modular exponentiation
         */
        if ((status == IfxPkc_Status_success) &&
            ((operationType == IfxPkc_OperationType_MULTN) || (operationType == IfxPkc_OperationType_RED) ||
             (operationType == IfxPkc_OperationType_EXP)))
        {
            IfxPkc_calculateRsqr(pkc->pkcSFR);
        }
    }

    return status;
}


IFX_STATIC IfxPkc_Status IfxPkc_Primitive_initMcOperation(IfxPkc_Primitive *pkc, IfxPkc_Primitive_McAlgorithm *montgomery)
{
    IfxPkc_Parameter parameter;
    IfxPkc_Status    status = IfxPkc_Status_success;

    /* 1. Configure CMD register */
    Ifx_PKC_CMD      cfg;
    cfg.U              = pkc->pkcSFR->CMD.U;

    cfg.B.TYPE         = (uint32)(pkc->operationType);
    cfg.B.FIELD        = (uint32)IfxPkc_Field_GFP;
    cfg.B.SELCURVE     = (uint32)(montgomery->curveAcceleration);

    pkc->pkcSFR->CMD.U = cfg.U;

    /* 2. Write operand location to pointer register */
    IfxPkc_setOperandPointers(pkc->pkcSFR, pkc->operationType);

    /* 3. Write static parameters to DATARAM */
    parameter = montgomery->mcParameters.p;
    status   |= IfxPkc_Primitive_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_McParamLocation_p);

    parameter = montgomery->mcParameters.a;
    status   |= IfxPkc_Primitive_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_McParamLocation_a);

    return status;
}


IFX_STATIC IfxPkc_Status IfxPkc_Primitive_initEdDsaOperation(IfxPkc_Primitive *pkc, IfxPkc_Primitive_EdDsaAlgorithm *edDsa)
{
    IfxPkc_Status        status        = IfxPkc_Status_success;
    IfxPkc_Parameter     parameter;
    IfxPkc_OperationType operationType = pkc->operationType;

    /* Configure CMD register */
    Ifx_PKC_CMD          cfg;
    cfg.U              = pkc->pkcSFR->CMD.U;

    cfg.B.TYPE         = (uint32)operationType;
    cfg.B.FIELD        = (uint32)IfxPkc_Field_GFP;
    cfg.B.SELCURVE     = (uint32)(edDsa->curveAcceleration);
    cfg.B.EDWARDS      = (uint32)(edDsa->enableEdwards);

    pkc->pkcSFR->CMD.U = cfg.U;

    /* Write static parameters to DATARAM */
    parameter = edDsa->edDsaParameters.p;
    status   |= IfxPkc_Primitive_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EdDsaParamLocation_p);

    parameter = edDsa->edDsaParameters.L;
    status   |= IfxPkc_Primitive_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EdDsaParamLocation_L);

    parameter = edDsa->edDsaParameters.d;
    status   |= IfxPkc_Primitive_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EdDsaParamLocation_d);

    return status;
}


IfxPkc_PrimalityStatus IfxPkc_Primitive_checkRMPrimality(IfxPkc_Primitive *pkc, IfxPkc_Parameter *testIntegerPtr, IfxPkc_Parameter *randomIntegerPtr)
{
    IfxPkc_Status          status          = IfxPkc_Status_success;
    /* Set primality status to unknown */
    IfxPkc_PrimalityStatus primalityStatus = IfxPkc_PrimalityStatus_unknown;
    /* current error status in STAT regiser */
    boolean                algoErrorStatus = IfxPkc_getAlgoErrorStatus(pkc->pkcSFR, pkc->operationType);

    if ((pkc->state == IfxPkc_State_operationInitialized) || ((pkc->state == IfxPkc_State_error) && (algoErrorStatus == TRUE)))
    {
        if (pkc->operationType == IfxPkc_OperationType_RABINMILLER)
        {
            /* Write dynamic paramters to DATARAM */
            status |= IfxPkc_Primitive_writeToDataram(pkc, testIntegerPtr->dataPtr, testIntegerPtr->sizeInWords, (IfxPkc_MemLocation)IfxPkc_RMParamLocation_testInteger);

            status |= IfxPkc_Primitive_writeToDataram(pkc, randomIntegerPtr->dataPtr, randomIntegerPtr->sizeInWords, (IfxPkc_MemLocation)IfxPkc_RMParamLocation_randomInteger);

            /* Perform the operation */
            if (status == IfxPkc_Status_success)
            {
                status = IfxPkc_Primitive_performOperation(pkc);
            }

            /* Check composite flag status */
            if (status == IfxPkc_Status_success)
            {
                if (IfxPkc_isCompositeFlagEnabled(pkc->pkcSFR) == TRUE)
                {
                    primalityStatus = IfxPkc_PrimalityStatus_composite;
                }
                else
                {
                    primalityStatus = IfxPkc_PrimalityStatus_probablyPrime;
                }
            }
        }
    }

    return primalityStatus;
}


IfxPkc_Status IfxPkc_Primitive_addEccPoints(IfxPkc_Primitive *pkc, IfxPkc_CurveParameter *point1, IfxPkc_CurveParameter *point2, IfxPkc_CurveParameter *resultantPoint)
{
    IfxPkc_Status    status          = IfxPkc_Status_failure;
    /* current error status in STAT regiser */
    boolean          algoErrorStatus = IfxPkc_getAlgoErrorStatus(pkc->pkcSFR, pkc->operationType);
    IfxPkc_Parameter parameter;

    if ((pkc->state == IfxPkc_State_operationInitialized) || ((pkc->state == IfxPkc_State_error) && (algoErrorStatus == TRUE)))
    {
        if (pkc->operationType == IfxPkc_OperationType_PADD)
        {
            /* Write dynamic parameters */
            parameter = point1->x;
            status    = IfxPkc_Primitive_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EccParamLocation_point1x);

            parameter = point1->y;
            status   |= IfxPkc_Primitive_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EccParamLocation_point1y);

            parameter = point2->x;
            status   |= IfxPkc_Primitive_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EccParamLocation_point2x);

            parameter = point2->y;
            status   |= IfxPkc_Primitive_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EccParamLocation_point2y);

            /* Perform operation */
            if (status == IfxPkc_Status_success)
            {
                status = IfxPkc_Primitive_performOperation(pkc);
            }

            /* Read result */
            if (status == IfxPkc_Status_success)
            {
                parameter = resultantPoint->x;
                status   |= IfxPkc_Primitive_readFromDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EccParamLocation_point3x);

                parameter = resultantPoint->y;
                status   |= IfxPkc_Primitive_readFromDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EccParamLocation_point3y);
            }
        }
    }

    return status;
}


IfxPkc_Status IfxPkc_Primitive_add3EccPoints(IfxPkc_Primitive *pkc, IfxPkc_CurveParameter *point1, IfxPkc_CurveParameter *point2, IfxPkc_CurveParameter *point3, IfxPkc_CurveParameter *resultantPoint)
{
    IfxPkc_Status    status          = IfxPkc_Status_failure;
    /* current error status in STAT regiser */
    boolean          algoErrorStatus = IfxPkc_getAlgoErrorStatus(pkc->pkcSFR, pkc->operationType);
    IfxPkc_Parameter parameter;

    if ((pkc->state == IfxPkc_State_operationInitialized) || ((pkc->state == IfxPkc_State_error) && (algoErrorStatus == TRUE)))
    {
        if (pkc->operationType == IfxPkc_OperationType_JPAKE3PADD)
        {
            /* Write dynamic parameters */
            parameter = point1->x;
            status    = IfxPkc_Primitive_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, IfxPkc_MemLocation_B);

            parameter = point1->y;
            status   |= IfxPkc_Primitive_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, IfxPkc_MemLocation_C);

            parameter = point2->x;
            status   |= IfxPkc_Primitive_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, IfxPkc_MemLocation_6);

            parameter = point2->y;
            status   |= IfxPkc_Primitive_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, IfxPkc_MemLocation_7);

            parameter = point3->x;
            status   |= IfxPkc_Primitive_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, IfxPkc_MemLocation_8);

            parameter = point3->y;
            status   |= IfxPkc_Primitive_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, IfxPkc_MemLocation_9);

            /* Perform operation */
            if (status == IfxPkc_Status_success)
            {
                status = IfxPkc_Primitive_performOperation(pkc);
            }

            /* Read result */
            if (status == IfxPkc_Status_success)
            {
                parameter = resultantPoint->x;
                status   |= IfxPkc_Primitive_readFromDataram(pkc, parameter.dataPtr, parameter.sizeInWords, IfxPkc_MemLocation_D);

                parameter = resultantPoint->y;
                status   |= IfxPkc_Primitive_readFromDataram(pkc, parameter.dataPtr, parameter.sizeInWords, IfxPkc_MemLocation_E);
            }
        }
    }

    return status;
}


IfxPkc_Status IfxPkc_Primitive_doubleEccPoint(IfxPkc_Primitive *pkc, IfxPkc_CurveParameter *point, IfxPkc_CurveParameter *resultantPoint)
{
    IfxPkc_Status    status          = IfxPkc_Status_failure;
    /* current error status in STAT regiser */
    boolean          algoErrorStatus = IfxPkc_getAlgoErrorStatus(pkc->pkcSFR, pkc->operationType);
    IfxPkc_Parameter parameter;

    if ((pkc->state == IfxPkc_State_operationInitialized) || ((pkc->state == IfxPkc_State_error) && (algoErrorStatus == TRUE)))
    {
        if (pkc->operationType == IfxPkc_OperationType_PDBL)
        {
            /* Write dynamic parameters */
            parameter = point->x;
            status    = IfxPkc_Primitive_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EccParamLocation_point1x);

            parameter = point->y;
            status   |= IfxPkc_Primitive_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EccParamLocation_point1y);

            /* Perform operation */
            if (status == IfxPkc_Status_success)
            {
                status = IfxPkc_Primitive_performOperation(pkc);
            }

            /* Read result */
            if (status == IfxPkc_Status_success)
            {
                parameter = resultantPoint->x;
                status   |= IfxPkc_Primitive_readFromDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EccParamLocation_point3x);

                parameter = resultantPoint->y;
                status   |= IfxPkc_Primitive_readFromDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EccParamLocation_point3y);
            }
        }
    }

    return status;
}


IfxPkc_Status IfxPkc_Primitive_multiplyEccPoint(IfxPkc_Primitive *pkc, IfxPkc_CurveParameter *point, IfxPkc_Parameter *scalar, IfxPkc_CurveParameter *resultantPoint)
{
    IfxPkc_Status    status          = IfxPkc_Status_failure;
    /* current error status in STAT regiser */
    boolean          algoErrorStatus = IfxPkc_getAlgoErrorStatus(pkc->pkcSFR, pkc->operationType);
    IfxPkc_Parameter parameter;

    if ((pkc->state == IfxPkc_State_operationInitialized) || ((pkc->state == IfxPkc_State_error) && (algoErrorStatus == TRUE)))
    {
        if (pkc->operationType == IfxPkc_OperationType_SMULT)
        {
            /* Write dynamic parameters */
            parameter = point->x;
            status    = IfxPkc_Primitive_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EccParamLocation_point1x);

            parameter = point->y;
            status   |= IfxPkc_Primitive_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EccParamLocation_point1y);

            /* Write scalar to Operand B / point 2 x coordinate location */
            parameter = *scalar;
            status   |= IfxPkc_Primitive_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EccParamLocation_point2x);

            /* Perform operation */
            if (status == IfxPkc_Status_success)
            {
                status = IfxPkc_Primitive_performOperation(pkc);
            }

            /* Read result */
            if (status == IfxPkc_Status_success)
            {
                parameter = resultantPoint->x;
                status   |= IfxPkc_Primitive_readFromDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EccParamLocation_point3x);

                parameter = resultantPoint->y;
                status   |= IfxPkc_Primitive_readFromDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EccParamLocation_point3y);
            }
        }
    }

    return status;
}


IfxPkc_Status IfxPkc_Primitive_checkEccParamAB(IfxPkc_Primitive *pkc, IfxPkc_Parameter *a, IfxPkc_Parameter *b)
{
    IfxPkc_Status                  status          = IfxPkc_Status_failure;
    /* current error status in STAT regiser */
    boolean                        algoErrorStatus = IfxPkc_getAlgoErrorStatus(pkc->pkcSFR, pkc->operationType);
    IfxPkc_Parameter               parameter;
    IfxPkc_Primitive_EccAlgorithm *ecc             = (IfxPkc_Primitive_EccAlgorithm *)(pkc->algoMechanism);

    if ((pkc->state == IfxPkc_State_operationInitialized) || ((pkc->state == IfxPkc_State_error) && (algoErrorStatus == TRUE)))
    {
        /* Not applicable for edwards curve */
        if ((pkc->operationType == IfxPkc_OperationType_CHECKAB) && (ecc->enableEdwards == FALSE))
        {
            /* Write dynamic parameters */
            parameter = *a;
            status    = IfxPkc_Primitive_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EccParamLocation_a);

            parameter = *b;
            status   |= IfxPkc_Primitive_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EccParamLocation_b);

            /* Perform operation */
            if (status == IfxPkc_Status_success)
            {
                status = IfxPkc_Primitive_performOperation(pkc);
            }
        }
    }

    return status;
}


IfxPkc_Status IfxPkc_Primitive_checkEccParamN(IfxPkc_Primitive *pkc, IfxPkc_Parameter *n)
{
    IfxPkc_Status    status          = IfxPkc_Status_failure;
    /* current error status in STAT regiser */
    boolean          algoErrorStatus = IfxPkc_getAlgoErrorStatus(pkc->pkcSFR, pkc->operationType);
    IfxPkc_Parameter parameter;

    if ((pkc->state == IfxPkc_State_operationInitialized) || ((pkc->state == IfxPkc_State_error) && (algoErrorStatus == TRUE)))
    {
        if (pkc->operationType == IfxPkc_OperationType_CHECKN)
        {
            /* Write dynamic parameters */
            parameter = *n;
            status    = IfxPkc_Primitive_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EccParamLocation_n);

            /* Perform operation */
            if (status == IfxPkc_Status_success)
            {
                status = IfxPkc_Primitive_performOperation(pkc);
            }
        }
    }

    return status;
}


IfxPkc_Status IfxPkc_Primitive_checkEccCoordinates(IfxPkc_Primitive *pkc, IfxPkc_CurveParameter *point)
{
    IfxPkc_Status    status          = IfxPkc_Status_failure;
    /* current error status in STAT regiser */
    boolean          algoErrorStatus = IfxPkc_getAlgoErrorStatus(pkc->pkcSFR, pkc->operationType);
    IfxPkc_Parameter parameter;

    if ((pkc->state == IfxPkc_State_operationInitialized) || ((pkc->state == IfxPkc_State_error) && (algoErrorStatus == TRUE)))
    {
        if (pkc->operationType == IfxPkc_OperationType_CHECKPXY)
        {
            /* Write dynamic parameters */
            parameter = point->x;
            status    = IfxPkc_Primitive_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EccParamLocation_point1x);

            parameter = point->y;
            status   |= IfxPkc_Primitive_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EccParamLocation_point1y);

            /* Perform operation */
            if (status == IfxPkc_Status_success)
            {
                status = IfxPkc_Primitive_performOperation(pkc);
            }
        }
    }

    return status;
}


IfxPkc_Status IfxPkc_Primitive_checkEccPointOnCurve(IfxPkc_Primitive *pkc, IfxPkc_CurveParameter *point)
{
    IfxPkc_Status    status          = IfxPkc_Status_failure;
    /* current error status in STAT regiser */
    boolean          algoErrorStatus = IfxPkc_getAlgoErrorStatus(pkc->pkcSFR, pkc->operationType);
    IfxPkc_Parameter parameter;

    if ((pkc->state == IfxPkc_State_operationInitialized) || ((pkc->state == IfxPkc_State_error) && (algoErrorStatus == TRUE)))
    {
        if (pkc->operationType == IfxPkc_OperationType_CHECKPOC)
        {
            /* Write dynamic parameters */
            parameter = point->x;
            status    = IfxPkc_Primitive_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EccParamLocation_point1x);

            parameter = point->y;
            status   |= IfxPkc_Primitive_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EccParamLocation_point1y);

            /* Perform operation */
            if (status == IfxPkc_Status_success)
            {
                status = IfxPkc_Primitive_performOperation(pkc);
            }
        }
    }

    return status;
}


IfxPkc_Status IfxPkc_Primitive_recoverYCoordinate(IfxPkc_Primitive *pkc, IfxPkc_Parameter *x, IfxPkc_BitValue *lsbY, IfxPkc_Parameter *y)
{
    IfxPkc_Status status          = IfxPkc_Status_failure;
    /* current error status in STAT regiser */
    boolean       algoErrorStatus = IfxPkc_getAlgoErrorStatus(pkc->pkcSFR, pkc->operationType);

    if ((pkc->state == IfxPkc_State_operationInitialized) || ((pkc->state == IfxPkc_State_error) && (algoErrorStatus == TRUE)))
    {
        if (pkc->operationType == IfxPkc_OperationType_YRECOVER)
        {
            /* Write dynamic parameters */
            status = IfxPkc_Primitive_writeToDataram(pkc, x->dataPtr, x->sizeInWords, (IfxPkc_MemLocation)IfxPkc_EccParamLocation_point1x);

            /* Write LSB of y */
            IfxPkc_setFlagA(pkc->pkcSFR, *lsbY);

            /* Perform operation */
            if (status == IfxPkc_Status_success)
            {
                status = IfxPkc_Primitive_performOperation(pkc);
            }

            /* Read y coordinate */
            if (status == IfxPkc_Status_success)
            {
                status |= IfxPkc_Primitive_readFromDataram(pkc, y->dataPtr, y->sizeInWords, (IfxPkc_MemLocation)IfxPkc_EccParamLocation_point3x);
            }
        }
    }

    return status;
}


IfxPkc_Status IfxPkc_Primitive_addMod(IfxPkc_Primitive *pkc, IfxPkc_Parameter *a, IfxPkc_Parameter *b, IfxPkc_Parameter *result)
{
    IfxPkc_Status status          = IfxPkc_Status_failure;
    /* current error status in STAT regiser */
    boolean       algoErrorStatus = IfxPkc_getAlgoErrorStatus(pkc->pkcSFR, pkc->operationType);

    if ((pkc->state == IfxPkc_State_operationInitialized) || ((pkc->state == IfxPkc_State_error) && (algoErrorStatus == TRUE)))
    {
        if (pkc->operationType == IfxPkc_OperationType_ADDN)
        {
            /* Write dynamic parameters */
            status  = IfxPkc_Primitive_writeToDataram(pkc, a->dataPtr, a->sizeInWords, (IfxPkc_MemLocation)IfxPkc_ArithmeticParamLocation_a);

            status |= IfxPkc_Primitive_writeToDataram(pkc, b->dataPtr, b->sizeInWords, (IfxPkc_MemLocation)IfxPkc_ArithmeticParamLocation_b);

            /* Perform operation */
            if (status == IfxPkc_Status_success)
            {
                status = IfxPkc_Primitive_performOperation(pkc);
            }

            /* Read result */
            if (status == IfxPkc_Status_success)
            {
                status = IfxPkc_Primitive_readFromDataram(pkc, result->dataPtr, result->sizeInWords, (IfxPkc_MemLocation)IfxPkc_ArithmeticParamLocation_c);
            }
        }
    }

    return status;
}


IfxPkc_Status IfxPkc_Primitive_subtractMod(IfxPkc_Primitive *pkc, IfxPkc_Parameter *a, IfxPkc_Parameter *b, IfxPkc_Parameter *result)
{
    IfxPkc_Status status          = IfxPkc_Status_failure;
    /* current error status in STAT regiser */
    boolean       algoErrorStatus = IfxPkc_getAlgoErrorStatus(pkc->pkcSFR, pkc->operationType);

    if ((pkc->state == IfxPkc_State_operationInitialized) || ((pkc->state == IfxPkc_State_error) && (algoErrorStatus == TRUE)))
    {
        if (pkc->operationType == IfxPkc_OperationType_SUBN)
        {
            /* Write dynamic parameters */
            status  = IfxPkc_Primitive_writeToDataram(pkc, a->dataPtr, a->sizeInWords, (IfxPkc_MemLocation)IfxPkc_ArithmeticParamLocation_a);

            status |= IfxPkc_Primitive_writeToDataram(pkc, b->dataPtr, b->sizeInWords, (IfxPkc_MemLocation)IfxPkc_ArithmeticParamLocation_b);

            /* Perform operation */
            if (status == IfxPkc_Status_success)
            {
                status = IfxPkc_Primitive_performOperation(pkc);
            }

            /* Read result */
            if (status == IfxPkc_Status_success)
            {
                status = IfxPkc_Primitive_readFromDataram(pkc, result->dataPtr, result->sizeInWords, (IfxPkc_MemLocation)IfxPkc_ArithmeticParamLocation_c);
            }
        }
    }

    return status;
}


IfxPkc_Status IfxPkc_Primitive_multiplyMod(IfxPkc_Primitive *pkc, IfxPkc_Parameter *a, IfxPkc_Parameter *b, IfxPkc_Parameter *result)
{
    IfxPkc_Status status          = IfxPkc_Status_failure;
    /* current error status in STAT regiser */
    boolean       algoErrorStatus = IfxPkc_getAlgoErrorStatus(pkc->pkcSFR, pkc->operationType);

    if ((pkc->state == IfxPkc_State_operationInitialized) || ((pkc->state == IfxPkc_State_error) && (algoErrorStatus == TRUE)))
    {
        if (pkc->operationType == IfxPkc_OperationType_MULTN)
        {
            /* Write dynamic parameters */
            status  = IfxPkc_Primitive_writeToDataram(pkc, a->dataPtr, a->sizeInWords, (IfxPkc_MemLocation)IfxPkc_ArithmeticParamLocation_a);

            status |= IfxPkc_Primitive_writeToDataram(pkc, b->dataPtr, b->sizeInWords, (IfxPkc_MemLocation)IfxPkc_ArithmeticParamLocation_b);

            /* Perform operation */
            if (status == IfxPkc_Status_success)
            {
                status = IfxPkc_Primitive_performOperation(pkc);
            }

            /* Read result */
            if (status == IfxPkc_Status_success)
            {
                status = IfxPkc_Primitive_readFromDataram(pkc, result->dataPtr, result->sizeInWords, (IfxPkc_MemLocation)IfxPkc_ArithmeticParamLocation_c);
            }
        }
    }

    return status;
}


IfxPkc_Status IfxPkc_Primitive_reduceMod(IfxPkc_Primitive *pkc, IfxPkc_Parameter *a, IfxPkc_Parameter *result)
{
    IfxPkc_Status        status          = IfxPkc_Status_failure;
    IfxPkc_OperationType operationType   = pkc->operationType;
    /* current error status in STAT regiser */
    boolean              algoErrorStatus = IfxPkc_getAlgoErrorStatus(pkc->pkcSFR, operationType);

    if ((pkc->state == IfxPkc_State_operationInitialized) || ((pkc->state == IfxPkc_State_error) && (algoErrorStatus == TRUE)))
    {
        if ((operationType == IfxPkc_OperationType_RED) || (operationType == IfxPkc_OperationType_RED2))
        {
            /* Write dynamic parameters */
            /* Write to location b according to UM */
            status = IfxPkc_Primitive_writeToDataram(pkc, a->dataPtr, a->sizeInWords, (IfxPkc_MemLocation)IfxPkc_ArithmeticParamLocation_b);

            /* Perform operation */
            if (status == IfxPkc_Status_success)
            {
                status = IfxPkc_Primitive_performOperation(pkc);
            }

            /* Read result */
            if (status == IfxPkc_Status_success)
            {
                status = IfxPkc_Primitive_readFromDataram(pkc, result->dataPtr, result->sizeInWords, (IfxPkc_MemLocation)IfxPkc_ArithmeticParamLocation_c);
            }
        }
    }

    return status;
}


IfxPkc_Status IfxPkc_Primitive_divideMod(IfxPkc_Primitive *pkc, IfxPkc_Parameter *a, IfxPkc_Parameter *b, IfxPkc_Parameter *result)
{
    IfxPkc_Status status          = IfxPkc_Status_failure;
    /* current error status in STAT regiser */
    boolean       algoErrorStatus = IfxPkc_getAlgoErrorStatus(pkc->pkcSFR, pkc->operationType);

    if ((pkc->state == IfxPkc_State_operationInitialized) || ((pkc->state == IfxPkc_State_error) && (algoErrorStatus == TRUE)))
    {
        if (pkc->operationType == IfxPkc_OperationType_DIVN)
        {
            /* Write dynamic parameters */
            status  = IfxPkc_Primitive_writeToDataram(pkc, a->dataPtr, a->sizeInWords, (IfxPkc_MemLocation)IfxPkc_ArithmeticParamLocation_a);

            status |= IfxPkc_Primitive_writeToDataram(pkc, b->dataPtr, b->sizeInWords, (IfxPkc_MemLocation)IfxPkc_ArithmeticParamLocation_b);

            /* Perform operation */
            if (status == IfxPkc_Status_success)
            {
                status = IfxPkc_Primitive_performOperation(pkc);
            }

            /* Read result */
            if (status == IfxPkc_Status_success)
            {
                status = IfxPkc_Primitive_readFromDataram(pkc, result->dataPtr, result->sizeInWords, (IfxPkc_MemLocation)IfxPkc_ArithmeticParamLocation_c);
            }
        }
    }

    return status;
}


IfxPkc_Status IfxPkc_Primitive_invertMod(IfxPkc_Primitive *pkc, IfxPkc_Parameter *a, IfxPkc_Parameter *result)
{
    IfxPkc_Status        status          = IfxPkc_Status_failure;
    IfxPkc_OperationType operationType   = pkc->operationType;
    /* current error status in STAT regiser */
    boolean              algoErrorStatus = IfxPkc_getAlgoErrorStatus(pkc->pkcSFR, operationType);

    if ((pkc->state == IfxPkc_State_operationInitialized) || ((pkc->state == IfxPkc_State_error) && (algoErrorStatus == TRUE)))
    {
        if ((operationType == IfxPkc_OperationType_INV) || (operationType == IfxPkc_OperationType_INV2))
        {
            /* Write dynamic parameters */
            /* Write to location b according to UM */
            status = IfxPkc_Primitive_writeToDataram(pkc, a->dataPtr, a->sizeInWords, (IfxPkc_MemLocation)IfxPkc_ArithmeticParamLocation_b);

            /* Perform operation */
            if (status == IfxPkc_Status_success)
            {
                status = IfxPkc_Primitive_performOperation(pkc);
            }

            /* Read result */
            if (status == IfxPkc_Status_success)
            {
                status = IfxPkc_Primitive_readFromDataram(pkc, result->dataPtr, result->sizeInWords, (IfxPkc_MemLocation)IfxPkc_ArithmeticParamLocation_c);
            }
        }
    }

    return status;
}


IfxPkc_Status IfxPkc_Primitive_squareRootMod(IfxPkc_Primitive *pkc, IfxPkc_Parameter *a, IfxPkc_Parameter *result)
{
    IfxPkc_Status status          = IfxPkc_Status_failure;
    /* current error status in STAT regiser */
    boolean       algoErrorStatus = IfxPkc_getAlgoErrorStatus(pkc->pkcSFR, pkc->operationType);

    if ((pkc->state == IfxPkc_State_operationInitialized) || ((pkc->state == IfxPkc_State_error) && (algoErrorStatus == TRUE)))
    {
        if (pkc->operationType == IfxPkc_OperationType_SQRTN)
        {
            /* Write dynamic parameters */
            status = IfxPkc_Primitive_writeToDataram(pkc, a->dataPtr, a->sizeInWords, (IfxPkc_MemLocation)IfxPkc_ArithmeticParamLocation_a);

            /* Perform operation */
            if (status == IfxPkc_Status_success)
            {
                status = IfxPkc_Primitive_performOperation(pkc);
            }

            /* Read result */
            if (status == IfxPkc_Status_success)
            {
                status = IfxPkc_Primitive_readFromDataram(pkc, result->dataPtr, result->sizeInWords, (IfxPkc_MemLocation)IfxPkc_ArithmeticParamLocation_c);
            }
        }
    }

    return status;
}


IfxPkc_Status IfxPkc_Primitive_multiply(IfxPkc_Primitive *pkc, IfxPkc_Parameter *a, IfxPkc_Parameter *b, IfxPkc_Parameter *result)
{
    IfxPkc_Status status          = IfxPkc_Status_failure;
    /* current error status in STAT regiser */
    boolean       algoErrorStatus = IfxPkc_getAlgoErrorStatus(pkc->pkcSFR, pkc->operationType);

    if ((pkc->state == IfxPkc_State_operationInitialized) || ((pkc->state == IfxPkc_State_error) && (algoErrorStatus == TRUE)))
    {
        if (pkc->operationType == IfxPkc_OperationType_MULT)
        {
            /* Write dynamic parameters */
            status  = IfxPkc_Primitive_writeToDataram(pkc, a->dataPtr, a->sizeInWords, (IfxPkc_MemLocation)IfxPkc_ArithmeticParamLocation_a);

            status |= IfxPkc_Primitive_writeToDataram(pkc, b->dataPtr, b->sizeInWords, (IfxPkc_MemLocation)IfxPkc_ArithmeticParamLocation_b);

            /* Perform operation */
            if (status == IfxPkc_Status_success)
            {
                status = IfxPkc_Primitive_performOperation(pkc);
            }

            /* Read result */
            if (status == IfxPkc_Status_success)
            {
                status = IfxPkc_Primitive_readFromDataram(pkc, result->dataPtr, result->sizeInWords, (IfxPkc_MemLocation)IfxPkc_ArithmeticParamLocation_c);
            }
        }
    }

    return status;
}


IfxPkc_Status IfxPkc_Primitive_exponentiateMod(IfxPkc_Primitive *pkc, IfxPkc_Parameter *a, IfxPkc_Parameter *b, IfxPkc_Parameter *result)
{
    IfxPkc_Status status          = IfxPkc_Status_failure;
    /* current error status in STAT regiser */
    boolean       algoErrorStatus = IfxPkc_getAlgoErrorStatus(pkc->pkcSFR, pkc->operationType);

    if ((pkc->state == IfxPkc_State_operationInitialized) || ((pkc->state == IfxPkc_State_error) && (algoErrorStatus == TRUE)))
    {
        if (pkc->operationType == IfxPkc_OperationType_EXP)
        {
            /* Write dynamic parameters */
            status  = IfxPkc_Primitive_writeToDataram(pkc, a->dataPtr, a->sizeInWords, (IfxPkc_MemLocation)IfxPkc_ArithmeticParamLocation_a);

            status |= IfxPkc_Primitive_writeToDataram(pkc, b->dataPtr, b->sizeInWords, (IfxPkc_MemLocation)IfxPkc_ArithmeticParamLocation_b);

            /* Perform operation */
            if (status == IfxPkc_Status_success)
            {
                status = IfxPkc_Primitive_performOperation(pkc);
            }

            /* Read result */
            if (status == IfxPkc_Status_success)
            {
                status = IfxPkc_Primitive_readFromDataram(pkc, result->dataPtr, result->sizeInWords, (IfxPkc_MemLocation)IfxPkc_ArithmeticParamLocation_c);
            }
        }
    }

    return status;
}


IfxPkc_Status IfxPkc_Primitive_multiplyMcPoint(IfxPkc_Primitive *pkc, IfxPkc_Parameter *pointX, IfxPkc_Parameter *scalar, IfxPkc_Parameter *resultantPointX)
{
    IfxPkc_Status status          = IfxPkc_Status_failure;
    /* current error status in STAT regiser */
    boolean       algoErrorStatus = IfxPkc_getAlgoErrorStatus(pkc->pkcSFR, pkc->operationType);

    if ((pkc->state == IfxPkc_State_operationInitialized) || ((pkc->state == IfxPkc_State_error) && (algoErrorStatus == TRUE)))
    {
        if (pkc->operationType == IfxPkc_OperationType_SMULT25519)
        {
            /* Write dynamic parameters */
            status  = IfxPkc_Primitive_writeToDataram(pkc, pointX->dataPtr, pointX->sizeInWords, (IfxPkc_MemLocation)IfxPkc_McParamLocation_point1x);

            status |= IfxPkc_Primitive_writeToDataram(pkc, scalar->dataPtr, scalar->sizeInWords, (IfxPkc_MemLocation)IfxPkc_McParamLocation_scalar);

            /* Perform operation */
            if (status == IfxPkc_Status_success)
            {
                status = IfxPkc_Primitive_performOperation(pkc);
            }

            /* Read result */
            if (status == IfxPkc_Status_success)
            {
                status |= IfxPkc_Primitive_readFromDataram(pkc, resultantPointX->dataPtr, resultantPointX->sizeInWords, (IfxPkc_MemLocation)IfxPkc_McParamLocation_point3x);
            }
        }
    }

    return status;
}


IfxPkc_Status IfxPkc_Primitive_multiplyEdDsaPoint(IfxPkc_Primitive *pkc, IfxPkc_CurveParameter *pointB, IfxPkc_Parameter *rLsb, IfxPkc_Parameter *rMsb, IfxPkc_CurveParameter *resultantPointR)
{
    IfxPkc_Status    status          = IfxPkc_Status_failure;
    /* current error status in STAT regiser */
    boolean          algoErrorStatus = IfxPkc_getAlgoErrorStatus(pkc->pkcSFR, pkc->operationType);
    IfxPkc_Parameter parameter;

    if ((pkc->state == IfxPkc_State_operationInitialized) || ((pkc->state == IfxPkc_State_error) && (algoErrorStatus == TRUE)))
    {
        if (pkc->operationType == IfxPkc_OperationType_EDDSASMULT)
        {
            /* Write dynamic parameters */
            parameter = pointB->x;
            status    = IfxPkc_Primitive_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EdDsaParamLocation_xB);

            parameter = pointB->y;
            status   |= IfxPkc_Primitive_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EdDsaParamLocation_yB);

            parameter = *rLsb;
            status   |= IfxPkc_Primitive_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EdDsaParamLocation_rLsb);

            if (rMsb != NULL_PTR)
            {
                parameter = *rMsb;
                status   |= IfxPkc_Primitive_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EdDsaParamLocation_rMsb);
            }

            /* Perform operation */
            if (status == IfxPkc_Status_success)
            {
                status = IfxPkc_Primitive_performOperation(pkc);
            }

            /* Read result */
            if (status == IfxPkc_Status_success)
            {
                parameter = resultantPointR->x;
                status   |= IfxPkc_Primitive_readFromDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EdDsaParamLocation_xR);

                parameter = resultantPointR->y;
                status   |= IfxPkc_Primitive_readFromDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EdDsaParamLocation_yR);
            }
        }
    }

    return status;
}
