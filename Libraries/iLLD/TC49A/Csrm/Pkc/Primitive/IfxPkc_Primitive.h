/**
 * \file IfxPkc_Primitive.h
 * \brief PKC PRIMITIVE details
 * \ingroup IfxLld_Pkc
 *
 * \version iLLD_2_0_1_2_19
 * \copyright Copyright (c) 2022 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 * \defgroup IfxLld_Pkc_Primitive_Usage How to use the PKC Primitive Interface layer?
 * \ingroup IfxLld_Pkc_Primitive
 *
 * \section IfxLld_Pkc_Primitive_Overview Overview:
 * This driver module interface layer is used for performing primitive operations operations using the resources provided by the Public Key Cryptography (PKC) module.
 * Current supported algorithms:
 *     1. ECC primitive operations
 *     2. Arithmetic operations
 *     3. Montgomery multiplication
 *     4. Rabin Miller Primality test.
 *
 * \section IfxLld_Pkc_Primitive_Steps Steps to use the Pkc driver
 * Refer to API descriptions for more info
 *
 * \subsection IfxLld_Pkc_Primitive_Step1 STEP 1 Module Initialization:
 *
 *     \code
 *     // 1. Enable the module clock
 *     IfxPkc_enableModule(&MODULE_PKC);
 *
 *     // 2. Instantiate the module config structure
 *     IfxPkc_Primitive_ModuleConfig config;
 *
 *     // 3. Instantiate the module handle
 *     IfxPkc_Primitive pkc;
 *
 *     // 4. Initialise the module config
 *     IfxPkc_Primitive_initModuleConfig(&MODULE_PKC, &config);
 *
 *     // 5. Specify the endianness of data
 *     config.endian = IfxPkc_endian_little;
 *
 *     // 6. Initialise the module
 *     IfxPkc_status status;
 *     status = IfxPkc_Primitive_initModule(&pkc, &config);
 *
 *     \endcode
 *
 * \subsection IfxLld_Pkc_Primitive_Step2 STEP 2 Operation Initialization:
 *
 *     \code
 *     // 1. Instantiate operation structure
 *     IfxPkc_Primtive_Operation operation;
 *
 *     // 2. Instantiate the data structure for algorithm needed
 *     // Here ECC specific data structure has been instantiated
 *     IfxPkc_Primitive_EccAlgorithm ecc;
 *
 *     // 3. Configure the above data structure
 *     // p, a, b arrays hold respective data and numWords specify the data length
 *     ecc.eccParameters.p.dataPtr = (uint32*)&p[0];
 *     ecc.eccParameters.p.sizeInWords = numWords;
 *     ecc.eccParameters.a.dataPtr = (uint32*)&a[0];
 *     ecc.eccParameters.a.sizeInWords = numWords;
 *     ecc.eccParameters.b.dataPtr = (uint32*)&b[0];
 *     ecc.eccParameters.b.sizeInWords = numWords;
 *
 *     // 4. Configure the operation structure
 *     // 4a. Specify the type of operation (Eg. ECC point addition)
 *     operation.operationType = IfxPkc_OperationType_PADD;
 *     // 4b. Specify the max operand size in bytes
 *     operation.dataSize = numWords*4;
 *     // 4c. Point the algoMechanism pointer to algorithm structure
 *     operation.algoMechanism = (IfxPkc_Primitive_EccAlgorithm *)&ecc;
 *
 *     // 5. Initialise operation
 *     status = IfxPkc_Primitive_initOperation(&pkc, &operation);
 *
 *     \endcode
 *
 * \subsection IfxLld_Pkc_Primitive_Step3 STEP 3 Perform operation:
 *
 *     Choose from the following functions for performing operation:
 *
 *     1. IfxPkc_Primitive_addEccPoints() for adding two ECC points
 *     2. IfxPkc_Primitive_doubleEccPoint() for doubling an ECC point
 *     3. IfxPkc_Primitive_multiplyEccPoint() for multiplying an ECC point with a scalar
 *     4. IfxPkc_Primitive_checkRMPrimality() for performing Rabin Miller Primality test
 *     5. For full list of operations, check the public APIs
 *
 *     Example:
 *     \code
 *
 *     // 1. Perform operation. (Eg. ECC point addition)
 *     // Add point1 and point2 then get resultantPoint. All points contain X and Y coordinate
 *     status = IfxPkc_Primitive_addEccPoints(pkc, &point1, &point2, &resultantPoint);
 *
 *     \endcode
 *
 * \subsection IfxLld_Pkc_Primitive_Step4 STEP 4 Read output data:
 *
 *     Output data in this example of ECC point addition is resultant ECC point and is stored in the resultantPoint
 *     array passed to the IfxPkc_Primitive_addEccPoints() function
 *
 * \subsection IfxLld_Pkc_Primitive_Step5 [Optional] STEP 5 Disable module clock:
 *
 *     \code
 *     IfxPkc_disableModule(pkc.pkcSFR);
 *     \endcode
 *
 * \defgroup IfxLld_Pkc_Primitive PRIMITIVE
 * \ingroup IfxLld_Pkc
 */

#ifndef IFXPKC_PRIMITIVE_H
#define IFXPKC_PRIMITIVE_H 1

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "Pkc/Std/IfxPkc.h"

/******************************************************************************/
/*-----------------------------Data Structures--------------------------------*/
/******************************************************************************/

/** \brief Data Structure for ECDSA Parameters
 */
typedef struct
{
    IfxPkc_Parameter p;        /**< \brief Domain parameter p or f(x) or q */
    IfxPkc_Parameter n;        /**< \brief Domain parameter n */
    IfxPkc_Parameter xG;       /**< \brief Domain parameter xG */
    IfxPkc_Parameter yG;       /**< \brief Domain parameter yG */
    IfxPkc_Parameter a;        /**< \brief Represents domain parameter a or d */
    IfxPkc_Parameter b;        /**< \brief Domain parameter b */
} IfxPkc_Primitive_EccParameters;

/** \brief Data Structure for EdDsa Curve Parameters
 */
typedef struct
{
    IfxPkc_Parameter p;       /**< \brief Curve parameters p Field size */
    IfxPkc_Parameter L;       /**< \brief Curve parameters L order of point B */
    IfxPkc_Parameter d;       /**< \brief Curve parameters d Parameters defining the curve E over GF(p) */
} IfxPkc_Primitive_EdDsaParameters;

/** \brief Data Structure for Montgomery Curve Parameters
 */
typedef struct
{
    IfxPkc_Parameter p;       /**< \brief Domain parameter p */
    IfxPkc_Parameter a;       /**< \brief Domain parameter a */
} IfxPkc_Primitive_McParameters;

/** \brief Handle of PKC Module
 */
typedef struct
{
    Ifx_PKC             *pkcSFR;               /**< \brief pkcSFR Pointer to the PKC SFR */
    IfxPkc_State         state;                /**< \brief state of the module */
    IfxPkc_OperationType operationType;        /**< \brief Type of Operation */
    void                *algoMechanism;        /**< \brief Pointer to algorithm specific data structure */
    uint16               dataSize;             /**< \brief Maximum size of the Operands (in data memory) (in bytes) */
    IfxPkc_Endian        endian;               /**< \brief Swap bytes on the bus interface */
    IfxPkc_Error         errors;               /**< \brief Structure holding the errors */
} IfxPkc_Primitive;

/** \brief Data Structure for Primitive Arithmetic Algorithms
 */
typedef struct
{
    IfxPkc_Parameter modulus;       /**< \brief Modulus (n) */
    IfxPkc_Field     field;         /**< \brief Defines the type of field */
} IfxPkc_Primitive_ArithmeticAlgorithm;

/** \brief Data Structure for ECC Algorithm
 */
typedef struct
{
    IfxPkc_Primitive_EccParameters eccParameters;           /**< \brief ECC Parameter structure */
    IfxPkc_Field                   field;                   /**< \brief Defines the type of field. ECC Decompression & Edwards only supports GF(p) */
    IfxPkc_Acceleration            curveAcceleration;       /**< \brief Enable accelerator for specific curve modulus */
    boolean                        enableEdwards;           /**< \brief Enable Edwards curve. ECC Decompression does not support edwards */
} IfxPkc_Primitive_EccAlgorithm;

/** \brief Data Structure for EdDSA Algorithm
 * EdDSA operations can be executed in field GF(p) only
 */
typedef struct
{
    IfxPkc_Primitive_EdDsaParameters edDsaParameters;
    boolean                          enableEdwards;           /**< \brief 0 for Ed25519 (Twisted Edwards); 1 for Ed448 (Edwards) */
    IfxPkc_Acceleration              curveAcceleration;       /**< \brief 0x6 for Ed25519 0x0 for Ed448 */
} IfxPkc_Primitive_EdDsaAlgorithm;

/** \brief Data Structure for Montgomery Algorithm
 */
typedef struct
{
    IfxPkc_Primitive_McParameters mcParameters;            /**< \brief Montgomery Parameter structure */
    IfxPkc_McAcceleration         curveAcceleration;       /**< \brief Enable accelerator */
} IfxPkc_Primitive_McAlgorithm;

/** \brief Module Configuration Structure
 */
typedef struct
{
    Ifx_PKC      *pkcSFR;        /**< \brief pkcSFR Pointer to the PKC SFR */
    IfxPkc_Endian endian;        /**< \brief Swap bytes on the bus interface */
} IfxPkc_Primitive_ModuleConfig;

/** \brief Operation configuration structure
 */
typedef struct
{
    void                *algoMechanism;        /**< \brief Pointer to algorithm specific data structure */
    uint16               dataSize;             /**< \brief Size of the Operands (in data memory) (in bytes) */
    IfxPkc_OperationType operationType;        /**< \brief Type of Operation */
} IfxPkc_Primitive_Operation;

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Function to initialize the default configuration of module for primitive operations
 * \param pkcSFR Pointer to the PKC SFR
 * \param config Configuration structure for PKC module
 * \return None
 */
IFX_EXTERN void IfxPkc_Primitive_initModuleConfig(Ifx_PKC *pkcSFR, IfxPkc_Primitive_ModuleConfig *config);

/** \brief Function to initialize the module for primitive operations
 * \param pkc Pointer to the Handle of PKC Module
 * \param config Configuration structure for PKC module
 * \return None
 */
IFX_EXTERN IfxPkc_Status IfxPkc_Primitive_initModule(IfxPkc_Primitive *pkc, IfxPkc_Primitive_ModuleConfig *config);

/** \brief Function to initialize any primitive PKC operation
 * \param pkc Pointer to the Handle of PKC Module
 * \param operation Pointer to operation configuration structure
 * \return Status of the operation
 */
IFX_EXTERN IfxPkc_Status IfxPkc_Primitive_initOperation(IfxPkc_Primitive *pkc, IfxPkc_Primitive_Operation *operation);

/** \brief Function to write data to DATARAM
 * \param pkc Pointer to the Handle of PKC Module
 * \param sourcePtr Pointer to source data from where the data is to be written
 * \param numWords Number of words to be written
 * \param memLocation Location of data in DATARAM
 * \return Status of the operation
 */
IFX_EXTERN IfxPkc_Status IfxPkc_Primitive_writeToDataram(IfxPkc_Primitive *pkc, uint32 *sourcePtr, uint32 numWords, IfxPkc_MemLocation memLocation);

/** \brief Function to read data from DATARAM
 * \param pkc Pointer to the Handle of PKC Module
 * \param destPtr Read data from DATARAM to this location
 * \param numWords Number of words to be read
 * \param memLocation Location of data in DATARAM
 * \return Status of the operation
 */
IFX_EXTERN IfxPkc_Status IfxPkc_Primitive_readFromDataram(IfxPkc_Primitive *pkc, uint32 *destPtr, uint32 numWords, IfxPkc_MemLocation memLocation);

/** \brief Function to check primality of an integer by performing one round of Rabin Miller test
 * Operation = RABINMILLER | Algo Mechanism: - | Input to initOperation = -
 * Note: User needs to call this multiple times depending on the number of iterations needed
 * \param pkc Pointer to the Handle of PKC Module
 * \param testIntegerPtr Pointer to integer to be tested for primality
 * \param randomIntegerPtr Pointer to random number used for primality test
 * \return Returns the primality status of the the test integer
 * after one round of Rabin Miller test
 */
IFX_EXTERN IfxPkc_PrimalityStatus IfxPkc_Primitive_checkRMPrimality(IfxPkc_Primitive *pkc, IfxPkc_Parameter *testIntegerPtr, IfxPkc_Parameter *randomIntegerPtr);

/** \brief Function to add two ECC points: point1 and point2
 * Operation = PADD | Algo Mechanism: IfxPkc_Primitive_EccAlgorithm | Input to initOperation = p, a, b | resultantPoint = point1 + point2
 * \param pkc Pointer to the Handle of PKC Module
 * \param point1 Point1
 * \param point2 Point2 to be added to Point1
 * \param resultantPoint Resultant point of the addition operation
 * \return Status of the operation
 */
IFX_EXTERN IfxPkc_Status IfxPkc_Primitive_addEccPoints(IfxPkc_Primitive *pkc, IfxPkc_CurveParameter *point1, IfxPkc_CurveParameter *point2, IfxPkc_CurveParameter *resultantPoint);

/** \brief Function to add three ECC points: point1, point2, and point3
 * Operation = JPAKE3PADD | Algo Mechanism: IfxPkc_Primitive_EccAlgorithm | Input to initOperation = p, n, a, b | resultantPoint = point1 + point2 + point3
 * \param pkc Pointer to the Handle of PKC Module
 * \param point1 Point1
 * \param point2 Point2 to be added to Point1
 * \param point3 Point3 to be added to Point1
 * \param resultantPoint Resultant point of the addition operation
 * \return Status of the operation
 */
IFX_EXTERN IfxPkc_Status IfxPkc_Primitive_add3EccPoints(IfxPkc_Primitive *pkc, IfxPkc_CurveParameter *point1, IfxPkc_CurveParameter *point2, IfxPkc_CurveParameter *point3, IfxPkc_CurveParameter *resultantPoint);

/** \brief Function to double an ECC point
 * Operation = PDBL | Algo Mechanism: IfxPkc_Primitive_EccAlgorithm | Input to initOperation = p, a, b | resultantPoint = point * 2
 * \param pkc Pointer to the Handle of PKC Module
 * \param point Point to be doubled
 * \param resultantPoint Resultant point
 * \return Status of the operation
 */
IFX_EXTERN IfxPkc_Status IfxPkc_Primitive_doubleEccPoint(IfxPkc_Primitive *pkc, IfxPkc_CurveParameter *point, IfxPkc_CurveParameter *resultantPoint);

/** \brief Function to multiply an ECC point with a scalar
 * Operation = SMULT | Algo Mechanism: IfxPkc_Primitive_EccAlgorithm | Input to initOperation = p, n, a, b | resultantPoint = point * scalar
 * \param pkc Pointer to the Handle of PKC Module
 * \param point Point to be multiplied by a scalar
 * \param scalar Scalar value
 * \param resultantPoint Resultant point
 * \return Status of the operation
 */
IFX_EXTERN IfxPkc_Status IfxPkc_Primitive_multiplyEccPoint(IfxPkc_Primitive *pkc, IfxPkc_CurveParameter *point, IfxPkc_Parameter *scalar, IfxPkc_CurveParameter *resultantPoint);

/** \brief Function to check domain paramter: a and b's validity
 * Operation = CHECKAB | Algo Mechanism: IfxPkc_Primitive_EccAlgorithm | Input to initOperation = p
 * Note: This function is NOT applicable for Edwards curves
 * \param pkc Pointer to the Handle of PKC Module
 * \param a Domain parameter a
 * \param b Domain Parameter b
 * \return Status of the operation
 */
IFX_EXTERN IfxPkc_Status IfxPkc_Primitive_checkEccParamAB(IfxPkc_Primitive *pkc, IfxPkc_Parameter *a, IfxPkc_Parameter *b);

/** \brief Function to check domain parameter n's validity
 * Operation = CHECKN | Algo Mechanism: IfxPkc_Primitive_EccAlgorithm | Input to initOperation = p
 * \param pkc Pointer to the Handle of PKC Module
 * \param n Domain parameter n
 * \return Status of the operation
 */
IFX_EXTERN IfxPkc_Status IfxPkc_Primitive_checkEccParamN(IfxPkc_Primitive *pkc, IfxPkc_Parameter *n);

/** \brief Function to check range constraint of a point (x<p and y<p)
 * Operation = CHECKPXY | Algo Mechanism: IfxPkc_Primitive_EccAlgorithm | Input to initOperation = p
 * \param pkc Pointer to the Handle of PKC Module
 * \param point Point on curve
 * \return Status of the operation
 */
IFX_EXTERN IfxPkc_Status IfxPkc_Primitive_checkEccCoordinates(IfxPkc_Primitive *pkc, IfxPkc_CurveParameter *point);

/** \brief Function to check whether a point lies on the curve described by domain parameters
 * Operation = CHECKPOC | Algo Mechanism: IfxPkc_Primitive_EccAlgorithm | Input to initOperation = p, a, b
 * \param pkc Pointer to the Handle of PKC Module
 * \param point Point on curve
 * \return Status of the operation
 */
IFX_EXTERN IfxPkc_Status IfxPkc_Primitive_checkEccPointOnCurve(IfxPkc_Primitive *pkc, IfxPkc_CurveParameter *point);

/** \brief Function to recover y coordinate of a point with the help of x coordinate and LSB of y
 * Operation = YRECOVER | Algo Mechanism: IfxPkc_Primitive_EccAlgorithm | Input to initOperation = p, a, b
 * \param pkc Pointer to the Handle of PKC Module
 * \param x X coordinate of the point
 * \param lsbY LSB of the Y coordinate
 * \param y Pointer to the resultant Y coordinate of the decompression/recovery operation
 * \return Status of the operation
 */
IFX_EXTERN IfxPkc_Status IfxPkc_Primitive_recoverYCoordinate(IfxPkc_Primitive *pkc, IfxPkc_Parameter *x, IfxPkc_BitValue *lsbY, IfxPkc_Parameter *y);

/** \brief Function to perform modular addition of two integers/binary polynomials
 * Operation = ADDN | Algo Mechanism: IfxPkc_Primitive_ArithmeticAlgorithm | Input to initOperation = modulus |
 * Fields = GF(P) & GF(2^m) | result = (a + b) mod N
 * \param pkc Pointer to the Handle of PKC Module
 * \param a Operand 1
 * \param b Operand 2
 * \param result Result of the operation
 * \return Status of the operation
 */
IFX_EXTERN IfxPkc_Status IfxPkc_Primitive_addMod(IfxPkc_Primitive *pkc, IfxPkc_Parameter *a, IfxPkc_Parameter *b, IfxPkc_Parameter *result);

/** \brief Function to perform modular subtraction of two integers/binary polynomials
 * Operation = SUBN | Algo Mechanism: IfxPkc_Primitive_ArithmeticAlgorithm | Input to initOperation = modulus |
 * Fields = GF(P) & GF(2^m) | result = (a - b) mod N
 * \param pkc Pointer to the Handle of PKC Module
 * \param a Operand 1
 * \param b Operand 2
 * \param result Result of the operation
 * \return Status of the operation
 */
IFX_EXTERN IfxPkc_Status IfxPkc_Primitive_subtractMod(IfxPkc_Primitive *pkc, IfxPkc_Parameter *a, IfxPkc_Parameter *b, IfxPkc_Parameter *result);

/** \brief Function to perform modular multiplication of two integers/binary polynomials
 * Operation = MULTN | Algo Mechanism: IfxPkc_Primitive_ArithmeticAlgorithm | Input to initOperation = modulus |
 * Fields = GF(P) & GF(2^m) | result = (a * b) mod N | Odd N
 * \param pkc Pointer to the Handle of PKC Module
 * \param a Operand 1
 * \param b Operand 2
 * \param result Result of the operation
 * \return Status of the operation
 */
IFX_EXTERN IfxPkc_Status IfxPkc_Primitive_multiplyMod(IfxPkc_Primitive *pkc, IfxPkc_Parameter *a, IfxPkc_Parameter *b, IfxPkc_Parameter *result);

/** \brief Function to perform modular reduction of integers/binary polynomials
 * Operation = RED, RED2 | Algo Mechanism: IfxPkc_Primitive_ArithmeticAlgorithm | Input to initOperation = modulus
 * Users should check parity of modulus before choosing operation type
 * Supports:
 * 1. Operation type: RED: (odd N, GF(p) & GF(2^m))
 * 2. Operation type: RED2: (even N and GF(p) only)
 * Operation result = A mod N
 * \param pkc Pointer to the Handle of PKC Module
 * \param a Operand 1
 * \param result Result of the operation
 * \return Status of the operation
 */
IFX_EXTERN IfxPkc_Status IfxPkc_Primitive_reduceMod(IfxPkc_Primitive *pkc, IfxPkc_Parameter *a, IfxPkc_Parameter *result);

/** \brief Function to perform modular division of two integers/binary polynomials
 * Operation = DIVN | Algo Mechanism: IfxPkc_Primitive_ArithmeticAlgorithm | Input to initOperation = modulus |
 * Fields = GF(P) & GF(2^m) | result = (a / b) mod N | Odd N
 * \param pkc Pointer to the Handle of PKC Module
 * \param a Operand 1
 * \param b Operand 2
 * \param result Result of the operation
 * \return Status of the operation
 */
IFX_EXTERN IfxPkc_Status IfxPkc_Primitive_divideMod(IfxPkc_Primitive *pkc, IfxPkc_Parameter *a, IfxPkc_Parameter *b, IfxPkc_Parameter *result);

/** \brief Function to perform modular inversion of integers/binary polynomials
 * Operation = INV, INV2 | Algo Mechanism: IfxPkc_Primitive_ArithmeticAlgorithm | Input to initOperation = modulus | result = (1/a) mod N
 * Users should check parity of modulus before choosing operation type
 * Supports:
 * 1. Operation type: INV: (odd N, GF(p) & GF(2^m))
 * 2. Operation type: INV2: (even N and GF(p) only)
 * Operation
 * \param pkc Pointer to the Handle of PKC Module
 * \param a Operand 1
 * \param result Result of the operation
 * \return Status of the operation
 */
IFX_EXTERN IfxPkc_Status IfxPkc_Primitive_invertMod(IfxPkc_Primitive *pkc, IfxPkc_Parameter *a, IfxPkc_Parameter *result);

/** \brief Function to perform modular square root of integers/binary polynomials
 * Operation = SQRTN | Algo Mechanism: IfxPkc_Primitive_ArithmeticAlgorithm | Input to initOperation = modulus |
 * Fields = GF(P) only | result = sqrt(A) mod N
 * \param pkc Pointer to the Handle of PKC Module
 * \param a Operand 1
 * \param result Result of the operation
 * \return Status of the operation
 */
IFX_EXTERN IfxPkc_Status IfxPkc_Primitive_squareRootMod(IfxPkc_Primitive *pkc, IfxPkc_Parameter *a, IfxPkc_Parameter *result);

/** \brief Function to perform simple multiplication of two integers/binary polynomials
 * Operation = MULT | Algo Mechanism: IfxPkc_Primitive_ArithmeticAlgorithm | Input to initOperation = - |
 * Fields = GF(p) & GF(2^m) | result = a * b
 * \param pkc Pointer to the Handle of PKC Module
 * \param a Operand 1
 * \param b Operand 2
 * \param result Result of the operation
 * \return Status of the operation
 */
IFX_EXTERN IfxPkc_Status IfxPkc_Primitive_multiply(IfxPkc_Primitive *pkc, IfxPkc_Parameter *a, IfxPkc_Parameter *b, IfxPkc_Parameter *result);

/** \brief Function to perform modular exponentiation of two integers/binary polynomials
 * Operation = EXP | Algo Mechanism: IfxPkc_Primitive_ArithmeticAlgorithm | Input to initOperation = modulus |
 * Fields = GF(P) only | result = (a^b) mod N
 * \param pkc Pointer to the Handle of PKC Module
 * \param a Operand 1
 * \param b Operand 2
 * \param result Result of the operation
 * \return Status of the operation
 */
IFX_EXTERN IfxPkc_Status IfxPkc_Primitive_exponentiateMod(IfxPkc_Primitive *pkc, IfxPkc_Parameter *a, IfxPkc_Parameter *b, IfxPkc_Parameter *result);

/** \brief Function to multiply Montgomery curve point with a scalar
 * Operation = SMULT25519 | Algo Mechanism: IfxPkc_Primitive_McAlgorithm | Input to initOperation = p, a |
 * Fields = GF(P) only | resultantPointX = scalar*pointX
 * \param pkc Pointer to the Handle of PKC Module
 * \param pointX X coordinate of point to be multiplied by a scalar
 * \param scalar Scalar value
 * \param resultantPointX X coordinate of Resultant point
 * \return Status of the operation
 */
IFX_EXTERN IfxPkc_Status IfxPkc_Primitive_multiplyMcPoint(IfxPkc_Primitive *pkc, IfxPkc_Parameter *pointX, IfxPkc_Parameter *scalar, IfxPkc_Parameter *resultantPointX);

/** \brief Function to perform point multiplication for EdDsa algorithm
 * Operation = EDDSASMULT | Algo Mechanism: IfxPkc_Primitive_EdDsaAlgorithm | Input to initOperation = p, L, d |
 * Fields = GF(P) only | resultantPointR = r * B
 * \param pkc Pointer to the Handle of PKC Module
 * \param pointB (xB, yB) coordinate of point to be multiplied by a scalar r
 * \param rLsb LSB of r
 * \param rMsb MSB of r (If empty then provide NULL_PTR)
 * \param resultantPointR coordinate of Resultant point (xR, yR)
 * \return Status of the operation
 */
IFX_EXTERN IfxPkc_Status IfxPkc_Primitive_multiplyEdDsaPoint(IfxPkc_Primitive *pkc, IfxPkc_CurveParameter *pointB, IfxPkc_Parameter *rLsb, IfxPkc_Parameter *rMsb, IfxPkc_CurveParameter *resultantPointR);
#endif /* IFXPKC_PRIMITIVE_H */
