/**
 * \file IfxPkc_Crypto.h
 * \brief PKC CRYPTO details
 * \ingroup IfxLld_Pkc
 *
 * \version iLLD_2_0_1_2_19
 * \copyright Copyright (c) 2022 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 *
 * \defgroup IfxLld_Pkc_Usage How to use the PKC Driver?
 * \ingroup IfxLld_Pkc
 *
 * \section IfxLld_Pkc_Overview Overview:
 * This driver module is used for performing asymmetric cryptographic operations using the resources provided by the Public Key Cryptography (PKC) module.\n
 *
 * The driver has two interface layers:
 *     - Crypto: For cryptographic operations like encryption, decryption, signature generation/verification and key generation
 *     - Primitive: For primitive operations like modular addition, etc.
 *
 * Functionality provided:
 *     1. Initialization of PKC module and operations
 *     2. Performing public key cryptographic operations
 *     3. Reading the results generated by the module
 *
 * Basic Steps common to both interface
 *     -# Decide the operation you have to perform and find which interface and API supports this by looking at the below table.
 *     -# Call IfxPkc_Crypto_initModuleConfig/IfxPkc_Primitive_initModuleConfig to initialize PKC module config
 *     -# Call IfxPkc_Crypto_initModule/IfxPkc_Primitive_initModule to initialize PKC module
 *     -# Instantiate the appropriate algoMechanism structure for the operation type (e.g. IfxPkc_Crypto_RsaAlgorithm; more info in interface doc)
 *     -# Instantiate IfxPkc_Crypto_Operation/IfxPkc_Primitive_Operation. Configure it and attach the algoMechanism structure.
 *     -# Call IfxPkc_Crypto_initOperation/IfxPkc_Primitive_initOperation
 *     -# Call the API found in below table for the operation type
 *
 * <table>
 * <caption id="multi_row">PKC Operation-API Table</caption>
 * <tr><th>Operation         <th>Operation Number  <th>Interface   <th>API
 * <tr><td>ADDN              <td>1                 <td>Primitive   <td>IfxPkc_Primitive_addMod
 * <tr><td>SUBN              <td>2                 <td>Primitive   <td>IfxPkc_Primitive_subtractMod
 * <tr><td>MULTN             <td>3                 <td>Primitive   <td>IfxPkc_Primitive_multiplyMod
 * <tr><td>RED               <td>4                 <td>Primitive   <td>IfxPkc_Primitive_reduceMod
 * <tr><td>DIVN              <td>5                 <td>Primitive   <td>IfxPkc_Primitive_divideMod
 * <tr><td>INV               <td>6                 <td>Primitive   <td>IfxPkc_Primitive_invertMod
 * <tr><td>SQRTN             <td>7                 <td>Primitive   <td>IfxPkc_Primitive_squareRootMod
 * <tr><td>MULT              <td>8                 <td>Primitive   <td>IfxPkc_Primitive_multiply
 * <tr><td>INV2              <td>9                 <td>Primitive   <td>IfxPkc_Primitive_invertMod
 * <tr><td>RED2              <td>10                <td>Primitive   <td>IfxPkc_Primitive_reduceMod
 * <tr><td>CLRMEM            <td>15                <td>            <td>IfxPkc_clearDataram
 * <tr><td>EXP               <td>16                <td>Primitive   <td>IfxPkc_Primitive_exponentiateMod
 * <tr><td>RSAPKGEN          <td>17                <td>Crypto      <td>IfxPkc_Crypto_generateKey
 * <tr><td>RSACRTKEYPARGEN   <td>18                <td>Crypto      <td>IfxPkc_Crypto_generateKey
 * <tr><td>RSACRTDEC         <td>19                <td>Crypto      <td>IfxPkc_Crypto_decrypt
 * <tr><td>RSAENC            <td>20                <td>Crypto      <td>IfxPkc_Crypto_encrypt
 * <tr><td>RSADEC            <td>21                <td>Crypto      <td>IfxPkc_Crypto_decrypt
 * <tr><td>RSASIG            <td>22                <td>Crypto      <td>IfxPkc_Crypto_generateSignature
 * <tr><td>RSAVER            <td>23                <td>Crypto      <td>IfxPkc_Crypto_verifySignature
 * <tr><td>DSAKEYGEN         <td>24                <td>Crypto      <td>IfxPkc_Crypto_generateKey
 * <tr><td>DSASIG            <td>25                <td>Crypto      <td>IfxPkc_Crypto_generateSignature
 * <tr><td>DSAVER            <td>26                <td>Crypto      <td>IfxPkc_Crypto_verifySignature
 * <tr><td>SRPSRVKEY         <td>27                <td>Crypto      <td>IfxPkc_Crypto_generateKey
 * <tr><td>SRPCLTKEY         <td>28                <td>Crypto      <td>IfxPkc_Crypto_generateKey
 * <tr><td>RSAHLFCRTREC      <td>29                <td>Crypto      <td>IfxPkc_Crypto_recombineHalfCrtOutputs
 * <tr><td>SRPSRVPUB         <td>30                <td>Crypto      <td>IfxPkc_Crypto_generateKey
 * <tr><td>RSAHLFCRTDEC      <td>31                <td>Crypto      <td>IfxPkc_Crypto_decryptHalfCrt
 * <tr><td>PDBL              <td>32                <td>Primitive   <td>IfxPkc_Primitive_doubleEccPoint
 * <tr><td>PADD              <td>33                <td>Primitive   <td>IfxPkc_Primitive_addEccPoints
 * <tr><td>SMULT             <td>34                <td>Primitive   <td>IfxPkc_Primitive_multiplyEccPoint
 * <tr><td>CHECKAB           <td>35                <td>Primitive   <td>IfxPkc_Primitive_checkEccParamAB
 * <tr><td>CHECKN            <td>36                <td>Primitive   <td>IfxPkc_Primitive_checkEccParamN
 * <tr><td>CHECKPXY          <td>37                <td>Primitive   <td>IfxPkc_Primitive_checkEccCoordinates
 * <tr><td>CHECKPOC          <td>38                <td>Primitive   <td>IfxPkc_Primitive_checkEccPointOnCurve
 * <tr><td>YRECOVER          <td>39                <td>Primitive   <td>IfxPkc_Primitive_recoverYCoordinate
 * <tr><td>SMULT25519        <td>40                <td>Primitive   <td>IfxPkc_Primitive_multiplyMcPoint
 * <tr><td>SM2SIG            <td>45                <td>Crypto      <td>IfxPkc_Crypto_generateSignature
 * <tr><td>SM2VER            <td>46                <td>Crypto      <td>IfxPkc_Crypto_verifySignature
 * <tr><td>SM2KEYEXCH        <td>47                <td>Crypto      <td>IfxPkc_Crypto_generateSharedSecret
 * <tr><td>ECDSASIG          <td>48                <td>Crypto      <td>IfxPkc_Crypto_generateSignature
 * <tr><td>ECDSAVER          <td>49                <td>Crypto      <td>IfxPkc_Crypto_verifySignature
 * <tr><td>ECDSAPV           <td>50                <td>Crypto      <td>IfxPkc_Crypto_validateDomainParameters
 * <tr><td>ECKCDSAPUBKEYGEN  <td>51                <td>Crypto      <td>IfxPkc_Crypto_generateKey
 * <tr><td>ECKCDSASIG        <td>52                <td>Crypto      <td>IfxPkc_Crypto_generateSignature
 * <tr><td>ECKCDSAVER        <td>53                <td>Crypto      <td>IfxPkc_Crypto_verifySignature
 * <tr><td>JPAKEZKPGEN       <td>54                <td>Crypto      <td>IfxPkc_Crypto_generateJPakeZkp
 * <tr><td>JPAKEZKPVER       <td>55                <td>Crypto      <td>IfxPkc_Crypto_verifyJPakeZkp
 * <tr><td>JPAKE3PADD        <td>56                <td>Primitive   <td>IfxPkc_Primitive_add3EccPoints
 * <tr><td>JPAKEKEYGEN       <td>57                <td>Crypto      <td>IfxPkc_Crypto_generateKey
 * <tr><td>JPAKEGENSTP2      <td>58                <td>Crypto      <td>IfxPkc_Crypto_generateJPakeStep2
 * <tr><td>EDDSASMULT        <td>59                <td>Primitive   <td>IfxPkc_Primitive_multiplyEdDsaPoint
 * <tr><td>EDDSASIG          <td>60                <td>Crypto      <td>IfxPkc_Crypto_generateSignature
 * <tr><td>EDDSAVER          <td>61                <td>Crypto      <td>IfxPkc_Crypto_verifySignature
 * <tr><td>RABINMILLER       <td>66                <td>Primitive   <td>IfxPkc_Primitive_checkRMPrimality
 * </table>
 *
 * \defgroup IfxLld_Pkc_Crypto_Usage How to use the PKC Crypto Interface layer?
 * \ingroup IfxLld_Pkc_Crypto
 *
 * \section IfxLld_Pkc_Crypto_Steps Steps to use the Pkc driver
 * See the steps first and find how to use all supported operations in next section
 *
 * \subsection IfxLld_Pkc_Crypto_Step1 STEP 1 Module Initialization:
 *
 *     \code
 *     // 1. Enable the module clock
 *     IfxPkc_enableModule(&MODULE_PKC);
 *
 *     // 2. Instantiate the module config structure
 *     IfxPkc_Crypto_ModuleConfig config;
 *
 *     // 3. Instantiate the module handle
 *     IfxPkc_Crypto pkc;
 *
 *     // 4. Initialise the module config
 *     IfxPkc_Crypto_initModuleConfig(&MODULE_PKC, &config);
 *
 *     // 5. Specify the endianness of data
 *     config.endian = IfxPkc_endian_little;
 *
 *     // 6. Initialise the module
 *     IfxPkc_status status;
 *     status = IfxPkc_Crypto_initModule(&pkc, &config);
 *
 *     \endcode
 *
 * \subsection IfxLld_Pkc_Crypto_Step2 STEP 2 Operation Initialization:
 *
 *     \code
 *     // 1. Instantiate operation structure
 *     IfxPkc_Crypto_Operation operation;
 *
 *     // 2. Instantiate the data structure for algorithm needed
 *     // Here RSA specific data structure has been instantiated
 *     IfxPkc_Crypto_RsaAlgorithm rsa;
 *
 *     // 3. Configure the above data structure
 *     // modulus and publicKey arrays hold respective data and numWords specify the data length
 *     rsa.rsaParameters.modulus.dataPtr = (uint32 *)&modulus[0];
 *     rsa.rsaParameters.modulus.sizeInWords = (uint32)numWords;
 *     rsa.rsaParameters.publicKey.dataPtr = (uint32 *)&publicKey[0];
 *     rsa.rsaParameters.publicKey.sizeInWords = (uint32)numWords;
 *
 *     // 4. Configure the operation structure
 *     // 4a. Specify the type of operation (Eg. RSA Encryption)
 *     operation.operationType = IfxPkc_operationType_RSAENC;
 *     // 4b. Specify the max operand size in bytes
 *     operation.dataSize = numWords*4;
 *     // 4c. Point the algoMechanism pointer to algorithm structure
 *     operation.algoMechanism = (IfxPkc_Crypto_RsaAlgorithm *)&rsa;
 *
 *     // 5. Initialise operation
 *     status = IfxPkc_Crypto_initOperation(&pkc, &operation);
 *
 *     \endcode
 *
 * \subsection IfxLld_Pkc_Crypto_Step3 STEP 3 Perform operation:
 *
 *     Choose from the following functions for performing operation:
 *
 *     1. IfxPkc_Crypto_encrypt() for Encryption
 *     2. IfxPkc_Crypto_decrypt() for Decryption
 *     3. IfxPkc_Crypto_generateSignature() for Signature Generation
 *     4. IfxPkc_Crypto_verifySignature() for Signature Verification
 *     5. For more, see table below
 *
 *     Example:
 *     \code
 *
 *     // 1. Perform operation. (Eg. RSA encryption)
 *     // message and cipherText holds respective data and numWords specify the data length
 *     status = IfxPkc_Crypto_encrypt(&pkc, (uint32 *)&message[0], (uint32 *)&cipherText[0], numWords);
 *
 *     \endcode
 *
 * \subsection IfxLld_Pkc_Crypto_Step4 STEP 4 Read output data:
 *
 *     Output data in this example of RSA Encryption is cipher text and is stored in the cipherText
 *     array passed to the IfxPkc_Crypto_encrypt() function
 *
 * \subsection IfxLld_Pkc_Crypto_Step5 [Optional] STEP 5 Disable module clock:
 *
 *     \code
 *     IfxPkc_disableModule(pkc.pkcSFR);
 *     \endcode
 *
 * \section IfxLld_Pkc_Crypto_Tables All Supported Operations
 * \subsection IfxLld_Pkc_Crypto_Tables_1 Encryption Operations
 * IFX_EXTERN IfxPkc_Status IfxPkc_Crypto_encrypt(IfxPkc_Crypto *pkc, uint32 *plainTextPtr, uint32 *cipherTextPtr, uint32 numWords)
 * <table>
 * <caption id="multi_row">Encryption Operations</caption>
 * <tr><th>Operation         <th>Algo Mechanism                  <th>Input (written in initOperation) <th>Input (written in this fn) <th>Output
 * <tr><td>RSAENC            <td>IfxPkc_Crypto_RsaAlgorithm      <td>modulus, publicKey               <td>plainTextPtr                <td>cipherTextPtr
 * </table>
 *
 * \subsection IfxLld_Pkc_Crypto_Tables_2 Decryption Operations
 * IFX_EXTERN IfxPkc_Status IfxPkc_Crypto_decrypt(IfxPkc_Crypto *pkc, uint32 *plainTextPtr, uint32 *cipherTextPtr, uint32 numWords)
 * <table>
 * <caption id="multi_row">Decryption Operations</caption>
 * <tr><th>Operation         <th>Algo Mechanism                  <th>Input (written in initOperation) <th>Input (written in this fn) <th>Output
 * <tr><td>RSADEC            <td>IfxPkc_Crypto_RsaAlgorithm      <td>modulus, privateKey              <td>cipherTextPtr               <td>plainTextPtr
 * <tr><td>RSACRTDEC         <td>IfxPkc_Crypto_RsaCrtAlgorithm   <td>p, q, dP, dQ, qInv               <td>cipherTextPtr               <td>plainTextPtr
 * </table>
 *
 * \subsection IfxLld_Pkc_Crypto_Tables_3 Signature Generation Operations
 * IFX_EXTERN IfxPkc_Status IfxPkc_Crypto_generateSignature(IfxPkc_Crypto *pkc, uint32 *hashPtr, uint32 hashLength, IfxPkc_Crypto_Signature *signaturePtr)
 * <table>
 * <caption id="multi_row">Signature Generation Operations</caption>
 * <tr><th>Operation  <th>Algo Mechanism                  <th>Input (written in initOperation)           <th>Input (written in this fn)      <th>Output
 * <tr><td>RSASIG     <td>IfxPkc_Crypto_RsaAlgorithm      <td>modulus, privateKey                        <td>hashPtr                         <td>signaturePtr: s
 * <tr><td>ECDSASIG   <td>IfxPkc_Crypto_EcdsaAlgorithm    <td>p, n, xG, yG, a, b, privateKey             <td>hashPtr, k                      <td>signaturePtr: r, s
 * <tr><td>DSASIG     <td>IfxPkc_Crypto_DsaAlgorithm      <td>p, g, privateKey, q                        <td>hashPtr, k                      <td>signaturePtr: r, s
 * <tr><td>ECKCDSASIG <td>IfxPkc_Crypto_EckcdsaAlgorithm  <td>p, n, xG, yG, a, b, privateKey             <td>hashPtr, k, signaturePtr: r     <td>signaturePtr: s
 * <tr><td>SM2SIG     <td>IfxPkc_Crypto_Sm2Algorithm      <td>p, n, xG, yG, a, b, privateKey             <td>hashPtr, k                      <td>signaturePtr: r, s
 * <tr><td>EDDSASIG   <td>IfxPkc_Crypto_EdDsaAlgorithm    <td>p, L, kLsb, kMsb, rLsb, rMsb, secretScalar <td> - (Provide NULL_PTR to hashPtr)<td>signaturePtr: s
 * </table>
 *
 * \subsection IfxLld_Pkc_Crypto_Tables_4 Signature Verification Operations
 * IFX_EXTERN IfxPkc_Status IfxPkc_Crypto_verifySignature(IfxPkc_Crypto *pkc, uint32 *hashPtr, uint32 hashLength, IfxPkc_Crypto_Signature *signaturePtr)
 * <table>
 * <caption id="multi_row">Signature Verification Operations</caption>
 * <tr><th>Operation  <th>Algo Mechanism                  <th>Input (written in initOperation)                <th>Input (written in this fn)         <th>Output
 * <tr><td>RSAVER     <td>IfxPkc_Crypto_RsaAlgorithm      <td>modulus, publicKey                              <td>hashPtr, signaturePtr: s           <td>status
 * <tr><td>ECDSAVER   <td>IfxPkc_Crypto_EcdsaAlgorithm    <td>p, n, xG, yG, a, b, publicKey_xQ, publicKey_yQ  <td>hashPtr, signaturePtr: r, s        <td>status
 * <tr><td>DSAVER     <td>IfxPkc_Crypto_DsaAlgorithm      <td>p, g, publicKey, q                              <td>hashPtr, signaturePtr: r, s        <td>status
 * <tr><td>SM2VER     <td>IfxPkc_Crypto_Sm2Algorithm      <td>p, n, xG, yG, a, b, publicKey_xQ, publicKey_yQ  <td>hashPtr, signaturePtr: r, s        <td>status
 * <tr><td>ECKCDSAVER <td>IfxPkc_Crypto_EckcdsaAlgorithm  <td>p, n, xG, yG, a, b, publicKey_xQ, publicKey_yQ  <td>hashPtr, signaturePtr: r, s        <td>status, eckcdsaParameters: xW, yW
 * <tr><td>EDDSAVER   <td>IfxPkc_Crypto_EdDsaAlgorithm    <td>p, L, kLsb, kMsb, xB, yB, d, I, yA, yR          <td> - (Provide NULL_PTR to hashPtr), signaturePtr: s <td>status
 * </table>
 *
 * \subsection IfxLld_Pkc_Crypto_Tables_5 Key Generation Operations
 * IFX_EXTERN IfxPkc_Status IfxPkc_Crypto_generateKey(IfxPkc_Crypto *pkc, void *keyPtr)\n
 * Provide appropriate structure to the function parameter keyPtr as mentioned below.
 * <table>
 * <caption id="multi_row">Key Generation Operations</caption>
 * <tr><th>Operation         <th>Algo Mechanism                  <th>Input (written in initOperation) <th>Input (written in this fn) <th>Output
 * <tr><td>RSAPKGEN          <td>IfxPkc_Crypto_RsaAlgorithm      <td>p, q, publicKey                  <td> -                         <td>IfxPkc_Crypto_RsaKey
 * <tr><td>RSACRTKEYPARGEN   <td>IfxPkc_Crypto_RsaCrtAlgorithm   <td>p, q, privateKey                 <td> -                         <td>IfxPkc_Crypto_RsaCrtKey
 * <tr><td>DSAKEYGEN         <td>IfxPkc_Crypto_DsaAlgorithm      <td>p, g, privateKey                 <td> -                         <td>IfxPkc_Crypto_DsaKey
 * <tr><td>ECKCDSAPUBKEYGEN  <td>IfxPkc_Crypto_EckcdsaAlgorithm  <td>p, n, xG, yG, a, b, privateKey   <td> -                         <td>IfxPkc_Crypto_EckcdsaKey
 * <tr><td>SRPCLTKEY         <td>IfxPkc_Crypto_SrpAlgorithm      <td>n, g, a, B, x, k, u              <td> -                         <td>IfxPkc_Crypto_SrpKey
 * <tr><td>SRPSRVKEY         <td>IfxPkc_Crypto_SrpAlgorithm      <td>n, A, a, u, v, b                 <td> -                         <td>IfxPkc_Crypto_SrpKey
 * <tr><td>SRPSRVPUB         <td>IfxPkc_Crypto_SrpAlgorithm      <td>n, g, k ,v, b                    <td> -                         <td>IfxPkc_Crypto_SrpKey
 * <tr><td>JPAKEKEYGEN       <td>IfxPkc_Crypto_JPakeAlgorithm    <td>p, n, a, b, X4, B, x2, x2s       <td> -                         <td>IfxPkc_Crypto_JPakeKey
 * </table>
 *
 * \subsection IfxLld_Pkc_Crypto_Tables_6 Domain Parameters Validation Operation
 * IFX_EXTERN IfxPkc_Status IfxPkc_Crypto_validateDomainParameters(IfxPkc_Crypto *pkc)
 * <table>
 * <caption id="multi_row">Domain Parameters Validation Operation</caption>
 * <tr><th>Operation  <th>Algo Mechanism                  <th>Input (written in initOperation)                <th>Input (written in this fn)         <th>Output
 * <tr><td>ECDSAPV    <td>IfxPkc_Crypto_EcdsaAlgorithm    <td>p, n, xG, yG, a, b                              <td> -                                 <td>status
 * </table>
 *
 * \subsection IfxLld_Pkc_Crypto_Tables_7 Shared Secret Generation Operation
 * IFX_EXTERN IfxPkc_Status IfxPkc_Crypto_generateSharedSecret(IfxPkc_Crypto *pkc, IfxPkc_Crypto_SharedSecret *sharedSecret)
 * <table>
 * <caption id="multi_row">Shared Secret Generation Operation</caption>
 * <tr><th>Operation  <th>Algo Mechanism             <th>Input (written in initOperation)                   <th>Input (written in this fn) <th>Output
 * <tr><td>SM2KEYEXCH <td>IfxPkc_Crypto_Sm2Algorithm <td>p, n, xG, yG, a, b, privateKey, k, publicKey_xQ,
 *                                                       publicKey_yQ, xRB, yRB, cofactor, xRA, towExpW     <td> -                         <td>sharedSecret
 * </table>
 *
 * \subsection IfxLld_Pkc_Crypto_Tables_8 Other J-PAKE Operations
 * IFX_EXTERN IfxPkc_Status IfxPkc_Crypto_generateJPakeZkp(IfxPkc_Crypto *pkc, IfxPkc_Parameter *r)\n
 * IFX_EXTERN IfxPkc_Status IfxPkc_Crypto_verifyJPakeZkp(IfxPkc_Crypto *pkc)\n
 * IFX_EXTERN IfxPkc_Status IfxPkc_Crypto_generateJPakeStep2(IfxPkc_Crypto *pkc, IfxPkc_CurveParameter *A, IfxPkc_Parameter *x2s, IfxPkc_CurveParameter *GA)\n
 * <table>
 * <caption id="multi_row">Other J-PAKE Operations</caption>
 * <tr><th>Operation      <th>Algo Mechanism                 <th>Input (written in initOperation)           <th>Input (written in this fn)         <th>Output
 * <tr><td>JPAKEZKPGEN    <td>IfxPkc_Crypto_JPakeAlgorithm   <td>n, v, x, hash                              <td> -                                 <td>r
 * <tr><td>JPAKEZKPVER    <td>IfxPkc_Crypto_JPakeAlgorithm   <td>n, p, a (d), b, xG, yG, V, X, r, hash      <td> -                                 <td>status
 * <tr><td>JPAKEGENSTP2   <td>IfxPkc_Crypto_JPakeAlgorithm   <td>n, p, a (d), b, X4, X3, X1, x2, s          <td> -                                 <td>A, x2s, GA
 * </table>
 *
 * \subsection IfxLld_Pkc_Crypto_Tables_9 RSA Half CRT Operations
 * IFX_EXTERN IfxPkc_Status IfxPkc_Crypto_generateJPakeZkp(IfxPkc_Crypto *pkc, IfxPkc_Parameter *r)\n
 * IFX_EXTERN IfxPkc_Status IfxPkc_Crypto_verifyJPakeZkp(IfxPkc_Crypto *pkc)\n
 * IFX_EXTERN IfxPkc_Status IfxPkc_Crypto_generateJPakeStep2(IfxPkc_Crypto *pkc, IfxPkc_CurveParameter *A, IfxPkc_Parameter *x2s, IfxPkc_CurveParameter *GA)\n
 * <table>
 * <caption id="multi_row">RSA Half CRT Operations</caption>
 * <tr><th>Operation      <th>Algo Mechanism                 <th>Input (written in initOperation)           <th>Input (written in this fn)         <th>Output
 * <tr><td>RSAHLFCRTDEC   <td>IfxPkc_Crypto_RsaCrtAlgorithm  <td>p, dP                                      <td> cipherText                        <td>vp
 * <tr><td>RSAHLFCRTREC   <td>IfxPkc_Crypto_RsaCrtAlgorithm  <td>p, q, qInv                                 <td> vp, vq                            <td>plainText
 * </table>
 *
 * \defgroup IfxLld_Pkc_Crypto CRYPTO
 * \ingroup IfxLld_Pkc
 */

#ifndef IFXPKC_CRYPTO_H
#define IFXPKC_CRYPTO_H 1

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "Pkc/Std/IfxPkc.h"

/******************************************************************************/
/*------------------------------Type Definitions------------------------------*/
/******************************************************************************/

/** \brief Data type for DSA Public key
 */
typedef IfxPkc_Parameter IfxPkc_Crypto_DsaKey;

/** \brief Data type for SRP Server Public/Session or Client Session key depending upon operation
 */
typedef IfxPkc_Parameter IfxPkc_Crypto_SrpKey;

/******************************************************************************/
/*-----------------------------Data Structures--------------------------------*/
/******************************************************************************/

/** \brief Data Structure for DSA Parameters
 */
typedef struct
{
    IfxPkc_Parameter p;                /**< \brief Domain parameter p or f(x) */
    IfxPkc_Parameter q;                /**< \brief Domain parameter q */
    IfxPkc_Parameter g;                /**< \brief Domain parameter g */
    IfxPkc_Parameter k;                /**< \brief Random k */
    IfxPkc_Parameter privateKey;       /**< \brief x PrivateKey */
    IfxPkc_Parameter publicKey;        /**< \brief y Public Key */
} IfxPkc_Crypto_DsaParameters;

/** \brief Data Structure for ECDSA Parameters
 */
typedef struct
{
    IfxPkc_Parameter p;                  /**< \brief Domain parameter p or f(x) */
    IfxPkc_Parameter n;                  /**< \brief Domain parameter n */
    IfxPkc_Parameter xG;                 /**< \brief Domain parameter xG */
    IfxPkc_Parameter yG;                 /**< \brief Domain parameter yG */
    IfxPkc_Parameter a;                  /**< \brief Domain parameter a */
    IfxPkc_Parameter b;                  /**< \brief Domain parameter b */
    IfxPkc_Parameter privateKey;         /**< \brief dA PrivateKey */
    IfxPkc_Parameter k;                  /**< \brief Random k */
    IfxPkc_Parameter publicKey_xQ;       /**< \brief xQ Public Key */
    IfxPkc_Parameter publicKey_yQ;       /**< \brief yQ Public Key */
} IfxPkc_Crypto_EcdsaParameters;

/** \brief Data Structure for EC-KCDSA Parameters
 */
typedef struct
{
    IfxPkc_Parameter p;                  /**< \brief Domain parameter p or f(x) */
    IfxPkc_Parameter n;                  /**< \brief Domain parameter n */
    IfxPkc_Parameter xG;                 /**< \brief Domain parameter xG */
    IfxPkc_Parameter yG;                 /**< \brief Domain parameter yG */
    IfxPkc_Parameter a;                  /**< \brief Domain parameter a */
    IfxPkc_Parameter b;                  /**< \brief Domain parameter b */
    IfxPkc_Parameter privateKey;         /**< \brief dA PrivateKey */
    IfxPkc_Parameter k;                  /**< \brief Random k */
    IfxPkc_Parameter publicKey_xQ;       /**< \brief xQ Public Key */
    IfxPkc_Parameter publicKey_yQ;       /**< \brief yQ Public Key */
    IfxPkc_Parameter xW;                 /**< \brief xW */
    IfxPkc_Parameter yW;                 /**< \brief yW */
} IfxPkc_Crypto_EckcdsaParameters;

typedef struct
{
    IfxPkc_Parameter p;                  /**< \brief Curve parameters p Field size */
    IfxPkc_Parameter L;                  /**< \brief Curve parameters L order of point B */
    IfxPkc_Parameter xB;                 /**< \brief Curve parameters xB Generator Point */
    IfxPkc_Parameter yB;                 /**< \brief Curve parameters yB Generator Point */
    IfxPkc_Parameter d;                  /**< \brief Curve parameters d Parameters defining the curve E over GF(p) */
    IfxPkc_Parameter I;                  /**< \brief Curve parameters I Auxiliary value I is used for point decompression */
    IfxPkc_Parameter kLsb;               /**< \brief Curve parameters k Message Hash */
    IfxPkc_Parameter kMsb;               /**< \brief Curve parameters k Message Hash */
    boolean          xALsb;              /**< \brief Curve parameters xA Public key LSB */
    IfxPkc_Parameter yA;                 /**< \brief Curve parameters yA Public key */
    boolean          xRLsb;              /**< \brief Curve parameters xR */
    IfxPkc_Parameter yR;                 /**< \brief Curve parameters yR */
    IfxPkc_Parameter rLsb;               /**< \brief Curve parameters r */
    IfxPkc_Parameter rMsb;               /**< \brief Curve parameters r */
    IfxPkc_Parameter secretScalar;       /**< \brief Curve parameters Secret scalar (s) */
} IfxPkc_Crypto_EdDsaParameters;

/** \brief Data Structure for J-PAKE Parameters
 */
typedef struct
{
    IfxPkc_Parameter      p;          /**< \brief Domain parameter p or f(x) */
    IfxPkc_Parameter      n;          /**< \brief Domain parameter n */
    IfxPkc_Parameter      xG;         /**< \brief Domain parameter xG */
    IfxPkc_Parameter      yG;         /**< \brief Domain parameter yG */
    IfxPkc_Parameter      a;          /**< \brief Domain parameter a or d */
    IfxPkc_Parameter      b;          /**< \brief Domain parameter b */
    IfxPkc_CurveParameter V;          /**< \brief Point V */
    IfxPkc_Parameter      v;          /**< \brief Parameter v */
    IfxPkc_CurveParameter X;          /**< \brief Point X */
    IfxPkc_Parameter      r;          /**< \brief Parameter r */
    IfxPkc_Parameter      x;          /**< \brief Parameter x */
    IfxPkc_Parameter      hash;       /**< \brief Parameter hash */
    IfxPkc_CurveParameter X4;         /**< \brief Point X4 */
    IfxPkc_CurveParameter X3;         /**< \brief Point X3 */
    IfxPkc_CurveParameter X1;         /**< \brief Point X1 */
    IfxPkc_Parameter      x2;         /**< \brief Parameter x2 */
    IfxPkc_Parameter      x2s;        /**< \brief Parameter x2s */
    IfxPkc_Parameter      s;          /**< \brief Parameter s */
    IfxPkc_CurveParameter B;          /**< \brief Point B */
} IfxPkc_Crypto_JPakeParameters;

/** \brief Data Structure for RSA CRT Parameters
 */
typedef struct
{
    IfxPkc_Parameter p;                /**< \brief p */
    IfxPkc_Parameter q;                /**< \brief q */
    IfxPkc_Parameter privateKey;       /**< \brief Private key: d */
    IfxPkc_Parameter dP;               /**< \brief dP */
    IfxPkc_Parameter dQ;               /**< \brief dQ */
    IfxPkc_Parameter qInv;             /**< \brief qInv */
} IfxPkc_Crypto_RsaCrtParameters;

/** \brief Data Structure for RSA Parameters
 */
typedef struct
{
    IfxPkc_Parameter modulus;          /**< \brief Modulus: n */
    IfxPkc_Parameter privateKey;       /**< \brief Private key: d */
    IfxPkc_Parameter publicKey;        /**< \brief Public key: e */
    IfxPkc_Parameter p;                /**< \brief p */
    IfxPkc_Parameter q;                /**< \brief q */
} IfxPkc_Crypto_RsaParameters;

/** \brief Structure for holding signature related parameters
 */
typedef struct
{
    uint32 *r;                /**< \brief Signature: r */
    uint32 *s;                /**< \brief Signature: s */
    uint32  sizeInWords;      /**< \brief Signature length in words */
} IfxPkc_Crypto_Signature;

/** \brief Data Structure for SM2 Parameters
 */
typedef struct
{
    IfxPkc_Parameter p;                  /**< \brief Domain parameter p or f(x) */
    IfxPkc_Parameter n;                  /**< \brief Domain parameter n */
    IfxPkc_Parameter xG;                 /**< \brief Domain parameter xG */
    IfxPkc_Parameter yG;                 /**< \brief Domain parameter yG */
    IfxPkc_Parameter a;                  /**< \brief Domain parameter a */
    IfxPkc_Parameter b;                  /**< \brief Domain parameter b */
    IfxPkc_Parameter privateKey;         /**< \brief dA PrivateKey */
    IfxPkc_Parameter k;                  /**< \brief Random k */
    IfxPkc_Parameter publicKey_xQ;       /**< \brief xQ Public Key */
    IfxPkc_Parameter publicKey_yQ;       /**< \brief yQ Public Key */
    IfxPkc_Parameter xRB;                /**< \brief xRB */
    IfxPkc_Parameter yRB;                /**< \brief yRB */
    IfxPkc_Parameter cofactor;           /**< \brief Cofactor h */
    IfxPkc_Parameter xRA;                /**< \brief xRA */
    IfxPkc_Parameter twoExpW;            /**< \brief 2^W */
} IfxPkc_Crypto_Sm2Parameters;

/** \brief Data Structure for SRP Parameters
 */
typedef struct
{
    IfxPkc_Parameter N;       /**< \brief Safe Prime */
    IfxPkc_Parameter A;       /**< \brief A = g^a (client generated) */
    IfxPkc_Parameter g;       /**< \brief Generator */
    IfxPkc_Parameter a;       /**< \brief Random number */
    IfxPkc_Parameter B;       /**< \brief Server Public Key */
    IfxPkc_Parameter x;       /**< \brief H(s,p) */
    IfxPkc_Parameter k;       /**< \brief H(N,g) */
    IfxPkc_Parameter u;       /**< \brief H(A, B) */
    IfxPkc_Parameter v;       /**< \brief g^x */
    IfxPkc_Parameter b;       /**< \brief Random number */
} IfxPkc_Crypto_SrpParameters;

/** \brief Handle of PKC Module
 */
typedef struct
{
    Ifx_PKC             *pkcSFR;               /**< \brief pkcSFR Pointer to the PKC SFR */
    IfxPkc_State         state;                /**< \brief state of the module */
    IfxPkc_OperationType operationType;        /**< \brief Type of Operation */
    void                *algoMechanism;        /**< \brief Pointer to algorithm specific data structure */
    uint16               dataSize;             /**< \brief Maximum size of the Operands (in data memory) (in bytes) */
    IfxPkc_Endian        endian;               /**< \brief Swap bytes on the bus interface */
    IfxPkc_Error         errors;               /**< \brief Structure holding the errors */
} IfxPkc_Crypto;

/** \brief Data Structure for DSA Algorithm
 */
typedef struct
{
    IfxPkc_Crypto_DsaParameters dsaParameters;       /**< \brief Data Structure for DSA Parameters */
    IfxPkc_Crypto_Signature     signature;           /**< \brief Signature data */
    uint32                     *hashPtr;             /**< \brief Hash of message: h */
} IfxPkc_Crypto_DsaAlgorithm;

/** \brief Data Structure for ECDSA Algorithm
 */
typedef struct
{
    IfxPkc_Crypto_EcdsaParameters ecdsaParameters;         /**< \brief Data Structure for ECDSA Parameters */
    IfxPkc_Crypto_Signature       signature;               /**< \brief Signature data */
    uint32                       *hashPtr;                 /**< \brief Hash of message: h */
    IfxPkc_Field                  field;                   /**< \brief Defines the type of field */
    IfxPkc_Acceleration           curveAcceleration;       /**< \brief Enable accelerator for specific curve modulus */
    boolean                       enableEdwards;           /**< \brief Enable Edwards curve. Only supports GF(p). */
} IfxPkc_Crypto_EcdsaAlgorithm;

/** \brief Data Structure for EC-KCDSA Algorithm
 */
typedef struct
{
    IfxPkc_Crypto_EckcdsaParameters eckcdsaParameters;       /**< \brief Data Structure for EC-KCDSA Parameters */
    IfxPkc_Crypto_Signature         signature;               /**< \brief Signature data */
    uint32                         *hashPtr;                 /**< \brief Hash of message: h */
    IfxPkc_Field                    field;                   /**< \brief Defines the type of field */
    IfxPkc_Acceleration             curveAcceleration;       /**< \brief Enable accelerator for specific curve modulus */
    boolean                         enableEdwards;           /**< \brief Enable Edwards curve. Only supports GF(p). */
} IfxPkc_Crypto_EckcdsaAlgorithm;

/** \brief Data Structure for EC-KCDSA Key Parameters
 */
typedef struct
{
    IfxPkc_Parameter publicKey_xQ;       /**< \brief xQ Public Key */
    IfxPkc_Parameter publicKey_yQ;       /**< \brief yQ Public Key */
} IfxPkc_Crypto_EckcdsaKey;

/** \brief Data Structure for EdDSA Algorithm
 * EdDSA operations can be executed in field GF(p) only
 */
typedef struct
{
    IfxPkc_Crypto_EdDsaParameters edDsaParameters;
    IfxPkc_Crypto_Signature       signature;               /**< \brief Signature data (Member r is irrelevant. s contains S) */
    boolean                       enableEdwards;           /**< \brief 0 for Ed25519 (Twisted Edwards); 1 for Ed448 (Edwards) */
    IfxPkc_Acceleration           curveAcceleration;       /**< \brief 0x6 for Ed25519 0x0 for Ed448 */
} IfxPkc_Crypto_EdDsaAlgorithm;

/** \brief Data Structure for J-PAKE Algorithm
 */
typedef struct
{
    IfxPkc_Crypto_JPakeParameters jPakeParameters;         /**< \brief Data Structure for J-PAKE Parameters */
    IfxPkc_Field                  field;                   /**< \brief Defines the type of field */
    IfxPkc_Acceleration           curveAcceleration;       /**< \brief Enable accelerator for specific curve modulus */
    boolean                       enableEdwards;           /**< \brief Enable Edwards curve. Only supports GF(p). */
    boolean                       curveGeneratorG;         /**< \brief Needed for Verify ZKP. TRUE: xG, yG is curve generator point. FALSE: It is another point */
} IfxPkc_Crypto_JPakeAlgorithm;

/** \brief Data Structure for J-PAKE Key Parameters
 */
typedef struct
{
    IfxPkc_Parameter xT;       /**< \brief Parameter xT */
    IfxPkc_Parameter yT;       /**< \brief Parameter yT */
} IfxPkc_Crypto_JPakeKey;

/** \brief Module Configuration Structure
 */
typedef struct
{
    Ifx_PKC      *pkcSFR;        /**< \brief pkcSFR Pointer to the PKC SFR */
    IfxPkc_Endian endian;        /**< \brief Swap bytes on the bus interface */
} IfxPkc_Crypto_ModuleConfig;

/** \brief Operation configuration structure
 */
typedef struct
{
    void                *algoMechanism;        /**< \brief Pointer to algorithm specific data structure */
    uint16               dataSize;             /**< \brief Size of the Operands (in data memory) (in bytes) */
    IfxPkc_OperationType operationType;        /**< \brief Type of Operation */
} IfxPkc_Crypto_Operation;

/** \brief Data Structure for RSA Algorithm
 */
typedef struct
{
    IfxPkc_Crypto_RsaParameters rsaParameters;        /**< \brief Data Structure for RSA Parameters */
    IfxPkc_Crypto_Signature     signature;            /**< \brief Signature data */
    uint32                     *cipherTextPtr;        /**< \brief Cipher text: C */
    uint32                     *plainTextPtr;         /**< \brief Plain text: M */
    uint32                     *hashPtr;              /**< \brief Hash of message: h */
} IfxPkc_Crypto_RsaAlgorithm;

/** \brief Data Structure for RSA CRT Algorithm
 */
typedef struct
{
    IfxPkc_Crypto_RsaCrtParameters rsaCrtParameters;       /**< \brief Data Structure for RSA CRT Parameters */
    uint32                        *cipherTextPtr;          /**< \brief Cipher text: C */
    uint32                        *plainTextPtr;           /**< \brief Plain text: M */
} IfxPkc_Crypto_RsaCrtAlgorithm;

/** \brief Data Structure for RSA CRT Key Parameters
 */
typedef struct
{
    IfxPkc_Parameter dP;         /**< \brief dP */
    IfxPkc_Parameter dQ;         /**< \brief dQ */
    IfxPkc_Parameter qInv;       /**< \brief qInv */
} IfxPkc_Crypto_RsaCrtKey;

/** \brief Data Structure for RSA Key Parameters
 */
typedef struct
{
    IfxPkc_Parameter modulus;          /**< \brief Modulus */
    IfxPkc_Parameter lambda;           /**< \brief Lambda */
    IfxPkc_Parameter privateKey;       /**< \brief Private Key */
} IfxPkc_Crypto_RsaKey;

/** \brief Data Structure for Shared Secret (SM2)
 */
typedef struct
{
    IfxPkc_Parameter xU;       /**< \brief xU */
    IfxPkc_Parameter yU;       /**< \brief yU */
} IfxPkc_Crypto_SharedSecret;

/** \brief Data Structure for SM2 Algorithm
 */
typedef struct
{
    IfxPkc_Crypto_Sm2Parameters sm2Parameters;           /**< \brief Data Structure for SM2 Parameters */
    IfxPkc_Crypto_Signature     signature;               /**< \brief Signature data */
    uint32                     *hashPtr;                 /**< \brief Hash of message: h */
    IfxPkc_Field                field;                   /**< \brief Defines the type of field */
    IfxPkc_Acceleration         curveAcceleration;       /**< \brief Enable accelerator for specific curve modulus */
    boolean                     enableEdwards;           /**< \brief Enable Edwards curve. Only supports GF(p). */
} IfxPkc_Crypto_Sm2Algorithm;

/** \brief Data Structure for SRP Algorithm
 * Edwards is not used. Acceleration not used. Field is always GF(P)
 */
typedef struct
{
    IfxPkc_Crypto_SrpParameters srpParameters;       /**< \brief Data Structure for SRP Parameters */
} IfxPkc_Crypto_SrpAlgorithm;

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Function to initialize the default configuration of module
 * \param pkcSFR Pointer to the PKC SFR
 * \param config Configuration structure for PKC module
 * \return None
 */
IFX_EXTERN void IfxPkc_Crypto_initModuleConfig(Ifx_PKC *pkcSFR, IfxPkc_Crypto_ModuleConfig *config);

/** \brief Function to initialize the module
 * \param pkc Pointer to the Handle of PKC Module
 * \param config Configuration structure for PKC module
 * \return None
 */
IFX_EXTERN IfxPkc_Status IfxPkc_Crypto_initModule(IfxPkc_Crypto *pkc, IfxPkc_Crypto_ModuleConfig *config);

/** \brief Function to initialize any PKC operation
 * \param pkc Pointer to the Handle of PKC Module
 * \param operation Pointer to operation configuration structure
 * \return Status of the operation
 */
IFX_EXTERN IfxPkc_Status IfxPkc_Crypto_initOperation(IfxPkc_Crypto *pkc, IfxPkc_Crypto_Operation *operation);

/** \brief Function to perform encryption of data
 * \param pkc Pointer to the Handle of PKC Module
 * \param plainTextPtr Source Plain text data pointer
 * \param cipherTextPtr Destination Cipher text data pointer
 * \param numWords number of words to be encrypted
 * \return Status of the operation
 */
IFX_EXTERN IfxPkc_Status IfxPkc_Crypto_encrypt(IfxPkc_Crypto *pkc, uint32 *plainTextPtr, uint32 *cipherTextPtr, uint32 numWords);

/** \brief Function to perform decryption of data
 * \param pkc Pointer to the Handle of PKC Module
 * \param plainTextPtr Destination Plain text data pointer
 * \param cipherTextPtr Source Cipher text data pointer
 * \param numWords number of words to be decrypted
 * \return Status of the operation
 */
IFX_EXTERN IfxPkc_Status IfxPkc_Crypto_decrypt(IfxPkc_Crypto *pkc, uint32 *plainTextPtr, uint32 *cipherTextPtr, uint32 numWords);

/** \brief Function to generate signature
 * \param pkc Pointer to the Handle of PKC Module
 * \param hashPtr Hash data
 * Note: EdDsa doesn't accept any hash as input so user may pass NULL_PTR
 * \param hashLength length of hash data in words
 * \param signaturePtr Signature data structure
 * \return Status of the operation
 */
IFX_EXTERN IfxPkc_Status IfxPkc_Crypto_generateSignature(IfxPkc_Crypto *pkc, uint32 *hashPtr, uint32 hashLength, IfxPkc_Crypto_Signature *signaturePtr);

/** \brief Function to verify signature. Returns failure if signature is invalid
 * Note: For EC-KCDSA, PKC engine doesn't perform complete verification but instead returns Point W (present in handle).
 * User needs to perform further steps on their own to complete verification. For more info refer UM.
 * \param pkc Pointer to the Handle of PKC Module
 * \param hashPtr Hash data
 * Note: EdDsa doesn't accept any hash as input so user may pass NULL_PTR
 * \param hashLength length of hash data in words
 * \param signaturePtr Signature data structure
 * \return Status of the operation
 */
IFX_EXTERN IfxPkc_Status IfxPkc_Crypto_verifySignature(IfxPkc_Crypto *pkc, uint32 *hashPtr, uint32 hashLength, IfxPkc_Crypto_Signature *signaturePtr);

/** \brief Function to generate key (and related parameters) for different algorithms
 * \param pkc Pointer to the Handle of PKC Module
 * \param keyPtr Pointer to the algorithm specific key data structure
 * The pointer should be typecasted to appropriate data type while calling this function.
 * \return Status of the operation
 */
IFX_EXTERN IfxPkc_Status IfxPkc_Crypto_generateKey(IfxPkc_Crypto *pkc, void *keyPtr);

/** \brief Function to check agreement of SM2 key exchange
 * and get shared secret (U = (xU, yU)) if agreement is successful or report failure otherwise
 * \param pkc Pointer to the Handle of PKC Module
 * \param sharedSecret Shared Secret
 * \return Status of the operation
 */
IFX_EXTERN IfxPkc_Status IfxPkc_Crypto_generateSharedSecret(IfxPkc_Crypto *pkc, IfxPkc_Crypto_SharedSecret *sharedSecret);

/** \brief Function to validate domain parameters of ECDSA
 * \param pkc Pointer to the Handle of PKC Module
 * \return Status of the operation
 */
IFX_EXTERN IfxPkc_Status IfxPkc_Crypto_validateDomainParameters(IfxPkc_Crypto *pkc);

/** \brief Function to generate Zero Knowledge Proof using J-PAKE Algorithm
 * \param pkc Pointer to the Handle of PKC Module
 * \param r Part of zkp = (V, r) where r is an integer
 * \return Status of the operation
 */
IFX_EXTERN IfxPkc_Status IfxPkc_Crypto_generateJPakeZkp(IfxPkc_Crypto *pkc, IfxPkc_Parameter *r);

/** \brief Function to verify Zero Knowledge Proof using J-PAKE Algorithm
 * \param pkc Pointer to the Handle of PKC Module
 * \return Status of the operation
 */
IFX_EXTERN IfxPkc_Status IfxPkc_Crypto_verifyJPakeZkp(IfxPkc_Crypto *pkc);

/** \brief Function to generate Step 2 of J-PAKE Algorithm
 * \param pkc Pointer to the Handle of PKC Module
 * \param A Resultant curve point A = GA * x2s
 * \param x2s Resultant Paramter x2s = x2 * s mod n, with shared password s
 * \param GA Resultant curve point GA = X1 + X3 + X4
 * \return Status of the operation
 */
IFX_EXTERN IfxPkc_Status IfxPkc_Crypto_generateJPakeStep2(IfxPkc_Crypto *pkc, IfxPkc_CurveParameter *A, IfxPkc_Parameter *x2s, IfxPkc_CurveParameter *GA);

/** \brief Function to do RSA Half CRT decryption for parallel processing
 * \param pkc Pointer to the Handle of PKC Module
 * \param cipherText Cipher text to be decrypted
 * \param vp Resultant intermediate output of RSA Half CRT decryption
 * Note: User needs to call this API two times (along with initOperation) to get both vp and vq
 * \return Status of the operation
 */
IFX_EXTERN IfxPkc_Status IfxPkc_Crypto_decryptHalfCrt(IfxPkc_Crypto *pkc, IfxPkc_Parameter *cipherText, IfxPkc_Parameter *vp);

/** \brief Function to recombine RSA Half CRT Outputs (vp, vq) into plain text
 * \param pkc Pointer to the Handle of PKC Module
 * \param vp Intermediate output of RSA Half CRT decryption
 * \param vq Intermediate output of RSA Half CRT decryption
 * \param plainText Result of recombination of vp and vq
 * \return Status of the operation
 */
IFX_EXTERN IfxPkc_Status IfxPkc_Crypto_recombineHalfCrtOutputs(IfxPkc_Crypto *pkc, IfxPkc_Parameter *vp, IfxPkc_Parameter *vq, IfxPkc_Parameter *plainText);

/** \brief Function to write data to DATARAM
 * \param pkc Pointer to the Handle of PKC Module
 * \param sourcePtr Pointer to source data from where the data is to be written
 * \param numWords Number of words to be written
 * \param memLocation Location of data in DATARAM
 * \return Status of the operation
 */
IFX_EXTERN IfxPkc_Status IfxPkc_Crypto_writeToDataram(IfxPkc_Crypto *pkc, uint32 *sourcePtr, uint32 numWords, IfxPkc_MemLocation memLocation);

/** \brief Function to read data from DATARAM
 * \param pkc Pointer to the Handle of PKC Module
 * \param destPtr Read data from DATARAM to this location
 * \param numWords Number of words to be read
 * \param memLocation Location of data in DATARAM
 * \return Status of the operation
 */
IFX_EXTERN IfxPkc_Status IfxPkc_Crypto_readFromDataram(IfxPkc_Crypto *pkc, uint32 *destPtr, uint32 numWords, IfxPkc_MemLocation memLocation);
#endif /* IFXPKC_CRYPTO_H */
