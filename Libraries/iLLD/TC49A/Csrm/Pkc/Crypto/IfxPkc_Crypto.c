/**
 * \file IfxPkc_Crypto.c
 * \brief PKC CRYPTO details
 *
 * \version iLLD_2_0_1_2_19
 * \copyright Copyright (c) 2022 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 *
 */

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "IfxPkc_Crypto.h"

/******************************************************************************/
/*-----------------------Private Function Prototypes--------------------------*/
/******************************************************************************/

/** \brief Function to start the PKC operation and check for timeout / errors.
 * Returns after operation is finished or timeout is reached.
 * \param pkc Pointer to the Handle of PKC Module
 * \return Status of the operation
 */
IFX_STATIC IfxPkc_Status IfxPkc_Crypto_performOperation(IfxPkc_Crypto *pkc);

/** \brief Function to initialize registers and DATARAM for RSA operations
 * \param pkc Pointer to the Handle of PKC Module
 * \param rsa RSA algorithm structure
 * \return Status of the operation
 */
IFX_STATIC IfxPkc_Status IfxPkc_Crypto_initRsaOperation(IfxPkc_Crypto *pkc, IfxPkc_Crypto_RsaAlgorithm *rsa);

/** \brief Function to initialize registers and DATARAM for RSA CRT operations
 * \param pkc Pointer to the Handle of PKC Module
 * \param rsaCrt RSA CRT algorithm structure
 * \return Status of the operation
 */
IFX_STATIC IfxPkc_Status IfxPkc_Crypto_initRsaCrtOperation(IfxPkc_Crypto *pkc, IfxPkc_Crypto_RsaCrtAlgorithm *rsaCrt);

/** \brief Function to initialize the DATARAM with static parameters for ECDSA operations
 * \param pkc Pointer to the Handle of PKC Module
 * \param ecdsa ECDSA algorithm structure
 * \return Status of the operation
 */
IFX_STATIC IfxPkc_Status IfxPkc_Crypto_initEcdsaOperation(IfxPkc_Crypto *pkc, IfxPkc_Crypto_EcdsaAlgorithm *ecdsa);

/** \brief Function to initialize registers and DATARAM for DSA operations
 * \param pkc Pointer to the Handle of PKC Module
 * \param dsa DSA algorithm structure
 * \return Status of the operation
 */
IFX_STATIC IfxPkc_Status IfxPkc_Crypto_initDsaOperation(IfxPkc_Crypto *pkc, IfxPkc_Crypto_DsaAlgorithm *dsa);

/** \brief Function to initialize the DATARAM with static parameters for EC-KCDSA operations
 * \param pkc Pointer to the Handle of PKC Module
 * \param eckcdsa EC-KCDSA algorithm structure
 * \return Status of the operation
 */
IFX_STATIC IfxPkc_Status IfxPkc_Crypto_initEckcdsaOperation(IfxPkc_Crypto *pkc, IfxPkc_Crypto_EckcdsaAlgorithm *eckcdsa);

/** \brief Function to initialize the DATARAM with static parameters for EdDSA operations
 * \param pkc Pointer to the Handle of PKC Module
 * \param edDsa EdDSA algorithm structure
 * \return Status of the operation
 */
IFX_STATIC IfxPkc_Status IfxPkc_Crypto_initEdDsaOperation(IfxPkc_Crypto *pkc, IfxPkc_Crypto_EdDsaAlgorithm *edDsa);

/** \brief Function to initialize the DATARAM with static parameters for SM2 operations
 * \param pkc Pointer to the Handle of PKC Module
 * \param sm2 SM2 algorithm structure
 * \return Status of the operation
 */
IFX_STATIC IfxPkc_Status IfxPkc_Crypto_initSm2Operation(IfxPkc_Crypto *pkc, IfxPkc_Crypto_Sm2Algorithm *sm2);

/** \brief Function to initialize the DATARAM with static parameters for SRP operations
 * \param pkc Pointer to the Handle of PKC Module
 * \param srp SRP algorithm structure
 * \return Status of the operation
 */
IFX_STATIC IfxPkc_Status IfxPkc_Crypto_initSrpOperation(IfxPkc_Crypto *pkc, IfxPkc_Crypto_SrpAlgorithm *srp);

/** \brief Function to initialize the DATARAM with static parameters for J-PAKE operations
 * \param pkc Pointer to the Handle of PKC Module
 * \param jPake J-PAKE algorithm structure
 * \return Status of the operation
 */
IFX_STATIC IfxPkc_Status IfxPkc_Crypto_initJPakeOperation(IfxPkc_Crypto *pkc, IfxPkc_Crypto_JPakeAlgorithm *jPake);

/** \brief Function to perform crypto operation using RSA algorithm. Write dynamic parameters, perform operation, read results.
 * \param pkc Pointer to the Handle of PKC Module
 * \param numWords Number of words to be encrypted/decrypted
 * \param cryptoOp Type of operation (encrypt/decrypt)
 * \return Status of the operation
 */
IFX_STATIC IfxPkc_Status IfxPkc_Crypto_performRsaCrypto(IfxPkc_Crypto *pkc, uint32 numWords, IfxPkc_CryptoOp cryptoOp);

/** \brief Function to perform crypto operation using RSA CRT algorithm. Write dynamic parameters, perform operation, read results.
 * \param pkc Pointer to the Handle of PKC Module
 * \param numWords Number of words to decrypted
 * \param cryptoOp Type of operation (only decrypt is supported)
 * \return Status of the operation
 */
IFX_STATIC IfxPkc_Status IfxPkc_Crypto_performRsaCrtCrypto(IfxPkc_Crypto *pkc, uint32 numWords, IfxPkc_CryptoOp cryptoOp);

/** \brief Function to perform signature related operation using RSA algorithm. Write dynamic parameters, perform operation, read results.
 * \param pkc Pointer to the Handle of PKC Module
 * \param hashLength Length of hash in words
 * \param signatureOp Type of operation (signature generate/verify)
 * \return Status of the operation
 */
IFX_STATIC IfxPkc_Status IfxPkc_Crypto_performRsaSignature(IfxPkc_Crypto *pkc, uint32 hashLength, IfxPkc_SignatureOp signatureOp);

/** \brief Function to perform signature related operation using ECDSA algorithm. Write dynamic parameters, perform operation, read results.
 * \param pkc Pointer to the Handle of PKC Module
 * \param hashLength Length of hash in words
 * \param signatureOp Type of operation (signature generate/verify)
 * \return Status of the operation
 */
IFX_STATIC IfxPkc_Status IfxPkc_Crypto_performEcdsaSignature(IfxPkc_Crypto *pkc, uint32 hashLength, IfxPkc_SignatureOp signatureOp);

/** \brief Function to perform signature related operation using DSA algorithm. Write dynamic parameters, perform operation, read results.
 * \param pkc Pointer to the Handle of PKC Module
 * \param hashLength Length of hash in words
 * \param signatureOp Type of operation (signature generate/verify)
 * \return Status of the operation
 */
IFX_STATIC IfxPkc_Status IfxPkc_Crypto_performDsaSignature(IfxPkc_Crypto *pkc, uint32 hashLength, IfxPkc_SignatureOp signatureOp);

/** \brief Function to perform signature related operation using EC-KCDSA algorithm. Write dynamic parameters, perform operation, read results.
 * \param pkc Pointer to the Handle of PKC Module
 * \param hashLength Length of hash in words
 * \param signatureOp Type of operation (signature generate/verify)
 * \return Status of the operation
 */
IFX_STATIC IfxPkc_Status IfxPkc_Crypto_performEckcdsaSignature(IfxPkc_Crypto *pkc, uint32 hashLength, IfxPkc_SignatureOp signatureOp);

/** \brief Function to perform signature related operation using EdDsa algorithm. Write dynamic parameters, perform operation, read results.
 * \param pkc Pointer to the Handle of PKC Module
 * \param signatureOp Type of operation (signature generate/verify)
 * \return Status of the operation
 */
IFX_STATIC IfxPkc_Status IfxPkc_Crypto_performEdDsaSignature(IfxPkc_Crypto *pkc, IfxPkc_SignatureOp signatureOp);

/** \brief Function to perform signature related operation using SM2 algorithm. Write dynamic parameters, perform operation, read results.
 * \param pkc Pointer to the Handle of PKC Module
 * \param hashLength Length of hash in words
 * \param signatureOp Type of operation (signature generate/verify)
 * \return Status of the operation
 */
IFX_STATIC IfxPkc_Status IfxPkc_Crypto_performSm2Signature(IfxPkc_Crypto *pkc, uint32 hashLength, IfxPkc_SignatureOp signatureOp);

/** \brief Function to generate key using RSA algorithm.
 * \param pkc Pointer to the Handle of PKC Module
 * \param rsaKey Pointer to rsa key data structure
 * \return Status of the operation
 */
IFX_STATIC IfxPkc_Status IfxPkc_Crypto_performRsaKeyGeneration(IfxPkc_Crypto *pkc, IfxPkc_Crypto_RsaKey *rsaKey);

/** \brief Function to generate key using RSA CRT algorithm.
 * \param pkc Pointer to the Handle of PKC Module
 * \param rsaCrtKey Pointer to rsa crt key data structure
 * \return Status of the operation
 */
IFX_STATIC IfxPkc_Status IfxPkc_Crypto_performRsaCrtKeyGeneration(IfxPkc_Crypto *pkc, IfxPkc_Crypto_RsaCrtKey *rsaCrtKey);

/** \brief Function to generate key using DSA algorithm.
 * \param pkc Pointer to the Handle of PKC Module
 * \param dsaKey Pointer to dsa key
 * \return Status of the operation
 */
IFX_STATIC IfxPkc_Status IfxPkc_Crypto_performDsaKeyGeneration(IfxPkc_Crypto *pkc, IfxPkc_Crypto_DsaKey *dsaKey);

/** \brief Function to generate key using EC-KCDSA algorithm.
 * \param pkc Pointer to the Handle of PKC Module
 * \param eckcdsaKey Pointer to eckcdsa key data structure
 * \return Status of the operation
 */
IFX_STATIC IfxPkc_Status IfxPkc_Crypto_performEckcdsaKeyGeneration(IfxPkc_Crypto *pkc, IfxPkc_Crypto_EckcdsaKey *eckcdsaKey);

/** \brief Function to generate Public/Session key using SRP algorithm.
 * \param pkc Pointer to the Handle of PKC Module
 * \param srpKey Pointer to SRP key data type
 * \return Status of the operation
 */
IFX_STATIC IfxPkc_Status IfxPkc_Crypto_performSrpKeyGeneration(IfxPkc_Crypto *pkc, IfxPkc_Crypto_SrpKey *srpKey);

/** \brief Function to generate session key using J-PAKE algorithm.
 * \param pkc Pointer to the Handle of PKC Module
 * \param jPakeKey Pointer to J-PAKE key data type
 * \return Status of the operation
 */
IFX_STATIC IfxPkc_Status IfxPkc_Crypto_performJPakeKeyGeneration(IfxPkc_Crypto *pkc, IfxPkc_Crypto_JPakeKey *jPakeKey);

/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxPkc_Crypto_initModuleConfig(Ifx_PKC *pkcSFR, IfxPkc_Crypto_ModuleConfig *config)
{
    const IfxPkc_Crypto_ModuleConfig defaultConfig = {
        .pkcSFR = NULL_PTR,
        .endian = IfxPkc_Endian_little
    };

    *config        = defaultConfig;

    config->pkcSFR = pkcSFR;
}


IfxPkc_Status IfxPkc_Crypto_initModule(IfxPkc_Crypto *pkc, IfxPkc_Crypto_ModuleConfig *config)
{
    IfxPkc_Status status = IfxPkc_Status_success;

    /* Check whether module is busy */
    if (IfxPkc_isModuleBusy(config->pkcSFR) != TRUE)
    {
        pkc->state       = IfxPkc_State_unknown;

        pkc->errors.Word = 0U;

        /* Get data from config structure */
        pkc->pkcSFR             = config->pkcSFR;
        pkc->endian             = config->endian;

        pkc->pkcSFR->CMD.B.SWAP = (uint32)(pkc->endian);

        pkc->state              = IfxPkc_State_moduleInitialized;
    }
    else /* Module is busy */
    {
        /* do nothing, return failure */
        status = IfxPkc_Status_failure;
    }

    return status;
}


IfxPkc_Status IfxPkc_Crypto_initOperation(IfxPkc_Crypto *pkc, IfxPkc_Crypto_Operation *operation)
{
    IfxPkc_Status status = IfxPkc_Status_success;

    /* Check whether module is in correct state */
    if ((pkc->state >= IfxPkc_State_moduleInitialized) && (pkc->state < IfxPkc_State_opBusy))
    {
        Ifx_PKC             *pkcSFR        = pkc->pkcSFR;
        IfxPkc_OperationType operationType = operation->operationType;
        uint32               dataSizeWords = IFXPKC_CALCWORDS_FROMBYTES((operation->dataSize));

        /* clear all errors in handle */
        pkc->errors.Word   = 0U;

        pkc->operationType = operationType;
        pkc->algoMechanism = operation->algoMechanism;

        /* Check that dataSize configured by user is valid */
        if (dataSizeWords <= IFXPKC_MAX_DATASIZE_WORDS)
        {
            pkc->dataSize = operation->dataSize;
        }
        else /* Invalid dataSize */
        {
            status |= IfxPkc_Status_failure;
        }

        /* Step 1. Clear DATARAM */
        status |= IfxPkc_clearDataram(pkc->pkcSFR);

        if (status == IfxPkc_Status_success)
        {
            /* Step 2: Write operation independent configuration */
            Ifx_PKC_CMD cfg;
            cfg.U         = pkcSFR->CMD.U;

            cfg.B.SIZE    = (uint32)((uint32)(operation->dataSize) - (uint32)1);  // Number of bytes - 1

            pkcSFR->CMD.U = cfg.U;

            /* Step 3: Do rest of the initialization depending on operation type */
            /* Configure for RSA */
            if (((operationType >= IfxPkc_OperationType_RSAENC) && (operationType <= IfxPkc_OperationType_RSAVER)) ||
                (operationType == IfxPkc_OperationType_RSAPKGEN))
            {
                status = IfxPkc_Crypto_initRsaOperation(pkc, (IfxPkc_Crypto_RsaAlgorithm *)operation->algoMechanism);
            }
            /* Configure for RSA CRT */
            else if (((operationType >= IfxPkc_OperationType_RSACRTKEYPARGEN) && (operationType <= IfxPkc_OperationType_RSACRTDEC)) ||
                     (operationType == IfxPkc_OperationType_RSAHLFCRTDEC) ||
                     (operationType == IfxPkc_OperationType_RSAHLFCRTREC))
            {
                status = IfxPkc_Crypto_initRsaCrtOperation(pkc, (IfxPkc_Crypto_RsaCrtAlgorithm *)operation->algoMechanism);
            }
            /* Configure for ECDSA */
            else if ((operationType >= IfxPkc_OperationType_ECDSASIG) && (operationType <= IfxPkc_OperationType_ECDSAPV))
            {
                status = IfxPkc_Crypto_initEcdsaOperation(pkc, (IfxPkc_Crypto_EcdsaAlgorithm *)operation->algoMechanism);
            }
            /* Configure for DSA */
            else if ((operationType >= IfxPkc_OperationType_DSAKEYGEN) && (operationType <= IfxPkc_OperationType_DSAVER))
            {
                status = IfxPkc_Crypto_initDsaOperation(pkc, (IfxPkc_Crypto_DsaAlgorithm *)operation->algoMechanism);
            }
            /* Configure for EC-KCDSA */
            else if ((operationType >= IfxPkc_OperationType_ECKCDSAPUBKEYGEN) && (operationType <= IfxPkc_OperationType_ECKCDSAVER))
            {
                status = IfxPkc_Crypto_initEckcdsaOperation(pkc, (IfxPkc_Crypto_EckcdsaAlgorithm *)operation->algoMechanism);
            }
            /* Configure for EdDSA */
            else if ((operationType == IfxPkc_OperationType_EDDSASIG) || (operationType == IfxPkc_OperationType_EDDSAVER))
            {
                status = IfxPkc_Crypto_initEdDsaOperation(pkc, (IfxPkc_Crypto_EdDsaAlgorithm *)operation->algoMechanism);
            }
            /* Configure for SM2 */
            else if ((operationType >= IfxPkc_OperationType_SM2SIG) && (operationType <= IfxPkc_OperationType_SM2KEYEXCH))
            {
                status = IfxPkc_Crypto_initSm2Operation(pkc, (IfxPkc_Crypto_Sm2Algorithm *)operation->algoMechanism);
            }
            /* Configure for SRP */
            else if (((operationType >= IfxPkc_OperationType_SRPSRVKEY) && (operationType <= IfxPkc_OperationType_SRPCLTKEY)) || (operationType == IfxPkc_OperationType_SRPSRVPUB))
            {
                status = IfxPkc_Crypto_initSrpOperation(pkc, (IfxPkc_Crypto_SrpAlgorithm *)operation->algoMechanism);
            }
            /* Configure for J-PAKE */
            else if ((operationType >= IfxPkc_OperationType_JPAKEZKPGEN) && (operationType <= IfxPkc_OperationType_JPAKEGENSTP2) && (operationType != IfxPkc_OperationType_JPAKE3PADD))
            {
                status = IfxPkc_Crypto_initJPakeOperation(pkc, (IfxPkc_Crypto_JPakeAlgorithm *)operation->algoMechanism);
            }
            /* Unsupported operation type */
            else
            {
                status = IfxPkc_Status_failure;
            }
        }
    }
    else /* Module is uninitialized */
    {
        /* do nothing, return failure */
        status = IfxPkc_Status_failure;
    }

    if (status == IfxPkc_Status_success)
    {
        pkc->state = IfxPkc_State_operationInitialized;
    }

    return status;
}


IfxPkc_Status IfxPkc_Crypto_encrypt(IfxPkc_Crypto *pkc, uint32 *plainTextPtr, uint32 *cipherTextPtr, uint32 numWords)
{
    IfxPkc_Status        status          = IfxPkc_Status_failure;
    IfxPkc_OperationType operationType   = pkc->operationType;
    /* current error status in STAT regiser */
    boolean              algoErrorStatus = IfxPkc_getAlgoErrorStatus(pkc->pkcSFR, pkc->operationType);

    /* Allow user to perform operations if
     * 1. Operation is initialized
     * 2. Last operation resulted in error and the user wants to retry with new dynamic parameters
     */
    if ((pkc->state == IfxPkc_State_operationInitialized) || ((pkc->state == IfxPkc_State_error) && (algoErrorStatus == TRUE)))
    {
        switch (operationType)
        {
        case IfxPkc_OperationType_RSAENC:
        {
            IfxPkc_Crypto_RsaAlgorithm *rsa = (IfxPkc_Crypto_RsaAlgorithm *)(pkc->algoMechanism);
            rsa->plainTextPtr  = plainTextPtr;
            rsa->cipherTextPtr = cipherTextPtr;
            status             = IfxPkc_Crypto_performRsaCrypto(pkc, numWords, IfxPkc_CryptoOp_encrypt);
            break;
        }
        default: break;
        }
    }

    return status;
}


IfxPkc_Status IfxPkc_Crypto_decrypt(IfxPkc_Crypto *pkc, uint32 *plainTextPtr, uint32 *cipherTextPtr, uint32 numWords)
{
    IfxPkc_Status        status          = IfxPkc_Status_failure;
    IfxPkc_OperationType operationType   = pkc->operationType;
    /* current error status in STAT regiser */
    boolean              algoErrorStatus = IfxPkc_getAlgoErrorStatus(pkc->pkcSFR, pkc->operationType);

    if ((pkc->state == IfxPkc_State_operationInitialized) || ((pkc->state == IfxPkc_State_error) && (algoErrorStatus == TRUE)))
    {
        switch (operationType)
        {
        case IfxPkc_OperationType_RSADEC:
        {
            IfxPkc_Crypto_RsaAlgorithm *rsa = (IfxPkc_Crypto_RsaAlgorithm *)(pkc->algoMechanism);
            rsa->plainTextPtr  = plainTextPtr;
            rsa->cipherTextPtr = cipherTextPtr;
            status             = IfxPkc_Crypto_performRsaCrypto(pkc, numWords, IfxPkc_CryptoOp_decrypt);
            break;
        }
        case IfxPkc_OperationType_RSACRTDEC:
        {
            IfxPkc_Crypto_RsaCrtAlgorithm *rsaCrt = (IfxPkc_Crypto_RsaCrtAlgorithm *)(pkc->algoMechanism);
            rsaCrt->plainTextPtr  = plainTextPtr;
            rsaCrt->cipherTextPtr = cipherTextPtr;
            status                = IfxPkc_Crypto_performRsaCrtCrypto(pkc, numWords, IfxPkc_CryptoOp_decrypt);
            break;
        }
        default: break;
        }
    }

    return status;
}


IfxPkc_Status IfxPkc_Crypto_generateSignature(IfxPkc_Crypto *pkc, uint32 *hashPtr, uint32 hashLength, IfxPkc_Crypto_Signature *signaturePtr)
{
    IfxPkc_Status        status        = IfxPkc_Status_failure;
    IfxPkc_OperationType operationType = pkc->operationType;

    /* read current error status in STAT regiser */
    boolean              algoErrorStatus = IfxPkc_getAlgoErrorStatus(pkc->pkcSFR, pkc->operationType);

    if ((pkc->state == IfxPkc_State_operationInitialized) || ((pkc->state == IfxPkc_State_error) && (algoErrorStatus == TRUE)))
    {
        /* Store signature related parameters in handle */
        IfxPkc_Crypto_Signature signature;
        signature.r           = signaturePtr->r;
        signature.s           = signaturePtr->s;
        signature.sizeInWords = signaturePtr->sizeInWords;

        switch (operationType)
        {
        /* RSA Signature Generation */
        case IfxPkc_OperationType_RSASIG:
        {
            IfxPkc_Crypto_RsaAlgorithm *rsa = (IfxPkc_Crypto_RsaAlgorithm *)(pkc->algoMechanism);
            rsa->hashPtr   = hashPtr;
            rsa->signature = signature;
            status         = IfxPkc_Crypto_performRsaSignature(pkc, hashLength, IfxPkc_SignatureOp_generate);
            break;
        }
        /* ECDSA Signature Generation */
        case IfxPkc_OperationType_ECDSASIG:
        {
            IfxPkc_Crypto_EcdsaAlgorithm *ecdsa = (IfxPkc_Crypto_EcdsaAlgorithm *)(pkc->algoMechanism);
            ecdsa->hashPtr   = hashPtr;
            ecdsa->signature = signature;
            status           = IfxPkc_Crypto_performEcdsaSignature(pkc, hashLength, IfxPkc_SignatureOp_generate);
            break;
        }
        /* DSA Signature Generation */
        case IfxPkc_OperationType_DSASIG:
        {
            IfxPkc_Crypto_DsaAlgorithm *dsa = (IfxPkc_Crypto_DsaAlgorithm *)(pkc->algoMechanism);
            dsa->hashPtr   = hashPtr;
            dsa->signature = signature;
            status         = IfxPkc_Crypto_performDsaSignature(pkc, hashLength, IfxPkc_SignatureOp_generate);
            break;
        }
        /* EC-KCDSA Signature Generation */
        case IfxPkc_OperationType_ECKCDSASIG:
        {
            IfxPkc_Crypto_EckcdsaAlgorithm *eckcdsa = (IfxPkc_Crypto_EckcdsaAlgorithm *)(pkc->algoMechanism);
            eckcdsa->hashPtr   = hashPtr;
            eckcdsa->signature = signature;
            status             = IfxPkc_Crypto_performEckcdsaSignature(pkc, hashLength, IfxPkc_SignatureOp_generate);
            break;
        }
        /* EDDSA Signature Generation */
        case IfxPkc_OperationType_EDDSASIG:
        {
            IfxPkc_Crypto_EdDsaAlgorithm *edDsa = (IfxPkc_Crypto_EdDsaAlgorithm *)(pkc->algoMechanism);
            edDsa->signature = signature;
            status           = IfxPkc_Crypto_performEdDsaSignature(pkc, IfxPkc_SignatureOp_generate);
            break;
        }
        /* SM2 Signature Generation */
        case IfxPkc_OperationType_SM2SIG:
        {
            IfxPkc_Crypto_Sm2Algorithm *sm2 = (IfxPkc_Crypto_Sm2Algorithm *)(pkc->algoMechanism);
            sm2->hashPtr   = hashPtr;
            sm2->signature = signature;
            status         = IfxPkc_Crypto_performSm2Signature(pkc, hashLength, IfxPkc_SignatureOp_generate);
            break;
        }
        /* Unsupported operation type */
        default: break;
        }
    }

    return status;
}


IfxPkc_Status IfxPkc_Crypto_verifySignature(IfxPkc_Crypto *pkc, uint32 *hashPtr, uint32 hashLength, IfxPkc_Crypto_Signature *signaturePtr)
{
    IfxPkc_Status        status        = IfxPkc_Status_failure;
    IfxPkc_OperationType operationType = pkc->operationType;

    /* read current error status in STAT regiser */
    boolean              algoErrorStatus = IfxPkc_getAlgoErrorStatus(pkc->pkcSFR, pkc->operationType);

    if ((pkc->state == IfxPkc_State_operationInitialized) || ((pkc->state == IfxPkc_State_error) && (algoErrorStatus == TRUE)))
    {
        /* Store signature related parameters in handle */
        IfxPkc_Crypto_Signature signature;
        signature.r           = signaturePtr->r;
        signature.s           = signaturePtr->s;
        signature.sizeInWords = signaturePtr->sizeInWords;

        switch (operationType)
        {
        /* RSA Signature Verification */
        case IfxPkc_OperationType_RSAVER:
        {
            IfxPkc_Crypto_RsaAlgorithm *rsa = (IfxPkc_Crypto_RsaAlgorithm *)(pkc->algoMechanism);
            rsa->hashPtr   = hashPtr;
            rsa->signature = signature;
            status         = IfxPkc_Crypto_performRsaSignature(pkc, hashLength, IfxPkc_SignatureOp_verify);
            break;
        }
        /* ECDSA Signature Verification */
        case IfxPkc_OperationType_ECDSAVER:
        {
            IfxPkc_Crypto_EcdsaAlgorithm *ecdsa = (IfxPkc_Crypto_EcdsaAlgorithm *)(pkc->algoMechanism);
            ecdsa->hashPtr   = hashPtr;
            ecdsa->signature = signature;
            status           = IfxPkc_Crypto_performEcdsaSignature(pkc, hashLength, IfxPkc_SignatureOp_verify);
            break;
        }
        /* DSA Signature Verification */
        case IfxPkc_OperationType_DSAVER:
        {
            IfxPkc_Crypto_DsaAlgorithm *dsa = (IfxPkc_Crypto_DsaAlgorithm *)(pkc->algoMechanism);
            dsa->hashPtr   = hashPtr;
            dsa->signature = signature;
            status         = IfxPkc_Crypto_performDsaSignature(pkc, hashLength, IfxPkc_SignatureOp_verify);
            break;
        }
        /* EDDSA Signature Generation */
        case IfxPkc_OperationType_EDDSAVER:
        {
            IfxPkc_Crypto_EdDsaAlgorithm *edDsa = (IfxPkc_Crypto_EdDsaAlgorithm *)(pkc->algoMechanism);
            edDsa->signature = signature;
            status           = IfxPkc_Crypto_performEdDsaSignature(pkc, IfxPkc_SignatureOp_verify);
            break;
        }
        /* SM2 Signature Verification */
        case IfxPkc_OperationType_SM2VER:
        {
            IfxPkc_Crypto_Sm2Algorithm *sm2 = (IfxPkc_Crypto_Sm2Algorithm *)(pkc->algoMechanism);
            sm2->hashPtr   = hashPtr;
            sm2->signature = signature;
            status         = IfxPkc_Crypto_performSm2Signature(pkc, hashLength, IfxPkc_SignatureOp_verify);
            break;
        }
        /* EC-KCDSA Signature Verification */
        case IfxPkc_OperationType_ECKCDSAVER:
        {
            IfxPkc_Crypto_EckcdsaAlgorithm *eckcdsa = (IfxPkc_Crypto_EckcdsaAlgorithm *)(pkc->algoMechanism);
            eckcdsa->hashPtr   = hashPtr;
            eckcdsa->signature = signature;
            status             = IfxPkc_Crypto_performEckcdsaSignature(pkc, hashLength, IfxPkc_SignatureOp_verify);
            break;
        }
        /* Unsupported operation type */
        default: break;
        }
    }

    return status;
}


IfxPkc_Status IfxPkc_Crypto_generateKey(IfxPkc_Crypto *pkc, void *keyPtr)
{
    IfxPkc_Status        status          = IfxPkc_Status_failure;
    IfxPkc_OperationType operationType   = pkc->operationType;
    /* read current error status in STAT regiser */
    boolean              algoErrorStatus = IfxPkc_getAlgoErrorStatus(pkc->pkcSFR, pkc->operationType);

    if ((pkc->state == IfxPkc_State_operationInitialized) || ((pkc->state == IfxPkc_State_error) && (algoErrorStatus == TRUE)))
    {
        switch (operationType)
        {
        /* RSA Private Key generation */
        case IfxPkc_OperationType_RSAPKGEN:
        {
            status = IfxPkc_Crypto_performRsaKeyGeneration(pkc, (IfxPkc_Crypto_RsaKey *)keyPtr);
            break;
        }
        /* RSA CRT Key Parameter generation */
        case IfxPkc_OperationType_RSACRTKEYPARGEN:
        {
            status = IfxPkc_Crypto_performRsaCrtKeyGeneration(pkc, (IfxPkc_Crypto_RsaCrtKey *)keyPtr);
            break;
        }
        /* DSA Key generation */
        case IfxPkc_OperationType_DSAKEYGEN:
        {
            status = IfxPkc_Crypto_performDsaKeyGeneration(pkc, (IfxPkc_Crypto_DsaKey *)keyPtr);
            break;
        }
        /* EC-KCDSA Key generation */
        case IfxPkc_OperationType_ECKCDSAPUBKEYGEN:
        {
            status = IfxPkc_Crypto_performEckcdsaKeyGeneration(pkc, (IfxPkc_Crypto_EckcdsaKey *)keyPtr);
            break;
        }
        /* SRP Public/Session Key generation */
        case IfxPkc_OperationType_SRPCLTKEY:
        case IfxPkc_OperationType_SRPSRVKEY:
        case IfxPkc_OperationType_SRPSRVPUB:
        {
            status = IfxPkc_Crypto_performSrpKeyGeneration(pkc, (IfxPkc_Crypto_SrpKey *)keyPtr);
            break;
        }
        /* JPAKE Session Key */
        case IfxPkc_OperationType_JPAKEKEYGEN:
        {
            status = IfxPkc_Crypto_performJPakeKeyGeneration(pkc, (IfxPkc_Crypto_JPakeKey *)keyPtr);
            break;
        }
        /* Unsupported operation type */
        default: break;
        }
    }

    return status;
}


IfxPkc_Status IfxPkc_Crypto_generateSharedSecret(IfxPkc_Crypto *pkc, IfxPkc_Crypto_SharedSecret *sharedSecret)
{
    IfxPkc_Status        status        = IfxPkc_Status_failure;
    IfxPkc_OperationType operationType = pkc->operationType;
    IfxPkc_Parameter     parameter;
    /* current error status in STAT regiser */
    boolean              algoErrorStatus = IfxPkc_getAlgoErrorStatus(pkc->pkcSFR, pkc->operationType);

    if ((pkc->state == IfxPkc_State_operationInitialized) || ((pkc->state == IfxPkc_State_error) && (algoErrorStatus == TRUE)))
    {
        switch (operationType)
        {
        /* SM2 */
        case IfxPkc_OperationType_SM2KEYEXCH:
        {
            status = IfxPkc_Crypto_performOperation(pkc);

            /* Key exchange agreement successful. Read shared secret */
            if (status == IfxPkc_Status_success)
            {
                parameter = sharedSecret->xU;
                status   |= IfxPkc_Crypto_readFromDataram(pkc, parameter.dataPtr, parameter.sizeInWords, IfxPkc_MemLocation_D);

                parameter = sharedSecret->yU;
                status   |= IfxPkc_Crypto_readFromDataram(pkc, parameter.dataPtr, parameter.sizeInWords, IfxPkc_MemLocation_E);
            }

            break;
        }
        /* Unsupported operation type */
        default: break;
        }
    }

    return status;
}


IfxPkc_Status IfxPkc_Crypto_validateDomainParameters(IfxPkc_Crypto *pkc)
{
    IfxPkc_Status        status          = IfxPkc_Status_failure;
    IfxPkc_OperationType operationType   = pkc->operationType;
    /* current error status in STAT regiser */
    boolean              algoErrorStatus = IfxPkc_getAlgoErrorStatus(pkc->pkcSFR, pkc->operationType);

    if ((pkc->state == IfxPkc_State_operationInitialized) || ((pkc->state == IfxPkc_State_error) && (algoErrorStatus == TRUE)))
    {
        switch (operationType)
        {
        case IfxPkc_OperationType_ECDSAPV:
        {
            status = IfxPkc_Crypto_performOperation(pkc);
            break;
        }
        default: break;
        }
    }

    return status;
}


IfxPkc_Status IfxPkc_Crypto_generateJPakeZkp(IfxPkc_Crypto *pkc, IfxPkc_Parameter *r)
{
    IfxPkc_Status status          = IfxPkc_Status_failure;
    /* read current error status in STAT regiser */
    boolean       algoErrorStatus = IfxPkc_getAlgoErrorStatus(pkc->pkcSFR, pkc->operationType);

    if ((pkc->state == IfxPkc_State_operationInitialized) || ((pkc->state == IfxPkc_State_error) && (algoErrorStatus == TRUE)))
    {
        if (pkc->operationType == IfxPkc_OperationType_JPAKEZKPGEN)
        {
            /* Perform the operation */
            status = IfxPkc_Crypto_performOperation(pkc);

            /* Read output data */
            if (status == IfxPkc_Status_success)
            {
                /* Read signature from r location */
                status |= IfxPkc_Crypto_readFromDataram(pkc, r->dataPtr, r->sizeInWords, (IfxPkc_MemLocation)IfxPkc_JPakeParamLocation_r);
            }
        }
    }

    return status;
}


IfxPkc_Status IfxPkc_Crypto_verifyJPakeZkp(IfxPkc_Crypto *pkc)
{
    IfxPkc_Status status          = IfxPkc_Status_failure;
    /* read current error status in STAT regiser */
    boolean       algoErrorStatus = IfxPkc_getAlgoErrorStatus(pkc->pkcSFR, pkc->operationType);

    if ((pkc->state == IfxPkc_State_operationInitialized) || ((pkc->state == IfxPkc_State_error) && (algoErrorStatus == TRUE)))
    {
        if (pkc->operationType == IfxPkc_OperationType_JPAKEZKPVER)
        {
            /* Perform the operation */
            status = IfxPkc_Crypto_performOperation(pkc);
        }
    }

    return status;
}


IfxPkc_Status IfxPkc_Crypto_generateJPakeStep2(IfxPkc_Crypto *pkc, IfxPkc_CurveParameter *A, IfxPkc_Parameter *x2s, IfxPkc_CurveParameter *GA)
{
    IfxPkc_Status status          = IfxPkc_Status_failure;
    /* read current error status in STAT regiser */
    boolean       algoErrorStatus = IfxPkc_getAlgoErrorStatus(pkc->pkcSFR, pkc->operationType);

    if ((pkc->state == IfxPkc_State_operationInitialized) || ((pkc->state == IfxPkc_State_error) && (algoErrorStatus == TRUE)))
    {
        if (pkc->operationType == IfxPkc_OperationType_JPAKEGENSTP2)
        {
            /* Perform the operation */
            status = IfxPkc_Crypto_performOperation(pkc);

            /* Read result */
            if (status == IfxPkc_Status_success)
            {
                IfxPkc_Parameter parameter;
                parameter = A->x;
                status   |= IfxPkc_Crypto_readFromDataram(pkc, parameter.dataPtr, parameter.sizeInWords, IfxPkc_MemLocation_8);

                parameter = A->y;
                status   |= IfxPkc_Crypto_readFromDataram(pkc, parameter.dataPtr, parameter.sizeInWords, IfxPkc_MemLocation_9);

                status   |= IfxPkc_Crypto_readFromDataram(pkc, x2s->dataPtr, x2s->sizeInWords, IfxPkc_MemLocation_B);

                parameter = GA->x;
                status   |= IfxPkc_Crypto_readFromDataram(pkc, parameter.dataPtr, parameter.sizeInWords, IfxPkc_MemLocation_D);

                parameter = GA->y;
                status   |= IfxPkc_Crypto_readFromDataram(pkc, parameter.dataPtr, parameter.sizeInWords, IfxPkc_MemLocation_E);
            }
        }
    }

    return status;
}


IfxPkc_Status IfxPkc_Crypto_decryptHalfCrt(IfxPkc_Crypto *pkc, IfxPkc_Parameter *cipherText, IfxPkc_Parameter *vp)
{
    IfxPkc_Status status          = IfxPkc_Status_failure;
    /* read current error status in STAT regiser */
    boolean       algoErrorStatus = IfxPkc_getAlgoErrorStatus(pkc->pkcSFR, pkc->operationType);

    if ((pkc->state == IfxPkc_State_operationInitialized) || ((pkc->state == IfxPkc_State_error) && (algoErrorStatus == TRUE)))
    {
        if (pkc->operationType == IfxPkc_OperationType_RSAHLFCRTDEC)
        {
            IfxPkc_Crypto_RsaCrtAlgorithm *rsaCrt = (IfxPkc_Crypto_RsaCrtAlgorithm *)pkc->algoMechanism;
            rsaCrt->cipherTextPtr = cipherText->dataPtr;

            /* Write cipher text */
            status = IfxPkc_Crypto_writeToDataram(pkc, cipherText->dataPtr, cipherText->sizeInWords, (IfxPkc_MemLocation)IfxPkc_RsaCrtParamLocation_cipherText);

            /* Perform the operation */
            if (status == IfxPkc_Status_success)
            {
                status = IfxPkc_Crypto_performOperation(pkc);
            }

            /* Read output data */
            if (status == IfxPkc_Status_success)
            {
                status = IfxPkc_Crypto_readFromDataram(pkc, vp->dataPtr, vp->sizeInWords, (IfxPkc_MemLocation)IfxPkc_RsaCrtParamLocation_vp);
            }
        }
    }

    return status;
}


IfxPkc_Status IfxPkc_Crypto_recombineHalfCrtOutputs(IfxPkc_Crypto *pkc, IfxPkc_Parameter *vp, IfxPkc_Parameter *vq, IfxPkc_Parameter *plainText)
{
    IfxPkc_Status status          = IfxPkc_Status_failure;
    /* read current error status in STAT regiser */
    boolean       algoErrorStatus = IfxPkc_getAlgoErrorStatus(pkc->pkcSFR, pkc->operationType);

    if ((pkc->state == IfxPkc_State_operationInitialized) || ((pkc->state == IfxPkc_State_error) && (algoErrorStatus == TRUE)))
    {
        if (pkc->operationType == IfxPkc_OperationType_RSAHLFCRTREC)
        {
            IfxPkc_Crypto_RsaCrtAlgorithm *rsaCrt = (IfxPkc_Crypto_RsaCrtAlgorithm *)pkc->algoMechanism;
            rsaCrt->plainTextPtr = plainText->dataPtr;

            /* Write vp */
            status = IfxPkc_Crypto_writeToDataram(pkc, vp->dataPtr, vp->sizeInWords, (IfxPkc_MemLocation)IfxPkc_RsaCrtParamLocation_vp);

            /* Write vq */
            status |= IfxPkc_Crypto_writeToDataram(pkc, vq->dataPtr, vq->sizeInWords, (IfxPkc_MemLocation)IfxPkc_RsaCrtParamLocation_vq);

            /* Perform the operation */
            if (status == IfxPkc_Status_success)
            {
                status = IfxPkc_Crypto_performOperation(pkc);
            }

            /* Read Plain text */
            if (status == IfxPkc_Status_success)
            {
                status = IfxPkc_Crypto_readFromDataram(pkc, plainText->dataPtr, plainText->sizeInWords, (IfxPkc_MemLocation)IfxPkc_RsaCrtParamLocation_plainText);
            }
        }
    }

    return status;
}


IfxPkc_Status IfxPkc_Crypto_writeToDataram(IfxPkc_Crypto *pkc, uint32 *sourcePtr, uint32 numWords, IfxPkc_MemLocation memLocation)
{
    IfxPkc_Status status = IfxPkc_Status_success;
    uint32       *destPtr;
    /* Max operand size in words */
    uint32        operandSizeWords = IFXPKC_CALCWORDS_FROMBYTES((pkc->dataSize));

    /* Check for NULL pointer */
    if (sourcePtr == NULL_PTR)
    {
        pkc->errors.Bits.nullPointer = 1u;
        status                       = IfxPkc_Status_failure;
    }

    /* Check if number of words satisfy range constraints */
    if ((status == IfxPkc_Status_success) && (numWords <= operandSizeWords))
    {
        /* Get the pointer to destination */
        destPtr = IfxPkc_getDataramPointer(pkc->pkcSFR, memLocation);
        IfxPkc_performDataramOp(IfxPkc_DataramOp_write, sourcePtr, destPtr, numWords, operandSizeWords, pkc->endian);
    }
    else /* Num words is out of range */
    {
        status = IfxPkc_Status_failure;
    }

    return status;
}


IfxPkc_Status IfxPkc_Crypto_readFromDataram(IfxPkc_Crypto *pkc, uint32 *destPtr, uint32 numWords, IfxPkc_MemLocation memLocation)
{
    IfxPkc_Status status = IfxPkc_Status_success;
    uint32       *sourcePtr;
    /* Max operand size in words */
    uint32        operandSizeWords = IFXPKC_CALCWORDS_FROMBYTES((pkc->dataSize));

    /* Check for NULL pointer */
    if (destPtr == NULL_PTR)
    {
        pkc->errors.Bits.nullPointer = 1u;
        status                       = IfxPkc_Status_failure;
    }

    /* Check if number of words satisfy range constraints */
    if ((status == IfxPkc_Status_success) && (numWords <= operandSizeWords))
    {
        /* Get the pointer to source data */
        sourcePtr = IfxPkc_getDataramPointer(pkc->pkcSFR, memLocation);
        IfxPkc_performDataramOp(IfxPkc_DataramOp_read, sourcePtr, destPtr, numWords, operandSizeWords, pkc->endian);
    }
    else  /* Num words is out of range */
    {
        status = IfxPkc_Status_failure;
    }

    return status;
}


IFX_STATIC IfxPkc_Status IfxPkc_Crypto_performOperation(IfxPkc_Crypto *pkc)
{
    IfxPkc_Status status       = IfxPkc_Status_success;
    uint32        timeoutCount = IFXPKC_TIMEOUT_COUNT;
    boolean       algoErrorStatus;

    /* 1. Start the operation */
    IfxPkc_startOperation(pkc->pkcSFR);
    pkc->state = IfxPkc_State_opBusy;

    /* 2. Wait for the module to complete the operation */
    while ((IfxPkc_isModuleBusy(pkc->pkcSFR)) && (timeoutCount > 0))
    {
        timeoutCount--;
    }

    /* 3. Update error bits in handle
     * Check the error bits for the operation just performed */
    pkc->errors     = IfxPkc_getErrors(pkc->pkcSFR);
    algoErrorStatus = IfxPkc_getAlgoErrorStatus(pkc->pkcSFR, pkc->operationType);

    /* 4. Check for error / timeout */
    if ((algoErrorStatus == TRUE) || (timeoutCount <= 0))
    {
        status     = IfxPkc_Status_failure;
        /* Update to error state */
        pkc->state = IfxPkc_State_error;
    }
    else
    {
        /* 5. Restore to operation initialized state */
        pkc->state = IfxPkc_State_operationInitialized;
    }

    return status;
}


IFX_STATIC IfxPkc_Status IfxPkc_Crypto_initRsaOperation(IfxPkc_Crypto *pkc, IfxPkc_Crypto_RsaAlgorithm *rsa)
{
    IfxPkc_Status        status        = IfxPkc_Status_success;
    IfxPkc_Parameter     parameter;
    IfxPkc_OperationType operationType = pkc->operationType;

    /* Configure CMD register */
    Ifx_PKC_CMD          cfg;
    cfg.U              = pkc->pkcSFR->CMD.U;

    cfg.B.TYPE         = (uint32)operationType;
    cfg.B.FIELD        = (uint32)IfxPkc_Field_GFP;
    cfg.B.SELCURVE     = (uint32)IfxPkc_Acceleration_none;

    pkc->pkcSFR->CMD.U = cfg.U;

    if ((operationType >= IfxPkc_OperationType_RSAENC) && (operationType <= IfxPkc_OperationType_RSAVER))
    {
        /* Write modulus to DATARAM */
        parameter = rsa->rsaParameters.modulus;
        status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_RsaParamLocation_modulus);

        /* Write Public key */
        if ((operationType == IfxPkc_OperationType_RSAENC) || (operationType == IfxPkc_OperationType_RSAVER))
        {
            parameter = rsa->rsaParameters.publicKey;
            status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_RsaParamLocation_publicKey);
        }
        /* Write Private Key */
        else
        {
            parameter = rsa->rsaParameters.privateKey;
            status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_RsaParamLocation_privateKey);
        }
    }
    /* RSA Private Key Generation */
    else if (operationType == IfxPkc_OperationType_RSAPKGEN)
    {
        parameter = rsa->rsaParameters.p;
        status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_RsaParamLocation_p);

        parameter = rsa->rsaParameters.q;
        status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_RsaParamLocation_q);

        parameter = rsa->rsaParameters.publicKey;
        status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_RsaParamLocation_publicKey);
    }
    /* Unsupported operation type */
    else
    {
        status = IfxPkc_Status_failure;
    }

    return status;
}


IFX_STATIC IfxPkc_Status IfxPkc_Crypto_initRsaCrtOperation(IfxPkc_Crypto *pkc, IfxPkc_Crypto_RsaCrtAlgorithm *rsaCrt)
{
    IfxPkc_Status        status        = IfxPkc_Status_success;
    IfxPkc_Parameter     parameter;
    IfxPkc_OperationType operationType = pkc->operationType;

    /* Configure CMD register */
    Ifx_PKC_CMD          cfg;
    cfg.U              = pkc->pkcSFR->CMD.U;

    cfg.B.TYPE         = (uint32)operationType;
    cfg.B.FIELD        = (uint32)IfxPkc_Field_GFP;
    cfg.B.SELCURVE     = (uint32)IfxPkc_Acceleration_none;

    pkc->pkcSFR->CMD.U = cfg.U;

    parameter          = rsaCrt->rsaCrtParameters.p;
    status            |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_RsaCrtParamLocation_p);

    if (operationType != IfxPkc_OperationType_RSAHLFCRTDEC)
    {
        parameter = rsaCrt->rsaCrtParameters.q;
        status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_RsaCrtParamLocation_q);
    }

    switch (operationType)
    {
    /* RSA CRT Decryption */
    case IfxPkc_OperationType_RSACRTDEC:
    {
        parameter = rsaCrt->rsaCrtParameters.dP;
        status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_RsaCrtParamLocation_dP);

        parameter = rsaCrt->rsaCrtParameters.dQ;
        status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_RsaCrtParamLocation_dQ);

        parameter = rsaCrt->rsaCrtParameters.qInv;
        status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_RsaCrtParamLocation_qInv);
        break;
    }
    /* RSA CRT Key pair generation */
    case IfxPkc_OperationType_RSACRTKEYPARGEN:
    {
        parameter = rsaCrt->rsaCrtParameters.privateKey;
        status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_RsaCrtParamLocation_privateKey);
        break;
    }
    /* RSA Half CRT Decryption */
    case IfxPkc_OperationType_RSAHLFCRTDEC:
    {
        parameter = rsaCrt->rsaCrtParameters.dP;
        status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_RsaCrtParamLocation_dP);
        break;
    }
    /* RSA Half CRT Recombination */
    case IfxPkc_OperationType_RSAHLFCRTREC:
    {
        parameter = rsaCrt->rsaCrtParameters.qInv;
        status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_RsaCrtParamLocation_qInv);
        break;
    }
    default: break;
    }

    return status;
}


IFX_STATIC IfxPkc_Status IfxPkc_Crypto_initEcdsaOperation(IfxPkc_Crypto *pkc, IfxPkc_Crypto_EcdsaAlgorithm *ecdsa)
{
    IfxPkc_Status        status        = IfxPkc_Status_success;
    IfxPkc_Parameter     parameter;
    IfxPkc_OperationType operationType = pkc->operationType;

    /* Edwards only applicable for GF(p) */
    if ((ecdsa->field == IfxPkc_Field_GF2M) && (ecdsa->enableEdwards == TRUE))
    {
        status = IfxPkc_Status_failure;
    }
    else
    {
        /* Configure CMD register */
        Ifx_PKC_CMD cfg;
        cfg.U              = pkc->pkcSFR->CMD.U;

        cfg.B.TYPE         = (uint32)operationType;
        cfg.B.FIELD        = (uint32)(ecdsa->field);
        cfg.B.SELCURVE     = (uint32)(ecdsa->curveAcceleration);
        cfg.B.EDWARDS      = (uint32)(ecdsa->enableEdwards);

        pkc->pkcSFR->CMD.U = cfg.U;

        /* Write static parameters to DATARAM */
        parameter = ecdsa->ecdsaParameters.p;
        status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EcdsaParamLocation_p);

        parameter = ecdsa->ecdsaParameters.n;
        status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EcdsaParamLocation_n);

        parameter = ecdsa->ecdsaParameters.xG;
        status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EcdsaParamLocation_xG);

        parameter = ecdsa->ecdsaParameters.yG;
        status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EcdsaParamLocation_yG);

        parameter = ecdsa->ecdsaParameters.a;
        status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EcdsaParamLocation_a);

        parameter = ecdsa->ecdsaParameters.b;
        status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EcdsaParamLocation_b);

        switch (operationType)
        {
        case IfxPkc_OperationType_ECDSASIG:
        {
            parameter = ecdsa->ecdsaParameters.privateKey;
            status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EcdsaParamLocation_privateKey);
            break;
        }
        case IfxPkc_OperationType_ECDSAVER:
        {
            parameter = ecdsa->ecdsaParameters.publicKey_xQ;
            status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EcdsaParamLocation_publicKeyXQ);

            parameter = ecdsa->ecdsaParameters.publicKey_yQ;
            status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EcdsaParamLocation_publicKeyYQ);
            break;
        }
        /* Do nothing */
        case IfxPkc_OperationType_ECDSAPV:
        {
            break;
        }
        /* Unsupported operation type */
        default:
        {
            status = IfxPkc_Status_failure;
            break;
        }
        }
    }

    return status;
}


IFX_STATIC IfxPkc_Status IfxPkc_Crypto_initDsaOperation(IfxPkc_Crypto *pkc, IfxPkc_Crypto_DsaAlgorithm *dsa)
{
    IfxPkc_Status        status        = IfxPkc_Status_success;
    IfxPkc_Parameter     parameter;
    IfxPkc_OperationType operationType = pkc->operationType;

    /* Configure CMD register */
    Ifx_PKC_CMD          cfg;
    cfg.U              = pkc->pkcSFR->CMD.U;

    cfg.B.TYPE         = (uint32)operationType;
    cfg.B.FIELD        = (uint32)IfxPkc_Field_GFP;
    cfg.B.SELCURVE     = (uint32)IfxPkc_Acceleration_none;

    pkc->pkcSFR->CMD.U = cfg.U;

    /* Write static parameters to DATARAM */
    parameter = dsa->dsaParameters.p;
    status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_DsaParamLocation_p);

    parameter = dsa->dsaParameters.g;
    status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_DsaParamLocation_g);

    switch (operationType)
    {
    case IfxPkc_OperationType_DSAKEYGEN:
    {
        parameter = dsa->dsaParameters.privateKey;
        status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_DsaParamLocation_privateKey);
        break;
    }
    case IfxPkc_OperationType_DSASIG:
    {
        parameter = dsa->dsaParameters.q;
        status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_DsaParamLocation_q);

        parameter = dsa->dsaParameters.privateKey;
        status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_DsaParamLocation_privateKey);

        break;
    }
    case IfxPkc_OperationType_DSAVER:
    {
        parameter = dsa->dsaParameters.q;
        status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_DsaParamLocation_q);

        parameter = dsa->dsaParameters.publicKey;
        status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_DsaParamLocation_publicKey);

        break;
    }
    default:
    {
        status = IfxPkc_Status_failure;
        break;
    }
    }

    return status;
}


IFX_STATIC IfxPkc_Status IfxPkc_Crypto_initEckcdsaOperation(IfxPkc_Crypto *pkc, IfxPkc_Crypto_EckcdsaAlgorithm *eckcdsa)
{
    IfxPkc_Status        status        = IfxPkc_Status_success;
    IfxPkc_Parameter     parameter;
    IfxPkc_OperationType operationType = pkc->operationType;

    /* Edwards only applicable for GF(p) */
    if ((eckcdsa->field == IfxPkc_Field_GF2M) && (eckcdsa->enableEdwards == TRUE))
    {
        status = IfxPkc_Status_failure;
    }
    else
    {
        /* Configure CMD register */
        Ifx_PKC_CMD cfg;
        cfg.U              = pkc->pkcSFR->CMD.U;

        cfg.B.TYPE         = (uint32)operationType;
        cfg.B.FIELD        = (uint32)(eckcdsa->field);
        cfg.B.SELCURVE     = (uint32)(eckcdsa->curveAcceleration);
        cfg.B.EDWARDS      = (uint32)(eckcdsa->enableEdwards);

        pkc->pkcSFR->CMD.U = cfg.U;

        /* Write static parameters to DATARAM */
        parameter = eckcdsa->eckcdsaParameters.p;
        status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EckcdsaParamLocation_p);

        parameter = eckcdsa->eckcdsaParameters.n;
        status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EckcdsaParamLocation_n);

        parameter = eckcdsa->eckcdsaParameters.xG;
        status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EckcdsaParamLocation_xG);

        parameter = eckcdsa->eckcdsaParameters.yG;
        status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EckcdsaParamLocation_yG);

        parameter = eckcdsa->eckcdsaParameters.a;
        status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EckcdsaParamLocation_a);

        parameter = eckcdsa->eckcdsaParameters.b;
        status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EckcdsaParamLocation_b);

        switch (operationType)
        {
        case IfxPkc_OperationType_ECKCDSAPUBKEYGEN:
        case IfxPkc_OperationType_ECKCDSASIG:
        {
            parameter = eckcdsa->eckcdsaParameters.privateKey;
            status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EckcdsaParamLocation_privateKey);
            break;
        }
        case IfxPkc_OperationType_ECKCDSAVER:
        {
            parameter = eckcdsa->eckcdsaParameters.publicKey_xQ;
            status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EckcdsaParamLocation_publicKeyXQ);

            parameter = eckcdsa->eckcdsaParameters.publicKey_yQ;
            status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EckcdsaParamLocation_publicKeyYQ);
            break;
        }
        /* Unsupported operation type */
        default:
        {
            status = IfxPkc_Status_failure;
            break;
        }
        }
    }

    return status;
}


IFX_STATIC IfxPkc_Status IfxPkc_Crypto_initEdDsaOperation(IfxPkc_Crypto *pkc, IfxPkc_Crypto_EdDsaAlgorithm *edDsa)
{
    IfxPkc_Status        status        = IfxPkc_Status_success;
    IfxPkc_Parameter     parameter;
    IfxPkc_OperationType operationType = pkc->operationType;

    /* Configure CMD register */
    Ifx_PKC_CMD          cfg;
    cfg.U          = pkc->pkcSFR->CMD.U;

    cfg.B.TYPE     = (uint32)operationType;
    cfg.B.FIELD    = (uint32)IfxPkc_Field_GFP;
    cfg.B.SELCURVE = (uint32)(edDsa->curveAcceleration);
    cfg.B.EDWARDS  = (uint32)(edDsa->enableEdwards);

    if (operationType == IfxPkc_OperationType_EDDSAVER)
    {
        cfg.B.FLAGA = edDsa->edDsaParameters.xALsb;
        cfg.B.FLAGB = edDsa->edDsaParameters.xRLsb;
    }

    pkc->pkcSFR->CMD.U = cfg.U;

    /* Write static parameters to DATARAM */
    parameter = edDsa->edDsaParameters.p;
    status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EdDsaParamLocation_p);

    parameter = edDsa->edDsaParameters.L;
    status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EdDsaParamLocation_L);

    parameter = edDsa->edDsaParameters.kLsb;
    status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EdDsaParamLocation_kLsb);

    parameter = edDsa->edDsaParameters.kMsb;
    status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EdDsaParamLocation_kMsb);

    switch (operationType)
    {
    case IfxPkc_OperationType_EDDSASIG:
    {
        parameter = edDsa->edDsaParameters.rLsb;
        status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EdDsaParamLocation_rLsb);

        parameter = edDsa->edDsaParameters.rMsb;
        status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EdDsaParamLocation_rMsb);

        parameter = edDsa->edDsaParameters.secretScalar;    /* Shared secret shares dataram loc with yR */
        status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EdDsaParamLocation_yR);
        break;
    }
    case IfxPkc_OperationType_EDDSAVER:
    {
        parameter = edDsa->edDsaParameters.xB;
        status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EdDsaParamLocation_xB);

        parameter = edDsa->edDsaParameters.yB;
        status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EdDsaParamLocation_yB);

        parameter = edDsa->edDsaParameters.d;
        status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EdDsaParamLocation_d);

        parameter = edDsa->edDsaParameters.I;
        status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EdDsaParamLocation_I);

        parameter = edDsa->edDsaParameters.yA;
        status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EdDsaParamLocation_rMsb);

        parameter = edDsa->edDsaParameters.yR;
        status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EdDsaParamLocation_yR);
        break;
    }
    /* Unsupported operation type */
    default:
    {
        status = IfxPkc_Status_failure;
        break;
    }
    }

    return status;
}


IFX_STATIC IfxPkc_Status IfxPkc_Crypto_initSm2Operation(IfxPkc_Crypto *pkc, IfxPkc_Crypto_Sm2Algorithm *sm2)
{
    IfxPkc_Status        status        = IfxPkc_Status_success;
    IfxPkc_Parameter     parameter;
    IfxPkc_OperationType operationType = pkc->operationType;

    /* Edwards only applicable for GF(p) */
    if ((sm2->field == IfxPkc_Field_GF2M) && (sm2->enableEdwards == TRUE))
    {
        status = IfxPkc_Status_failure;
    }
    else
    {
        /* Configure CMD register */
        Ifx_PKC_CMD cfg;
        cfg.U              = pkc->pkcSFR->CMD.U;

        cfg.B.TYPE         = (uint32)operationType;
        cfg.B.FIELD        = (uint32)(sm2->field);
        cfg.B.SELCURVE     = (uint32)(sm2->curveAcceleration);
        cfg.B.EDWARDS      = (uint32)(sm2->enableEdwards);

        pkc->pkcSFR->CMD.U = cfg.U;

        /* Write static parameters to DATARAM */
        parameter = sm2->sm2Parameters.p;
        status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_Sm2ParamLocation_p);

        parameter = sm2->sm2Parameters.n;
        status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_Sm2ParamLocation_n);

        parameter = sm2->sm2Parameters.xG;
        status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_Sm2ParamLocation_xG);

        parameter = sm2->sm2Parameters.yG;
        status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_Sm2ParamLocation_yG);

        parameter = sm2->sm2Parameters.a;
        status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_Sm2ParamLocation_a);

        parameter = sm2->sm2Parameters.b;
        status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_Sm2ParamLocation_b);

        switch (operationType)
        {
        case IfxPkc_OperationType_SM2SIG:
        {
            parameter = sm2->sm2Parameters.privateKey;
            status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_Sm2ParamLocation_privateKey);
            break;
        }
        case IfxPkc_OperationType_SM2VER:
        {
            parameter = sm2->sm2Parameters.publicKey_xQ;
            status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_Sm2ParamLocation_publicKeyXQ);

            parameter = sm2->sm2Parameters.publicKey_yQ;
            status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_Sm2ParamLocation_publicKeyYQ);
            break;
        }
        case IfxPkc_OperationType_SM2KEYEXCH:
        {
            parameter = sm2->sm2Parameters.privateKey;
            status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_Sm2ParamLocation_privateKey);

            parameter = sm2->sm2Parameters.k;
            status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_Sm2ParamLocation_k);

            parameter = sm2->sm2Parameters.publicKey_xQ;
            status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_Sm2ParamLocation_publicKeyXQ);

            parameter = sm2->sm2Parameters.publicKey_yQ;
            status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_Sm2ParamLocation_publicKeyYQ);

            parameter = sm2->sm2Parameters.xRB;
            status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, IfxPkc_MemLocation_A);

            parameter = sm2->sm2Parameters.yRB;
            status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, IfxPkc_MemLocation_B);

            parameter = sm2->sm2Parameters.cofactor;
            status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, IfxPkc_MemLocation_C);

            parameter = sm2->sm2Parameters.xRA;
            status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, IfxPkc_MemLocation_D);

            parameter = sm2->sm2Parameters.twoExpW;
            status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, IfxPkc_MemLocation_F);
            break;
        }
        /* Unsupported operation type */
        default:
        {
            status = IfxPkc_Status_failure;
            break;
        }
        }
    }

    return status;
}


IFX_STATIC IfxPkc_Status IfxPkc_Crypto_initSrpOperation(IfxPkc_Crypto *pkc, IfxPkc_Crypto_SrpAlgorithm *srp)
{
    IfxPkc_Status        status        = IfxPkc_Status_success;
    IfxPkc_Parameter     parameter;
    IfxPkc_OperationType operationType = pkc->operationType;

    /* Configure CMD register */
    Ifx_PKC_CMD          cfg;
    cfg.U              = pkc->pkcSFR->CMD.U;

    cfg.B.TYPE         = (uint32)operationType;
    cfg.B.FIELD        = (uint32)IfxPkc_Field_GFP;
    cfg.B.SELCURVE     = (uint32)IfxPkc_Acceleration_none;
    cfg.B.EDWARDS      = (uint32)FALSE;

    pkc->pkcSFR->CMD.U = cfg.U;

    /* Write static parameters to DATARAM */
    parameter = srp->srpParameters.N;
    status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_SrpParamLocation_N);

    switch (operationType)
    {
    case IfxPkc_OperationType_SRPCLTKEY:
    {
        parameter = srp->srpParameters.g;
        status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_SrpParamLocation_g);

        parameter = srp->srpParameters.a;
        status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_SrpParamLocation_a);

        parameter = srp->srpParameters.B;
        status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_SrpParamLocation_B);

        parameter = srp->srpParameters.x;
        status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_SrpParamLocation_x);

        parameter = srp->srpParameters.k;
        status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_SrpParamLocation_k);

        parameter = srp->srpParameters.u;
        status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_SrpParamLocation_u);
        break;
    }
    case IfxPkc_OperationType_SRPSRVPUB:
    {
        parameter = srp->srpParameters.g;
        status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_SrpParamLocation_g);

        parameter = srp->srpParameters.k;
        status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_SrpParamLocation_k);

        parameter = srp->srpParameters.v;
        status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_SrpParamLocation_v);

        parameter = srp->srpParameters.b;
        status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_SrpParamLocation_b);
        break;
    }
    case IfxPkc_OperationType_SRPSRVKEY:
    {
        parameter = srp->srpParameters.A;
        status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_SrpParamLocation_A);

        parameter = srp->srpParameters.a;
        status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_SrpParamLocation_a);

        parameter = srp->srpParameters.u;
        status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_SrpParamLocation_u);

        parameter = srp->srpParameters.v;
        status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_SrpParamLocation_v);

        parameter = srp->srpParameters.b;
        status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_SrpParamLocation_b);
        break;
    }
    /* Unsupported operation type */
    default: break;
    }

    return status;
}


IFX_STATIC IfxPkc_Status IfxPkc_Crypto_initJPakeOperation(IfxPkc_Crypto *pkc, IfxPkc_Crypto_JPakeAlgorithm *jPake)
{
    IfxPkc_Status        status        = IfxPkc_Status_success;
    IfxPkc_Parameter     parameter;
    IfxPkc_OperationType operationType = pkc->operationType;

    /* Edwards only applicable for GF(p) */
    if ((jPake->field == IfxPkc_Field_GF2M) && (jPake->enableEdwards == TRUE))
    {
        status = IfxPkc_Status_failure;
    }
    else
    {
        /* Configure CMD register */
        Ifx_PKC_CMD cfg;
        cfg.U              = pkc->pkcSFR->CMD.U;

        cfg.B.TYPE         = (uint32)operationType;
        cfg.B.FIELD        = (uint32)jPake->field;
        cfg.B.SELCURVE     = (uint32)jPake->curveAcceleration;
        cfg.B.EDWARDS      = (uint32)jPake->enableEdwards;

        pkc->pkcSFR->CMD.U = cfg.U;

        /* Write static parameters to DATARAM */
        parameter = jPake->jPakeParameters.n;
        status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_JPakeParamLocation_n);

        if ((operationType >= IfxPkc_OperationType_JPAKEZKPVER) && (operationType <= IfxPkc_OperationType_JPAKEGENSTP2))
        {
            parameter = jPake->jPakeParameters.p;
            status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_JPakeParamLocation_p);

            parameter = jPake->jPakeParameters.a;
            status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_JPakeParamLocation_a);

            /* Write b if edwards is disabled */
            if (!(jPake->enableEdwards))
            {
                parameter = jPake->jPakeParameters.b;
                status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_JPakeParamLocation_b);
            }
        }

        switch (operationType)
        {
        case IfxPkc_OperationType_JPAKEZKPVER:
        {
            /* Configure Operand pointer reg */
            IfxPkc_JPakeParamLocation xGMemLocation = (jPake->curveGeneratorG == TRUE) ? IfxPkc_JPakeParamLocation_xG : IfxPkc_JPakeParamLocation_xT;
            pkc->pkcSFR->PTR.B.OPPTRA = xGMemLocation;

            parameter                 = jPake->jPakeParameters.xG;
            status                   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)xGMemLocation);

            parameter                 = jPake->jPakeParameters.yG;
            status                   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)(xGMemLocation + 1));

            parameter                 = jPake->jPakeParameters.V.x;
            status                   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_JPakeParamLocation_xV);

            parameter                 = jPake->jPakeParameters.V.y;
            status                   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_JPakeParamLocation_yV);

            parameter                 = jPake->jPakeParameters.X.x;
            status                   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_JPakeParamLocation_xX);

            parameter                 = jPake->jPakeParameters.X.y;
            status                   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_JPakeParamLocation_yX);

            parameter                 = jPake->jPakeParameters.r;
            status                   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_JPakeParamLocation_r);

            parameter                 = jPake->jPakeParameters.hash;
            status                   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_JPakeParamLocation_hash);
            break;
        }
        case IfxPkc_OperationType_JPAKEZKPGEN:
        {
            parameter = jPake->jPakeParameters.v;
            status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_JPakeParamLocation_xX);

            parameter = jPake->jPakeParameters.x;
            status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_JPakeParamLocation_x);

            parameter = jPake->jPakeParameters.hash;
            status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_JPakeParamLocation_hash);
            break;
        }
        case IfxPkc_OperationType_JPAKEGENSTP2:
        {
            parameter = jPake->jPakeParameters.X4.x;
            status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, IfxPkc_MemLocation_6);

            parameter = jPake->jPakeParameters.X4.y;
            status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, IfxPkc_MemLocation_7);

            parameter = jPake->jPakeParameters.X3.x;
            status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, IfxPkc_MemLocation_8);

            parameter = jPake->jPakeParameters.X3.y;
            status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, IfxPkc_MemLocation_9);

            parameter = jPake->jPakeParameters.x2;
            status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, IfxPkc_MemLocation_A);

            parameter = jPake->jPakeParameters.X1.x;
            status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, IfxPkc_MemLocation_B);

            parameter = jPake->jPakeParameters.X1.y;
            status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, IfxPkc_MemLocation_C);

            parameter = jPake->jPakeParameters.s;
            status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, IfxPkc_MemLocation_D);
            break;
        }
        case IfxPkc_OperationType_JPAKEKEYGEN:
        {
            parameter = jPake->jPakeParameters.X4.x;
            status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, IfxPkc_MemLocation_6);

            parameter = jPake->jPakeParameters.X4.y;
            status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, IfxPkc_MemLocation_7);

            parameter = jPake->jPakeParameters.B.x;
            status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, IfxPkc_MemLocation_8);

            parameter = jPake->jPakeParameters.B.y;
            status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, IfxPkc_MemLocation_9);

            parameter = jPake->jPakeParameters.x2;
            status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, IfxPkc_MemLocation_A);

            parameter = jPake->jPakeParameters.x2s;
            status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, IfxPkc_MemLocation_B);
            break;
        }
        default: break;
        }
    }

    return status;
}


IFX_STATIC IfxPkc_Status IfxPkc_Crypto_performRsaCrypto(IfxPkc_Crypto *pkc, uint32 numWords, IfxPkc_CryptoOp cryptoOp)
{
    IfxPkc_Status               status = IfxPkc_Status_success;
    IfxPkc_Crypto_RsaAlgorithm *rsa    = (IfxPkc_Crypto_RsaAlgorithm *)pkc->algoMechanism;

    /* Write dynamic parameters */
    if (cryptoOp == IfxPkc_CryptoOp_encrypt)
    {
        status = IfxPkc_Crypto_writeToDataram(pkc, rsa->plainTextPtr, numWords, (IfxPkc_MemLocation)IfxPkc_RsaParamLocation_plainText);
    }
    else if (cryptoOp == IfxPkc_CryptoOp_decrypt)
    {
        status = IfxPkc_Crypto_writeToDataram(pkc, rsa->cipherTextPtr, numWords, (IfxPkc_MemLocation)IfxPkc_RsaParamLocation_cipherText);
    }

    /* Perform the operation */
    if (status == IfxPkc_Status_success)
    {
        status = IfxPkc_Crypto_performOperation(pkc);
    }

    /* Read output data */
    if (status == IfxPkc_Status_success)
    {
        if (cryptoOp == IfxPkc_CryptoOp_encrypt)
        {
            status = IfxPkc_Crypto_readFromDataram(pkc, rsa->cipherTextPtr, numWords, (IfxPkc_MemLocation)IfxPkc_RsaParamLocation_cipherText);
        }
        else if (cryptoOp == IfxPkc_CryptoOp_decrypt)
        {
            status = IfxPkc_Crypto_readFromDataram(pkc, rsa->plainTextPtr, numWords, (IfxPkc_MemLocation)IfxPkc_RsaParamLocation_plainText);
        }
    }

    return status;
}


IFX_STATIC IfxPkc_Status IfxPkc_Crypto_performRsaCrtCrypto(IfxPkc_Crypto *pkc, uint32 numWords, IfxPkc_CryptoOp cryptoOp)
{
    IfxPkc_Status                  status = IfxPkc_Status_success;
    IfxPkc_Crypto_RsaCrtAlgorithm *rsaCrt = (IfxPkc_Crypto_RsaCrtAlgorithm *)pkc->algoMechanism;

    if (cryptoOp == IfxPkc_CryptoOp_decrypt)
    {
        status = IfxPkc_Crypto_writeToDataram(pkc, rsaCrt->cipherTextPtr, numWords, (IfxPkc_MemLocation)IfxPkc_RsaCrtParamLocation_cipherText);

        /* Perform the operation */
        if (status == IfxPkc_Status_success)
        {
            status = IfxPkc_Crypto_performOperation(pkc);
        }

        /* Read output data */
        if (status == IfxPkc_Status_success)
        {
            status = IfxPkc_Crypto_readFromDataram(pkc, rsaCrt->plainTextPtr, numWords, (IfxPkc_MemLocation)IfxPkc_RsaCrtParamLocation_plainText);
        }
    }
    /* Unsupported crypto operation type for RSA CRT */
    else
    {
        status = IfxPkc_Status_failure;
    }

    return status;
}


IFX_STATIC IfxPkc_Status IfxPkc_Crypto_performRsaSignature(IfxPkc_Crypto *pkc, uint32 hashLength, IfxPkc_SignatureOp signatureOp)
{
    IfxPkc_Status               status = IfxPkc_Status_success;
    IfxPkc_Crypto_RsaAlgorithm *rsa    = (IfxPkc_Crypto_RsaAlgorithm *)(pkc->algoMechanism);

    /* Write dynamic parameters */
    status = IfxPkc_Crypto_writeToDataram(pkc, rsa->hashPtr, hashLength, (IfxPkc_MemLocation)IfxPkc_RsaParamLocation_hash);

    if ((status == IfxPkc_Status_success) && (signatureOp == IfxPkc_SignatureOp_verify))
    {
        status = IfxPkc_Crypto_writeToDataram(pkc, rsa->signature.s, rsa->signature.sizeInWords, (IfxPkc_MemLocation)IfxPkc_RsaParamLocation_s);
    }

    /* Perform the operation */
    if (status == IfxPkc_Status_success)
    {
        status = IfxPkc_Crypto_performOperation(pkc);
    }

    /* Read output data */
    if ((status == IfxPkc_Status_success) && (signatureOp == IfxPkc_SignatureOp_generate))
    {
        status = IfxPkc_Crypto_readFromDataram(pkc, rsa->signature.s, rsa->signature.sizeInWords, (IfxPkc_MemLocation)IfxPkc_RsaParamLocation_s);
    }

    return status;
}


IFX_STATIC IfxPkc_Status IfxPkc_Crypto_performEcdsaSignature(IfxPkc_Crypto *pkc, uint32 hashLength, IfxPkc_SignatureOp signatureOp)
{
    IfxPkc_Status                 status = IfxPkc_Status_success;
    IfxPkc_Parameter              parameter;
    IfxPkc_Crypto_EcdsaAlgorithm *ecdsa  = (IfxPkc_Crypto_EcdsaAlgorithm *)(pkc->algoMechanism);

    /* Write dynamic parameters */
    status |= IfxPkc_Crypto_writeToDataram(pkc, ecdsa->hashPtr, hashLength, (IfxPkc_MemLocation)IfxPkc_EcdsaParamLocation_hash);

    if (signatureOp == IfxPkc_SignatureOp_generate)
    {
        parameter = ecdsa->ecdsaParameters.k;
        status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EcdsaParamLocation_k);
    }
    else if (signatureOp == IfxPkc_SignatureOp_verify)
    {
        status |= IfxPkc_Crypto_writeToDataram(pkc, ecdsa->signature.r, ecdsa->signature.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EcdsaParamLocation_r);

        status |= IfxPkc_Crypto_writeToDataram(pkc, ecdsa->signature.s, ecdsa->signature.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EcdsaParamLocation_s);
    }

    /* Perform the operation */
    if (status == IfxPkc_Status_success)
    {
        status = IfxPkc_Crypto_performOperation(pkc);
    }

    /* Read output data */
    if ((status == IfxPkc_Status_success) && (signatureOp == IfxPkc_SignatureOp_generate))
    {
        status |= IfxPkc_Crypto_readFromDataram(pkc, ecdsa->signature.r, ecdsa->signature.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EcdsaParamLocation_r);

        status |= IfxPkc_Crypto_readFromDataram(pkc, ecdsa->signature.s, ecdsa->signature.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EcdsaParamLocation_s);
    }

    return status;
}


IFX_STATIC IfxPkc_Status IfxPkc_Crypto_performDsaSignature(IfxPkc_Crypto *pkc, uint32 hashLength, IfxPkc_SignatureOp signatureOp)
{
    IfxPkc_Status               status = IfxPkc_Status_success;
    IfxPkc_Parameter            parameter;
    IfxPkc_Crypto_DsaAlgorithm *dsa    = (IfxPkc_Crypto_DsaAlgorithm *)(pkc->algoMechanism);

    /* Write dynamic parameters */
    status |= IfxPkc_Crypto_writeToDataram(pkc, dsa->hashPtr, hashLength, (IfxPkc_MemLocation)IfxPkc_DsaParamLocation_hash);

    if (signatureOp == IfxPkc_SignatureOp_generate)
    {
        parameter = dsa->dsaParameters.k;
        status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_DsaParamLocation_k);
    }
    else if (signatureOp == IfxPkc_SignatureOp_verify)
    {
        status |= IfxPkc_Crypto_writeToDataram(pkc, dsa->signature.r, dsa->signature.sizeInWords, (IfxPkc_MemLocation)IfxPkc_DsaParamLocation_r);

        status |= IfxPkc_Crypto_writeToDataram(pkc, dsa->signature.s, dsa->signature.sizeInWords, (IfxPkc_MemLocation)IfxPkc_DsaParamLocation_s);
    }

    /* Perform the operation */
    if (status == IfxPkc_Status_success)
    {
        status = IfxPkc_Crypto_performOperation(pkc);
    }

    /* Read output data */
    if ((status == IfxPkc_Status_success) && (signatureOp == IfxPkc_SignatureOp_generate))
    {
        status |= IfxPkc_Crypto_readFromDataram(pkc, dsa->signature.r, dsa->signature.sizeInWords, (IfxPkc_MemLocation)IfxPkc_DsaParamLocation_r);

        status |= IfxPkc_Crypto_readFromDataram(pkc, dsa->signature.s, dsa->signature.sizeInWords, (IfxPkc_MemLocation)IfxPkc_DsaParamLocation_s);
    }

    return status;
}


IFX_STATIC IfxPkc_Status IfxPkc_Crypto_performEckcdsaSignature(IfxPkc_Crypto *pkc, uint32 hashLength, IfxPkc_SignatureOp signatureOp)
{
    IfxPkc_Status                   status  = IfxPkc_Status_success;
    IfxPkc_Parameter                parameter;
    IfxPkc_Crypto_EckcdsaAlgorithm *eckcdsa = (IfxPkc_Crypto_EckcdsaAlgorithm *)(pkc->algoMechanism);

    /* Write dynamic parameters */
    status |= IfxPkc_Crypto_writeToDataram(pkc, eckcdsa->hashPtr, hashLength, (IfxPkc_MemLocation)IfxPkc_EcdsaParamLocation_hash);

    status |= IfxPkc_Crypto_writeToDataram(pkc, eckcdsa->signature.r, eckcdsa->signature.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EckcdsaParamLocation_r);

    if (signatureOp == IfxPkc_SignatureOp_generate)
    {
        parameter = eckcdsa->eckcdsaParameters.k;
        status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EckcdsaParamLocation_k);
    }
    else if (signatureOp == IfxPkc_SignatureOp_verify)
    {
        status |= IfxPkc_Crypto_writeToDataram(pkc, eckcdsa->signature.s, eckcdsa->signature.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EckcdsaParamLocation_s);
    }

    /* Perform the operation */
    if (status == IfxPkc_Status_success)
    {
        status = IfxPkc_Crypto_performOperation(pkc);
    }

    /* Read output data */
    if (status == IfxPkc_Status_success)
    {
        if (signatureOp == IfxPkc_SignatureOp_generate)
        {
            status |= IfxPkc_Crypto_readFromDataram(pkc, eckcdsa->signature.s, eckcdsa->signature.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EckcdsaParamLocation_s);
        }
        else if (signatureOp == IfxPkc_SignatureOp_verify)
        {
            parameter = eckcdsa->eckcdsaParameters.xW;
            status   |= IfxPkc_Crypto_readFromDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EckcdsaParamLocation_xW);

            parameter = eckcdsa->eckcdsaParameters.yW;
            status   |= IfxPkc_Crypto_readFromDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EckcdsaParamLocation_yW);
        }
    }

    return status;
}


IFX_STATIC IfxPkc_Status IfxPkc_Crypto_performEdDsaSignature(IfxPkc_Crypto *pkc, IfxPkc_SignatureOp signatureOp)
{
    IfxPkc_Status                 status = IfxPkc_Status_success;
    IfxPkc_Crypto_EdDsaAlgorithm *edDsa  = (IfxPkc_Crypto_EdDsaAlgorithm *)(pkc->algoMechanism);

    /* Write signature */
    if (signatureOp == IfxPkc_SignatureOp_verify)
    {
        status |= IfxPkc_Crypto_writeToDataram(pkc, edDsa->signature.s, edDsa->signature.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EdDsaParamLocation_xR);
    }

    /* Perform the operation */
    if (status == IfxPkc_Status_success)
    {
        status = IfxPkc_Crypto_performOperation(pkc);
    }

    /* Read output data */
    if (status == IfxPkc_Status_success)
    {
        if (signatureOp == IfxPkc_SignatureOp_generate)
        {
            /* Read signature from xR location */
            status |= IfxPkc_Crypto_readFromDataram(pkc, edDsa->signature.s, edDsa->signature.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EdDsaParamLocation_xR);
        }
    }

    return status;
}


IFX_STATIC IfxPkc_Status IfxPkc_Crypto_performSm2Signature(IfxPkc_Crypto *pkc, uint32 hashLength, IfxPkc_SignatureOp signatureOp)
{
    IfxPkc_Status               status = IfxPkc_Status_success;
    IfxPkc_Parameter            parameter;
    IfxPkc_Crypto_Sm2Algorithm *sm2    = (IfxPkc_Crypto_Sm2Algorithm *)(pkc->algoMechanism);

    /* Write dynamic parameters */
    status |= IfxPkc_Crypto_writeToDataram(pkc, sm2->hashPtr, hashLength, (IfxPkc_MemLocation)IfxPkc_Sm2ParamLocation_hash);

    if (signatureOp == IfxPkc_SignatureOp_generate)
    {
        parameter = sm2->sm2Parameters.k;
        status   |= IfxPkc_Crypto_writeToDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_Sm2ParamLocation_k);
    }
    else if (signatureOp == IfxPkc_SignatureOp_verify)
    {
        status |= IfxPkc_Crypto_writeToDataram(pkc, sm2->signature.r, sm2->signature.sizeInWords, (IfxPkc_MemLocation)IfxPkc_Sm2ParamLocation_r);

        status |= IfxPkc_Crypto_writeToDataram(pkc, sm2->signature.s, sm2->signature.sizeInWords, (IfxPkc_MemLocation)IfxPkc_Sm2ParamLocation_s);
    }

    /* Perform the operation */
    if (status == IfxPkc_Status_success)
    {
        status = IfxPkc_Crypto_performOperation(pkc);
    }

    /* Read output data */
    if ((status == IfxPkc_Status_success) && (signatureOp == IfxPkc_SignatureOp_generate))
    {
        status |= IfxPkc_Crypto_readFromDataram(pkc, sm2->signature.r, sm2->signature.sizeInWords, (IfxPkc_MemLocation)IfxPkc_Sm2ParamLocation_r);

        status |= IfxPkc_Crypto_readFromDataram(pkc, sm2->signature.s, sm2->signature.sizeInWords, (IfxPkc_MemLocation)IfxPkc_Sm2ParamLocation_s);
    }

    return status;
}


IFX_STATIC IfxPkc_Status IfxPkc_Crypto_performRsaKeyGeneration(IfxPkc_Crypto *pkc, IfxPkc_Crypto_RsaKey *rsaKey)
{
    IfxPkc_Status    status = IfxPkc_Status_success;
    IfxPkc_Parameter parameter;

    /* Perform the operation */
    status = IfxPkc_Crypto_performOperation(pkc);

    /* Read output data */
    if (status == IfxPkc_Status_success)
    {
        parameter = rsaKey->modulus;
        status   |= IfxPkc_Crypto_readFromDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_RsaParamLocation_modulus);

        parameter = rsaKey->lambda;
        status   |= IfxPkc_Crypto_readFromDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_RsaParamLocation_lambda);

        parameter = rsaKey->privateKey;
        status   |= IfxPkc_Crypto_readFromDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_RsaParamLocation_privateKey);
    }

    return status;
}


IFX_STATIC IfxPkc_Status IfxPkc_Crypto_performRsaCrtKeyGeneration(IfxPkc_Crypto *pkc, IfxPkc_Crypto_RsaCrtKey *rsaCrtKey)
{
    IfxPkc_Status    status = IfxPkc_Status_success;
    IfxPkc_Parameter parameter;

    /* Perform the operation */
    status = IfxPkc_Crypto_performOperation(pkc);

    /* Read output data */
    if (status == IfxPkc_Status_success)
    {
        parameter = rsaCrtKey->dP;
        status   |= IfxPkc_Crypto_readFromDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_RsaCrtParamLocation_dP);

        parameter = rsaCrtKey->dQ;
        status   |= IfxPkc_Crypto_readFromDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_RsaCrtParamLocation_dQ);

        parameter = rsaCrtKey->qInv;
        status   |= IfxPkc_Crypto_readFromDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_RsaCrtParamLocation_qInv);
    }

    return status;
}


IFX_STATIC IfxPkc_Status IfxPkc_Crypto_performDsaKeyGeneration(IfxPkc_Crypto *pkc, IfxPkc_Crypto_DsaKey *dsaKey)
{
    IfxPkc_Status status = IfxPkc_Status_success;

    /* Perform the operation */
    status = IfxPkc_Crypto_performOperation(pkc);

    /* Read output data */
    if (status == IfxPkc_Status_success)
    {
        status |= IfxPkc_Crypto_readFromDataram(pkc, dsaKey->dataPtr, dsaKey->sizeInWords, (IfxPkc_MemLocation)IfxPkc_DsaParamLocation_publicKey);
    }

    return status;
}


IFX_STATIC IfxPkc_Status IfxPkc_Crypto_performEckcdsaKeyGeneration(IfxPkc_Crypto *pkc, IfxPkc_Crypto_EckcdsaKey *eckcdsaKey)
{
    IfxPkc_Status    status = IfxPkc_Status_success;
    IfxPkc_Parameter parameter;

    /* Perform the operation */
    status = IfxPkc_Crypto_performOperation(pkc);

    /* Read output data */
    if (status == IfxPkc_Status_success)
    {
        parameter = eckcdsaKey->publicKey_xQ;
        status   |= IfxPkc_Crypto_readFromDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EckcdsaParamLocation_publicKeyXQ);

        parameter = eckcdsaKey->publicKey_yQ;
        status   |= IfxPkc_Crypto_readFromDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_EckcdsaParamLocation_publicKeyYQ);
    }

    return status;
}


IFX_STATIC IfxPkc_Status IfxPkc_Crypto_performSrpKeyGeneration(IfxPkc_Crypto *pkc, IfxPkc_Crypto_SrpKey *srpKey)
{
    IfxPkc_Status status = IfxPkc_Status_success;

    /* Perform the operation */
    status = IfxPkc_Crypto_performOperation(pkc);

    /* Read output data */
    if (status == IfxPkc_Status_success)
    {
        /* Read Public key */
        if (pkc->operationType == IfxPkc_OperationType_SRPSRVPUB)
        {
            status |= IfxPkc_Crypto_readFromDataram(pkc, srpKey->dataPtr, srpKey->sizeInWords, (IfxPkc_MemLocation)IfxPkc_SrpParamLocation_B);
        }
        /* Read Session key */
        else
        {
            status |= IfxPkc_Crypto_readFromDataram(pkc, srpKey->dataPtr, srpKey->sizeInWords, (IfxPkc_MemLocation)IfxPkc_SrpParamLocation_S);
        }
    }

    return status;
}


IFX_STATIC IfxPkc_Status IfxPkc_Crypto_performJPakeKeyGeneration(IfxPkc_Crypto *pkc, IfxPkc_Crypto_JPakeKey *jPakeKey)
{
    IfxPkc_Status status = IfxPkc_Status_success;

    /* Perform the operation */
    status = IfxPkc_Crypto_performOperation(pkc);

    /* Read output data */
    if (status == IfxPkc_Status_success)
    {
        IfxPkc_Parameter parameter;
        parameter = jPakeKey->xT;
        status   |= IfxPkc_Crypto_readFromDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_JPakeParamLocation_xT);

        parameter = jPakeKey->yT;
        status   |= IfxPkc_Crypto_readFromDataram(pkc, parameter.dataPtr, parameter.sizeInWords, (IfxPkc_MemLocation)IfxPkc_JPakeParamLocation_yT);
    }

    return status;
}
