/**
 * \file IfxPkc.h
 * \brief PKC  basic functionality
 * \ingroup IfxLld_Pkc
 *
 * \version iLLD_2_0_1_2_19
 * \copyright Copyright (c) 2023 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 *
 */

#ifndef IFXPKC_H
#define IFXPKC_H 1

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "_Impl/IfxPkc_cfg.h"
#include "Cpu/Std/Ifx_Types.h"
#include "IfxPkc_reg.h"
#include "IfxPkc_bf.h"
#include "Src/Std/IfxSrc.h"
#include "Ap/Std/IfxApApu.h"
#include "Ap/Std/IfxApProt.h"

/******************************************************************************/
/*-----------------------------------Macros-----------------------------------*/
/******************************************************************************/

/** \brief Macro that returns a mask of error bits of STAT register
 */
#define IFXPKC_ERRORMASK                                                        \
    ((uint32)                                                                   \
     ((uint32)(IFX_PKC_STAT_PT_INVALID_MSK << IFX_PKC_STAT_PT_INVALID_OFF)) |   \
     ((uint32)(IFX_PKC_STAT_OOR_MSK << IFX_PKC_STAT_OOR_OFF)) |                 \
     ((uint32)(IFX_PKC_STAT_M_INVALID_MSK << IFX_PKC_STAT_M_INVALID_OFF)) |     \
     ((uint32)(IFX_PKC_STAT_NIMPL_MSK << IFX_PKC_STAT_NIMPL_OFF)) |             \
     ((uint32)(IFX_PKC_STAT_SIG_INVALID_MSK << IFX_PKC_STAT_SIG_INVALID_OFF)) | \
     ((uint32)(IFX_PKC_STAT_P_INVALID_MSK << IFX_PKC_STAT_P_INVALID_OFF)) |     \
     ((uint32)(IFX_PKC_STAT_NOTINV_MSK << IFX_PKC_STAT_NOTINV_OFF)) |           \
     ((uint32)(IFX_PKC_STAT_NQR_MSK << IFX_PKC_STAT_NQR_OFF)))

/** \brief Macro that accepts STAT register and returns True if any error bit is set
 */
#define IFXPKC_CHECK_ERRORSTATUS(x)              ((uint32)(x & IFXPKC_ERRORMASK) != (uint32)0)

/** \brief Macro that checks 32 bit multiplicity of input data byte size
 */
#define IFXPKC_CHECKINPUTBYTESIZE(x)             (((x & (uint32)(4 - 1)) == (uint32)0))

/** \brief Macro that checks 32 bit multiplicity of input data bit size
 */
#define IFXPKC_CHECKINPUTBITSIZE(x)              (((x & (uint32)(32 - 1)) == (uint32)0))

/** \brief Macro that calculates 32 bit  memory words from input data bit size
 */
#define IFXPKC_CALCWORDS_FROMBITS(x)             (IFXPKC_CHECKINPUTBITSIZE(x) ? (uint32)(x >> 5U) : (uint32)((x >> 5U) + 1U))

/** \brief Macro that calculates 32 bit  memory words from input Byte size.
 */
#define IFXPKC_CALCWORDS_FROMBYTES(x)            (IFXPKC_CHECKINPUTBYTESIZE(x) ? (uint32)(x >> 2U) : (uint32)((x >> 2U) + 1U))

/** \brief Macro that accepts STAT register and algorithm specific mask and returns True if any error bit is set
 */
#define IFXPKC_CHECK_ALGO_ERRORSTATUS(reg, mask) ((uint32)(reg & mask) != (uint32)0)

/** \brief Macro that returns a mask of error bits of STAT register for OOR Error
 */
#define IFXPKC_ERRORMASK_OOR         ((uint32)(IFX_PKC_STAT_OOR_MSK << IFX_PKC_STAT_OOR_OFF))

/** \brief Macro that returns a mask of error bits of STAT register for P_INVALID
 */
#define IFXPKC_ERRORMASK_P_INVALID   ((uint32)(IFX_PKC_STAT_P_INVALID_MSK << IFX_PKC_STAT_P_INVALID_OFF))

/** \brief Macro that returns a mask of error bits of STAT register for NQR
 */
#define IFXPKC_ERRORMASK_NQR         ((uint32)(IFX_PKC_STAT_NQR_MSK << IFX_PKC_STAT_NQR_OFF))

/** \brief Macro that returns a mask of error bits of STAT register for NOTINV error
 */
#define IFXPKC_ERRORMASK_NOTINV      ((uint32)(IFX_PKC_STAT_NOTINV_MSK << IFX_PKC_STAT_NOTINV_OFF))

/** \brief Macro that returns a mask of error bits of STAT register for PT_INVALID
 */
#define IFXPKC_ERRORMASK_PT_INVALID  ((uint32)(IFX_PKC_STAT_PT_INVALID_MSK << IFX_PKC_STAT_PT_INVALID_OFF))

/** \brief Macro that returns a mask of error bits of STAT register for M_INVALID
 */
#define IFXPKC_ERRORMASK_M_INVALID   ((uint32)(IFX_PKC_STAT_M_INVALID_MSK << IFX_PKC_STAT_M_INVALID_OFF))

/** \brief Macro that returns a mask of error bits of STAT register for SIG_INVALID
 */
#define IFXPKC_ERRORMASK_SIG_INVALID ((uint32)(IFX_PKC_STAT_SIG_INVALID_MSK << IFX_PKC_STAT_SIG_INVALID_OFF))

/** \brief Macro that returns a mask of error bits of STAT register for RSASIG
 */
#define IFXPKC_ERRORMASK_RSASIG      (IFXPKC_ERRORMASK_OOR | IFXPKC_ERRORMASK_NOTINV)

/** \brief Macro that returns a mask of error bits of STAT register for RSAVER
 */
#define IFXPKC_ERRORMASK_RSAVER      (IFXPKC_ERRORMASK_OOR | IFXPKC_ERRORMASK_SIG_INVALID)

/** \brief Macro that returns a mask of error bits of STAT register for EC-KCDSA
 */
#define IFXPKC_ERRORMASK_ECKCDSA     (IFXPKC_ERRORMASK_RSASIG | IFXPKC_ERRORMASK_PT_INVALID)

/** \brief Macro that returns a mask of error bits of STAT register for ECDSASIG
 */
#define IFXPKC_ERRORMASK_ECDSASIG    (IFXPKC_ERRORMASK_ECKCDSA | IFXPKC_ERRORMASK_SIG_INVALID)

/** \brief Macro that returns a mask of error bits of STAT register for ECDSAPV
 */
#define IFXPKC_ERRORMASK_ECDSAPV     (IFXPKC_ERRORMASK_ECKCDSA | IFXPKC_ERRORMASK_P_INVALID)

/** \brief Macro that returns a mask of error bits of STAT register for DSAVER
 */
#define IFXPKC_ERRORMASK_DSAVER      (IFXPKC_ERRORMASK_RSASIG | IFXPKC_ERRORMASK_SIG_INVALID)

/** \brief Macro that returns a mask of error bits of STAT register for ECC
 */
#define IFXPKC_ERRORMASK_ECC_CHECKAB (IFXPKC_ERRORMASK_OOR | IFXPKC_ERRORMASK_P_INVALID)

/** \brief Macro that returns a mask of error bits of STAT register for Rabin Miller
 */
#define IFXPKC_ERRORMASK_RM          (IFXPKC_ERRORMASK_OOR | IFXPKC_ERRORMASK_M_INVALID)

/** \brief Macro that returns a mask of error bits of STAT register for Modular inversion operation
 */
#define IFXPKC_ERRORMASK_INV         (IFXPKC_ERRORMASK_RM | IFXPKC_ERRORMASK_NOTINV)

/** \brief Macro that returns a mask of error bits of STAT register for Modular Square root operation
 */
#define IFXPKC_ERRORMASK_SQRTN       (IFXPKC_ERRORMASK_OOR | IFXPKC_ERRORMASK_NQR)

/** \brief Macro that returns a mask of error bits of STAT register for EDDSAVER Operation
 */
#define IFXPKC_ERRORMASK_EDDSAVER    (IFXPKC_ERRORMASK_OOR | IFXPKC_ERRORMASK_PT_INVALID | IFXPKC_ERRORMASK_SIG_INVALID)

/******************************************************************************/
/*-------------------------------Enumerations---------------------------------*/
/******************************************************************************/

/** \brief Enumeration to select accelerator for specific curves
 */
typedef enum
{
    IfxPkc_Acceleration_none       = 0,  /**< \brief No acceleration */
    IfxPkc_Acceleration_P256       = 1,  /**< \brief Acceleration for P256 */
    IfxPkc_Acceleration_P384       = 2,  /**< \brief Acceleration for P384 */
    IfxPkc_Acceleration_P521       = 3,  /**< \brief Acceleration for P521 */
    IfxPkc_Acceleration_P192       = 4,  /**< \brief Acceleration for P192 */
    IfxPkc_Acceleration_CURVE25519 = 5,  /**< \brief Acceleration for Curve25519 */
    IfxPkc_Acceleration_ED25519    = 6   /**< \brief Acceleration for Ed25519 */
} IfxPkc_Acceleration;

/** \brief Enumeration for location of paramters in DATARAM used in arithmetic operations
 */
typedef enum
{
    IfxPkc_ArithmeticParamLocation_n = 0,  /**< \brief Location 0x0 Operand N (Modulus) */
    IfxPkc_ArithmeticParamLocation_a = 2,  /**< \brief Location 0x2 Operand A */
    IfxPkc_ArithmeticParamLocation_b = 4,  /**< \brief Location 0x4 Operand B */
    IfxPkc_ArithmeticParamLocation_c = 6   /**< \brief Location 0x6 Operand C */
} IfxPkc_ArithmeticParamLocation;

/** \brief Enumeration for selecting the bit value for any field
 */
typedef enum
{
    IfxPkc_BitValue_0 = 0,  /**< \brief Value 0 */
    IfxPkc_BitValue_1 = 1   /**< \brief Value 1 */
} IfxPkc_BitValue;

/** \brief Enumeration to select Encryption / Decryption operation
 */
typedef enum
{
    IfxPkc_CryptoOp_decrypt = 0,  /**< \brief Perform Decryption */
    IfxPkc_CryptoOp_encrypt = 1   /**< \brief Perform encryption */
} IfxPkc_CryptoOp;

/** \brief Enumeration for type of DATARAM operation
 */
typedef enum
{
    IfxPkc_DataramOp_read  = 0, /**< \brief Read from DATARAM */
    IfxPkc_DataramOp_write = 1  /**< \brief Write to DATARAM */
} IfxPkc_DataramOp;

/** \brief Enumeration for DSA parameter location in DATARAM
 */
typedef enum
{
    IfxPkc_DsaParamLocation_p          = 0,  /**< \brief Location 0x0 */
    IfxPkc_DsaParamLocation_q          = 2,  /**< \brief Location 0x2 */
    IfxPkc_DsaParamLocation_g          = 3,  /**< \brief Location 0x3 */
    IfxPkc_DsaParamLocation_k          = 5,  /**< \brief Location 0x5 */
    IfxPkc_DsaParamLocation_privateKey = 6,  /**< \brief Location 0x6 */
    IfxPkc_DsaParamLocation_publicKey  = 8,  /**< \brief Location 0x8 */
    IfxPkc_DsaParamLocation_r          = 10, /**< \brief Location 0xA */
    IfxPkc_DsaParamLocation_s          = 11, /**< \brief Location 0xB */
    IfxPkc_DsaParamLocation_hash       = 12  /**< \brief Location 0xC */
} IfxPkc_DsaParamLocation;

/** \brief Enumeration for ECC parameter location in DATARAM
 */
typedef enum
{
    IfxPkc_EccParamLocation_p       = 0,   /**< \brief Location 0x0 */
    IfxPkc_EccParamLocation_n       = 1,   /**< \brief Location 0x1 */
    IfxPkc_EccParamLocation_xG      = 2,   /**< \brief Location 0x2 */
    IfxPkc_EccParamLocation_yG      = 3,   /**< \brief Location 0x3 */
    IfxPkc_EccParamLocation_a       = 4,   /**< \brief Location 0x4 */
    IfxPkc_EccParamLocation_b       = 5,   /**< \brief Location 0x5 */
    IfxPkc_EccParamLocation_point1x = 6,   /**< \brief Location 0x6 Operand A */
    IfxPkc_EccParamLocation_point1y = 7,   /**< \brief Location 0x7 Operand A + 1 */
    IfxPkc_EccParamLocation_point2x = 8,   /**< \brief Location 0x8 Operand B */
    IfxPkc_EccParamLocation_point2y = 9,   /**< \brief Location 0x9 Operand B + 1 */
    IfxPkc_EccParamLocation_point3x = 10,  /**< \brief Location 0xA Operand C */
    IfxPkc_EccParamLocation_point3y = 11   /**< \brief Location 0xB Operand C + 1 */
} IfxPkc_EccParamLocation;

/** \brief Enumeration for ECDSA parameter location in DATARAM
 */
typedef enum
{
    IfxPkc_EcdsaParamLocation_p           = 0,  /**< \brief Location 0x0 */
    IfxPkc_EcdsaParamLocation_n           = 1,  /**< \brief Location 0x1 */
    IfxPkc_EcdsaParamLocation_xG          = 2,  /**< \brief Location 0x2 */
    IfxPkc_EcdsaParamLocation_yG          = 3,  /**< \brief Location 0x3 */
    IfxPkc_EcdsaParamLocation_a           = 4,  /**< \brief Location 0x4 */
    IfxPkc_EcdsaParamLocation_b           = 5,  /**< \brief Location 0x5 */
    IfxPkc_EcdsaParamLocation_privateKey  = 6,  /**< \brief Location 0x6 */
    IfxPkc_EcdsaParamLocation_k           = 7,  /**< \brief Location 0x7 */
    IfxPkc_EcdsaParamLocation_publicKeyXQ = 8,  /**< \brief Location 0x8 */
    IfxPkc_EcdsaParamLocation_publicKeyYQ = 9,  /**< \brief Location 0x9 */
    IfxPkc_EcdsaParamLocation_r           = 10, /**< \brief Location 0xA */
    IfxPkc_EcdsaParamLocation_s           = 11, /**< \brief Location 0xB */
    IfxPkc_EcdsaParamLocation_hash        = 12  /**< \brief Location 0xC */
} IfxPkc_EcdsaParamLocation;

/** \brief Enumeration for EC-KCDSA parameter location in DATARAM
 */
typedef enum
{
    IfxPkc_EckcdsaParamLocation_p           = 0,  /**< \brief Location 0x0 */
    IfxPkc_EckcdsaParamLocation_n           = 1,  /**< \brief Location 0x1 */
    IfxPkc_EckcdsaParamLocation_xG          = 2,  /**< \brief Location 0x2 */
    IfxPkc_EckcdsaParamLocation_yG          = 3,  /**< \brief Location 0x3 */
    IfxPkc_EckcdsaParamLocation_a           = 4,  /**< \brief Location 0x4 */
    IfxPkc_EckcdsaParamLocation_b           = 5,  /**< \brief Location 0x5 */
    IfxPkc_EckcdsaParamLocation_privateKey  = 6,  /**< \brief Location 0x6 */
    IfxPkc_EckcdsaParamLocation_k           = 7,  /**< \brief Location 0x7 */
    IfxPkc_EckcdsaParamLocation_publicKeyXQ = 8,  /**< \brief Location 0x8 */
    IfxPkc_EckcdsaParamLocation_publicKeyYQ = 9,  /**< \brief Location 0x9 */
    IfxPkc_EckcdsaParamLocation_r           = 10, /**< \brief Location 0xA */
    IfxPkc_EckcdsaParamLocation_s           = 11, /**< \brief Location 0xB */
    IfxPkc_EckcdsaParamLocation_hash        = 12, /**< \brief Location 0xC */
    IfxPkc_EckcdsaParamLocation_xW          = 13, /**< \brief Location 0xD */
    IfxPkc_EckcdsaParamLocation_yW          = 14  /**< \brief Location 0xE */
} IfxPkc_EckcdsaParamLocation;

typedef enum
{
    IfxPkc_EdDsaParamLocation_p    = 0,  /**< \brief Location 0x0 */
    IfxPkc_EdDsaParamLocation_L    = 1,  /**< \brief Location 0x1 */
    IfxPkc_EdDsaParamLocation_xB   = 2,  /**< \brief Location 0x2 */
    IfxPkc_EdDsaParamLocation_yB   = 3,  /**< \brief Location 0x3 */
    IfxPkc_EdDsaParamLocation_d    = 4,  /**< \brief Location 0x4 */
    IfxPkc_EdDsaParamLocation_I    = 5,  /**< \brief Location 0x5 */
    IfxPkc_EdDsaParamLocation_kLsb = 6,  /**< \brief Location 0x6 */
    IfxPkc_EdDsaParamLocation_kMsb = 7,  /**< \brief Location 0x7 */
    IfxPkc_EdDsaParamLocation_rLsb = 8,  /**< \brief Location 0x8 rLsb or xA */
    IfxPkc_EdDsaParamLocation_rMsb = 9,  /**< \brief Location 0x9 rMsb or xB */
    IfxPkc_EdDsaParamLocation_xR   = 10, /**< \brief Location 0xA xR or S (Signature component) */
    IfxPkc_EdDsaParamLocation_yR   = 11  /**< \brief Location 0xB yR or s (shared secret) */
} IfxPkc_EdDsaParamLocation;

/** \brief Enumeration to select endian type
 */
typedef enum
{
    IfxPkc_Endian_little = 0,  /**< \brief Native format (little endian) */
    IfxPkc_Endian_big    = 1   /**< \brief Byte swapped (big endian) */
} IfxPkc_Endian;

/** \brief Enumeration to select the field type
 */
typedef enum
{
    IfxPkc_Field_GFP  = 0, /**< \brief Field is GF(p) */
    IfxPkc_Field_GF2M = 1  /**< \brief Field is GF(2^m) */
} IfxPkc_Field;

/** \brief Enumeration for J-PAKE parameter location in DATARAM
 */
typedef enum
{
    IfxPkc_JPakeParamLocation_p    = 0,   /**< \brief Location 0x0 */
    IfxPkc_JPakeParamLocation_n    = 1,   /**< \brief Location 0x1 */
    IfxPkc_JPakeParamLocation_xG   = 2,   /**< \brief Location 0x2 */
    IfxPkc_JPakeParamLocation_yG   = 3,   /**< \brief Location 0x3 */
    IfxPkc_JPakeParamLocation_a    = 4,   /**< \brief Location 0x4 */
    IfxPkc_JPakeParamLocation_b    = 5,   /**< \brief Location 0x5 */
    IfxPkc_JPakeParamLocation_xV   = 6,   /**< \brief Location 0x6 */
    IfxPkc_JPakeParamLocation_yV   = 7,   /**< \brief Location 0x7 */
    IfxPkc_JPakeParamLocation_xX   = 8,   /**< \brief Location 0x8 */
    IfxPkc_JPakeParamLocation_yX   = 9,   /**< \brief Location 0x9 */
    IfxPkc_JPakeParamLocation_r    = 10,  /**< \brief Location 0xA */
    IfxPkc_JPakeParamLocation_x    = 11,  /**< \brief Location 0xB */
    IfxPkc_JPakeParamLocation_hash = 12,  /**< \brief Location 0xC */
    IfxPkc_JPakeParamLocation_xT   = 13,  /**< \brief Location 0xD */
    IfxPkc_JPakeParamLocation_yT   = 14   /**< \brief Location 0xE */
} IfxPkc_JPakeParamLocation;

/** \brief Enumeration to select accelerator for Montgomery curve
 */
typedef enum
{
    IfxPkc_McAcceleration_none       = 0, /**< \brief No acceleration */
    IfxPkc_McAcceleration_CURVE25519 = 5  /**< \brief Acceleration for Curve25519 */
} IfxPkc_McAcceleration;

/** \brief Enumeration for location of paramters in DATARAM used in Montogomery operation
 */
typedef enum
{
    IfxPkc_McParamLocation_p       = 0,  /**< \brief Location 0x0 Curve parameter p */
    IfxPkc_McParamLocation_a       = 1,  /**< \brief Location 0x1 Curve parameter a */
    IfxPkc_McParamLocation_point1x = 2,  /**< \brief Location 0x2 Point 1 x */
    IfxPkc_McParamLocation_scalar  = 3,  /**< \brief Location 0x3 k */
    IfxPkc_McParamLocation_point3x = 4   /**< \brief Location 0x4 Point 3 x */
} IfxPkc_McParamLocation;

/** \brief Enumeration to select memory location
 */
typedef enum
{
    IfxPkc_MemLocation_0 = 0,   /**< \brief OFFSET: 0x0000 Location 0x0 */
    IfxPkc_MemLocation_1 = 1,   /**< \brief OFFSET: 0x0200 Location 0x1 */
    IfxPkc_MemLocation_2 = 2,   /**< \brief OFFSET: 0x0400 Location 0x2 */
    IfxPkc_MemLocation_3 = 3,   /**< \brief OFFSET: 0x0600 Location 0x3 */
    IfxPkc_MemLocation_4 = 4,   /**< \brief OFFSET: 0x0800 Location 0x4 */
    IfxPkc_MemLocation_5 = 5,   /**< \brief OFFSET: 0x0A00 Location 0x5 */
    IfxPkc_MemLocation_6 = 6,   /**< \brief OFFSET: 0x0C00 Location 0x6 */
    IfxPkc_MemLocation_7 = 7,   /**< \brief OFFSET: 0x0E00 Location 0x7 */
    IfxPkc_MemLocation_8 = 8,   /**< \brief OFFSET: 0x1000 Location 0x8 */
    IfxPkc_MemLocation_9 = 9,   /**< \brief OFFSET: 0x1200 Location 0x9 */
    IfxPkc_MemLocation_A = 10,  /**< \brief OFFSET: 0x1400 Location 0xA */
    IfxPkc_MemLocation_B = 11,  /**< \brief OFFSET: 0x1600 Location 0xB */
    IfxPkc_MemLocation_C = 12,  /**< \brief OFFSET: 0x1800 Location 0xC */
    IfxPkc_MemLocation_D = 13,  /**< \brief OFFSET: 0x1A00 Location 0xD */
    IfxPkc_MemLocation_E = 14,  /**< \brief OFFSET: 0x1C00 Location 0xE */
    IfxPkc_MemLocation_F = 15   /**< \brief OFFSET: 0x1E00 Location 0xF */
} IfxPkc_MemLocation;

/** \brief Enumeration to select operand
 */
typedef enum
{
    IfxPkc_Operand_a = 0,  /**< \brief Operand A */
    IfxPkc_Operand_b = 1,  /**< \brief Operand B */
    IfxPkc_Operand_c = 2,  /**< \brief Operand C */
    IfxPkc_Operand_n = 3   /**< \brief Operand N */
} IfxPkc_Operand;

/** \brief Enumeration to select operation type
 */
typedef enum
{
    IfxPkc_OperationType_none             = 0,   /**< \brief Not selected */
    IfxPkc_OperationType_ADDN             = 1,   /**< \brief Modular addition (GF(p) & GF(2^m)) */
    IfxPkc_OperationType_SUBN             = 2,   /**< \brief Modular subtraction (GF(p) & GF(2^m)) */
    IfxPkc_OperationType_MULTN            = 3,   /**< \brief Modular multiplication (odd N, GF(p) & GF(2^m)) */
    IfxPkc_OperationType_RED              = 4,   /**< \brief Modular reduction (odd N, GF(p) & GF(2^m)) */
    IfxPkc_OperationType_DIVN             = 5,   /**< \brief Modular division (odd N, GF(p) & GF(2^m)) */
    IfxPkc_OperationType_INV              = 6,   /**< \brief Modular inversion (odd N, GF(p) & GF(2^m)) */
    IfxPkc_OperationType_SQRTN            = 7,   /**< \brief Modular square root (GF(p) only) */
    IfxPkc_OperationType_MULT             = 8,   /**< \brief Multiplication (GF(p) & GF(2^m)) */
    IfxPkc_OperationType_INV2             = 9,   /**< \brief Modular inversion (even N and GF(p) only) */
    IfxPkc_OperationType_RED2             = 10,  /**< \brief Modular reduction (even N and GF(p) only) */
    IfxPkc_OperationType_CLRMEM           = 15,  /**< \brief Clear data memory */
    IfxPkc_OperationType_EXP              = 16,  /**< \brief Modular exponentiation (GF(p) only) */
    IfxPkc_OperationType_RSAPKGEN         = 17,  /**< \brief RSA - Private Key Generation (GF(p) only) */
    IfxPkc_OperationType_RSACRTKEYPARGEN  = 18,  /**< \brief RSA - CRT Key Parameter Generation (GF(p) only) */
    IfxPkc_OperationType_RSACRTDEC        = 19,  /**< \brief RSA - CRT Decryption (GF(p) only) */
    IfxPkc_OperationType_RSAENC           = 20,  /**< \brief RSA - Encryption (GF(p) only) */
    IfxPkc_OperationType_RSADEC           = 21,  /**< \brief RSA - Decryption (GF(p) only) */
    IfxPkc_OperationType_RSASIG           = 22,  /**< \brief RSA - Signature Generation (GF(p) only) */
    IfxPkc_OperationType_RSAVER           = 23,  /**< \brief RSA - Signature Verification (GF(p) only) */
    IfxPkc_OperationType_DSAKEYGEN        = 24,  /**< \brief DSA - Key Generation (GF(p) only) */
    IfxPkc_OperationType_DSASIG           = 25,  /**< \brief DSA - Signature Generation (GF(p) only) */
    IfxPkc_OperationType_DSAVER           = 26,  /**< \brief DSA - Signature Verification (GF(p) only) */
    IfxPkc_OperationType_SRPSRVKEY        = 27,  /**< \brief SRP - Server Session Key (GF(p) only) */
    IfxPkc_OperationType_SRPCLTKEY        = 28,  /**< \brief SRP - Client Session Key (GF(p) only) */
    IfxPkc_OperationType_RSAHLFCRTREC     = 29,  /**< \brief RSA - Half CRT Recombination (GF(p) only) */
    IfxPkc_OperationType_SRPSRVPUB        = 30,  /**< \brief SRP - Server Public Key (GF(p) only) */
    IfxPkc_OperationType_RSAHLFCRTDEC     = 31,  /**< \brief RSA - Half CRT Decryption (GF(p) only) */
    IfxPkc_OperationType_PDBL             = 32,  /**< \brief ECC Point Doubling (GF(p) & GF(2^m)) */
    IfxPkc_OperationType_PADD             = 33,  /**< \brief ECC Point Addition (GF(p) & GF(2^m)) */
    IfxPkc_OperationType_SMULT            = 34,  /**< \brief ECC Point Multiplication (GF(p) & GF(2^m)) */
    IfxPkc_OperationType_CHECKAB          = 35,  /**< \brief ECC Check a & b (GF(p) & GF(2^m)) */
    IfxPkc_OperationType_CHECKN           = 36,  /**< \brief ECC Check n!=p (GF(p) & GF(2^m)) */
    IfxPkc_OperationType_CHECKPXY         = 37,  /**< \brief ECC Check x<p, y<p (GF(p) & GF(2^m)) */
    IfxPkc_OperationType_CHECKPOC         = 38,  /**< \brief ECC Check point on curve (GF(p) & GF(2^m)) */
    IfxPkc_OperationType_YRECOVER         = 39,  /**< \brief ECC Point Decompression (GF(p) only) */
    IfxPkc_OperationType_SMULT25519       = 40,  /**< \brief Montgomery curve Point Multiplication */
    IfxPkc_OperationType_SM2SIG           = 45,  /**< \brief SM2 - Signature Generation (GF(p) & GF(2^m)) */
    IfxPkc_OperationType_SM2VER           = 46,  /**< \brief SM2 - Signature Verification (GF(p) & GF(2^m)) */
    IfxPkc_OperationType_SM2KEYEXCH       = 47,  /**< \brief SM2 - Key Exchange (GF(p) & GF(2^m)) */
    IfxPkc_OperationType_ECDSASIG         = 48,  /**< \brief ECDSA - Signature Generation (GF(p) & GF(2^m)) */
    IfxPkc_OperationType_ECDSAVER         = 49,  /**< \brief ECDSA - Signature Verification */
    IfxPkc_OperationType_ECDSAPV          = 50,  /**< \brief ECDSA - Domain Parameters Validation */
    IfxPkc_OperationType_ECKCDSAPUBKEYGEN = 51,  /**< \brief ECKCDSA - Public key generation */
    IfxPkc_OperationType_ECKCDSASIG       = 52,  /**< \brief ECKCDSA - Signature generation */
    IfxPkc_OperationType_ECKCDSAVER       = 53,  /**< \brief ECKCDSA - Signature verification */
    IfxPkc_OperationType_JPAKEZKPGEN      = 54,  /**< \brief JPAKE - Generate ZKP */
    IfxPkc_OperationType_JPAKEZKPVER      = 55,  /**< \brief JPAKE - Verify ZKP */
    IfxPkc_OperationType_JPAKE3PADD       = 56,  /**< \brief JPAKE - 3-point addition */
    IfxPkc_OperationType_JPAKEKEYGEN      = 57,  /**< \brief JPAKE - Generate Session Key */
    IfxPkc_OperationType_JPAKEGENSTP2     = 58,  /**< \brief JPAKE - Generate Step 2 */
    IfxPkc_OperationType_EDDSASMULT       = 59,  /**< \brief EdDSA - Point multiplication */
    IfxPkc_OperationType_EDDSASIG         = 60,  /**< \brief EdDSA - Signature generation */
    IfxPkc_OperationType_EDDSAVER         = 61,  /**< \brief EdDSA - Signature verification */
    IfxPkc_OperationType_RABINMILLER      = 66   /**< \brief Rabin-Miller (GF(p) only) */
} IfxPkc_OperationType;

/** \brief Primality status of a number
 */
typedef enum
{
    IfxPkc_PrimalityStatus_unknown       = -1, /**< \brief Unknown status */
    IfxPkc_PrimalityStatus_probablyPrime = 0,  /**< \brief The integer is probably prime */
    IfxPkc_PrimalityStatus_composite     = 1   /**< \brief The integer is composite */
} IfxPkc_PrimalityStatus;

/** \brief Enumeration for Rabin Miller parameter location in DATARAM
 */
typedef enum
{
    IfxPkc_RMParamLocation_testInteger   = 0, /**< \brief Location 0x0 */
    IfxPkc_RMParamLocation_randomInteger = 6  /**< \brief Location 0x6 */
} IfxPkc_RMParamLocation;

/** \brief Enumeration for RSA CRT parameter location in DATARAM
 */
typedef enum
{
    IfxPkc_RsaCrtParamLocation_p          = 2,  /**< \brief Location 0x2 */
    IfxPkc_RsaCrtParamLocation_q          = 3,  /**< \brief Location 0x3 */
    IfxPkc_RsaCrtParamLocation_cipherText = 4,  /**< \brief Location 0x4 */
    IfxPkc_RsaCrtParamLocation_plainText  = 5,  /**< \brief Location 0x5 */
    IfxPkc_RsaCrtParamLocation_privateKey = 6,  /**< \brief Location 0x6 */
    IfxPkc_RsaCrtParamLocation_dP         = 10, /**< \brief Location 0xA */
    IfxPkc_RsaCrtParamLocation_dQ         = 11, /**< \brief Location 0xB */
    IfxPkc_RsaCrtParamLocation_qInv       = 12, /**< \brief Location 0xC */
    IfxPkc_RsaCrtParamLocation_vp         = 13, /**< \brief Location 0xD */
    IfxPkc_RsaCrtParamLocation_vq         = 14  /**< \brief Location 0xE */
} IfxPkc_RsaCrtParamLocation;

/** \brief Enumeration for RSA parameter location in DATARAM
 */
typedef enum
{
    IfxPkc_RsaParamLocation_modulus    = 0,  /**< \brief Location 0x0 */
    IfxPkc_RsaParamLocation_lambda     = 1,  /**< \brief Location 0x1 */
    IfxPkc_RsaParamLocation_p          = 2,  /**< \brief Location 0x2 */
    IfxPkc_RsaParamLocation_q          = 3,  /**< \brief Location 0x3 */
    IfxPkc_RsaParamLocation_cipherText = 4,  /**< \brief Location 0x4 */
    IfxPkc_RsaParamLocation_plainText  = 5,  /**< \brief Location 0x5 */
    IfxPkc_RsaParamLocation_privateKey = 6,  /**< \brief Location 0x6 */
    IfxPkc_RsaParamLocation_publicKey  = 8,  /**< \brief Location 0x8 */
    IfxPkc_RsaParamLocation_s          = 11, /**< \brief Location 0xB */
    IfxPkc_RsaParamLocation_hash       = 12  /**< \brief Location 0xC */
} IfxPkc_RsaParamLocation;

/** \brief Enumeration to select Signature generation / verification operation
 */
typedef enum
{
    IfxPkc_SignatureOp_generate = 0,  /**< \brief Perform Signature generation */
    IfxPkc_SignatureOp_verify   = 1   /**< \brief Perform Signature verification */
} IfxPkc_SignatureOp;

/** \brief Enumeration for SM2 parameter location in DATARAM
 */
typedef enum
{
    IfxPkc_Sm2ParamLocation_p           = 0,  /**< \brief Location 0x0 */
    IfxPkc_Sm2ParamLocation_n           = 1,  /**< \brief Location 0x1 */
    IfxPkc_Sm2ParamLocation_xG          = 2,  /**< \brief Location 0x2 */
    IfxPkc_Sm2ParamLocation_yG          = 3,  /**< \brief Location 0x3 */
    IfxPkc_Sm2ParamLocation_a           = 4,  /**< \brief Location 0x4 */
    IfxPkc_Sm2ParamLocation_b           = 5,  /**< \brief Location 0x5 */
    IfxPkc_Sm2ParamLocation_privateKey  = 6,  /**< \brief Location 0x6 */
    IfxPkc_Sm2ParamLocation_k           = 7,  /**< \brief Location 0x7 */
    IfxPkc_Sm2ParamLocation_publicKeyXQ = 8,  /**< \brief Location 0x8 */
    IfxPkc_Sm2ParamLocation_publicKeyYQ = 9,  /**< \brief Location 0x9 */
    IfxPkc_Sm2ParamLocation_r           = 10, /**< \brief Location 0xA */
    IfxPkc_Sm2ParamLocation_s           = 11, /**< \brief Location 0xB */
    IfxPkc_Sm2ParamLocation_hash        = 12  /**< \brief Location 0xC */
} IfxPkc_Sm2ParamLocation;

/** \brief Enumeration for SRP parameter location in DATARAM
 */
typedef enum
{
    IfxPkc_SrpParamLocation_N = 0,   /**< \brief Location 0x0 */
    IfxPkc_SrpParamLocation_A = 2,   /**< \brief Location 0x2 */
    IfxPkc_SrpParamLocation_g = 3,   /**< \brief Location 0x3 */
    IfxPkc_SrpParamLocation_a = 4,   /**< \brief Location 0x4 */
    IfxPkc_SrpParamLocation_B = 5,   /**< \brief Location 0x5 */
    IfxPkc_SrpParamLocation_x = 6,   /**< \brief Location 0x6 */
    IfxPkc_SrpParamLocation_k = 7,   /**< \brief Location 0x7 */
    IfxPkc_SrpParamLocation_u = 8,   /**< \brief Location 0x8 */
    IfxPkc_SrpParamLocation_v = 10,  /**< \brief Location 0xA */
    IfxPkc_SrpParamLocation_S = 11,  /**< \brief Location 0xB */
    IfxPkc_SrpParamLocation_b = 12   /**< \brief Location 0xC */
} IfxPkc_SrpParamLocation;

/** \brief Enumeration to select the state of the module
 */
typedef enum
{
    IfxPkc_State_unknown              = -1, /**< \brief state is unknown */
    IfxPkc_State_moduleInitialized    = 0,  /**< \brief the module has been initialized */
    IfxPkc_State_operationInitialized = 1,  /**< \brief operation has been initialized */
    IfxPkc_State_error                = 2,  /**< \brief the module has encountered an error */
    IfxPkc_State_opBusy               = 3   /**< \brief the module is active and performing some operation */
} IfxPkc_State;

typedef enum
{
    IfxPkc_Status_unknown = -1,  /**< \brief Operation state is unknown */
    IfxPkc_Status_success = 0,   /**< \brief Operation successful */
    IfxPkc_Status_failure = 1    /**< \brief Operation Failed */
} IfxPkc_Status;

/******************************************************************************/
/*-----------------------------Data Structures--------------------------------*/
/******************************************************************************/

/** \brief Bitfield structure holding the error status bits of module
 */
typedef struct
{
    uint32 pointInvalid : 1;                 /**< \brief Point invalid (point not on curve) error */
    uint32 outOfRange : 1;                   /**< \brief Out of range error */
    uint32 modulusInvalid : 1;               /**< \brief Modulus not valid error */
    uint32 functionNotImplemented : 1;       /**< \brief Not implemented function error */
    uint32 signatureInvalid : 1;             /**< \brief Signature not valid error */
    uint32 parameterInvalid : 1;             /**< \brief Parameter not valid error */
    uint32 notInvertible : 1;                /**< \brief Not invertible error */
    uint32 notQuadraticResidue : 1;          /**< \brief Not quadratic residue error */
    uint32 softwareError : 1;                /**< \brief Software Error reported by driver */
    uint32 nullPointer : 1;                  /**< \brief Null Pointer referenced */
    uint32 failPtr : 5;
} IfxPkc_ErrorBits;

/** \brief Structure for holding parameters to be written to DATARAM
 */
typedef struct
{
    uint32 *dataPtr;          /**< \brief Pointer to data */
    uint32  sizeInWords;      /**< \brief Number of words */
} IfxPkc_Parameter;

/** \brief PROT and APU Configuration for PKC Module
 */
typedef struct
{
    IfxApProt_ProtConfig proteConfig;        /**< \brief PROTE related configuration */
    IfxApProt_ProtConfig protseConfig;       /**< \brief PROTSE related configuration */
    IfxApApu_ApuConfig   apuConfig;          /**< \brief APU Configuration */
} IfxPkc_ApConfig;

/** \brief Structure for holding curve parameters containing x and y coordinates
 */
typedef struct
{
    IfxPkc_Parameter x;       /**< \brief X Co-ordinate */
    IfxPkc_Parameter y;       /**< \brief Y Co-ordinate */
} IfxPkc_CurveParameter;

/** \brief Union holding the error status of module
 */
typedef union
{
    IfxPkc_ErrorBits Bits;       /**< \brief Bitfield holding specific error information */
    uint32           Word;       /**< \brief Word holding consolidated operation error status */
} IfxPkc_Error;

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Function to initialize the PROT and APU Config of PKC Module with default value
 * \param config PROT and APU Config
 * \return None
 */
IFX_INLINE void IfxPkc_initApConfig(IfxPkc_ApConfig *config);

/** \brief Function to initialize the PROT and APU of PKC Module
 * \param pkcSFR Pointer to the PKC SFR
 * \param config PROT and APU Config
 * \return None
 */
IFX_INLINE void IfxPkc_initAp(Ifx_PKC *pkcSFR, IfxPkc_ApConfig *config);

/** \brief Function that requests to enable the module clock
 * \param pkcSFR Pointer to the PKC SFR
 * \return None
 */
IFX_INLINE void IfxPkc_enableModule(Ifx_PKC *pkcSFR);

/** \brief Function that requests to disable the module clock
 * \param pkcSFR Pointer to the PKC SFR
 * \return None
 */
IFX_INLINE void IfxPkc_disableModule(Ifx_PKC *pkcSFR);

/** \brief Function that checks whether the module clock is enabled
 * \param pkcSFR Pointer to the PKC SFR
 * \return Returns TRUE: Module clock is enabled
 * returns FALSE: Off, module is not clocked
 */
IFX_INLINE boolean IfxPkc_isModuleEnabled(Ifx_PKC *pkcSFR);

/** \brief Function that checks whether Sleep Mode Control is possible or not
 * \param pkcSFR Pointer to the PKC SFR
 * \return Returns TRUE: Sleep mode request is enabled and functional
 * returns FALSE: Module disregards the sleep mode control signal
 */
IFX_INLINE boolean IfxPkc_isSleepModeControlEnabled(Ifx_PKC *pkcSFR);

/** \brief Function that enables/disables module to react to sleep mode requests
 * \param pkcSFR Pointer to the PKC SFR
 * \param sleepModeControl TRUE: enable, FALSE: disable
 * \return None
 */
IFX_INLINE void IfxPkc_setSleepModeControl(Ifx_PKC *pkcSFR, boolean sleepModeControl);

/** \brief Function that sets position of operands and results in data memory
 * \param pkcSFR Pointer to the PKC SFR
 * \param operand Operand A/B/C/N
 * \param memLocation Choose location in data memory
 * \return None
 */
IFX_INLINE void IfxPkc_setOperandPointer(Ifx_PKC *pkcSFR, IfxPkc_Operand operand, IfxPkc_MemLocation memLocation);

/** \brief Function that start the public key cryptographic operation
 * \param pkcSFR Pointer to the PKC SFR
 * \return None
 */
IFX_INLINE void IfxPkc_startOperation(Ifx_PKC *pkcSFR);

/** \brief Function that clears the IRQ output
 * \param pkcSFR Pointer to the PKC SFR
 * \return None
 */
IFX_INLINE void IfxPkc_clearIrqOutput(Ifx_PKC *pkcSFR);

/** \brief Function that checks whether any operation is ongoing
 * \param pkcSFR Pointer to the PKC SFR
 * \return returns TRUE: Operation is ongoing / Module is Busy
 * returns FALSE: Operation is finished / Module is NOT Busy
 */
IFX_INLINE boolean IfxPkc_isModuleBusy(Ifx_PKC *pkcSFR);

/** \brief Function that returns TRUE if any error bits are set
 * \param pkcSFR Pointer to the PKC SFR
 * \return returns TRUE: Any error bit is set
 * returns FALSE: No error bit is set
 */
IFX_INLINE boolean IfxPkc_getErrorStatus(Ifx_PKC *pkcSFR);

/** \brief Function that returns the memory address of a DATARAM location
 * \param memLocation Memory location
 * \return returns the address of chosen memory location
 */
IFX_INLINE uint32 IfxPkc_getMemoryAddress(IfxPkc_MemLocation memLocation);

/** \brief Function that returns pointer to DATARAM based on memory location
 * \param pkcSFR Pointer to the PKC SFR
 * \param memLocation Memory location
 * \return returns the pointer to chosen memory location
 */
IFX_INLINE uint32 *IfxPkc_getDataramPointer(Ifx_PKC *pkcSFR, IfxPkc_MemLocation memLocation);

/** \brief Function that sets endianness of data
 * \param pkcSFR Pointer to the PKC SFR
 * \param endian Little or big endian
 * \return None
 */
IFX_INLINE void IfxPkc_setEndianness(Ifx_PKC *pkcSFR, IfxPkc_Endian endian);

/** \brief Function that checks whether Composite bit is set
 * \param pkcSFR Pointer to the PKC SFR
 * \return True if composite bit is enabled
 * False if composite bit is not enabled
 */
IFX_INLINE boolean IfxPkc_isCompositeFlagEnabled(Ifx_PKC *pkcSFR);

/** \brief Function that sets the Flag A bit used by some operations to store single-bit operands
 * \param pkcSFR Pointer to the PKC SFR
 * \param operand Value to set/unset the bit field
 * \return None
 */
IFX_INLINE void IfxPkc_setFlagA(Ifx_PKC *pkcSFR, IfxPkc_BitValue operand);

/** \brief Function that sets the Flag B bit used by some operations to store single-bit operands
 * \param pkcSFR Pointer to the PKC SFR
 * \param operand Value to set/unset the bit field
 * \return None
 */
IFX_INLINE void IfxPkc_setFlagB(Ifx_PKC *pkcSFR, IfxPkc_BitValue operand);

/** \brief Function that informs PKC to (re)calculate R2 mod N for the next arithmetic operation
 * \param pkcSFR Pointer to the PKC SFR
 * \return None
 */
IFX_INLINE void IfxPkc_calculateRsqr(Ifx_PKC *pkcSFR);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Returns error bits set by the module
 * \param pkcSFR Pointer to the PKC SFR
 * \return errors
 */
IFX_EXTERN IfxPkc_Error IfxPkc_getErrors(Ifx_PKC *pkcSFR);

/** \brief Function that returns true if any algorithm specific error bits are set
 * \param pkcSFR Pointer to the PKC SFR
 * \param operationType Type of operation
 * \return returns TRUE if any algorithm specific error bits are set
 */
IFX_EXTERN boolean IfxPkc_getAlgoErrorStatus(Ifx_PKC *pkcSFR, IfxPkc_OperationType operationType);

/** \brief Function that clears any data present in the DATARAM
 * \param pkcSFR Pointer to the PKC SFR
 * \return Operation status
 */
IFX_EXTERN IfxPkc_Status IfxPkc_clearDataram(Ifx_PKC *pkcSFR);

/** \brief Function to transfer data to or from DATARAM
 * \param dataramOp Read/Write operation to perform on DATARAM
 * \param sourcePtr Source data pointer
 * \param destPtr Destination data pointer
 * \param numWords Number of words to read/write
 * \param operandSizeWords Size of operand configured
 * \param endian Endianness of data
 * \return None
 */
IFX_EXTERN void IfxPkc_performDataramOp(IfxPkc_DataramOp dataramOp, uint32 *sourcePtr, uint32 *destPtr, uint32 numWords, uint32 operandSizeWords, IfxPkc_Endian endian);

/** \brief Function that sets operand pointers according to operation type
 * \param pkcSFR Pointer to the PKC SFR
 * \param operationType Type of operation
 * \return None
 */
IFX_EXTERN void IfxPkc_setOperandPointers(Ifx_PKC *pkcSFR, IfxPkc_OperationType operationType);

/** \brief Configures access to all masters to all the PKC in the device
 * \param apConfig pointer to configuration structure
 * \return None
 */
IFX_EXTERN void IfxPkc_configureAccessToPkc(IfxApApu_ApuConfig *apConfig);

/******************************************************************************/
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE void IfxPkc_initApConfig(IfxPkc_ApConfig *config)
{
    IfxApProt_initConfig(&config->proteConfig);
    IfxApProt_initConfig(&config->protseConfig);
    IfxApApu_initConfig(&config->apuConfig);
}


IFX_INLINE void IfxPkc_initAp(Ifx_PKC *pkcSFR, IfxPkc_ApConfig *config)
{
    /* Initialize the PROT */
    IfxApProt_init((Ifx_PROT_PROT *)&pkcSFR->PROTE, &config->proteConfig);
    IfxApProt_init((Ifx_PROT_PROT *)&pkcSFR->PROTSE, &config->protseConfig);

    /* Change the state to CONFIG, Configure APU and set PROT state back to RUN */
    /* Initialize the APU */
    IfxApProt_setState((Ifx_PROT_PROT *)&pkcSFR->PROTSE, IfxApProt_State_config);
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&pkcSFR->ACCEN, &config->apuConfig);
    IfxApProt_setState((Ifx_PROT_PROT *)&pkcSFR->PROTSE, IfxApProt_State_run);
}


IFX_INLINE void IfxPkc_enableModule(Ifx_PKC *pkcSFR)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&pkcSFR->PROTE, IfxApProt_State_config);
#endif

    pkcSFR->CLC.B.DISR = (uint32)0;

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&pkcSFR->PROTE, IfxApProt_State_run);
#endif

    while (pkcSFR->CLC.B.DISS == (uint32)1)
    {
        /* wait until module is enabled */
    }
}


IFX_INLINE void IfxPkc_disableModule(Ifx_PKC *pkcSFR)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&pkcSFR->PROTE, IfxApProt_State_config);
#endif

    pkcSFR->CLC.B.DISR = (uint32)1;

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&pkcSFR->PROTE, IfxApProt_State_run);
#endif

    while (pkcSFR->CLC.B.DISS == (uint32)0)
    {
        /* wait until module is disabled */
    }
}


IFX_INLINE boolean IfxPkc_isModuleEnabled(Ifx_PKC *pkcSFR)
{
    boolean return_status = FALSE;
    return_status = (pkcSFR->CLC.B.DISS == (uint32)0);
    return return_status;
}


IFX_INLINE boolean IfxPkc_isSleepModeControlEnabled(Ifx_PKC *pkcSFR)
{
    boolean return_status = FALSE;
    return_status = (pkcSFR->CLC.B.EDIS == (uint32)0);
    return return_status;
}


IFX_INLINE void IfxPkc_setSleepModeControl(Ifx_PKC *pkcSFR, boolean sleepModeControl)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&pkcSFR->PROTE, IfxApProt_State_config);
#endif

    if (sleepModeControl == TRUE)
    {
        pkcSFR->CLC.B.EDIS = (uint32)0;
    }
    else
    {
        pkcSFR->CLC.B.EDIS = (uint32)1;
    }

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&pkcSFR->PROTE, IfxApProt_State_run);
#endif
}


IFX_INLINE void IfxPkc_setOperandPointer(Ifx_PKC *pkcSFR, IfxPkc_Operand operand, IfxPkc_MemLocation memLocation)
{
    switch (operand)
    {
    case IfxPkc_Operand_a:
    {
        pkcSFR->PTR.B.OPPTRA = (uint32)memLocation;
        break;
    }
    case IfxPkc_Operand_b:
    {
        pkcSFR->PTR.B.OPPTRB = (uint32)memLocation;
        break;
    }
    case IfxPkc_Operand_c:
    {
        pkcSFR->PTR.B.OPPTRC = (uint32)memLocation;
        break;
    }
    case IfxPkc_Operand_n:
    {
        pkcSFR->PTR.B.OPPTRN = (uint32)memLocation;
        break;
    }
    }
}


IFX_INLINE void IfxPkc_startOperation(Ifx_PKC *pkcSFR)
{
    pkcSFR->CTRL.B.PKSTART = (uint32)1;
}


IFX_INLINE void IfxPkc_clearIrqOutput(Ifx_PKC *pkcSFR)
{
    pkcSFR->CTRL.B.CLRIRQ = (uint32)1;
}


IFX_INLINE boolean IfxPkc_isModuleBusy(Ifx_PKC *pkcSFR)
{
    boolean return_status = FALSE;
    return_status = ((uint32)(pkcSFR->STAT.B.BUSY) == (uint32)1);
    return return_status;
}


IFX_INLINE boolean IfxPkc_getErrorStatus(Ifx_PKC *pkcSFR)
{
    Ifx_PKC_STAT statReg;
    boolean      errorStatus;

    statReg.U   = pkcSFR->STAT.U;
    errorStatus = IFXPKC_CHECK_ERRORSTATUS(statReg.U);
    return errorStatus;
}


IFX_INLINE uint32 IfxPkc_getMemoryAddress(IfxPkc_MemLocation memLocation)
{
    uint32 address;
    address = (uint32)(128) * (uint32)(memLocation);
    return address;
}


IFX_INLINE uint32 *IfxPkc_getDataramPointer(Ifx_PKC *pkcSFR, IfxPkc_MemLocation memLocation)
{
    uint32  memoryAddress;
    uint32 *dataramPointer;
    /* Get the starting destination address in DATARAM */
    memoryAddress  = IfxPkc_getMemoryAddress(memLocation);
    /* Get the pointer to DATARAM */
    dataramPointer = (uint32 *)&(pkcSFR->DATARAM[memoryAddress]);
    return dataramPointer;
}


IFX_INLINE void IfxPkc_setEndianness(Ifx_PKC *pkcSFR, IfxPkc_Endian endian)
{
    pkcSFR->CMD.B.SWAP = (uint32)endian;
}


IFX_INLINE boolean IfxPkc_isCompositeFlagEnabled(Ifx_PKC *pkcSFR)
{
    boolean return_status = FALSE;
    return_status = ((uint32)(pkcSFR->STAT.B.CMPST) == (uint32)1);
    return return_status;
}


IFX_INLINE void IfxPkc_setFlagA(Ifx_PKC *pkcSFR, IfxPkc_BitValue operand)
{
    pkcSFR->CMD.B.FLAGA = (uint32)operand;
}


IFX_INLINE void IfxPkc_setFlagB(Ifx_PKC *pkcSFR, IfxPkc_BitValue operand)
{
    pkcSFR->CMD.B.FLAGB = (uint32)operand;
}


IFX_INLINE void IfxPkc_calculateRsqr(Ifx_PKC *pkcSFR)
{
    pkcSFR->CMD.B.CALCRSQR = (uint32)1;
}


#endif /* IFXPKC_H */
