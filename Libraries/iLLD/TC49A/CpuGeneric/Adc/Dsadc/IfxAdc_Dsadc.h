/**
 * \file IfxAdc_Dsadc.h
 * \brief ADC DSADC details
 * \ingroup IfxLld_Adc
 *
 * \version iLLD_2_0_1_2_19
 * \copyright Copyright (c) 2023 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 *
 * DSADC (Delta Sigma ADC) Interface Driver.
 *
 *   DSADC Inteface layer driver provides initialization and runtime manipulation for the DSADC and EXMOD channels in the ADC Functional Block.
 *
 *   \defgroup IfxLld_Adc_Dsadc_Usage How to use the DSADC Interface driver?
 *   \ingroup IfxLld_Adc
 *
 *   How to Use the Driver:
 *
 *   This Driver can be used to initialize:
 *   1. EXMOD channels for external modulator and internal filter chain usage
 *   2. DSADC channels with full analog modulator and filter chain capabilities
 *
 *   Configuration of DSADC module is contained in the IfxAdc_Dsadc_Config:
 *   1. adcSFR           --> Pointer to ADC module sfr
 *   2. svSignalConfig   --> Supervision signal configuration
 *   3. CarrierConfig    --> Carrier generation configuration.
 *   4. supplyLevel      --> Dsadc supply level
 *
 *   Configuration of DSADC channels:
 *
 *   Configuration of the DSADC channel is contained in the IfxAdc_Dsadc_ChannelConfig structure.
 *   This configuration structure contains:
 *   1. channelId        --> channel number of DSADC
 *   2. adcSFR           --> pointer to the ADC SFR base address.
 *   3. input            --> Input configuration to the DSADC channel
 *   4. filterChain      --> Filter chain configuration
 *   5. analogModulator  --> Analog Modulator configuration
 *   6. trigger          --> Trigger setup with all triggers
 *   7. timestamp        --> Time stamp configuration
 *   8. resultHandling   --> Result handling configuration
 *   9. Autocalibration  --> Flag to allow automatic calibration of channel
 *   10. serviceRequest  --> Service request configuration for result, boundary and timestamp
 *   11. boundCfg        --> Boundary configuration for limit checking
 *   12. gainCalibration --> Gain calibration settings
 *   13. queueCfg        --> Software buffer configuration
 *   14. channelPins     --> Channel pin configuration
 *   15. enableChannel   --> Enable channel
 *
 *   Configuration of the EXMOD channel is contained in the IfxAdc_Dsadc_ExmodChannelConfig
 *   This configuration structure contains:
 *   1. channelId        --> EXMOD channel number
 *   2. adcSFR           --> pointer to the ADC SFR base address.
 *   3. extModulator     --> External Modulator input and clock Configuration
 *   4. filterChain      --> Filter chain configuration
 *   5. trigger          --> Trigger setup with all triggers
 *   6. timestamp        --> Time stamp configuration
 *   7. resultHandling   --> Result handling configuration
 *   8. serviceRequest   --> Service Request configuration
 *   9. boundCfg         --> Boundary configuration for limit checking
 *   10. queueCfg        --> Software buffer configuration
 *   11. exmodPins       --> Exmod channel pins configuration
 *
 *   NOTE : EXMOD filter chain consist of only CIC filter and gain correction.
 *   1. Integrator configuration(IfxAdc_Dsadc_IntegratorConfig) and Offset compensation(IfxAdc_Dsadc_OffsetCompConfig) configuration should be passed NULL_PTR
 *      in filter chain configuration for EXMOD.
 *   2. Trigger configuration contains Inmux (inMuxTrig) and Integrator(integratorTrig) trigger both should be passed NULL_PTR for Exmod channel configuration
 *
 *
 *   Some of the elements are optional during configuration (trigger, timeStamp, limitChecking). Many channels can be mapped to the same
 *   configurations of these types. Hence, these are kept as pointers in the above configuration. User has to initialize objects of these types
 *   and map them to the config structure, if the user desires to use these functionalities.
 *
 *   Steps to use the driver:
 *
 *   \section IfxLld_Adc_Dsadc_Preparation Preparation
 *   \subsection IfxLld_Adc_Dsadc_Include Include Files
 *
 *   Include following header file into your C code:
 *   \code
 *   #include <Adc/Dsadc/IfxAdc_Dsadc.h>
 *   \endcode
 *
 *  \code
 *
 *  //=======================================CONFIGURE=========================================================================
 *  //Modify below configuration to extend the number of channels
 *  #define DSADC_NUM_CHANNELS       (1u)                                           // Number of DSADC Channel to be configured
 *  #define DSADC_CHANNEL0           IfxAdc_DsadcChannel_0                          // DSADC CHANNEL to be configured
 *  #define ANALOG_FULL_SCALE        25000                                          // ANALOG FULL SCALE VALUE
 *  #define CIC_DECIMATION_FACTOR    128                                            // CIC decimation factor
 *
 *  #define IFX_INTPRIO_DSADC_CH0_SR0    1                                          // Channel service request Priority
 *
 *  IfxAdc_DsadcChannel channelArray[DSADC_NUM_CHANNELS] = {DSADC_CHANNEL0};        // Channel Array. Add channel if needed
 *  IfxAdc_Dsadcp_In *posPinArray[DSADC_NUM_CHANNELS] = {&IfxAdc_DSADCPA_AN2_IN};   // Positive Pins
 *  IfxAdc_Dsadcn_In *negPinArray[DSADC_NUM_CHANNELS] = {NULL_PTR};                 // Negative Pins.
 *  Ifx_Priority channelPriority[DSADC_NUM_CHANNELS] = {IFX_INTPRIO_DSADC_CH0_SR0}; // Channel Result event Priority
 *
 *  //========================================================================================================================
 *
 *  //===================================================Global variables=====================================================
 *  IfxAdc_Dsadc g_dsadc;                                                    // DSADC module handle
 *  IfxAdc_Dsadc_Channel g_dsadcChannel[DSADC_NUM_CHANNELS];                 // DSADC channel handle
 *  IfxAdc_Dsadc_Config g_dsadcConfig;                                       // DSADC configuration structure
 *  IfxAdc_Dsadc_ChannelConfig g_dsadcChannelConfig[DSADC_NUM_CHANNELS];     // DSADC channel configuration structure
 *  IfxAdc_Dsadc_InterruptConfig g_dsadcIntConfig;                           // DSADC interrupt configuration
 *  volatile uint16  g_result[DSADC_NUM_CHANNELS];                           // Variable to store the result of the measurement
 *   //=========================================================================================================================
 *
 *  \endcode
 *
 *  Create an interrupt handler for result service request:
 *   \code
 *    // priorities are normally defined in Ifx_IntPrioDef.h
 *
 *   IFX_INTERRUPT(DSADC0SR0ISR, 0, IFX_INTPRIO_DSADC_CH0_SR0)
 *   {
 *        //Read Dsadc channel Result.
 *        g_result[0] = IfxAdc_Dsadc_readDsadcChannelResult(&g_dsadcChannel[0]);
 *   }
 *   \endcode
 *
 *   \subsection IfxLld_Adc_Dsadc_Init Module Initialization
 *   \code
 *         //Enable ADC module
 *         IfxAdc_enableModule(&MODULE_ADC);
 *
 *         //Set the global configuration of DSADC to default values
 *         IfxAdc_Dsadc_initModuleConfig(&g_dsadcConfig, &MODULE_ADC);
 *
 *         //After IfxAdc_Dsadc_initModuleConfig, IfxAdc_Dsadc_CarrierConfig and IfxAdc_Dsadc_SvSigConfig will be set to NULL.
 *         //Follow below steps for carrier configuration.
 *         IfxAdc_Dsadc_CarrierConfig myCarrierConfig;
 *         IfxAdc_Dsadc_initCarrierGenConfig(&myCarrierConfig);
 *
 *         //Modify the myCarrierConfig to desired values
 *         myCarrierConfig.carrierMode = IfxAdc_DsadcCgOperatingMode_squareWave;
 *         g_dsadcConfig.carrierConfig = &myCarrierConfig;
 *
 *        //Module initialization. Global clock enable and configuration of global registers will be done in IfxAdc_Dsadc_initModule.
 *        IfxAdc_Dsadc_initModule(&g_dsadc, &g_dsadcConfig);
 *
 *       uint8 chIndex = 0u;
 *
 *       for(chIndex = 0u; chIndex < DSADC_NUM_CHANNELS; chIndex++)
 *       {
 *          // Initialize the configuration with default values
 *          IfxAdc_Dsadc_initChannelConfig(&g_dsadcChannelConfig[chIndex], &MODULE_ADC);
 *
 *          // Change DSADC channel configuration
 *          g_dsadcChannelConfig[chIndex].channelId = channelArray[chIndex];
 *
 *          // Input configuration of channel
 *          g_dsadcChannelConfig[chIndex].input.inputMuxControl = IfxAdc_DsadcInputMuxActCtrl_preset;  // Preset by SW, update by trigger
 *          g_dsadcChannelConfig[chIndex].input.inputMuxSel     = IfxAdc_DsadcInSel_a;                 // Input MUX selection (SW preset)
 *
 *          // Result Handling
 *          g_dsadcChannelConfig[chIndex].resultHandling.disableFIFO   = TRUE;         //  Disable the FIFO
 *
 *          // Analog Modulator
 *          g_dsadcChannelConfig[chIndex].analogModulator.positiveInput   = IfxAdc_DsadcInCfg_inputPin; // Set positive pin input
 *          g_dsadcChannelConfig[chIndex].analogModulator.negativeInput   = IfxAdc_DsadcInCfg_ground;   // Set positive pin input
 *
 *          // Filter Chain Configuration
 *          g_dsadcChannelConfig[chIndex].filterChain.cicDecimationFactor = CIC_DECIMATION_FACTOR;       // Set CIC decimation factor
 *          g_dsadcChannelConfig[chIndex].filterChain.cicDataShift        = IFXADC_DSADC_CICSHIFT(CIC_DECIMATION_FACTOR, ANALOG_FULL_SCALE); // Select CIC Data shift offset
 *          g_dsadcChannelConfig[chIndex].filterChain.gainFactor          = IFXADC_DSADC_GAINFACTOR(CIC_DECIMATION_FACTOR, ANALOG_FULL_SCALE, g_dsadcChannelConfig[chIndex].filterChain.cicDataShift);  // Set gain factor write value
 *          g_dsadcChannelConfig[chIndex].filterChain.enableFilterChain   = TRUE;
 *
 *          // Gain calibration configuration
 *          g_dsadcChannelConfig[chIndex].gainCalibration.calTarget              = ANALOG_FULL_SCALE;
 *          g_dsadcChannelConfig[chIndex].gainCalibration.cicDecimationRate      = IfxAdc_DsadcCicDecimationRate_256; // Set CIC decimation of 256 during calibration
 *          g_dsadcChannelConfig[chIndex].gainCalibration.cicShift               = IfxAdc_DsadcCicShift_24to40;       // Select the valid outputs bits from the CIC filter
 *          g_dsadcChannelConfig[chIndex].gainCalibration.gainCorrectionFactor   = 4687;                              // Set multiplication factor for gain correction during calibration
 *
 *          // Result Service Request
 *          g_dsadcChannelConfig[chIndex].serviceRequest.intCfg[0].priority      = channelPriority[chIndex]; // Set Interrupt priority
 *          g_dsadcChannelConfig[chIndex].serviceRequest.intCfg[0].typeOfService = IfxSrc_Tos_cpu0;       // Set interrupt provider
 *          // Set identifier of Virtual machine interrupt service provider
 *          g_dsadcChannelConfig[chIndex].serviceRequest.intCfg[0].vmId          = IfxSrc_VmId_0;
 *          // Select service request for result event from main filter chain
 *          g_dsadcChannelConfig[chIndex].serviceRequest.sr0Enable               = IfxAdc_DsadcSrvReq0_always;
 *          g_dsadcChannelConfig[chIndex].serviceRequest.enableServiceReq        = TRUE; // Enable service request configurations
 *
 *          // Pins Configuration
 *          IfxAdc_Dsadc_ChannelPinConfig pins = {
 *                  NULL_PTR,               IfxPort_InputMode_noPullDevice,    // Trigger pin not used
 *                  negPinArray[chIndex],   IfxPort_InputMode_noPullDevice,    // Negative analog input not used
 *                  posPinArray[chIndex],   IfxPort_InputMode_noPullDevice     // Positive analog input
 *          };
 *
 *          g_dsadcChannelConfig[chIndex].channelPins = &pins;
 *
 *          g_dsadcChannelConfig[chIndex].enableChannel = TRUE;                        // Enable channel
 *
 *          // Initialize the channel
 *          IfxAdc_Dsadc_initChannel(&g_dsadcChannel[chIndex], &g_dsadcChannelConfig[chIndex]);
 *       }
 *
 *        // trigger calibration
 *       for(chIndex = 0u; chIndex < DSADC_NUM_CHANNELS; chIndex++)
 *       {
 *          IfxAdc_triggerDsadcCalibration(g_dsadcChannelConfig[chIndex].channelId);
 *
 *           //Wait for calibration to get over
 *          while(IfxAdc_DsadcCalibrationState_calibrated != IfxAdc_getDsadcCalibrationStatus(g_dsadcChannelConfig[chIndex].channelId));
 *       }
 *
 *   \endcode
 *
 *    The DSADC is ready for use now!
 *
 *   \section IfxLld_Adc_Dsadc_ConversionResult Conversion Result
 *   \code
 *          //User can obtain the result of conversion through the "readResult" API's.
 *          // Main result of DSADC channel
 *          uint16 result;
 *          result = IfxAdc_Dsadc_readDsadcChannelResult(&g_dsadcChannel[0]);
 *
 *          //Aux result of DSADC channel (Auxiliary filter should be enabled in configuration)
 *          uint16 auxResult;
 *          auxResult = IfxAdc_getDsadcAuxResult(g_dsadcChannelConfig[chIndex].channelId);
 *
 *   \endcode
 *
 *   \subsection IfxLld_Adc_Dsadc_Exmod EXMOD Channel initialization
 *   \code
 *
 *   //=============================================CONFIGURE===================================================================
 *  //Modify below configuration to extend the number of channels
 *  #define EXMOD_NUM_CHANNELS       (1u)                                           // Number of EXMOD Channel to be configured
 *  #define EXMOD_CHANNEL            IfxAdc_Exmod_0                                 // EXMOD CHANNEL to be configured
 *  #define ANALOG_FULL_SCALE        25000                                          // ANALOG FULL SCALE VALUE
 *  #define CIC_DECIMATION_FACTOR    128                                            // CIC decimation factor
 *
 *  #define IFX_INTPRIO_EXMOD_CH0_SR0    1                                          // Channel service request Priority
 *
 *  IfxAdc_Exmod channelArray[EXMOD_NUM_CHANNELS]    = {EXMOD_CHANNEL};             // Channel Array. Add channel if needed
 *  IfxAdc_Clkin_In *clkPinArray[EXMOD_NUM_CHANNELS] = {&IfxAdc_CLKIN0_P33_5_IN};   // Clock Pin Array
 *  IfxAdc_Data_In *datPinArray[EXMOD_NUM_CHANNELS]  = {&IfxAdc_DATA0_P33_6_IN};   // Data Pin Array
 *  Ifx_Priority channelPriority[EXMOD_NUM_CHANNELS] = {IFX_INTPRIO_EXMOD_CH0_SR0}; // Channel Result event Priority
 *
 *  //=======================================================================================================================
 *
 *  //============================================Global variables===========================================================
 *  IfxAdc_Dsadc g_dsadc;                                                         // DSADC module handle
 *  IfxAdc_Dsadc_Exmod g_exmodChannel[EXMOD_NUM_CHANNELS];                        // EXMOD channel handle
 *  IfxAdc_Dsadc_Config g_dsadcConfig;                                            // DSADC configuration structure
 *  IfxAdc_Dsadc_ExmodChannelConfig g_exmodChannelConfig[EXMOD_NUM_CHANNELS];     // EXMOD channel configuration structure
 *  IfxAdc_Dsadc_InterruptConfig g_dsadcIntConfig;                                // DSADC interrupt configuration
 *  volatile uint16  g_result[EXMOD_NUM_CHANNELS];                                // Variable to store the result of the measurement
 *   //=======================================================================================================================
 *   \endcode
 *
 *   Create an interrupt handler for result service request:
 *   \code
 *    // priorities are normally defined in Ifx_IntPrioDef.h
 *
 *   IFX_INTERRUPT(DSADC0SR0ISR, 0, IFX_INTPRIO_EXMOD_CH0_SR0)
 *   {
 *        //Read Exmod channel Result.
 *        g_result[0] = IfxAdc_Dsadc_readExmodChannelResult(&g_exmodChannel[0]);
 *   }
 *   \endcode
 *   \code
 *   // Enable ADC module
 *    IfxAdc_enableModule(&MODULE_ADC);
 *
 *    // Initialize module to default
 *    IfxAdc_Dsadc_initModuleConfig(&g_dsadcConfig, &MODULE_ADC);
 *
 *    // Initialize DSADC module with updated configuration
 *    IfxAdc_Dsadc_initModule(&g_dsadc, &g_dsadcConfig);
 *
 *    uint8 chIndex = 0u;
 *   for(chIndex = 0u; chIndex < EXMOD_NUM_CHANNELS; chIndex++)
 *  {
 *      // Initialize the configuration with default values
 *      IfxAdc_Dsadc_initExmodChannelConfig(&g_exmodChannelConfig[chIndex], &MODULE_ADC);
 *
 *      // Change DSADC channel configuration
 *      g_exmodChannelConfig[chIndex].channelId = channelArray[chIndex];           // Channel ID
 *
 *      // External modulator configuration of channel
 *      g_exmodChannelConfig[chIndex].extModulator.dataSource          = IfxAdc_ExmodDataSource_inputA;      // Data source
 *      g_exmodChannelConfig[chIndex].extModulator.dataStream          = IfxAdc_ExmodDataStream_risingEdge;  // Data sampling on rising edge clock
 *      g_exmodChannelConfig[chIndex].extModulator.clkSrc              = IfxAdc_ExmodClockSource_inputA;     // Clock source
 *      g_exmodChannelConfig[chIndex].extModulator.clkFreq             = IfxAdc_ExmodClockFreq_fadcdiv4;     // External modulator Clock frequency
 *      g_exmodChannelConfig[chIndex].extModulator.enableManchester    = FALSE;                              // Manchester decoding disabled
 *
 *      // Filter Chain Configuration
 *      g_exmodChannelConfig[chIndex].filterChain.cicDecimationFactor = CIC_DECIMATION_FACTOR;       // Set CIC decimation factor
 *      g_exmodChannelConfig[chIndex].filterChain.cicDataShift        = IFXADC_DSADC_CICSHIFT(CIC_DECIMATION_FACTOR, ANALOG_FULL_SCALE); // Select CIC Data shift offset
 *      g_exmodChannelConfig[chIndex].filterChain.gainFactor          = IFXADC_DSADC_GAINFACTOR(CIC_DECIMATION_FACTOR, ANALOG_FULL_SCALE, g_exmodChannelConfig[chIndex].filterChain.cicDataShift);  // Set gain factor write value
 *      g_exmodChannelConfig[chIndex].filterChain.enableFilterChain   = TRUE;     // Disable filter chain at the beginning
 *
 *      // Result Service Request
 *      g_exmodChannelConfig[chIndex].serviceRequest.intCfg[0].priority      = channelPriority[chIndex]; // Set Interrupt priority
 *      g_exmodChannelConfig[chIndex].serviceRequest.intCfg[0].typeOfService = IfxSrc_Tos_cpu0;          // Set interrupt provider
 *      // Set identifier of Virtual machine interrupt service provider
 *      g_exmodChannelConfig[chIndex].serviceRequest.intCfg[0].vmId          = IfxSrc_VmId_0;
 *      // Select service request for result event from main filter chain
 *      g_exmodChannelConfig[chIndex].serviceRequest.sr0Enable               = IfxAdc_DsadcSrvReq0_always;  // Raise service request always
 *      g_exmodChannelConfig[chIndex].serviceRequest.enableServiceReq        = TRUE;                        // Enable service request configurations
 *
 *      // Result Handling
 *      g_exmodChannelConfig[chIndex].resultHandling.disableFIFO   = TRUE;         //  Disable the FIFO
 *
 *      // Pins Configuration
 *      IfxAdc_Dsadc_ExmodPinConfig pins = {
 *              clkPinArray[chIndex],   IfxPort_InputMode_noPullDevice,    // Clock Pin
 *              datPinArray[chIndex],   IfxPort_InputMode_noPullDevice,    // Data source input input pin
 *              IfxPort_PadDriver_cmosAutomotiveSpeed1
 *      };
 *      g_exmodChannelConfig[chIndex].exmodPins = &pins;
 *
 *      // Initialize the channel
 *      IfxAdc_Dsadc_initExmodChannel(&g_exmodChannel[chIndex], &g_exmodChannelConfig[chIndex]);
 *  }
 *
 *   \endcode
 *
 *   The EXMOD channel is ready for use now!
 *
 *   \section IfxLld_Adc_Exmod_ConversionResult Conversion Result
 *   \code
 *          //Main result of EXMOD channel
 *          uint16 exmodResult;
 *          exmodResult = IfxAdc_Dsadc_readExmodChannelResult(&g_exmodChannel[chIndex]);
 *
 *          //If Aux result of EXMOD channel. (Auxiliary filter should be enabled in configuration)
 *          uint16 exmodAuxResult;
 *          exmodAuxResult = IfxAdc_getExmodAuxResult(g_exmodChannelConfig[chIndex].channelId);
 *   \endcode
 *
 * \subsection IfxLld_Adc_Dsadc_Queue DSADC Linear Buffer configuration with timestamp enabled and Type of Service as CPU
 *  The conversion result in the DSADC result register is copied in software buffer on result service request event.
 *  The callback is done if the buffer gets full.
 *
 *  Create an interrupt handler for result service request:
 *  \code
 *   // priorities are normally defined in Ifx_IntPrioDef.h
 *   #define IFX_INTPRIO_SR0 10
 *
 *  IFX_INTERRUPT(DSADC0SR0ISR, 0, IFX_INTPRIO_SR0)
 *  {
 *       //Result will be copied to software buffer. Provides a callback if software buffer gets full
 *       IfxAdc_Dsadc_dsadcResultIsr(&myChannel);
 *  }
 *  \endcode
 *
 *  Callback if software buffer gets full
 *  \code
 *   void bufferFull()
 *   {
 *       //New buffer or same buffer could be configured for next set of results
 *    buffcount++;
 *        IfxAdc_Dsadc_setupDsadcResultBuffer(&myChannel, bufAddr[buffcount], IfxAdc_Dsadc_BufferSize_32);
 *   }
 *  \endcode
 *
 *  Queue Configuration without DMA
 *  \code
 *      #define NUM_RESULTS 31U
 *      #define BUFFER_SIZE (NUM_RESULTS + 1U) //Adding 1 for timestamp
 *
 *      IFXADC_DSADC_RESULT_BUFFER_WITH_TS(dsadcResType, BUFFER_SIZE);
 *
 *      static uint16 __attribute__ ((aligned(64))) resultBuffer[BUFFER_SIZE];
 *      static uint16 __attribute__ ((aligned(64))) resultBuffer1[BUFFER_SIZE];
 *
 *      static buffcount = 0U;
 *      uint32 bufAddr[] = {(uint32)&resultBuffer, (uint32)&resultBuffer1};
 *
 *      //Refer Module initialization section above for below points
 *      //1. Enabel ADC module
 *      //2. Declare a DSADC module structure
 *      //3. Set the global configuration of DSADC to default values
 *      //4. Declare a DSADC module,handle structure
 *      //5. Module initialization. Global clock enable and configuration of global registers will be done in IfxAdc_Dsadc_initModule.
 *      //6. Declare a "config" structure of DSADC/EXMOD configuration,and decide which Channel you desire to use.
 *      //7. Declare a "handle" structure of DSADC/EXMOD channel.
 *      //8. Set the configuration to default values, using inbuilt default setting function.
 *      //9. Modify the configuration as per need.
 *
 *      //Enable Timestamp in result configuration
 *      myConfig.resultHandling.enableTimeStamp = 1U;
 *
 *      //Configure timestamp
 *      IfxAdc_Dsadc_TimeStampConfig tmpstmpConfig = {IfxAdc_DsadcTimestampClock_fmod, TRUE};
 *      myConfig.timestamp = &tmpstmpConfig;
 *
 *      //Queue configuration
 *      IfxAdc_Dsadc_QueueConfig queueCfg;
 *      queueCfg.dmaCfg           = NULL_PTR;
 *      queueCfg.size             = IfxAdc_Dsadc_BufferSize_32;
 *     queueCfg.bufferType       = IfxAdc_Dsadc_BufferType_linearWithTimestamp;
 *      queueCfg.bufferFullHandler= (IfxAdc_Dsadc_Callback)&bufferFull;
 *      queueCfg.bufferPtr        = (uint16 *)&resultBuffer;
 *      myConfig.queueCfg         = &queueCfg;
 *
 *      //Configure service request and result configuration. Refer IfxLld_Adc_Dsadc_Init section
 *
 *      //Now, initialize the DSADC/EXMOD channel with your configuration and handle structures:
 *       IfxAdc_Dsadc_initChannel (&myChannel, &myConfig);
 *
 *       //Reading result and timestamp from the buffer
 *       uint16 timestamp, index;
 *       sint16 results;
 *       dsadcResType *resPtr = (dsadcResType *)&resultBuffer;
 *
 *       timestamp = resPtr->timeStamp; //use timestamp value
 *       for(index = 0u; index < BUFFER_SIZE; index++)
 *       {
 *          results = resPtr->results[index]; //use result values
 *       }
 *
 * \endcode
 *
 * \defgroup IfxLld_Adc_Dsadc DSADC
 * \ingroup IfxLld_Adc
 * \defgroup IfxLld_Adc_Dsadc_Enum Enumerations
 * \ingroup IfxLld_Adc_Dsadc
 * \defgroup IfxLld_Adc_Dsadc_Data_Structures Data Structures
 * \ingroup IfxLld_Adc_Dsadc
 * \defgroup IfxLld_Adc_Dsadc_Module_Initializaton Module Initialization
 * \ingroup IfxLld_Adc_Dsadc
 * \defgroup IfxLld_Adc_Dsadc_Channel_Initialization Dsadc and Exmod Channels
 * \ingroup IfxLld_Adc_Dsadc
 * \defgroup IfxLld_Adc_Dsadc_Result Channel Result
 * \ingroup IfxLld_Adc_Dsadc
 */

#ifndef IFXADC_DSADC_H
#define IFXADC_DSADC_H 1

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "Adc/Std/IfxAdc.h"
#include "Dma/Dma/IfxDma_Dma.h"
#include "math.h"

/******************************************************************************/
/*-----------------------------------Macros-----------------------------------*/
/******************************************************************************/

/** \brief Get the VCM connection register write value from the positive and negative pin connections
 */
#define IFXADC_DSADC_VCMWRITEVAL(pos, neg) ((uint32)((neg << 4u) | pos))

/** \brief get the SRCFG write value for DSADC, EXMOD channels
 */
#define IFXADC_DSADC_SRCFGWRITEVAL(sr0, sr1, sr2, sr3) \
    ((uint32)sr0 << IFX_ADC_DSADC_IN_SRCFG_SR0E_OFF) | \
    ((uint32)sr1 << IFX_ADC_DSADC_IN_SRCFG_SR1E_OFF) | \
    ((uint32)sr2 << IFX_ADC_DSADC_IN_SRCFG_SR2E_OFF) | \
    ((uint32)sr3 << IFX_ADC_DSADC_IN_SRCFG_SR3E_OFF)

/** \brief MACRO to set the trigger configuration in the register
 */
#define IFXADC_DSADC_WRITETRIGCFG(reg, delayCount, mode, trigSel)                      \
    (reg.U = (uint32)((uint32)(delayCount << IFX_ADC_DSADC_IN_BNDTRCFG_BNDTRDLY_OFF) | \
                      (uint32)(mode << IFX_ADC_DSADC_IN_BNDTRCFG_BNDTRM_OFF) |         \
                      (uint32)(trigSel)))

#define IFXADC_DSADC_MAX_SERV_REQ_NODE (4u)

/** \brief MACRO to get linear buffer type with timestamp
 */
#define IFXADC_DSADC_RESULT_BUFFER_WITH_TS(typeName, numOfResults) \
    typedef struct {                                               \
        uint16 timeStamp;                                          \
        sint16 results[numOfResults];                              \
    } typeName;

/** \brief MACRO to calculate CICSHIFT for Dsadc channel
 */
#define IFXADC_DSADC_CICSHIFT(decFactor, analogFullScaleVal) \
    (IfxAdc_DsadcCicShift)round(14 - log2((2 * analogFullScaleVal) / (pow(decFactor, 3) * 4 * 0.666667)));

/** \brief MACRO to calculate GAINFACTOR for Dsadc channel
 */
#define IFXADC_DSADC_GAINFACTOR(decFactor, analogFullScaleVal, cicShift) \
    (float)(((2 * analogFullScaleVal) / (pow(decFactor, 3) * 4 * 0.666667)) * (pow(2, cicShift - 14)) * 4096);

/******************************************************************************/
/*------------------------------Type Definitions------------------------------*/
/******************************************************************************/

/** \brief Type definition for handler functions
 * \return None
 */
typedef void (*IfxAdc_Dsadc_Callback)(void);

/******************************************************************************/
/*--------------------------------Enumerations--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Adc_Dsadc_Enum
 * \{ */
/** \brief Enumeration describing BufferSize
 * Note: Enum matches the DMA circular buffer size limitations.
 * Possible buffer sizes of the circular buffer can be (1,2,4,8..64K)
 */
typedef enum
{
    IfxAdc_Dsadc_BufferSize_none  = 0,   /**< \brief Buffer not configured */
    IfxAdc_Dsadc_BufferSize_2     = 1,   /**< \brief Buffer Size is 2 byte */
    IfxAdc_Dsadc_BufferSize_4     = 2,   /**< \brief Buffer size is 4 byte */
    IfxAdc_Dsadc_BufferSize_8     = 3,   /**< \brief Buffer size is 8 byte */
    IfxAdc_Dsadc_BufferSize_16    = 4,   /**< \brief Buffer size is 16 byte */
    IfxAdc_Dsadc_BufferSize_32    = 5,   /**< \brief Buffer size is 32 byte */
    IfxAdc_Dsadc_BufferSize_64    = 6,   /**< \brief Buffer size is 64 byte */
    IfxAdc_Dsadc_BufferSize_128   = 7,   /**< \brief Buffer size is 128 byte */
    IfxAdc_Dsadc_BufferSize_256   = 8,   /**< \brief Buffer size is 256 byte */
    IfxAdc_Dsadc_BufferSize_512   = 9,   /**< \brief Buffer size is 512 byte */
    IfxAdc_Dsadc_BufferSize_1024  = 10,  /**< \brief Buffer size is 1024 byte */
    IfxAdc_Dsadc_BufferSize_2048  = 11,  /**< \brief Buffer size is 2048 byte */
    IfxAdc_Dsadc_BufferSize_4096  = 12,  /**< \brief Buffer size is 4096 byte */
    IfxAdc_Dsadc_BufferSize_8192  = 13,  /**< \brief Buffer size is 8192 byte */
    IfxAdc_Dsadc_BufferSize_16384 = 14,  /**< \brief Buffer size is 16384 byte */
    IfxAdc_Dsadc_BufferSize_32768 = 15   /**< \brief Buffer size is 32768 byte */
} IfxAdc_Dsadc_BufferSize;

/** \brief Enumeration describing buffer types.
 */
typedef enum
{
    IfxAdc_Dsadc_BufferType_linear              = 0,  /**< \brief Configured buffer is linear buffer */
    IfxAdc_Dsadc_BufferType_linearWithTimestamp = 1,  /**< \brief Configured buffer is Linear buffer with timestamp */
    IfxAdc_Dsadc_BufferType_circular            = 2   /**< \brief Configured buffer is circular buffer */
} IfxAdc_Dsadc_BufferType;

/** \} */

/******************************************************************************/
/*-----------------------------Data Structures--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Adc_Dsadc_Data_Structures
 * \{ */
/** \brief Data structure holding service request configuration raised by DMA to CPU.
 * If configured buffer is of type linear then buffer full interrupt.
 */
typedef struct
{
    Ifx_Priority priority;            /**< \brief Interrupt priority */
    IfxSrc_Tos   typeOfService;       /**< \brief type of interrupt service */
    IfxSrc_VmId  vmId;                /**< \brief Virtual Machine Number */
} IfxAdc_Dsadc_DmaSrvReq;

/** \brief Configuration of Rectifier in Filter Chain
 */
typedef struct
{
    uint8                           sdPositive;        /**< \brief Sign delay value for positive halfwave */
    uint8                           sdNegative;        /**< \brief Sign delay value for negative halfwave */
    IfxAdc_DsadcRectifierSignSource signSignal;        /**< \brief Sign signal to be delayed */
    IfxAdc_DsadcChannel             signChannel;       /**< \brief Channel providing sign signal */
    boolean                         enable;            /**< \brief Rectification enable/disable */
} IfxAdc_Dsadc_RectifierConfig;

/** \} */

/** \addtogroup IfxLld_Adc_Dsadc_Data_Structures
 * \{ */
/** \brief AUX CIC filter Configuration for DSADC and EXMOD channels
 */
typedef struct
{
    IfxAdc_DsadcAuxCicDecFactor decimationFactor;       /**< \brief Decimation Factor (16-128) */
    boolean                     enableAuxCIC;           /**< \brief Auxiliary CIC filter enabled */
} IfxAdc_Dsadc_AuxCicFilterConfig;

/** \brief Dsadc carrier pin configuration
 */
typedef struct
{
    IFX_CONST IfxAdc_Pwm_Out *cgpPos;           /**< \brief Positive-carrier pin configuration */
    IfxPort_OutputMode        cgpPosMode;       /**< \brief Positive-carrier pin input mode which should be configured */
    IFX_CONST IfxAdc_Pwm_Out *cgNeg;            /**< \brief Negative-carrier pin  which should be configured */
    IfxPort_OutputMode        cgNegMode;        /**< \brief Negative-carrier pin output mode which should be configured */
    IfxPort_PadDriver         pinDriver;        /**< \brief Pin Driver Configuration */
} IfxAdc_Dsadc_CarrierPinConfig;

/** \brief Dsadc DMA handle
 */
typedef struct
{
    IfxDma_Dma_Channel channel;       /**< \brief DMA channel handle */
    IfxDma_Index       dmaId;         /**< \brief Dma Module Index */
    boolean            useDma;        /**< \brief use Dma for Data transfer/s */
} IfxAdc_Dsadc_Dma;

/** \brief Dma configuration
 */
typedef struct
{
    IfxAdc_Dsadc_DmaSrvReq *dmaSrvReqCfg;       /**< \brief ISR configuration from DMA to CPU on buffer full */
    IfxDma_ChannelId        channelId;          /**< \brief DMA channel number */
    IfxDma_Index            dmaId;              /**< \brief Dma Module Index */
} IfxAdc_Dsadc_DmaConfig;

/** \brief Configuration of Integrator component
 */
typedef struct
{
    IfxAdc_Dsadc_RectifierConfig     rectifier;                   /**< \brief Rectifier configuration structure */
    uint8                            numCycles;                   /**< \brief Number of Cycles for internal window control (REPVAL) */
    uint8                            numAccValues;                /**< \brief Number of values to accumulate per cycle (INVAL) */
    uint8                            numDiscardValues;            /**< \brief Number of values to discard (NUMVALDIS) */
    IfxAdc_DsadcIntegratorWindowCtrl windowControl;               /**< \brief Integration Window Size control.INTCFG.IWS */
    IfxAdc_DsadcIntegratorShift      selectBits;                  /**< \brief Select bits through INTCFG.ISC */
    boolean                          restartFilterChain;          /**< \brief if TRUE, Main filter chain is restarted on integration window open */
    boolean                          restartAuxFilterChain;       /**< \brief if TRUE, Auxiliary filter chain is restarted on integration window open */
    boolean                          extTriggerStart;             /**< \brief If TRUE, then integration window is started by the Trigger signal. (INTEN automatically controlled) */
    boolean                          enableIntegrator;            /**< \brief if TRUE, Integrator is enabled */
} IfxAdc_Dsadc_IntegratorConfig;

/** \brief Data structure holding interrupt configuration
 */
typedef struct
{
    Ifx_Priority priority;            /**< \brief Interrupt priority */
    IfxSrc_Tos   typeOfService;       /**< \brief type of interrupt service */
    IfxSrc_VmId  vmId;                /**< \brief Virtual Machine Number */
} IfxAdc_Dsadc_InterruptConfig;

/** \brief Configuration of offset compensation
 */
typedef struct
{
    IfxAdc_DsadcOffCompFilter filterCutoff;       /**< \brief High pass filter configuration */
    uint16                    offsetComp;         /**< \brief Offset Compensation value. */
} IfxAdc_Dsadc_OffsetCompConfig;

/** \brief Configuration of Trigger
 */
typedef struct
{
    uint16                  delayCount;       /**< \brief Delay count (80MHz clock) */
    IfxAdc_DsadcTriggerSel  triggerSel;       /**< \brief Select the source of the HW Trigger */
    IfxAdc_DsadcTriggerMode mode;             /**< \brief Active Edge of trigger */
} IfxAdc_Dsadc_Trigger;

/** \brief Common mode voltage configuration for DSADC channels
 * Each byte configuration represents the nibble in VCM register.
 * Set each individual bit for corresponding pin connection
 */
typedef struct
{
    uint8 positivePins;       /**< \brief Positive pin connections to Vcm (DSADCx_VCM) */
    uint8 negativePins;       /**< \brief Negative pin connections to Vcm (DSADCx_VCM) */
} IfxAdc_Dsadc_VcmConnection;

/** \} */

/** \addtogroup IfxLld_Adc_Dsadc_Data_Structures
 * \{ */
/** \brief Analog modulator configuration
 */
typedef struct
{
    IfxAdc_Dsadc_VcmConnection vcmConnection;         /**< \brief Connection to common mode voltage */
    IfxAdc_DsadcModulatorFreq  frequency;             /**< \brief Analog modulator Frequency */
    IfxAdc_DsadcInCfg          positiveInput;         /**< \brief Positive Pin input */
    IfxAdc_DsadcInCfg          negativeInput;         /**< \brief Negative Input */
    IfxAdc_DsadcDitherTrim     ditherTrimLevel;       /**< \brief Dither Trim Level for Modulator */
} IfxAdc_Dsadc_AnalogModConfig;

/** \brief Configuration of Boundary Limit Checking
 */
typedef struct
{
    uint16                      lowerBound;             /**< \brief Lower Boundary for limit checking */
    uint16                      upperBound;             /**< \brief Upper Boundary for limit checking */
    IfxAdc_DsadcBoundaryCmpMode boundaryMode;           /**< \brief Condition under which boundary flag is generated */
    IfxAdc_DsadcBoundaryServReq srvReqConfig;           /**< \brief Boundary Service Request configuration */
    boolean                     enableHysteresis;       /**< \brief TRUE --> Enable Hysteresis. BFL goes high when result crosses upper boundary and remains high until result crosses lower boundary */
    boolean                     srvReqGateEnable;       /**< \brief True --> Service Request gate enabled */
} IfxAdc_Dsadc_BoundaryConfig;

/** \brief Carrier configuration
 */
typedef struct
{
    IfxAdc_DsadcCgOperatingMode        carrierMode;       /**< \brief Carrier generator operating mode */
    IfxAdc_DsadcPwmGeneration          pwmMode;           /**< \brief PWM generation mode */
    IfxAdc_DsadcCarrierSignalPol       signalPol;         /**< \brief Carrier signal polarity */
    IfxAdc_DsadcCarrierSignalDivFactor divFactor;         /**< \brief Division factor for carrier signal generator input frequency */
    IfxAdc_Dsadc_CarrierPinConfig     *carrierPins;       /**< \brief Carrier pin configuration */
} IfxAdc_Dsadc_CarrierConfig;

typedef struct
{
    IfxAdc_DsadcInputMuxActCtrl inputMuxControl;       /**< \brief Mode of Input MUX action control */
    IfxAdc_DsadcInSel           inputMuxSel;           /**< \brief Input MUX selection (SW preset) */
} IfxAdc_Dsadc_ChannelInputConfig;

/** \brief Dsadc channel pin configuration
 */
typedef struct
{
    IFX_CONST IfxAdc_Trig_In   *triggerPin;           /**< \brief Trigger/Gate input Pin which should be configured */
    IfxPort_InputMode           triggerPinMode;       /**< \brief Trigger/Gate input pin input mode which should be configured */
    IFX_CONST IfxAdc_Dsadcn_In *dsadcn;               /**< \brief Negative analog input Pin which should be configured */
    IfxPort_InputMode           dsadcnMode;           /**< \brief Negative analog input pin output mode which should be configured */
    IFX_CONST IfxAdc_Dsadcp_In *dsadcp;               /**< \brief Positive analog input Pin which should be configured */
    IfxPort_InputMode           dsadcpMode;           /**< \brief Positive analog input pin output mode which should be configured */
    IfxPort_PadDriver           pinDriver;            /**< \brief Pin Driver Configuration */
} IfxAdc_Dsadc_ChannelPinConfig;

/** \brief Configuration of Service Request Generation (DSADC channels)
 */
typedef struct
{
    IfxAdc_Dsadc_InterruptConfig intCfg[IFXADC_DSADC_MAX_SERV_REQ_NODE];       /**< \brief Interrupt configuration */
    IfxAdc_DsadcSrvReq0          sr0Enable;                                    /**< \brief Service request for result event from main filter chain */
    IfxAdc_DsadcSrvReq3          sr3Enable;                                    /**< \brief Service request for special events: timestamp trigger or capture event for sign delay measurement */
    boolean                      sr1Enable;                                    /**< \brief Service request for result event from auxiliary filter chain */
    boolean                      sr2Enable;                                    /**< \brief Service request for alarms: limit checking */
    boolean                      enableServiceReq;                             /**< \brief Set to TRUE to enable service request configurations */
} IfxAdc_Dsadc_ChannelServiceReqConfig;

/** \brief Input Configuration of EXMOD channel
 */
typedef struct
{
    IfxAdc_ExmodDataSource  dataSource;             /**< \brief External modulator data source */
    IfxAdc_ExmodDataStream  dataStream;             /**< \brief External modulator sampling edge */
    IfxAdc_ExmodClockSource clkSrc;                 /**< \brief External modulator clock source */
    IfxAdc_ExmodClockFreq   clkFreq;                /**< \brief External modulator clock frequency */
    boolean                 enableManchester;       /**< \brief Enable/Disable manchester decoding */
} IfxAdc_Dsadc_ExmodInputConfig;

/** \brief Exmod Pin configuration
 */
typedef struct
{
    IFX_CONST IfxAdc_Clkin_In   *clkPin;              /**< \brief External modulator clock input pin */
    IfxPort_InputMode            clkPinMode;          /**< \brief Clock input pin mode */
    IFX_CONST IfxAdc_Clkout_Out *clkOutPin;           /**< \brief External modulator clock output pin */
    IfxPort_OutputMode           clkOutPinMode;       /**< \brief Clock Output pin mode */
    IFX_CONST IfxAdc_Data_In    *dataIn;              /**< \brief Data source input for Exmod */
    IfxPort_InputMode            dataInMode;          /**< \brief Data input pin mode */
    IfxPort_PadDriver            pinDriver;           /**< \brief Pin Driver Configuration */
} IfxAdc_Dsadc_ExmodPinConfig;

/** \brief Configuration of Service Request Generation (DSADC channels)
 */
typedef struct
{
    IfxAdc_Dsadc_InterruptConfig intCfg[IFXADC_DSADC_MAX_SERV_REQ_NODE];       /**< \brief Interrupt configuration */
    IfxAdc_DsadcSrvReq0          sr0Enable;                                    /**< \brief Service request for result event from main filter chain */
    boolean                      sr1Enable;                                    /**< \brief Service request for result event from auxiliary filter chain */
    boolean                      sr2Enable;                                    /**< \brief Service request for alarms: limit checking */
    boolean                      sr3Enable;                                    /**< \brief Service request for special events: timestamp trigger or capture event for sign delay measurement */
    boolean                      enableServiceReq;                             /**< \brief Set to TRUE to enable service request configurations */
} IfxAdc_Dsadc_ExmodServiceReqConfig;

/** \brief Configuration of the filter chain. (EXMOD channels do not have Offset compensation, Gain correction)
 */
typedef struct
{
    IfxAdc_Dsadc_AuxCicFilterConfig auxCicFilter;              /**< \brief AUX CIC filter configuration */
    uint16                          cicDecimationFactor;       /**< \brief CIC decimation factor (3-767). OSR = (cicDecimationFactor + 1) */
    uint16                          gainFactor;                /**< \brief Gain factor write value. (Actual gain factor = GainFactor/4096) */
    IfxAdc_Dsadc_OffsetCompConfig  *offsetComp;                /**< \brief Offset compensation configuration */
    IfxAdc_Dsadc_IntegratorConfig  *integrator;                /**< \brief Integrator Configuration */
    IfxAdc_DsadcCicShift            cicDataShift;              /**< \brief CIC Data shift offset */
    boolean                         enableFilterChain;         /**< \brief If TRUE: Filter chain is enabled */
} IfxAdc_Dsadc_FilterChainConfig;

/** \brief Dsadc Queue Handle
 */
typedef struct
{
    void                   *bufferPtr;          /**< \brief Application buffer */
    IfxAdc_Dsadc_Callback   buffHandler;        /**< \brief Callback if buffer is full */
    IfxAdc_Dsadc_Dma        dma;                /**< \brief Dma Handle */
    IfxAdc_Dsadc_BufferType bufferType;         /**< \brief Type of the buffer */
    uint16                  writeIndex;         /**< \brief Write Index of the buffer */
    uint16                  readIndex;          /**< \brief Read Index of the buffer */
    uint16                  size;               /**< \brief Size of the buffer in bytes */
    uint16                  validResult;        /**< \brief Number of valid results */
    boolean                 bufferFull;         /**< \brief Flag to indicate if buffer full */
    boolean                 queueEnabled;       /**< \brief True --> If queue enabled */
} IfxAdc_Dsadc_Queue;

/** \brief DSADC Queue Configuration
 */
typedef struct
{
    IfxAdc_Dsadc_DmaConfig *dmaCfg;                  /**< \brief Dma Configuration */
    void                   *bufferPtr;               /**< \brief Pointer to the application buffer */
    IfxAdc_Dsadc_Callback   bufferFullHandler;       /**< \brief Pointer to the Buffer full handler */
    IfxAdc_Dsadc_BufferSize size;                    /**< \brief Size of the buffer */
    IfxAdc_Dsadc_BufferType bufferType;              /**< \brief Type of the buffer */
} IfxAdc_Dsadc_QueueConfig;

/** \brief Result of DSADC / EXMOD channels
 */
typedef struct
{
    uint16 timestamp;       /**< \brief Timestamp counter value */
    uint16 result[4];       /**< \brief Array holding the result values in FIFO. Type is signed. */
} IfxAdc_Dsadc_Result;

/** \brief Configuration of Result Handling
 */
typedef struct
{
    IfxAdc_DsadcFifoSrLevel   fifoSrvLevel;          /**< \brief FIFO fill level for service Request */
    IfxAdc_DsadcDataReadWidth dataReadWidth;         /**< \brief Data Read Width */
    boolean                   readAsUnsigned;        /**< \brief read result as unsigned (RDM=1) */
    boolean                   enableTimeStamp;       /**< \brief Enable Time Stamp */
    boolean                   disableFIFO;           /**< \brief True: Disable the FIFO */
} IfxAdc_Dsadc_ResultConfig;

/** \brief Supervisor signal configuration
 */
typedef struct
{
    IfxAdc_DsadcChannel  channelSelect;       /**< \brief Selection of the channel for supervision */
    IfxAdc_DsadcSvSigSel signalSelect;        /**< \brief Signal selection for supervision */
} IfxAdc_Dsadc_SvSigConfig;

/** \brief Configuration of Time Stamp for Result Handling
 */
typedef struct
{
    IfxAdc_DsadcTimestampClock timestampClk;        /**< \brief Timestamp counter clock selection */
    boolean                    enableCounter;       /**< \brief If Set TRUE: Counter starts counting at TSCLK rate */
} IfxAdc_Dsadc_TimeStampConfig;

/** \brief Structure Holding Various trigger Configurations
 */
typedef struct
{
    IfxAdc_Dsadc_Trigger *boundaryTrig;         /**< \brief Boundary Trigger Configuration */
    IfxAdc_Dsadc_Trigger *integratorTrig;       /**< \brief Integrator Trigger Configuration */
    IfxAdc_Dsadc_Trigger *timestampTrig;        /**< \brief Time Stamp Trigger Configuration */
    IfxAdc_Dsadc_Trigger *inMuxTrig;            /**< \brief Input Multiplexer Trigger Configuration */
    IfxAdc_Dsadc_Trigger *serviceReqTrig;       /**< \brief Service Request Trigger Configuration. Trigger Mode will be ignored for service request configuration. */
} IfxAdc_Dsadc_TriggerConfig;

/** \} */

/** \brief Configuration for gain calibration
 */
typedef struct
{
    uint16                        calFactor;                  /**< \brief Multiplication factor for gain calibration */
    uint16                        calTarget;                  /**< \brief Target value for the calibration algorithm */
    uint16                        gainCorrectionFactor;       /**< \brief Multiplication Factor for Gain Correction During Calibration */
    IfxAdc_DsadcCicShift          cicShift;                   /**< \brief Position of the CIC Filter Output Shifter During Calibration */
    IfxAdc_DsadcCicDecimationRate cicDecimationRate;          /**< \brief Decimation Rate of the CIC Filter During Calibration */
} IfxAdc_Dsadc_GainCalibrationConfig;

/** \addtogroup IfxLld_Adc_Dsadc_Data_Structures
 * \{ */
/** \brief Handle of the DSADC driver
 */
typedef struct
{
    Ifx_ADC_DSADC *sfrPtr;       /**< \brief pointer to the SFR structure of DSADC */
} IfxAdc_Dsadc;

/** \brief Handle of DSADC channel
 */
typedef struct
{
    IfxAdc_Dsadc_Queue        queue;                  /**< \brief Queue handle information */
    IfxAdc_Dsadc_Result       result;                 /**< \brief Structure holding result information */
    IfxAdc_DsadcChannel       channelId;              /**< \brief Channel ID */
    IfxAdc_DsadcDataReadWidth resultReadWidth;        /**< \brief Result read width of DSADC channel */
    IfxAdc_DsadcFifoSrLevel   fifoLevel;              /**< \brief FIFO fill level for service Request */
    IfxAdc_Dsadc_Callback     resHandler;             /**< \brief Result Handler */
    Ifx_ADC_DSADC_IN         *sfrPtr;                 /**< \brief Pointer to the base of channel SFR */
    boolean                   fifoEnabled;            /**< \brief If TRUE, FIFO is enabled for this channel */
    boolean                   timeStampEnabled;       /**< \brief If TRUE, time stamp read is enabled for channel */
} IfxAdc_Dsadc_Channel;

/** \brief Configuration of DSADC analog modulator channel
 */
typedef struct
{
    IfxAdc_Dsadc_ChannelInputConfig      input;                 /**< \brief Input configuration of channel */
    IfxAdc_Dsadc_ResultConfig            resultHandling;        /**< \brief Result Handling Configuration */
    IfxAdc_Dsadc_AnalogModConfig         analogModulator;       /**< \brief Analog Modulator Configuration */
    IfxAdc_Dsadc_FilterChainConfig       filterChain;           /**< \brief Filter Chain Configuration */
    IfxAdc_Dsadc_ChannelServiceReqConfig serviceRequest;        /**< \brief Service Request Configuration */
    IfxAdc_Dsadc_BoundaryConfig          boundCfg;              /**< \brief Limit Checking configurations */
    IfxAdc_Dsadc_GainCalibrationConfig   gainCalibration;       /**< \brief Gain calibration configurations */
    IfxAdc_Dsadc_QueueConfig            *queueCfg;              /**< \brief Queue configuration */
    IfxAdc_Dsadc_TimeStampConfig        *timestamp;             /**< \brief Timestamp Configuration */
    IfxAdc_Dsadc_TriggerConfig          *trigger;               /**< \brief Trigger configuration */
    IfxAdc_Dsadc_ChannelPinConfig       *channelPins;           /**< \brief Channel pins configuration */
    Ifx_ADC                             *adcSFR;                /**< \brief Pointer to the ADC SFR set */
    IfxAdc_DsadcChannel                  channelId;             /**< \brief Channel ID */
    boolean                              autoCalibration;       /**< \brief If TRUE, automatic calibration is enabled */
    boolean                              enableChannel;         /**< \brief enable Channel at the end of initialization */
} IfxAdc_Dsadc_ChannelConfig;

/** \brief Structure holding the global configuration of the DSADC
 */
typedef struct
{
    Ifx_ADC                    *adcSFR;               /**< \brief Pointer to the ADC SFR pointer */
    IfxAdc_Dsadc_SvSigConfig   *svSignalConfig;       /**< \brief supervision signal config */
    IfxAdc_Dsadc_CarrierConfig *carrierConfig;        /**< \brief Carrier Generation configuration */
    IfxAdc_DsadcSupplyLevel     supplyLevel;          /**< \brief Dsadc supply level */
} IfxAdc_Dsadc_Config;

/** \brief Handle of EXMOD channel
 */
typedef struct
{
    IfxAdc_Exmod              channelId;              /**< \brief Channel ID */
    IfxAdc_Dsadc_Result       result;                 /**< \brief Structure holding result information */
    IfxAdc_Dsadc_Queue        queue;                  /**< \brief Queue handle information */
    Ifx_ADC_DSADC_EX         *sfrPtr;                 /**< \brief Pointer to the base of channel SFR */
    IfxAdc_Dsadc_Callback     resHandler;             /**< \brief Result Handler */
    IfxAdc_DsadcDataReadWidth resultReadWidth;        /**< \brief Result read width of DSADC channel */
    IfxAdc_DsadcFifoSrLevel   fifoLevel;              /**< \brief FIFO fill level for service Request */
    boolean                   fifoEnabled;            /**< \brief If TRUE, FIFO is enabled for this channel */
    boolean                   timeStampEnabled;       /**< \brief If TRUE, time stamp read is enabled for channel */
} IfxAdc_Dsadc_Exmod;

/** \brief Configuration of EXMOD channel
 */
typedef struct
{
    IfxAdc_Dsadc_ExmodInputConfig      extModulator;         /**< \brief External Modulator input Configuration */
    IfxAdc_Dsadc_FilterChainConfig     filterChain;          /**< \brief Filter Chain Configuration */
    IfxAdc_Dsadc_BoundaryConfig        boundCfg;             /**< \brief Limit Checking Configuration */
    IfxAdc_Dsadc_ResultConfig          resultHandling;       /**< \brief Result Handling Configuration */
    IfxAdc_Dsadc_ExmodServiceReqConfig serviceRequest;       /**< \brief Service Request configuration */
    IfxAdc_Dsadc_QueueConfig          *queueCfg;             /**< \brief Queue configuration */
    IfxAdc_Dsadc_TimeStampConfig      *timestamp;            /**< \brief Timestamp Configuration */
    IfxAdc_Dsadc_TriggerConfig        *trigger;              /**< \brief Trigger Configuration */
    IfxAdc_Dsadc_ExmodPinConfig       *exmodPins;            /**< \brief Exmod pin configuration */
    Ifx_ADC                           *adcSFR;               /**< \brief Pointer to the ADC SFR set */
    IfxAdc_Exmod                       channelId;            /**< \brief Channel ID */
} IfxAdc_Dsadc_ExmodChannelConfig;

/** \} */

/** \addtogroup IfxLld_Adc_Dsadc_Module_Initializaton
 * \{ */

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Initialize the module configuration to default values
 * \param config Pointer to the configuration
 * \param adc Pointer to ADC module sfr
 * \return None
 */
IFX_EXTERN void IfxAdc_Dsadc_initModuleConfig(IfxAdc_Dsadc_Config *config, Ifx_ADC *adc);

/** \brief Function for initialization of DSADC global configurations
 * \param dsadc pointer to the DSADC driver handle
 * \param config Pointer to the DSADC configuration
 * \return None
 */
IFX_EXTERN void IfxAdc_Dsadc_initModule(IfxAdc_Dsadc *dsadc, IfxAdc_Dsadc_Config *config);

/** \brief Configures the carrier signal generator
 * \param dsadc pointer to module handle
 * \param carrierCfg Pointer to the Carrier Signal Configuration
 * \return None
 */
IFX_EXTERN void IfxAdc_Dsadc_initCarrierGeneration(IfxAdc_Dsadc *dsadc, IfxAdc_Dsadc_CarrierConfig *carrierCfg);

/** \brief Function initializes carrier generation configuration structure to default values
 * \param config Carrier generation configuration structure
 * \return None
 */
IFX_EXTERN void IfxAdc_Dsadc_initCarrierGenConfig(IfxAdc_Dsadc_CarrierConfig *config);

/** \} */

/** \addtogroup IfxLld_Adc_Dsadc_Channel_Initialization
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Configures the Offset Compensation for DSADC channel
 * \param channelId pointer to the dsadc sfr structure
 * \param offsetCfg Offset Compensation configuration
 * \return None
 */
IFX_INLINE void IfxAdc_Dsadc_setupOffsetComp(IfxAdc_DsadcChannel channelId, IfxAdc_Dsadc_OffsetCompConfig *offsetCfg);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Initializes EXMOD channel
 * \param channel handle of Exmod channel
 * \param config Pointer to the channel configuration
 * \return None
 */
IFX_EXTERN void IfxAdc_Dsadc_initExmodChannel(IfxAdc_Dsadc_Exmod *channel, IfxAdc_Dsadc_ExmodChannelConfig *config);

/** \brief Initializes DSADC channel
 * \param channel handle of DSADC channel
 * \param config Pointer to the channel configuration
 * \return None
 */
IFX_EXTERN void IfxAdc_Dsadc_initChannel(IfxAdc_Dsadc_Channel *channel, IfxAdc_Dsadc_ChannelConfig *config);

/** \brief Initialize the DSADC channel configuration to default values
 * \param config Pointer to the channel configuration
 * \param adc Pointer to ADC sfr
 * \return None
 */
IFX_EXTERN void IfxAdc_Dsadc_initChannelConfig(IfxAdc_Dsadc_ChannelConfig *config, Ifx_ADC *adc);

/** \brief Configures the Integrator of the DSADC channel
 * \param channelId Channel ID
 * \param integratorCfg Pointer to the Integrator Configuration
 * \return None
 */
IFX_EXTERN void IfxAdc_Dsadc_setupIntegrator(IfxAdc_DsadcChannel channelId, IfxAdc_Dsadc_IntegratorConfig *integratorCfg);

/** \brief Initialize the Exmod channel configuration to default values
 * \param config Initialize the Exmod channel configuration to default values
 * \param adc Pointer to ADC module sfr
 * \return None
 */
IFX_EXTERN void IfxAdc_Dsadc_initExmodChannelConfig(IfxAdc_Dsadc_ExmodChannelConfig *config, Ifx_ADC *adc);

/** \brief Configures the rectifier
 * \param dsadc Pointer to Dsadc channel sfr
 * \param rectifierCfg Pointer to the rectifier Configuration
 * \return None
 */
IFX_EXTERN void IfxAdc_Dsadc_initRectifier(Ifx_ADC_DSADC_IN *dsadc, IfxAdc_Dsadc_RectifierConfig *rectifierCfg);

/** \} */

/** \addtogroup IfxLld_Adc_Dsadc_Result
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Get most recent result of auxiliary filter of Dsadc channel
 * \param channel Pointer to the channel handle
 * \return Result value (16bit) of channel
 */
IFX_INLINE uint16 IfxAdc_Dsadc_readDsadcAuxiliaryFilterResult(IfxAdc_Dsadc_Channel *channel);

/** \brief Get most recent result of auxiliary filter of Exmod channel
 * \param channel Pointer to the channel handle
 * \return Result value (16bit) of channel
 */
IFX_INLINE uint16 IfxAdc_Dsadc_readExmodAuxiliaryFilterResult(IfxAdc_Dsadc_Exmod *channel);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Get result from main filter chain of DSADC channel
 * \param channel Pointer to the channel handle
 * \return Result value (16bit) of channel
 */
IFX_EXTERN uint16 IfxAdc_Dsadc_readDsadcChannelResult(IfxAdc_Dsadc_Channel *channel);

/** \brief Get result of Exmod channel
 * \param channel Pointer to the Exmod channel handle
 * \return Result value (16bit) of channel
 */
IFX_EXTERN uint16 IfxAdc_Dsadc_readExmodChannelResult(IfxAdc_Dsadc_Exmod *channel);

/** \} */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Function to clear buffer of Dsadc channel
 * \param channel Pointer to dsadc handle
 * \return None
 */
IFX_INLINE void IfxAdc_Dsadc_clearDsadcBuffer(IfxAdc_Dsadc_Channel *channel);

/** \brief Function to check if buffer full of Dsadc channel.
 * \param channel Pointer to dsadc handle
 * \return Returns Buffer full status
 * TRUE --> Buffer Full
 * FALSE --> Buffer not full
 */
IFX_INLINE boolean IfxAdc_Dsadc_isDsadcBufferFull(IfxAdc_Dsadc_Channel *channel);

/** \brief Function to check if Dsadc buffer empty
 * \param channel Pointer to dsadc handle
 * \return Returns buffer empty status
 * TRUE --> Buffer empty
 * FALSE --> Buffer not empty.
 */
IFX_INLINE boolean IfxAdc_Dsadc_isDsadcBufferEmpty(IfxAdc_Dsadc_Channel *channel);

/** \brief Function to clear Exmod buffer
 * \param channel Pointer to Exmod handle
 * \return None
 */
IFX_INLINE void IfxAdc_Dsadc_clearExmodBuffer(IfxAdc_Dsadc_Exmod *channel);

/** \brief Function to check if Exmod buffer full.
 * \param channel Pointer to Exmod handle
 * \return Returns Buffer full status.
 * TRUE --> Buffer Full
 * FALSE --> Buffer not full
 */
IFX_INLINE boolean IfxAdc_Dsadc_isExmodBufferFull(IfxAdc_Dsadc_Exmod *channel);

/** \brief Function to check if Exmod buffer empty
 * \param channel Pointer to dsadc handle
 * \return Returns buffer empty status
 * TRUE --> Buffer empty
 * FALSE --> Buffer not empty.
 */
IFX_INLINE boolean IfxAdc_Dsadc_isExmodBufferEmpty(IfxAdc_Dsadc_Exmod *channel);

/** \brief Configures the Dsadc boundary.
 * \param channel handle of DSADC channel
 * \param lowerBound Lower Boundary value for limit checking
 * \param upperBound Upper Boundary value for limit checking
 * \return None
 */
IFX_INLINE void IfxAdc_Dsadc_configureDsadcBoundary(IfxAdc_Dsadc_Channel *channel, uint16 lowerBound, uint16 upperBound);

/** \brief Configures the Exmod boundary.
 * \param channel handle of Exmod channel
 * \param lowerBound Lower Boundary value for limit checking
 * \param upperBound Upper Boundary value for limit checking
 * \return None
 */
IFX_INLINE void IfxAdc_Dsadc_configureExmodBoundary(IfxAdc_Dsadc_Exmod *channel, uint16 lowerBound, uint16 upperBound);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Function to get number of new results from the buffer for Dsadc channel.
 * \param channel Pointer to dsadc handle
 * \return Returns number of valid result in buffer.
 */
IFX_EXTERN uint16 IfxAdc_Dsadc_getNumberOfDsadcResults(IfxAdc_Dsadc_Channel *channel);

/** \brief Function to get number of new results from the buffer for Exmod channel.
 * \param channel Pointer to Exmod handle
 * \return Returns number of valid result in buffer.
 */
IFX_EXTERN uint16 IfxAdc_Dsadc_getNumberOfExmodResults(IfxAdc_Dsadc_Exmod *channel);

/** \brief Function to setup the Dsadc result buffer.
 * \param channel Pointer to dsadc channel information
 * \param buffer Pointer to the buffer
 * \param size Size of the buffer
 * \return Return
 * IfxAdc_Status_success --> Setting up of result buffer is successful
 * IfxAdc_Status_failure --> Issue in setting up of result buffer
 */
IFX_EXTERN IfxAdc_Status IfxAdc_Dsadc_setupDsadcResultBuffer(IfxAdc_Dsadc_Channel *channel, void *buffer, IfxAdc_Dsadc_BufferSize size);

/** \brief Function to setup the Exmod result buffer.
 * \param channel Pointer to Exmod channel information
 * \param buffer Pointer to the buffer
 * \param size Size of the buffer
 * \return Return
 * IfxAdc_Status_success --> Setting up of result buffer is successful
 * IfxAdc_Status_failure --> Issue in setting up of result buffer
 */
IFX_EXTERN IfxAdc_Status IfxAdc_Dsadc_setupExmodResultBuffer(IfxAdc_Dsadc_Exmod *channel, void *buffer, IfxAdc_Dsadc_BufferSize size);

/** \brief Function to read immediate data from  buffer of Dsadc channel
 * \param channel Pointer to dsadc channel handle
 * \return Returns immediate unread data from the buffer.
 */
IFX_EXTERN uint16 IfxAdc_Dsadc_readDsadcCircularBufferResult(IfxAdc_Dsadc_Channel *channel);

/** \brief Function to read immediate data from buffer of Exmod channel
 * \param channel Pointer to Exmod channel handle
 * \return Returns immediate unread data from the Exmod channel buffer.
 */
IFX_EXTERN uint16 IfxAdc_Dsadc_readExmodCircularBufferResult(IfxAdc_Dsadc_Exmod *channel);

/** \brief Function to copy results from application buffer to another linear buffer
 * \param channel Pointer to dsadc channel handle
 * \param resBuff Buffer to store result
 * \param size Size of data to be read
 * \return Returns read status
 * IfxAdc_Status_success --> Read result successful
 * IfxAdc_Status_failure --> Buffer empty,read failed
 */
IFX_EXTERN IfxAdc_Status IfxAdc_Dsadc_readDsadcStreamResult(IfxAdc_Dsadc_Channel *channel, uint16 *resBuff, uint16 size);

/** \brief Function to copy results from application buffer to another linear buffer.
 * \param channel Pointer to Exmod channel handle
 * \param resBuff Buffer to store result
 * \param size Size of data to be read
 * \return Returns read status
 * IfxAdc_Status_success --> Read result successful
 * IfxAdc_Status_failure --> Buffer empty,read failed
 */
IFX_EXTERN IfxAdc_Status IfxAdc_Dsadc_readExmodStreamResult(IfxAdc_Dsadc_Exmod *channel, uint16 *resBuff, uint16 size);

/** \brief Dsadc channel Isr for writing data from hardware FIFO to software buffer.
 * \param channel Pointer to dsadc channel handle
 * \return None
 */
IFX_EXTERN void IfxAdc_Dsadc_dsadcResultIsr(IfxAdc_Dsadc_Channel *channel);

/** \brief Exmod channel Isr for writing data from hardware FIFO to software buffer.
 * \param channel Pointer to dsadc Exmod handle
 * \return None
 */
IFX_EXTERN void IfxAdc_Dsadc_exmodResultIsr(IfxAdc_Dsadc_Exmod *channel);

/******************************************************************************/
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE void IfxAdc_Dsadc_setupOffsetComp(IfxAdc_DsadcChannel channelId, IfxAdc_Dsadc_OffsetCompConfig *offsetCfg)
{
    Ifx_ADC_DSADC_IN *sfrPtr = &(MODULE_ADC.DSADC.IN[channelId]);
    sfrPtr->CHCFG.B.OCEN     = (uint32)(offsetCfg->filterCutoff);
    sfrPtr->OFFCOMP.B.OFFSET = (uint32)(offsetCfg->offsetComp);
}


IFX_INLINE void IfxAdc_Dsadc_clearDsadcBuffer(IfxAdc_Dsadc_Channel *channel)
{
    uint16  bufferSize     = channel->queue.size;
    uint16 *localBufferPtr = (uint16 *)(channel->queue.bufferPtr);
    uint16  index          = 0;

    for (index = 0; index < bufferSize; index++)
    {
        localBufferPtr[index] = 0;
    }
}


IFX_INLINE boolean IfxAdc_Dsadc_isDsadcBufferFull(IfxAdc_Dsadc_Channel *channel)
{
    return channel->queue.bufferFull;
}


IFX_INLINE boolean IfxAdc_Dsadc_isDsadcBufferEmpty(IfxAdc_Dsadc_Channel *channel)
{
    boolean bufferStatus = FALSE;

    if (channel->queue.validResult == 0u)
    {
        bufferStatus = TRUE;
    }

    return bufferStatus;
}


IFX_INLINE void IfxAdc_Dsadc_clearExmodBuffer(IfxAdc_Dsadc_Exmod *channel)
{
    uint16  bufferSize     = channel->queue.size;
    uint16 *localBufferPtr = (uint16 *)(channel->queue.bufferPtr);
    uint16  index          = 0;

    for (index = 0; index < bufferSize; index++)
    {
        localBufferPtr[index] = 0;
    }
}


IFX_INLINE boolean IfxAdc_Dsadc_isExmodBufferFull(IfxAdc_Dsadc_Exmod *channel)
{
    return channel->queue.bufferFull;
}


IFX_INLINE boolean IfxAdc_Dsadc_isExmodBufferEmpty(IfxAdc_Dsadc_Exmod *channel)
{
    boolean bufferStatus = FALSE;

    if (channel->queue.validResult == 0u)
    {
        bufferStatus = TRUE;
    }

    return bufferStatus;
}


IFX_INLINE uint16 IfxAdc_Dsadc_readDsadcAuxiliaryFilterResult(IfxAdc_Dsadc_Channel *channel)
{
    return IfxAdc_getDsadcAuxResult(channel->channelId);
}


IFX_INLINE uint16 IfxAdc_Dsadc_readExmodAuxiliaryFilterResult(IfxAdc_Dsadc_Exmod *channel)
{
    return IfxAdc_getExmodAuxResult(channel->channelId);
}


IFX_INLINE void IfxAdc_Dsadc_configureDsadcBoundary(IfxAdc_Dsadc_Channel *channel, uint16 lowerBound, uint16 upperBound)
{
    channel->sfrPtr->BOUNDSEL.U = (lowerBound | (upperBound << IFX_ADC_DSADC_IN_BOUNDSEL_BOUNDARYU_OFF));
}


IFX_INLINE void IfxAdc_Dsadc_configureExmodBoundary(IfxAdc_Dsadc_Exmod *channel, uint16 lowerBound, uint16 upperBound)
{
    channel->sfrPtr->BOUNDSEL.U = (lowerBound | (upperBound << IFX_ADC_DSADC_IN_BOUNDSEL_BOUNDARYU_OFF));
}


#endif /* IFXADC_DSADC_H */
