/**
 * \file IfxAdc_Dsadc.c
 * \brief ADC DSADC details
 *
 * \version iLLD_2_0_1_2_19
 * \copyright Copyright (c) 2023 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 *
 */

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "IfxAdc_Dsadc.h"

/** \addtogroup IfxLld_Adc_Dsadc_Channel_Initialization
 * \{ */

/******************************************************************************/
/*-----------------------Private Function Prototypes--------------------------*/
/******************************************************************************/

/** \brief Setup Triggers for DSADC/EXMOD channels
 * \param triggerCfg Pointer to the trigger Configuration
 * \param channelId EXMOD, DSADC channel ID
 * \param hasAnalogMod set to TRUE for DSADC channels
 * \return None
 */
IFX_STATIC void IfxAdc_Dsadc_setupTriggers(IfxAdc_Dsadc_TriggerConfig *triggerCfg, uint8 channelId, boolean hasAnalogMod);

/** \brief Setup the filter chain for DSADC/EXMOD channels
 * \param filterChainCfg Pointer to the Filter Chain configuration
 * \param channelId EXMOD, DSADC channel ID
 * \param hasAnalogMod set to TRUE for DSADC channels
 * \return None
 */
IFX_STATIC void IfxAdc_Dsadc_setupFilterChain(IfxAdc_Dsadc_FilterChainConfig *filterChainCfg, uint8 channelId, boolean hasAnalogMod);

/** \} */

/******************************************************************************/
/*------------------------Inline Function Prototypes--------------------------*/
/******************************************************************************/

/** \brief Function to convert buffer size in half word from enum
 * \param value Enum of circular buffer
 * \return Return size of buffer in bytes from enum value
 */
IFX_INLINE uint16 IfxAdc_Dsadc_getBufferSize(IfxAdc_Dsadc_BufferSize value);

/******************************************************************************/
/*-----------------------Private Function Prototypes--------------------------*/
/******************************************************************************/

/** \brief Configure limit checking for DSADC/EXMOD channels
 * \param boundaryCfg Pointer to boundary configuration
 * \param channelId EXMOD, DSADC channel ID
 * \param hasAnalogMod True --> Function is intended to be used for Dsadc channel
 * FALSE --> Function is intended to be used for Exmod channel
 * \return None
 */
IFX_STATIC void IfxAdc_Dsadc_configureBoundary(IfxAdc_Dsadc_BoundaryConfig *boundaryCfg, uint8 channelId, boolean hasAnalogMod);

/** \brief Function to the configure DMA
 * \param queue Pointer to queue configuration
 * \param channel Pointer to handle of DSADC/EXMOD channel
 * \param hasAnalogMod TRUE --> Function is intended to be used for Dsadc channel
 * FALSE --> Function is intended to be used for Exmod channel
 * \return None
 */
IFX_STATIC void IfxAdc_Dsadc_configureDma(IfxAdc_Dsadc_QueueConfig *queue, void *channel, boolean hasAnalogMod);

/** \brief Function to copy data from hardware FIFO to software buffer for Dsadc channel.
 * \param channel Pointer to dsadc/exmod channel handle
 * \return None
 */
IFX_STATIC void IfxAdc_Dsadc_writeDsadcBuffer(IfxAdc_Dsadc_Channel *channel);

/** \brief Function to read immediate data from Circular buffer
 * \param channel Pointer to dsadc/exmod channel handle
 * \param hasAnalogMod True --> Function is intended to be used for Dsadc channel
 * FALSE --> Function is intended to be used for Exmod channel
 * \return Returns immediate unread data from the buffer.
 */
IFX_STATIC uint16 IfxAdc_Dsadc_readCircularBufferResult(void *channel, boolean hasAnalogMod);

/** \brief Function to copy results from application buffer to another linear buffer.
 * \param channel Pointer to dsadc/Exmod channel handle
 * \param resBuff Buffer to store result
 * \param size Size of data to be read
 * \param hasAnalogMod True --> Function is intended to be used for Dsadc channel
 * FALSE --> Function is intended to be used for Exmod channel
 * \return Returns read status
 * IfxAdc_Status_success --> Read result successful
 * IfxAdc_Status_failure --> Buffer empty,read failed
 */
IFX_STATIC IfxAdc_Status IfxAdc_Dsadc_readStreamResult(void *channel, uint16 *resBuff, uint16 size, boolean hasAnalogMod);

/** \brief Function to setup the buffer during initialization.
 * \param queueConfig Pointer to queue configuration
 * \param channel Pointer to dsadc/Exmod channel handle
 * \param hasAnalogMod True --> Function is intended to be used for Dsadc channel
 * FALSE --> Function is intended to be used for Exmod channel
 * \return Return
 * IfxAdc_Status_success --> Setting up of result buffer is successful
 * IfxAdc_Status_failure --> Issue in setting up of result buffer
 */
IFX_STATIC IfxAdc_Status IfxAdc_Dsadc_initBuffer(IfxAdc_Dsadc_QueueConfig *queueConfig, void *channel, boolean hasAnalogMod);

/** \brief Function to copy data from hardware FIFO to software buffer for Exmod channel.
 * \param channel Pointer to dsadc/exmod channel handle
 * \return None
 */
IFX_STATIC void IfxAdc_Dsadc_writeExmodBuffer(IfxAdc_Dsadc_Exmod *channel);

/** \brief Function to get number of results in the buffer
 * \param channel Pointer to dsadc/Exmod channel handle
 * \param hasAnalogMod True --> Function is intended to be used for Dsadc channel
 * \return Return valid result from the buffer
 */
IFX_STATIC uint16 IfxAdc_Dsadc_getNumberOfResults(void *channel, boolean hasAnalogMod);

/** \brief Function to update internal handle information from DMA.
 * \param channel Pointer to dsadc/Exmod channel handle
 * \param hasAnalogMod True --> Function is intended to be used for Dsadc channel
 * \return None
 */
IFX_STATIC void IfxAdc_Dsadc_updateHandleInfoFromDma(void *channel, boolean hasAnalogMod);

/******************************************************************************/
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE uint16 IfxAdc_Dsadc_getBufferSize(IfxAdc_Dsadc_BufferSize value)
{
    uint16 bufferSize = 1u;

    while (value != 0u)
    {
        bufferSize = (bufferSize << 1u);
        value--;
    }

    //Buffer size in half words.
    bufferSize = (bufferSize >> 1u);

    return bufferSize;
}


/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxAdc_Dsadc_initModuleConfig(IfxAdc_Dsadc_Config *config, Ifx_ADC *adc)
{
    // initialize all to default values
    const IfxAdc_Dsadc_Config defaultConfig = {
        .adcSFR         = NULL_PTR,
        .svSignalConfig = NULL_PTR,
        .carrierConfig  = NULL_PTR,
        .supplyLevel    = IfxAdc_DsadcSupplyLevel_between3_7V_And_5_5V,
    };

    *config        = defaultConfig;

    config->adcSFR = adc;
}


void IfxAdc_Dsadc_initModule(IfxAdc_Dsadc *dsadc, IfxAdc_Dsadc_Config *config)
{
    Ifx_ADC_DSADC *modptr = &(config->adcSFR->DSADC);
    /* updating the handle */
    dsadc->sfrPtr = modptr;

    /* Enable Dsadc global */
    IfxAdc_enableDsadcGlobal();

    /* Configure Dsadc supply level */
    modptr->GLOBCFG.B.DSADCSUP = config->supplyLevel;

    if (config->svSignalConfig != NULL_PTR)
    {
        Ifx_ADC_DSADC_GLOBCFG globCfg;
        globCfg.U         = modptr->GLOBCFG.U;
        /* Supervision signal and channel selection */
        globCfg.B.SVSIG   = config->svSignalConfig->signalSelect;
        globCfg.B.SVCH    = config->svSignalConfig->channelSelect;
        /* Writing the register */
        modptr->GLOBCFG.U = globCfg.U;
    }

    /* Carrier generation initialization */
    if (config->carrierConfig != NULL_PTR)
    {
        IfxAdc_Dsadc_initCarrierGeneration(dsadc, config->carrierConfig);
    }
}


void IfxAdc_Dsadc_initExmodChannel(IfxAdc_Dsadc_Exmod *channel, IfxAdc_Dsadc_ExmodChannelConfig *config)
{
    /* Declare, initialize variables / pointers */
    IfxAdc_Exmod                        channelId   = config->channelId;
    Ifx_ADC_DSADC_EX                   *dsadc       = &(config->adcSFR->DSADC.EX[channelId]);
    IfxAdc_Dsadc_ExmodInputConfig      *exmodclk    = &(config->extModulator);
    IfxAdc_Dsadc_ResultConfig          *resultCfg   = &(config->resultHandling);
    IfxAdc_Dsadc_ExmodServiceReqConfig *srvCfg      = &(config->serviceRequest);
    IfxAdc_Dsadc_ExmodPinConfig        *pinCfg      = config->exmodPins;
    IfxAdc_Dsadc_QueueConfig           *queueCfgPtr = config->queueCfg;
    IfxAdc_Dsadc_DmaConfig             *dmaCfgPtr   = NULL_PTR;
    volatile Ifx_SRC_SRCR              *src         = NULL_PTR;
    uint8                               i;

    Ifx_ADC_DSADC_EX_CHCFG              chcfg;
    Ifx_ADC_DSADC_EX_SRCFG              srcfg;

    /* Update handle with relevant config */
    channel->sfrPtr           = dsadc;
    channel->channelId        = channelId;
    channel->fifoEnabled      = !(resultCfg->disableFIFO);
    channel->timeStampEnabled = resultCfg->enableTimeStamp;
    channel->resultReadWidth  = resultCfg->dataReadWidth;
    channel->fifoLevel        = resultCfg->fifoSrvLevel;

    /* Enable Exmod clock */
    IfxAdc_enableExmodClock(channelId);

    /* Read relevant common registers */
    chcfg.U = dsadc->CHCFG.U;

    /* Initialize clock and input for external modulator */
    chcfg.B.DSR   = exmodclk->dataSource;
    chcfg.B.CSR   = exmodclk->clkSrc;
    chcfg.B.DIVM  = exmodclk->clkFreq;
    chcfg.B.DSS   = exmodclk->dataStream;
    chcfg.B.MANEN = exmodclk->enableManchester;

    /* Fifo Flush. Remove all entries from result FIFO */
    chcfg.B.FIFL = 1u;

    /* Initialize filter chain */
    IfxAdc_Dsadc_setupFilterChain(&(config->filterChain), (uint8)channelId, FALSE);

    /* Initialize Triggers / timestamps */
    if (config->trigger != NULL_PTR)
    {
        IfxAdc_Dsadc_setupTriggers(config->trigger, (uint8)channelId, FALSE);
    }

    /* Initialize result handling */
    chcfg.B.RDM   = (uint32)(resultCfg->readAsUnsigned);
    chcfg.B.TSM   = (uint32)(resultCfg->enableTimeStamp);
    chcfg.B.DRM   = (resultCfg->disableFIFO) ? (uint32)(0x01U) : (uint32)(resultCfg->dataReadWidth);
    chcfg.B.SRLVL = resultCfg->fifoSrvLevel;

    /*Initialize Timestamp*/
    if (config->timestamp != NULL_PTR)
    {
        chcfg.B.TSCLK  = config->timestamp->timestampClk;
        chcfg.B.TSCRUN = config->timestamp->enableCounter;
    }

    /* Initialize Limit checking */
    IfxAdc_Dsadc_configureBoundary(&(config->boundCfg), (uint8)channelId, FALSE);

    /* Initialize service requests */
    if (srvCfg->enableServiceReq)
    {
        srcfg.U = IFXADC_DSADC_SRCFGWRITEVAL(srvCfg->sr0Enable, srvCfg->sr1Enable, srvCfg->sr2Enable, srvCfg->sr3Enable);
    }
    else
    {
        srcfg.U = 0u;
    }

    for (i = 0u; i < IFXADC_DSADC_MAX_SERV_REQ_NODE; i++)
    {
        /* Interrupt configuration */
        if ((srvCfg->intCfg[i].priority > 0u) || (srvCfg->intCfg[i].typeOfService == IfxSrc_Tos_dma0) || (srvCfg->intCfg[i].typeOfService == IfxSrc_Tos_dma1))
        {
            src = IfxAdc_getExmodSrcPointer(channelId, i);
            IfxSrc_init(src, srvCfg->intCfg[i].typeOfService, srvCfg->intCfg[i].priority, srvCfg->intCfg[i].vmId);
            IfxSrc_enable(src);
        }
    }

    /* Queue Configuration */
    if (queueCfgPtr != NULL_PTR)
    {
        dmaCfgPtr = (queueCfgPtr->dmaCfg);

        /* Initialize and update the handle with buffer address and size*/
        IfxAdc_Dsadc_initBuffer(queueCfgPtr, (uint32 *)channel, FALSE);

        /* DMA configuration */
        if (dmaCfgPtr != NULL_PTR)
        {
            IfxAdc_Dsadc_configureDma(queueCfgPtr, (uint32 *)channel, FALSE);
        }
        else
        {
            /* If DMA not configured update handle with FALSE*/
            channel->queue.dma.useDma = FALSE;
        }
    }

    /* Pin configurations  */
    if (pinCfg != NULL_PTR)
    {
        /*  Clock source pin configuration*/
        if (pinCfg->clkPin != NULL_PTR)
        {
            IfxAdc_initExmodClockPin(pinCfg->clkPin, pinCfg->clkPinMode, pinCfg->pinDriver);
        }

        /*  Clock Out source pin configuration*/
        if (pinCfg->clkOutPin != NULL_PTR)
        {
            IfxAdc_initExmodClockOutPin(pinCfg->clkOutPin, pinCfg->clkOutPinMode, pinCfg->pinDriver);
        }

        /* Data source pin configuration*/
        if (pinCfg->dataIn != NULL_PTR)
        {
            IfxAdc_initExmodDataPin(pinCfg->dataIn, pinCfg->dataInMode, pinCfg->pinDriver);
        }
    }

    /* Write back to the registers */
    dsadc->CHCFG.U = chcfg.U;
    dsadc->SRCFG.U = srcfg.U;

    /* Enable the filter chain */
    if (config->filterChain.enableFilterChain)
    {
        IfxAdc_enableExmodFilterChain(channelId);
    }
}


void IfxAdc_Dsadc_initChannel(IfxAdc_Dsadc_Channel *channel, IfxAdc_Dsadc_ChannelConfig *config)
{
    /* Declare, initialize variables / pointers */
    IfxAdc_DsadcChannel                   channelId     = config->channelId;
    Ifx_ADC_DSADC_IN                     *dsadc         = &(config->adcSFR->DSADC.IN[channelId]);
    IfxAdc_Dsadc_AnalogModConfig         *modCfg        = &(config->analogModulator);
    IfxAdc_Dsadc_ResultConfig            *resultCfg     = &(config->resultHandling);
    IfxAdc_Dsadc_ChannelServiceReqConfig *srvCfg        = &(config->serviceRequest);
    IfxAdc_Dsadc_GainCalibrationConfig   *gainCalCfgPtr = &(config->gainCalibration);
    IfxAdc_Dsadc_ChannelPinConfig        *pinCfg        = config->channelPins;
    IfxAdc_Dsadc_QueueConfig             *queueCfgPtr   = config->queueCfg;
    IfxAdc_Dsadc_DmaConfig               *dmaCfgPtr     = NULL_PTR;
    volatile Ifx_SRC_SRCR                *src           = NULL_PTR;
    uint8                                 i;

    Ifx_ADC_DSADC_IN_CHCFG                chcfg;
    Ifx_ADC_DSADC_IN_VCM                  vcm;
    Ifx_ADC_DSADC_IN_SRCFG                srcfg;
    Ifx_ADC_DSADC_IN_GAINCAL              gainCal;
    Ifx_ADC_DSADC_IN_GAINCTR              gainCtrl;

    /* Update handle with relevant config */
    channel->sfrPtr           = dsadc;
    channel->channelId        = channelId;
    channel->fifoEnabled      = !(resultCfg->disableFIFO);
    channel->timeStampEnabled = resultCfg->enableTimeStamp;
    channel->resultReadWidth  = resultCfg->dataReadWidth;
    channel->fifoLevel        = resultCfg->fifoSrvLevel;

    /* Enable Dsadc Clock*/
    IfxAdc_enableDsadcClock(channelId);

    /* Read relevant common registers */
    chcfg.U    = dsadc->CHCFG.U;
    gainCal.U  = dsadc->GAINCAL.U;
    gainCtrl.U = dsadc->GAINCTR.U;

    /* Initialize Auto-calibration */
    chcfg.B.AUTOCAL = (uint32)(config->autoCalibration);

    /* initialize the input */
    chcfg.B.INSEL = config->input.inputMuxSel;
    chcfg.B.INMAC = config->input.inputMuxControl;

    /* FIFO Flush. Remove all entries from result FIFO */
    chcfg.B.FIFL = 1u;

    /* Initialize analog modulator */
    chcfg.B.INCFGP = modCfg->positiveInput;
    chcfg.B.INCFGN = modCfg->negativeInput;
    vcm.U          = IFXADC_DSADC_VCMWRITEVAL(modCfg->vcmConnection.positivePins, modCfg->vcmConnection.negativePins);
    chcfg.B.DIVM   = modCfg->frequency;

    if (modCfg->ditherTrimLevel == IfxAdc_DsadcDitherTrim_disabled)
    {
        chcfg.B.DITHEN = 0u;
    }
    else
    {
        chcfg.B.DITRIM = modCfg->ditherTrimLevel;
    }

    /* Initialize filter chain */
    IfxAdc_Dsadc_setupFilterChain(&(config->filterChain), (uint8)channelId, TRUE);

    /* Setup Gain calibration */
    gainCal.B.CALFACTOR = gainCalCfgPtr->calFactor;
    gainCal.B.CALTARGET = gainCalCfgPtr->calTarget;
    gainCtrl.B.CALCICS  = gainCalCfgPtr->cicShift;
    gainCtrl.B.CALGFAC  = gainCalCfgPtr->gainCorrectionFactor;
    gainCtrl.B.CICDEC   = gainCalCfgPtr->cicDecimationRate;

    /* Initialize Triggers / timestamps */
    if (config->trigger != NULL_PTR)
    {
        IfxAdc_Dsadc_setupTriggers(config->trigger, (uint8)channelId, TRUE);
    }

    /* Initialize result handling */
    chcfg.B.RDM   = (uint32)(resultCfg->readAsUnsigned);
    chcfg.B.TSM   = (uint32)(resultCfg->enableTimeStamp);
    chcfg.B.DRM   = (resultCfg->disableFIFO) ? (uint32)(0x01U) : (uint32)(resultCfg->dataReadWidth);
    chcfg.B.SRLVL = resultCfg->fifoSrvLevel;

    /*Initialize timestamp*/
    if (config->timestamp != NULL_PTR)
    {
        chcfg.B.TSCLK  = (uint32)(config->timestamp->timestampClk);
        chcfg.B.TSCRUN = (uint32)(config->timestamp->enableCounter);
    }

    /*Initialize Limit checking */
    IfxAdc_Dsadc_configureBoundary(&(config->boundCfg), (uint8)channelId, TRUE);

    /* Initialize service requests */
    if (srvCfg->enableServiceReq)
    {
        srcfg.U = IFXADC_DSADC_SRCFGWRITEVAL(srvCfg->sr0Enable, srvCfg->sr1Enable, srvCfg->sr2Enable, srvCfg->sr3Enable);
    }
    else
    {
        srcfg.U = 0u;
    }

    for (i = 0u; i < IFXADC_DSADC_MAX_SERV_REQ_NODE; i++)
    {
        /* Interrupt configuration */
        if ((srvCfg->intCfg[i].priority > 0u) || (srvCfg->intCfg[i].typeOfService == IfxSrc_Tos_dma0) || (srvCfg->intCfg[i].typeOfService == IfxSrc_Tos_dma1))
        {
            src = IfxAdc_getDsadcSrcPointer(channelId, i);
            IfxSrc_init(src, srvCfg->intCfg[i].typeOfService, srvCfg->intCfg[i].priority, srvCfg->intCfg[i].vmId);
            IfxSrc_enable(src);
        }
    }

    /* Queue Configuration */
    if (queueCfgPtr != NULL_PTR)
    {
        dmaCfgPtr = (queueCfgPtr->dmaCfg);

        /* Initialize and update the handle with buffer address and size*/
        IfxAdc_Dsadc_initBuffer(queueCfgPtr, (uint32 *)channel, TRUE);

        /* DMA configuration */
        if (dmaCfgPtr != NULL_PTR)
        {
            IfxAdc_Dsadc_configureDma(queueCfgPtr, (uint32 *)channel, TRUE);
        }
        else
        {
            /* If DMA not configured update handle with FALSE*/
            channel->queue.dma.useDma = FALSE;
        }
    }

    /* Pin configurations */
    if (pinCfg != NULL_PTR)
    {
        /* Negative analog pin configuration*/
        if (pinCfg->dsadcn != NULL_PTR)
        {
            IfxAdc_initDsadcnPin(pinCfg->dsadcn, pinCfg->dsadcnMode, pinCfg->pinDriver);
        }

        /* Positive analog pin configuration*/
        if (pinCfg->dsadcp != NULL_PTR)
        {
            IfxAdc_initDsadcpPin(pinCfg->dsadcp, pinCfg->dsadcpMode, pinCfg->pinDriver);
        }

        /* Trigger pin configuration*/
        if (pinCfg->triggerPin != NULL_PTR)
        {
            IfxAdc_initDsadcTrigPin(pinCfg->triggerPin, pinCfg->triggerPinMode, pinCfg->pinDriver);
        }
    }

    /* Write back to the registers */
    dsadc->CHCFG.U   = chcfg.U;
    dsadc->GAINCAL.U = gainCal.U;
    dsadc->GAINCTR.U = gainCtrl.U;
    dsadc->VCM.U     = vcm.U;
    dsadc->SRCFG.U   = srcfg.U;

    /* Enable the filter chain */
    if (config->filterChain.enableFilterChain)
    {
        IfxAdc_enableDsadcFilterChain(channelId);
    }

    /* Enable the analog modulator */
    if (config->enableChannel)
    {
        IfxAdc_enableDsadcChannel(channelId);
    }
}


uint16 IfxAdc_Dsadc_readDsadcChannelResult(IfxAdc_Dsadc_Channel *channel)
{
    uint16 *resultPtr  = &(channel->result.result[0]);
    uint16  result     = 0u;
    uint32  tempResVal = 0;

    if (IfxAdc_getDsadcResultEvent(channel->channelId))
    {
        if (channel->fifoEnabled)
        {
            uint8 fillLevel = IfxAdc_getDsadcFifoFillLevel(channel->channelId);
            uint8 readIndex = 0u;

            if (channel->timeStampEnabled)
            {
                tempResVal                = channel->sfrPtr->RESM.U;
                channel->result.timestamp = (uint16)tempResVal;
                readIndex++;

                if ((channel->resultReadWidth == IfxAdc_DsadcDataReadWidth_32Bit) && (readIndex < fillLevel))
                {
                    *resultPtr++ = (uint16)(tempResVal >> IFX_ADC_DSADC_IN_RESM_RESULTHI_OFF);
                    readIndex++;
                }
            }

            while (readIndex < fillLevel)
            {
                tempResVal   = channel->sfrPtr->RESM.U;
                *resultPtr++ = (uint16)tempResVal;
                readIndex++;

                if ((channel->resultReadWidth == IfxAdc_DsadcDataReadWidth_32Bit) && (readIndex < fillLevel))
                {
                    *resultPtr++ = (uint16)(tempResVal >> IFX_ADC_DSADC_IN_RESM_RESULTHI_OFF);
                    readIndex++;
                }
            }

            result = channel->result.result[0];
        }
        else
        {
            tempResVal = channel->sfrPtr->RESM.U;

            if (channel->timeStampEnabled)
            {
                channel->result.timestamp = (uint16)(tempResVal >> IFX_ADC_DSADC_IN_RESM_RESULTHI_OFF);
            }

            *resultPtr = (uint16)tempResVal;
            result     = *resultPtr;
        }

        IfxAdc_clearDsadcResultEvent(channel->channelId);
    }

    return result;
}


void IfxAdc_Dsadc_initChannelConfig(IfxAdc_Dsadc_ChannelConfig *config, Ifx_ADC *adc)
{
    // initialize all to default values
    const IfxAdc_Dsadc_ChannelConfig defaultChannelConfig = {
        .channelId = IfxAdc_DsadcChannel_0,
        .adcSFR    = NULL_PTR,
        .input     = {
            .inputMuxControl = IfxAdc_DsadcInputMuxActCtrl_preset,
            .inputMuxSel     = IfxAdc_DsadcInSel_a
        },
        .resultHandling              = {
            .readAsUnsigned  = FALSE,
            .enableTimeStamp = FALSE,
            .disableFIFO     = FALSE,
            .fifoSrvLevel    = IfxAdc_DsadcFifoSrLevel_1,
            .dataReadWidth   = IfxAdc_DsadcDataReadWidth_16Bit
        },
        .analogModulator             = {
            .frequency     = IfxAdc_DsadcModulatorFreq_40MHz,
            .positiveInput = IfxAdc_DsadcInCfg_inputPin,
            .negativeInput = IfxAdc_DsadcInCfg_ground,
            .vcmConnection = {
                .positivePins = 0u,
                .negativePins = 0u
            },
            .ditherTrimLevel         = IfxAdc_DsadcDitherTrim_level2
        },
        .filterChain                 = {
            .auxCicFilter            = {
                .decimationFactor = IfxAdc_DsadcAuxCicDecFactor_16,
                .enableAuxCIC     = FALSE
            },
            .cicDecimationFactor = 3u,
            .cicDataShift        = IfxAdc_DsadcCicShift_0to16,
            .gainFactor          = 4096u,
            .offsetComp          = NULL_PTR,
            .integrator          = NULL_PTR,
            .enableFilterChain   = FALSE
        },
        .serviceRequest              = {
            .intCfg[0].priority      = 0u,
            .intCfg[0].typeOfService = IfxSrc_Tos_cpu0,
            .intCfg[0].vmId          = IfxSrc_VmId_0,

            .intCfg[1].priority      = 0u,
            .intCfg[1].typeOfService = IfxSrc_Tos_cpu0,
            .intCfg[1].vmId          = IfxSrc_VmId_0,

            .intCfg[2].priority      = 0u,
            .intCfg[2].typeOfService = IfxSrc_Tos_cpu0,
            .intCfg[2].vmId          = IfxSrc_VmId_0,

            .intCfg[3].priority      = 0u,
            .intCfg[3].typeOfService = IfxSrc_Tos_cpu0,
            .intCfg[3].vmId          = IfxSrc_VmId_0,

            .sr0Enable               = IfxAdc_DsadcSrvReq0_never,
            .sr1Enable               = FALSE,
            .sr2Enable               = FALSE,
            .sr3Enable               = IfxAdc_DsadcSrvReq3_never,
            .enableServiceReq        = FALSE
        },
        .boundCfg                    = {
            .upperBound       = 0,
            .lowerBound       = 0,
            .boundaryMode     = IfxAdc_DsadcBoundaryCmpMode_disable,
            .enableHysteresis = FALSE,
            .srvReqConfig     = IfxAdc_DsadcBoundaryServReq_insideBoundary,
            .srvReqGateEnable = FALSE,
        },
        .gainCalibration             = {
            .calFactor            = 4096,
            .calTarget            = 25000,
            .gainCorrectionFactor = 4096,
            .cicShift             = IfxAdc_DsadcCicShift_0to16,
            .cicDecimationRate    = IfxAdc_DsadcCicDecimationRate_128,
        },
        .queueCfg        = NULL_PTR,
        .timestamp       = NULL_PTR,
        .trigger         = NULL_PTR,
        .channelPins     = NULL_PTR,
        .autoCalibration = FALSE,
        .enableChannel   = TRUE
    };

    *config        = defaultChannelConfig;

    config->adcSFR = adc;
}


void IfxAdc_Dsadc_setupIntegrator(IfxAdc_DsadcChannel channelId, IfxAdc_Dsadc_IntegratorConfig *integratorCfg)
{
    Ifx_ADC_DSADC_IN       *sfrPtr = &(MODULE_ADC.DSADC.IN[channelId]);
    Ifx_ADC_DSADC_IN_INTCFG intCfg;

    intCfg.U = sfrPtr->INTCFG.U;

    if (!integratorCfg->extTriggerStart)
    {
        sfrPtr->INTTRCFG.B.INTTRM = (uint32)IfxAdc_DsadcTriggerMode_bothEdge;
    }

    if (!integratorCfg->restartFilterChain)
    {
        intCfg.B.FRC = 2u; /* no effect on filter chain */
    }
    else if (integratorCfg->restartAuxFilterChain)
    {
        intCfg.B.FRC = 1u; /* Restart both AUX and main filter chain */
    }
    else
    {
        intCfg.B.FRC = 0u; /* Restart main filter chain */
    }

    intCfg.B.INTEN   = integratorCfg->enableIntegrator;
    intCfg.B.ISC     = (uint32)integratorCfg->selectBits;                                                             /* Select Bits */

    intCfg.B.NVALDIS = (uint32)integratorCfg->numDiscardValues;                                                       /* Number of values to discard */
    intCfg.B.NVALINT = (uint32)integratorCfg->numAccValues - 1u > 0u ? (uint32)integratorCfg->numAccValues - 1u : 0u; /* Number of values to be accumulated */

    if (integratorCfg->windowControl == IfxAdc_DsadcIntegratorWindowCtrl_internal)
    {
        intCfg.B.REPVAL = (uint32)integratorCfg->numCycles - 1u > 0u ? (uint32)integratorCfg->numCycles - 1u : 0u; /* Number of cycles */
        intCfg.B.IWS    = 0u;                                                                                      /*Internally controlled end of integration after (REPVAL+1) */
    }
    else if (integratorCfg->windowControl == IfxAdc_DsadcIntegratorWindowCtrl_external)
    {
        intCfg.B.IWS = 1u;  /*Externally controlled end of integration*/
    }
    else
    {
        intCfg.B.IWS = 2u;  /* Software control end of integration*/
    }

    sfrPtr->INTCFG.U = intCfg.U;

    /* Initialize Rectifier */
    IfxAdc_Dsadc_initRectifier(sfrPtr, &(integratorCfg->rectifier));
}


IFX_STATIC void IfxAdc_Dsadc_setupTriggers(IfxAdc_Dsadc_TriggerConfig *triggerCfg, uint8 channelId, boolean hasAnalogMod)
{
    if (hasAnalogMod)
    {
        Ifx_ADC_DSADC_IN *chPtr = &(MODULE_ADC.DSADC.IN[channelId]);

        /* Input Mux trigger */
        if (triggerCfg->inMuxTrig != NULL_PTR)
        {
            Ifx_ADC_DSADC_IN_IMXTRCFG imxTrcfg;
            imxTrcfg.B.IMXTRDLY = triggerCfg->inMuxTrig->delayCount;
            imxTrcfg.B.IMXTRM   = triggerCfg->inMuxTrig->mode;
            imxTrcfg.B.IMXTRS   = triggerCfg->inMuxTrig->triggerSel;
            chPtr->IMXTRCFG.U   = imxTrcfg.U;
        }

        /* Integration trigger */
        if (triggerCfg->integratorTrig != NULL_PTR)
        {
            Ifx_ADC_DSADC_IN_INTTRCFG intTrcfg;
            intTrcfg.B.INTTRDLY = triggerCfg->integratorTrig->delayCount;
            intTrcfg.B.INTTRM   = triggerCfg->integratorTrig->mode;
            intTrcfg.B.INTTRS   = triggerCfg->integratorTrig->triggerSel;
            chPtr->INTTRCFG.U   = intTrcfg.U;
        }

        /* Boundary trigger */
        if (triggerCfg->boundaryTrig != NULL_PTR)
        {
            Ifx_ADC_DSADC_IN_BNDTRCFG bndTrcfg;
            bndTrcfg.B.BNDTRDLY = triggerCfg->boundaryTrig->delayCount;
            bndTrcfg.B.BNDTRM   = triggerCfg->boundaryTrig->mode;
            bndTrcfg.B.BNDTRS   = triggerCfg->boundaryTrig->triggerSel;
            chPtr->BNDTRCFG.U   = bndTrcfg.U;
        }

        /* Time Stamp trigger */
        if (triggerCfg->timestampTrig != NULL_PTR)
        {
            Ifx_ADC_DSADC_IN_TSTRCFG tsTrcfg;
            tsTrcfg.B.TSTRDLY = triggerCfg->timestampTrig->delayCount;
            tsTrcfg.B.TSTRM   = triggerCfg->timestampTrig->mode;
            tsTrcfg.B.TSTRS   = triggerCfg->timestampTrig->triggerSel;
            chPtr->TSTRCFG.U  = tsTrcfg.U;
        }

        /* Service Request trigger */
        if (triggerCfg->serviceReqTrig != NULL_PTR)
        {
            Ifx_ADC_DSADC_IN_SRTRCFG srTrcfg;
            srTrcfg.B.SRTRDLY = triggerCfg->serviceReqTrig->delayCount;
            srTrcfg.B.SRTRS   = triggerCfg->serviceReqTrig->triggerSel;
            chPtr->SRTRCFG.U  = srTrcfg.U;
        }
    }
    else
    {
        Ifx_ADC_DSADC_EX *exPtr = &(MODULE_ADC.DSADC.EX[channelId]);

        /* Boundary trigger */
        if (triggerCfg->boundaryTrig != NULL_PTR)
        {
            Ifx_ADC_DSADC_EX_BNDTRCFG exbndTrcfg;
            exbndTrcfg.B.BNDTRDLY = triggerCfg->boundaryTrig->delayCount;
            exbndTrcfg.B.BNDTRM   = triggerCfg->boundaryTrig->mode;
            exbndTrcfg.B.BNDTRS   = triggerCfg->boundaryTrig->triggerSel;
            exPtr->BNDTRCFG.U     = exbndTrcfg.U;
        }

        /* Time Stamp trigger */
        if (triggerCfg->timestampTrig != NULL_PTR)
        {
            Ifx_ADC_DSADC_EX_TSTRCFG extsTrcfg;
            extsTrcfg.B.TSTRDLY = triggerCfg->timestampTrig->delayCount;
            extsTrcfg.B.TSTRM   = triggerCfg->timestampTrig->mode;
            extsTrcfg.B.TSTRS   = triggerCfg->timestampTrig->triggerSel;
            exPtr->TSTRCFG.U    = extsTrcfg.U;
        }

        /* Service Request trigger */
        if (triggerCfg->serviceReqTrig != NULL_PTR)
        {
            Ifx_ADC_DSADC_EX_SRTRCFG exsrTrcfg;
            exsrTrcfg.B.SRTRDLY = triggerCfg->serviceReqTrig->delayCount;
            exsrTrcfg.B.SRTRS   = triggerCfg->serviceReqTrig->triggerSel;
            exPtr->SRTRCFG.U    = exsrTrcfg.U;
        }
    }
}


IFX_STATIC void IfxAdc_Dsadc_setupFilterChain(IfxAdc_Dsadc_FilterChainConfig *filterChainCfg, uint8 channelId, boolean hasAnalogMod)
{
    Ifx_ADC                  *adc = &MODULE_ADC;

    Ifx_ADC_DSADC_IN_CICCFG   cicCfg;
    Ifx_ADC_DSADC_IN_GAINCORR gainCorr;

    /* step 1: AUX CIC filter */
    cicCfg.B.CFAEN        = filterChainCfg->auxCicFilter.enableAuxCIC;
    cicCfg.B.CFADF        = filterChainCfg->auxCicFilter.decimationFactor;
    /* Step 2: CIC filter */
    cicCfg.B.CFMDF        = filterChainCfg->cicDecimationFactor;
    /* Step 3: GAIN and data shift */
    gainCorr.B.CICSHIFT   = filterChainCfg->cicDataShift;
    gainCorr.B.GAINFACTOR = (uint32)(filterChainCfg->gainFactor);

    if (hasAnalogMod)
    {
        adc->DSADC.IN[channelId].CICCFG.U   = cicCfg.U;
        adc->DSADC.IN[channelId].GAINCORR.U = gainCorr.U;

        /* Step 4: Offset compensation -- OPTIONAL */
        if (filterChainCfg->offsetComp != NULL_PTR)
        {
            IfxAdc_Dsadc_setupOffsetComp((IfxAdc_DsadcChannel)channelId, filterChainCfg->offsetComp);
        }

        /* Step 5: Integrator -- OPTIONAL */
        if (filterChainCfg->integrator != NULL_PTR)
        {
            IfxAdc_Dsadc_setupIntegrator((IfxAdc_DsadcChannel)channelId, filterChainCfg->integrator);
        }
    }
    else
    {
        adc->DSADC.EX[channelId].CICCFG.U   = cicCfg.U;
        adc->DSADC.EX[channelId].GAINCORR.U = gainCorr.U;
    }
}


void IfxAdc_Dsadc_initExmodChannelConfig(IfxAdc_Dsadc_ExmodChannelConfig *config, Ifx_ADC *adc)
{
    // initialize all to default values
    const IfxAdc_Dsadc_ExmodChannelConfig defaultExmodChannelConfig = {
        .channelId    = IfxAdc_Exmod_0,
        .adcSFR       = NULL_PTR,
        .extModulator = {
            .dataSource       = IfxAdc_ExmodDataSource_inputA,
            .dataStream       = IfxAdc_ExmodDataStream_fallingEdge,
            .clkSrc           = IfxAdc_ExmodClockSource_internal,
            .clkFreq          = IfxAdc_ExmodClockFreq_fadcdiv4,
            .enableManchester = FALSE
        },
        .filterChain                 = {
            .auxCicFilter            = {
                .decimationFactor = IfxAdc_DsadcAuxCicDecFactor_16,
                .enableAuxCIC     = FALSE
            },
            .cicDecimationFactor = 3u,
            .cicDataShift        = IfxAdc_DsadcCicShift_0to16,
            .gainFactor          = 4096u,
            .offsetComp          = NULL_PTR,
            .integrator          = NULL_PTR,
        },
        .boundCfg                    = {
            .upperBound       = 0,
            .lowerBound       = 0,
            .boundaryMode     = IfxAdc_DsadcBoundaryCmpMode_disable,
            .enableHysteresis = FALSE,
            .srvReqConfig     = IfxAdc_DsadcBoundaryServReq_insideBoundary,
            .srvReqGateEnable = FALSE,
        },
        .queueCfg       = NULL_PTR,
        .timestamp      = NULL_PTR,
        .trigger        = NULL_PTR,
        .exmodPins      = NULL_PTR,
        .resultHandling = {
            .readAsUnsigned  = FALSE,
            .enableTimeStamp = FALSE,
            .disableFIFO     = FALSE,
            .fifoSrvLevel    = IfxAdc_DsadcFifoSrLevel_1,
            .dataReadWidth   = IfxAdc_DsadcDataReadWidth_16Bit
        },
        .serviceRequest              = {
            .intCfg[0].priority      = 0u,
            .intCfg[0].typeOfService = IfxSrc_Tos_cpu0,
            .intCfg[0].vmId          = IfxSrc_VmId_0,

            .intCfg[1].priority      = 0u,
            .intCfg[1].typeOfService = IfxSrc_Tos_cpu0,
            .intCfg[1].vmId          = IfxSrc_VmId_0,

            .intCfg[2].priority      = 0u,
            .intCfg[2].typeOfService = IfxSrc_Tos_cpu0,
            .intCfg[2].vmId          = IfxSrc_VmId_0,

            .intCfg[3].priority      = 0u,
            .intCfg[3].typeOfService = IfxSrc_Tos_cpu0,
            .intCfg[3].vmId          = IfxSrc_VmId_0,

            .sr0Enable               = IfxAdc_DsadcSrvReq0_never,
            .sr1Enable               = FALSE,
            .sr2Enable               = FALSE,
            .sr3Enable               = FALSE,
            .enableServiceReq        = FALSE
        }
    };

    *config        = defaultExmodChannelConfig;

    config->adcSFR = adc;
}


void IfxAdc_Dsadc_initCarrierGeneration(IfxAdc_Dsadc *dsadc, IfxAdc_Dsadc_CarrierConfig *carrierCfg)
{
    Ifx_ADC_DSADC_CGCFG            cgCfg;
    Ifx_ADC_DSADC                 *modptr = dsadc->sfrPtr;
    IfxAdc_Dsadc_CarrierPinConfig *pinCfg = carrierCfg->carrierPins;

    /* Carrier signal configuration */
    cgCfg.U         = modptr->CGCFG.U;
    cgCfg.B.CGMOD   = carrierCfg->carrierMode;
    cgCfg.B.BREV    = carrierCfg->pwmMode;
    cgCfg.B.DIVCG   = carrierCfg->divFactor;
    cgCfg.B.SIGPOL  = carrierCfg->signalPol;
    /* cgCfg.B.TRIGEN  = carrierCfg->triggerMode; */ //Sfr fix needed
    modptr->CGCFG.U = cgCfg.U;

    /* Pin configuration */
    if (pinCfg != NULL_PTR)
    {
        /* Carrier generator positive pin configuration*/
        if (pinCfg->cgpPos != NULL_PTR)
        {
            IfxAdc_initCgPwmPin(pinCfg->cgpPos, pinCfg->cgpPosMode, pinCfg->pinDriver);
        }

        /* Carrier generator negative pin configuration*/
        if (pinCfg->cgNeg != NULL_PTR)
        {
            IfxAdc_initCgPwmPin(pinCfg->cgNeg, pinCfg->cgNegMode, pinCfg->pinDriver);
        }
    }
}


void IfxAdc_Dsadc_initRectifier(Ifx_ADC_DSADC_IN *dsadc, IfxAdc_Dsadc_RectifierConfig *rectifierCfg)
{
    Ifx_ADC_DSADC_IN        *modptr = dsadc;
    Ifx_ADC_DSADC_IN_RECTCFG rectCfg;
    Ifx_ADC_DSADC_IN_CGSYNC  cgSync;

    /* Read the register values */
    rectCfg.U = modptr->RECTCFG.U;
    cgSync.U  = modptr->CGSYNC.U;

    /* Configure the sign delay for synchronization*/
    cgSync.B.SDNEG = rectifierCfg->sdNegative;
    cgSync.B.SDPOS = rectifierCfg->sdPositive;

    /* Configure rectifier */
    rectCfg.B.RFEN = rectifierCfg->enable;
    rectCfg.B.SSCH = rectifierCfg->signChannel;
    rectCfg.B.SSRC = rectifierCfg->signSignal;

    /* Write register with configured values*/
    modptr->CGSYNC.U  = cgSync.U;
    modptr->RECTCFG.U = rectCfg.U;
}


uint16 IfxAdc_Dsadc_readExmodChannelResult(IfxAdc_Dsadc_Exmod *channel)
{
    uint16 *resultPtr  = &(channel->result.result[0]);
    uint16  result     = 0u;
    uint32  tempResVal = 0;

    if (IfxAdc_getExmodResultEvent(channel->channelId))
    {
        if (channel->fifoEnabled)
        {
            uint8 fillLevel = IfxAdc_getExmodFifoFillLevel(channel->channelId);
            uint8 readIndex = 0u;

            if (channel->timeStampEnabled)
            {
                tempResVal                = channel->sfrPtr->RESM.U;

                channel->result.timestamp = (uint16)tempResVal;
                readIndex++;

                if ((channel->resultReadWidth == IfxAdc_DsadcDataReadWidth_32Bit) && (readIndex < fillLevel))
                {
                    *resultPtr++ = (uint16)(tempResVal >> IFX_ADC_DSADC_IN_RESM_RESULTHI_OFF);
                    readIndex++;
                }
            }

            while (readIndex < fillLevel)
            {
                tempResVal   = channel->sfrPtr->RESM.U;
                *resultPtr++ = (uint16)tempResVal;
                readIndex++;

                if ((channel->resultReadWidth == IfxAdc_DsadcDataReadWidth_32Bit) && (readIndex < fillLevel))
                {
                    *resultPtr++ = (uint16)(tempResVal >> IFX_ADC_DSADC_IN_RESM_RESULTHI_OFF);
                    readIndex++;
                }
            }

            result = channel->result.result[0];
        }
        else
        {
            tempResVal = channel->sfrPtr->RESM.U;

            if (channel->timeStampEnabled)
            {
                channel->result.timestamp = (uint16)(tempResVal >> IFX_ADC_DSADC_IN_RESM_RESULTHI_OFF);
            }

            *resultPtr = (uint16)tempResVal;
            result     = *resultPtr;
        }

        IfxAdc_clearExmodResultEvent(channel->channelId);
    }

    return result;
}


void IfxAdc_Dsadc_initCarrierGenConfig(IfxAdc_Dsadc_CarrierConfig *config)
{
    const IfxAdc_Dsadc_CarrierConfig defaultConfig = {
        .carrierMode = IfxAdc_DsadcCgOperatingMode_stopped,
        .pwmMode     = IfxAdc_DsadcPwmGeneration_normal,
        .signalPol   = IfxAdc_DsadcCarrierSignalPol_normal,
        .divFactor   = IfxAdc_DsadcCarrierSignalDivFactor_cgp2,
        .carrierPins = NULL_PTR,
    };
    *config = defaultConfig;
}


IFX_STATIC void IfxAdc_Dsadc_configureBoundary(IfxAdc_Dsadc_BoundaryConfig *boundaryCfg, uint8 channelId, boolean hasAnalogMod)
{
    Ifx_ADC *adc = &MODULE_ADC;

    if (hasAnalogMod)
    {
        Ifx_ADC_DSADC_IN_BNDCFG   bndCfg;
        Ifx_ADC_DSADC_IN_BOUNDSEL bndSel;
        /* Reading Register */
        bndCfg.U = adc->DSADC.IN[channelId].BNDCFG.U;

        /* Configuring boundary mode for BFL and service request configuration for boundary */
        bndCfg.B.BNDMODE = boundaryCfg->boundaryMode;
        bndCfg.B.HYSTEN  = boundaryCfg->enableHysteresis;
        bndCfg.B.SR2CFG  = boundaryCfg->srvReqConfig;
        bndCfg.B.SR2GT   = boundaryCfg->srvReqGateEnable;

        /* Configuring upper and lower boundary */
        bndSel.B.BOUNDARYL = boundaryCfg->lowerBound;
        bndSel.B.BOUNDARYU = boundaryCfg->upperBound;

        /* Writing Register */
        adc->DSADC.IN[channelId].BNDCFG.U   = bndCfg.U;
        adc->DSADC.IN[channelId].BOUNDSEL.U = bndSel.U;
    }
    else
    {
        Ifx_ADC_DSADC_EX_BNDCFG   exbndCfg;
        Ifx_ADC_DSADC_EX_BOUNDSEL exbndSel;

        /* Reading Register */
        exbndCfg.U = adc->DSADC.EX[channelId].BNDCFG.U;

        /* Configuring boundary mode for BFL and service request configuration for boundary */
        exbndCfg.B.BNDMODE = boundaryCfg->boundaryMode;
        exbndCfg.B.HYSTEN  = boundaryCfg->enableHysteresis;
        exbndCfg.B.SR2CFG  = boundaryCfg->srvReqConfig;

        /* Configuring upper and lower boundary */
        exbndSel.B.BOUNDARYL = boundaryCfg->lowerBound;
        exbndSel.B.BOUNDARYU = boundaryCfg->upperBound;

        /* Writing Register */
        adc->DSADC.EX[channelId].BNDCFG.U   = exbndCfg.U;
        adc->DSADC.EX[channelId].BOUNDSEL.U = exbndSel.U;
    }
}


uint16 IfxAdc_Dsadc_getNumberOfDsadcResults(IfxAdc_Dsadc_Channel *channel)
{
    return IfxAdc_Dsadc_getNumberOfResults(channel, TRUE);
}


uint16 IfxAdc_Dsadc_getNumberOfExmodResults(IfxAdc_Dsadc_Exmod *channel)
{
    return IfxAdc_Dsadc_getNumberOfResults(channel, FALSE);
}


IfxAdc_Status IfxAdc_Dsadc_setupDsadcResultBuffer(IfxAdc_Dsadc_Channel *channel, void *buffer, IfxAdc_Dsadc_BufferSize size)
{
    uint16       *localBufferPtr = (uint16 *)buffer;
    IfxAdc_Status status         = IfxAdc_Status_success;
    uint8         index          = 0u;
    uint16        buffersize     = IfxAdc_Dsadc_getBufferSize(size);
    uint32        transferCount  = 0u;

    /* Check if Fifo enabled, Buffer size is not zero and BufferPtr is not NULL */
    if ((buffersize != 0U) && (localBufferPtr != NULL_PTR))
    {
        /* Update the handle for buffer address and size */
        channel->queue.bufferPtr    = (uint16 *)localBufferPtr;
        channel->queue.writeIndex   = 0u;
        channel->queue.readIndex    = 0u;
        channel->queue.size         = buffersize;
        channel->queue.bufferFull   = FALSE;
        channel->queue.validResult  = 0u;
        channel->queue.queueEnabled = TRUE;

        /* Flushing the fifo */
        for (index = 0u; index < buffersize; index++)
        {
            localBufferPtr[index] = (uint16)0U;
        }

        /* If Dma configured update the destination address in Dma configuration */
        if (channel->queue.dma.useDma)
        {
            /*1. Update destination Address */
            IfxDma_Dma_setChannelDestinationAddress(&(channel->queue.dma.channel), (uint32)localBufferPtr);

            if (channel->queue.bufferType != IfxAdc_Dsadc_BufferType_circular)
            {
                if (channel->resultReadWidth == IfxAdc_DsadcDataReadWidth_16Bit)
                {
                    transferCount = (channel->queue.size << 1u) / ((channel->fifoLevel + 1u) * ((channel->resultReadWidth + 1u) << 1u));
                }
                else
                {
                    transferCount = (channel->queue.size << 1u) / ((channel->fifoLevel + 1u) * ((channel->resultReadWidth - 1u) << 1u));
                }

                /* Update transfer count */
                IfxDma_Dma_setChannelTransferCount(&(channel->queue.dma.channel), transferCount);
                /* Enable channel hardware transaction request */
                IfxDma_enableChannelTransaction(channel->queue.dma.channel.dma, channel->queue.dma.channel.channelId);
            }
            else
            {
                /*2. Circular Buffer: Update Circular Address rang. */
                IfxDma_setCircularBufferDestinationLength(channel->queue.dma.channel.dma, channel->queue.dma.channel.channelId, size);
            }
        }
    }
    else
    {
        /* Update queueEnable to FALSE if BufferPtr is NULL or size is 0 */
        channel->queue.queueEnabled = FALSE;
        status                      = IfxAdc_Status_failure;
    }

    return status;
}


IfxAdc_Status IfxAdc_Dsadc_setupExmodResultBuffer(IfxAdc_Dsadc_Exmod *channel, void *buffer, IfxAdc_Dsadc_BufferSize size)
{
    uint16       *localBufferPtr = (uint16 *)buffer;
    IfxAdc_Status status         = IfxAdc_Status_success;
    uint8         index          = 0u;
    uint16        buffersize     = IfxAdc_Dsadc_getBufferSize(size);
    uint32        transferCount  = 0u;

    /* Check if Fifo enabled, Buffer size is not zero and BufferPtr is not NULL */
    if ((buffersize != 0U) && (localBufferPtr != NULL_PTR))
    {
        /* Update the handle for buffer address and size */
        channel->queue.bufferPtr    = (uint16 *)localBufferPtr;
        channel->queue.writeIndex   = 0u;
        channel->queue.readIndex    = 0u;
        channel->queue.size         = buffersize;
        channel->queue.bufferFull   = FALSE;
        channel->queue.validResult  = 0u;
        channel->queue.queueEnabled = TRUE;

        /* Flushing the fifo */
        for (index = 0u; index < buffersize; index++)
        {
            localBufferPtr[index] = (uint16)0U;
        }

        /* If Dma configured update the destination address in Dma configuration */
        if (channel->queue.dma.useDma)
        {
            /*1. Update destination Address */
            IfxDma_Dma_setChannelDestinationAddress(&(channel->queue.dma.channel), (uint32)localBufferPtr);

            if (channel->queue.bufferType != IfxAdc_Dsadc_BufferType_circular)
            {
                if (channel->resultReadWidth == IfxAdc_DsadcDataReadWidth_16Bit)
                {
                    transferCount = (channel->queue.size << 1u) / ((channel->fifoLevel + 1u) * ((channel->resultReadWidth + 1u) << 1u));
                }
                else
                {
                    transferCount = (channel->queue.size << 1u) / ((channel->fifoLevel + 1u) * ((channel->resultReadWidth - 1u) << 1u));
                }

                /* Update transfer count */
                IfxDma_Dma_setChannelTransferCount(&(channel->queue.dma.channel), transferCount);
                /* Enable channel hardware transaction request */
                IfxDma_enableChannelTransaction(channel->queue.dma.channel.dma, channel->queue.dma.channel.channelId);
            }
            else
            {
                /*2. Circular Buffer: Update Circular Address rang. */
                IfxDma_setCircularBufferDestinationLength(channel->queue.dma.channel.dma, channel->queue.dma.channel.channelId, size);
            }
        }
    }
    else
    {
        /* Update queueEnable to FALSE if BufferPtr is NULL or size is 0 */
        channel->queue.queueEnabled = FALSE;
        status                      = IfxAdc_Status_failure;
    }

    return status;
}


uint16 IfxAdc_Dsadc_readDsadcCircularBufferResult(IfxAdc_Dsadc_Channel *channel)
{
    return IfxAdc_Dsadc_readCircularBufferResult(channel, TRUE);
}


uint16 IfxAdc_Dsadc_readExmodCircularBufferResult(IfxAdc_Dsadc_Exmod *channel)
{
    return IfxAdc_Dsadc_readCircularBufferResult(channel, FALSE);
}


IfxAdc_Status IfxAdc_Dsadc_readDsadcStreamResult(IfxAdc_Dsadc_Channel *channel, uint16 *resBuff, uint16 size)
{
    return IfxAdc_Dsadc_readStreamResult(channel, resBuff, size, TRUE);
}


IfxAdc_Status IfxAdc_Dsadc_readExmodStreamResult(IfxAdc_Dsadc_Exmod *channel, uint16 *resBuff, uint16 size)
{
    return IfxAdc_Dsadc_readStreamResult(channel, resBuff, size, FALSE);
}


void IfxAdc_Dsadc_dsadcResultIsr(IfxAdc_Dsadc_Channel *channel)
{
    IfxAdc_Dsadc_Queue *localquePtr = &(channel->queue);

    /* Check if queue enable */
    if (localquePtr->queueEnabled)
    {
        /* Store the result from hardware FIFO to software buffer */
        IfxAdc_Dsadc_writeDsadcBuffer(channel);

        /* Check if callback configured if buffer is full */
        if ((localquePtr->bufferFull) && (localquePtr->buffHandler != NULL_PTR))
        {
            /* Do Callback if buffer gets full */
            (*localquePtr->buffHandler)();
        }
    }

    /* Check if callback configured for result event */
    if (channel->resHandler != NULL_PTR)
    {
        /* Callback for each result event */
        (*channel->resHandler)();
    }
}


void IfxAdc_Dsadc_exmodResultIsr(IfxAdc_Dsadc_Exmod *channel)
{
    IfxAdc_Dsadc_Queue *localquePtr = &(channel->queue);

    /* Check if queue enable */
    if (localquePtr->queueEnabled)
    {
        /* Store the result from hardware FIFO to software buffer */
        IfxAdc_Dsadc_writeExmodBuffer(channel);

        /* Check if callback configured if buffer is full */
        if ((localquePtr->bufferFull) && (localquePtr->buffHandler != NULL_PTR))
        {
            /* Do Callback if buffer gets full */
            (*localquePtr->buffHandler)();
        }
    }

    /* Check if callback configured for result event */
    if (channel->resHandler != NULL_PTR)
    {
        /* Callback for each result event */
        (*channel->resHandler)();
    }
}


IFX_STATIC void IfxAdc_Dsadc_configureDma(IfxAdc_Dsadc_QueueConfig *queue, void *channel, boolean hasAnalogMod)
{
    IfxAdc_Dsadc_DmaConfig   *dmaCfgPtr        = (queue->dmaCfg);
    Ifx_DMA                  *dmaSFR           = (Ifx_DMA *)(IfxDma_cfg_indexMap[dmaCfgPtr->dmaId].module);
    IfxAdc_DsadcFifoSrLevel   fifoSrvLevel     = IfxAdc_DsadcFifoSrLevel_1;
    IfxAdc_DsadcDataReadWidth resultReadWidth  = IfxAdc_DsadcDataReadWidth_16Bit;
    uint32                    resultRegAddress = 0U;
    Ifx_ADC_DSADC_IN         *channelSfr       = NULL_PTR;
    Ifx_ADC_DSADC_EX         *exmodSfr         = NULL_PTR;
    IfxAdc_Dsadc_Channel     *channelHandle    = NULL_PTR;
    IfxAdc_Dsadc_Exmod       *exmodHandle      = NULL_PTR;
    uint16                    buffSize         = 0U;

    if (hasAnalogMod)
    {
        channelHandle                   = (IfxAdc_Dsadc_Channel *)channel;
        channelSfr                      = channelHandle->sfrPtr;
        //Update handle
        channelHandle->queue.dma.useDma = TRUE;
        /* Update channelId and dmaId in handle */
        channelHandle->queue.dma.dmaId  = dmaCfgPtr->dmaId;

        fifoSrvLevel                    = channelHandle->fifoLevel;
        resultReadWidth                 = channelHandle->resultReadWidth;
        buffSize                        = channelHandle->queue.size;
        resultRegAddress                = (uint32)&(channelSfr->RESM.U);
    }
    else
    {
        exmodHandle                   = (IfxAdc_Dsadc_Exmod *)channel;
        exmodSfr                      = exmodHandle->sfrPtr;
        //Update handle
        exmodHandle->queue.dma.useDma = TRUE;
        /* Update channelId in handle */
        exmodHandle->queue.dma.dmaId  = dmaCfgPtr->dmaId;

        fifoSrvLevel                  = exmodHandle->fifoLevel;
        resultReadWidth               = exmodHandle->resultReadWidth;
        buffSize                      = exmodHandle->queue.size;
        resultRegAddress              = (uint32)&(exmodSfr->RESM.U);
    }

    //DMA Module handle
    IfxDma_Dma dma;

    if (dmaSFR->CLC.B.DISS)
    {
        // DMA module configuration
        IfxDma_Dma_Config dmaConfig;
        IfxDma_Dma_initModuleConfig(&dmaConfig, dmaSFR);
        //Enable clock of DMA
        IfxDma_Dma_initModule(&dma, &dmaConfig);
    }

    IfxDma_Dma_createModuleHandle(&dma, dmaSFR);

    //DMA channel configuration
    IfxDma_Dma_ChannelConfig dmaCfg;
    IfxDma_Dma_initChannelConfig(&dmaCfg, &dma);

    /* Update DMA channel id in handle */
    dmaCfg.channelId = dmaCfgPtr->channelId;

    /* DMA channel configuration */
    dmaCfg.requestSource          = IfxDma_ChannelRequestSource_peripheral;  //DMA request will be raised by CDSP result event
    dmaCfg.pattern                = IfxDma_ChannelPattern_0_disable;
    dmaCfg.hardwareRequestEnabled = TRUE;                                    // will be triggered from DSADC result service request

    /* Source Address configuration */
    dmaCfg.sourceAddress                   = resultRegAddress;               // Result register address
    dmaCfg.sourceAddressIncrementStep      = IfxDma_ChannelIncrementStep_1;
    dmaCfg.sourceAddressIncrementDirection = IfxDma_ChannelIncrementDirection_positive;
    dmaCfg.sourceCircularBufferEnabled     = TRUE;

    /* Destination Address configuration */
    dmaCfg.destinationAddress                   = (uint32)(queue->bufferPtr);
    dmaCfg.destinationAddressIncrementStep      = IfxDma_ChannelIncrementStep_1;
    dmaCfg.destinationAddressIncrementDirection = IfxDma_ChannelIncrementDirection_positive;

    if (queue->bufferType == IfxAdc_Dsadc_BufferType_circular)
    {
        dmaCfg.transferCount                    = 1u;
        dmaCfg.requestMode                      = IfxDma_ChannelRequestMode_oneTransferPerRequest;
        dmaCfg.operationMode                    = IfxDma_ChannelOperationMode_continuous;     // hw request enable remains set after transaction
        dmaCfg.destinationAddressCircularRange  = (IfxDma_ChannelIncrementCircular)(queue->size);
        dmaCfg.destinationCircularBufferEnabled = TRUE;
        dmaCfg.wrapDestinationInterruptEnabled  = FALSE;
    }
    else //Linear buffer
    {
        if (resultReadWidth == IfxAdc_DsadcDataReadWidth_16Bit)
        {
            dmaCfg.transferCount = (buffSize << 1u) / ((fifoSrvLevel + 1u) * ((resultReadWidth + 1u) << 1u));
        }
        else
        {
            dmaCfg.transferCount = (buffSize << 1u) / ((fifoSrvLevel + 1u) * ((resultReadWidth - 1u) << 1u));
        }

        dmaCfg.requestMode                      = IfxDma_ChannelRequestMode_oneTransferPerRequest;
        dmaCfg.operationMode                    = IfxDma_ChannelOperationMode_single;     // hw request is disabled after transaction
        dmaCfg.destinationAddressCircularRange  = IfxDma_ChannelIncrementCircular_none;
        dmaCfg.destinationCircularBufferEnabled = FALSE;
        dmaCfg.wrapDestinationInterruptEnabled  = FALSE;
        dmaCfg.channelInterruptEnabled          = TRUE;
        dmaCfg.channelInterruptControl          = IfxDma_ChannelInterruptControl_thresholdLimitMatch;     //Interrupt will be raised when TCOUNT = 0
    }

    /* Block mode is selected based on the configured Fifo fill level
     * If Fifo fill level is 4 dma block mode is selected as IfxDma_ChannelMove_4(4 DMA move per DMA transfer) */
    if (resultReadWidth == IfxAdc_DsadcDataReadWidth_16Bit)
    {
        if (fifoSrvLevel < IfxAdc_DsadcFifoSrLevel_3)
        {
            dmaCfg.blockMode = (IfxDma_ChannelMove)fifoSrvLevel;
        }
        else if (fifoSrvLevel == IfxAdc_DsadcFifoSrLevel_3)
        {
            dmaCfg.blockMode = IfxDma_ChannelMove_3;     //3 DMA move per DMA transfer
        }
        else
        {
            dmaCfg.blockMode = IfxDma_ChannelMove_4;     //4 DMA move per DMA transfer
        }

        dmaCfg.moveSize                   = IfxDma_ChannelMoveSize_16bit;
        dmaCfg.sourceAddressCircularRange = IfxDma_ChannelIncrementCircular_2;           //Keep the same address
    }
    else
    {
        dmaCfg.moveSize                   = IfxDma_ChannelMoveSize_32bit;
        dmaCfg.blockMode                  = (IfxDma_ChannelMove)(fifoSrvLevel >> 1u);
        dmaCfg.sourceAddressCircularRange = IfxDma_ChannelIncrementCircular_4; //Keep the same address
    }

    /* DMA interrupt configuration */
    if (dmaCfgPtr->dmaSrvReqCfg != NULL_PTR)
    {
        dmaCfg.channelInterruptTypeOfService = dmaCfgPtr->dmaSrvReqCfg->typeOfService;
        dmaCfg.channelVmId                   = dmaCfgPtr->dmaSrvReqCfg->vmId;
        dmaCfg.channelInterruptPriority      = dmaCfgPtr->dmaSrvReqCfg->priority;
    }

    if (hasAnalogMod)
    {
        IfxDma_Dma_initChannel(&channelHandle->queue.dma.channel, &dmaCfg);
    }
    else
    {
        IfxDma_Dma_initChannel(&exmodHandle->queue.dma.channel, &dmaCfg);
    }
}


IFX_STATIC void IfxAdc_Dsadc_writeDsadcBuffer(IfxAdc_Dsadc_Channel *channel)
{
    Ifx_ADC_DSADC_IN *channelSfr       = channel->sfrPtr;
    uint16           *resultbufferPtr  = (uint16 *)(channel->queue.bufferPtr);
    uint16            localWriteIndex  = channel->queue.writeIndex;
    uint16            localValidResult = channel->queue.validResult;
    boolean           localBufferFull  = channel->queue.bufferFull;
    uint16            bufferSize       = channel->queue.size;
    uint16            numResult        = 0u;
    uint8             readIndex        = 0u;
    uint32            tempResVal       = 0u;
    uint8             fillLevel        = IfxAdc_getDsadcFifoFillLevel(channel->channelId);

    if ((localBufferFull == TRUE) && (channel->queue.bufferType != IfxAdc_Dsadc_BufferType_circular))
    {
        /* Linear buffer is Full */
    }
    else
    {
        /* Number of result to check for buffer full status.*/
        numResult = localValidResult + fillLevel;

        /* Check if buffer full */
        if (numResult >= bufferSize)
        {
            /* Local variable to update buffer full status in handle */
            localBufferFull = TRUE;

            if (channel->queue.bufferType != IfxAdc_Dsadc_BufferType_circular)
            {
                /* Update fill level to read result until buffer overflow does not happen*/
                fillLevel = bufferSize - localValidResult;
            }
        }

        /* DRM = 2*/
        if (channel->resultReadWidth == IfxAdc_DsadcDataReadWidth_32Bit)
        {
            while (readIndex < fillLevel)
            {
                /* Read result value in local variable */
                tempResVal                       = channelSfr->RESM.U;
                resultbufferPtr[localWriteIndex] = (uint16)tempResVal;                                                   // Update lower 16 bit result value in buffer
                localWriteIndex                  = ((localWriteIndex + 1u) >= bufferSize) ? 0u : (localWriteIndex + 1u); // Increment write index
                readIndex++;

                resultbufferPtr[localWriteIndex] = (uint16)(tempResVal >> IFX_ADC_CDSP_DSP_RES_CRESULTHI_OFF);           //Update higher 16 bit result in buffer
                localWriteIndex                  = ((localWriteIndex + 1u) >= bufferSize) ? 0u : (localWriteIndex + 1u); // Increment write index
                readIndex++;
            }
        }
        else /*DRM = 1: 16 bit read access. Upper part of the result register contains sign bit*/
        {
            while (readIndex < fillLevel)
            {
                /* Read result value in local variable */
                tempResVal                       = channelSfr->RESM.U;
                resultbufferPtr[localWriteIndex] = (uint16)tempResVal;                                                   // Update lower 16 bit result value in buffer
                localWriteIndex                  = ((localWriteIndex + 1u) >= bufferSize) ? 0u : (localWriteIndex + 1u); // Increment write index
                readIndex++;
            }
        }

        /* Clear result event */
        IfxAdc_clearDsadcResultEvent(channel->channelId);
    }

    /*Update the write pointer and valid results in handle*/
    channel->queue.writeIndex = localWriteIndex;
    channel->queue.bufferFull = localBufferFull;

    if (!localBufferFull)
    {
        channel->queue.validResult += readIndex;
    }
    else
    {
        channel->queue.validResult = bufferSize;
    }
}


IFX_STATIC uint16 IfxAdc_Dsadc_readCircularBufferResult(void *channel, boolean hasAnalogMod)
{
    IfxAdc_Dsadc_Channel *channelHandle    = NULL_PTR;
    IfxAdc_Dsadc_Exmod   *exmodHandle      = NULL_PTR;
    uint16                result           = 0U;
    uint16                localReadIndex   = 0U;
    uint16                localValidResult = 0U;
    uint16                localWriteIndex  = 0U;
    boolean               localBufferFull  = FALSE;
    uint16                bufferSize       = 0U;
    uint16               *resultbufferPtr  = NULL_PTR;

    /* Update values in local variable from handle */
    if (hasAnalogMod)
    {
        channelHandle    = (IfxAdc_Dsadc_Channel *)channel;
        localReadIndex   = channelHandle->queue.readIndex;
        localValidResult = channelHandle->queue.validResult;
        localBufferFull  = channelHandle->queue.bufferFull;
        localWriteIndex  = channelHandle->queue.writeIndex;
        resultbufferPtr  = (uint16 *)(channelHandle->queue.bufferPtr);
        bufferSize       = channelHandle->queue.size;
    }
    else
    {
        exmodHandle      = (IfxAdc_Dsadc_Exmod *)channel;
        localReadIndex   = exmodHandle->queue.readIndex;
        localValidResult = exmodHandle->queue.validResult;
        localBufferFull  = exmodHandle->queue.bufferFull;
        localWriteIndex  = exmodHandle->queue.writeIndex;
        resultbufferPtr  = (uint16 *)(exmodHandle->queue.bufferPtr);
        bufferSize       = exmodHandle->queue.size;
    }

    /* Return result 0 if buffer empty */
    if (localValidResult == 0U)
    {
        result = 0U;
    }
    else
    {
        /* If buffer is full the updating the read index since the current read index will contain the latest value */
        if (localBufferFull)
        {
            /* Updating read index to point to the old value in the buffer if the buffer is overflowed */
            localReadIndex = localWriteIndex;
        }

        /* Read immediate result from buffer based on read index */
        result         = resultbufferPtr[localReadIndex];
        localReadIndex = ((localReadIndex + 1u) >= bufferSize) ? 0u : (localReadIndex + 1u);          // Increment read index

        /* Update values in handle based on Dsadc/Exmod channel */
        if (hasAnalogMod)
        {
            channelHandle->queue.readIndex    = localReadIndex;                         //Update read index in handle
            channelHandle->queue.validResult -= 1U;                                     //Decrement and update valid result count
            channelHandle->queue.bufferFull   = FALSE;                                  //Update buffer full status
        }
        else
        {
            exmodHandle->queue.readIndex    = localReadIndex;                         //Update read index in handle
            exmodHandle->queue.validResult -= 1U;                                     //Decrement and update valid result count
            exmodHandle->queue.bufferFull   = FALSE;                                  //Update buffer full status
        }
    }

    return result;
}


IFX_STATIC IfxAdc_Status IfxAdc_Dsadc_readStreamResult(void *channel, uint16 *resBuff, uint16 size, boolean hasAnalogMod)
{
    IfxAdc_Dsadc_Channel *channelHandle    = NULL_PTR;
    IfxAdc_Dsadc_Exmod   *exmodHandle      = NULL_PTR;
    uint16                index            = 0u;
    uint16                localReadIndex   = 0u;
    uint16                localValidResult = 0u;
    uint16                bufferSize       = 0u;
    uint16               *resultbufferPtr  = NULL_PTR;
    IfxAdc_Status         status           = IfxAdc_Status_success;

    if (hasAnalogMod)
    {
        channelHandle    = (IfxAdc_Dsadc_Channel *)channel;
        localReadIndex   = channelHandle->queue.readIndex;
        localValidResult = channelHandle->queue.validResult;
        resultbufferPtr  = (uint16 *)(channelHandle->queue.bufferPtr);
        bufferSize       = channelHandle->queue.size;
    }
    else
    {
        exmodHandle      = (IfxAdc_Dsadc_Exmod *)channel;
        localReadIndex   = exmodHandle->queue.readIndex;
        localValidResult = exmodHandle->queue.validResult;
        resultbufferPtr  = (uint16 *)(exmodHandle->queue.bufferPtr);
        bufferSize       = exmodHandle->queue.size;
    }

    /* Return Error if buffer empty or number of valid result in buffer is less than size */
    if ((localValidResult == 0U) || (localValidResult < size))
    {
        /* If buffer empty, return Error */
        status = IfxAdc_Status_failure;
    }
    else
    {
        /* Store the result from circular buffer to linear buffer*/
        for (index = 0; index < size; index++)
        {
            resBuff[index] = resultbufferPtr[localReadIndex];
            localReadIndex = ((localReadIndex + 1u) >= bufferSize) ? 0u : (localReadIndex + 1u);
        }

        localValidResult -= size;                  // Decrement valid result
    }

    if (hasAnalogMod)
    {
        channelHandle->queue.readIndex   = localReadIndex;   //Update read index in handle
        channelHandle->queue.bufferFull  = FALSE;            // Update buffer full status
        channelHandle->queue.validResult = localValidResult; // Update valid result
    }
    else
    {
        exmodHandle->queue.readIndex   = localReadIndex;   //Update read index in handle
        exmodHandle->queue.bufferFull  = FALSE;            // Update buffer full status
        exmodHandle->queue.validResult = localValidResult; // Update valid result
    }

    return status;
}


IFX_STATIC IfxAdc_Status IfxAdc_Dsadc_initBuffer(IfxAdc_Dsadc_QueueConfig *queueConfig, void *channel, boolean hasAnalogMod)
{
    uint16       *localBufferPtr = (uint16 *)(queueConfig->bufferPtr);
    IfxAdc_Status status         = IfxAdc_Status_success;
    uint16        buffersize     = IfxAdc_Dsadc_getBufferSize(queueConfig->size);
    uint16        index          = 0u;

    if (hasAnalogMod)
    {
        IfxAdc_Dsadc_Channel *channelHandle = (IfxAdc_Dsadc_Channel *)channel;

        /* Check if Buffer size is not zero and BufferPtr is not NULL */
        if ((buffersize != 0U) && (localBufferPtr != NULL_PTR))
        {
            /* Update the handle for buffer address and size */
            channelHandle->queue.bufferPtr    = (uint16 *)localBufferPtr;
            channelHandle->queue.writeIndex   = 0U;
            channelHandle->queue.readIndex    = 0U;
            channelHandle->queue.size         = buffersize;
            channelHandle->queue.bufferFull   = FALSE;
            channelHandle->queue.validResult  = 0U;
            channelHandle->queue.queueEnabled = TRUE;
            channelHandle->queue.buffHandler  = queueConfig->bufferFullHandler;
            channelHandle->queue.bufferType   = queueConfig->bufferType;

            /* Flushing the user provided buffer */
            for (index = 0u; index < buffersize; index++)
            {
                localBufferPtr[index] = (uint16)0U;
            }
        }
        else
        {
            /* Update queueEnable to FALSE if BufferPtr is NULL or size is 0 */
            channelHandle->queue.queueEnabled = FALSE;
            status                            = IfxAdc_Status_failure;
        }
    }
    else
    {
        IfxAdc_Dsadc_Exmod *exmodHandle = (IfxAdc_Dsadc_Exmod *)channel;

        /* Check if Buffer size is not zero and BufferPtr is not NULL */
        if ((buffersize != 0U) && (localBufferPtr != NULL_PTR))
        {
            /* Update the handle for buffer address and size */
            exmodHandle->queue.bufferPtr    = (uint16 *)localBufferPtr;
            exmodHandle->queue.writeIndex   = 0U;
            exmodHandle->queue.readIndex    = 0U;
            exmodHandle->queue.size         = buffersize;
            exmodHandle->queue.bufferFull   = FALSE;
            exmodHandle->queue.validResult  = 0U;
            exmodHandle->queue.queueEnabled = TRUE;
            exmodHandle->queue.buffHandler  = queueConfig->bufferFullHandler;
            exmodHandle->queue.bufferType   = queueConfig->bufferType;

            /* Flushing the user provided buffer */
            for (index = 0u; index < buffersize; index++)
            {
                localBufferPtr[index] = (uint16)0U;
            }
        }
        else
        {
            /* Update queueEnable to FALSE if BufferPtr is NULL or size is 0 */
            exmodHandle->queue.queueEnabled = FALSE;
            status                          = IfxAdc_Status_failure;
        }
    }

    return status;
}


IFX_STATIC void IfxAdc_Dsadc_writeExmodBuffer(IfxAdc_Dsadc_Exmod *channel)
{
    Ifx_ADC_DSADC_EX *exmodSfr         = channel->sfrPtr;
    uint16           *resultbufferPtr  = (uint16 *)(channel->queue.bufferPtr);
    uint16            localWriteIndex  = channel->queue.writeIndex;
    uint16            localValidResult = channel->queue.validResult;
    boolean           localBufferFull  = channel->queue.bufferFull;
    uint16            bufferSize       = channel->queue.size;
    uint16            numResult        = 0u;
    uint8             readIndex        = 0u;
    uint32            tempResVal       = 0u;
    uint8             fillLevel        = IfxAdc_getExmodFifoFillLevel(channel->channelId);

    if ((localBufferFull == TRUE) && (channel->queue.bufferType != IfxAdc_Dsadc_BufferType_circular))
    {
        /* Linear buffer is Full */
    }
    else
    {
        /* Number of result to check for buffer full status.*/
        numResult = localValidResult + fillLevel;

        /* Check if buffer full */
        if (numResult >= bufferSize)
        {
            /* Local variable to update buffer full status in handle */
            localBufferFull = TRUE;

            if (channel->queue.bufferType != IfxAdc_Dsadc_BufferType_circular)
            {
                /* Update fill level to read result until buffer overflow does not happen*/
                fillLevel = bufferSize - localValidResult;
            }
        }

        /* DRM = 2*/
        if (channel->resultReadWidth == IfxAdc_DsadcDataReadWidth_32Bit)
        {
            while (readIndex < fillLevel)
            {
                /* Read result value in local variable */
                tempResVal                       = exmodSfr->RESM.U;
                resultbufferPtr[localWriteIndex] = (uint16)tempResVal;                                                   // Update lower 16 bit result value in buffer
                localWriteIndex                  = ((localWriteIndex + 1u) >= bufferSize) ? 0u : (localWriteIndex + 1u); // Increment write index
                readIndex++;

                resultbufferPtr[localWriteIndex] = (uint16)(tempResVal >> IFX_ADC_CDSP_DSP_RES_CRESULTHI_OFF);           //Update higher 16 bit result in buffer
                localWriteIndex                  = ((localWriteIndex + 1u) >= bufferSize) ? 0u : (localWriteIndex + 1u); // Increment write index
                readIndex++;
            }
        }
        else /*DRM = 1: 16 bit read access. Upper part of the result register contains sign bit*/
        {
            while (readIndex < fillLevel)
            {
                /* Read result value in local variable */
                tempResVal                       = exmodSfr->RESM.U;
                resultbufferPtr[localWriteIndex] = (uint16)tempResVal;                                                   // Update lower 16 bit result value in buffer
                localWriteIndex                  = ((localWriteIndex + 1u) >= bufferSize) ? 0u : (localWriteIndex + 1u); // Increment write index
                readIndex++;
            }
        }

        /* Clear result event */
        IfxAdc_clearExmodResultEvent(channel->channelId);
    }

    /*Update the write pointer and valid results in handle*/
    channel->queue.writeIndex = localWriteIndex;
    channel->queue.bufferFull = localBufferFull;

    if (!localBufferFull)
    {
        channel->queue.validResult += readIndex;
    }
    else
    {
        channel->queue.validResult = bufferSize;
    }
}


IFX_STATIC uint16 IfxAdc_Dsadc_getNumberOfResults(void *channel, boolean hasAnalogMod)
{
    IfxAdc_Dsadc_Channel   *channelHandle    = NULL_PTR;
    IfxAdc_Dsadc_Exmod     *exmodHandle      = NULL_PTR;
    uint16                  validResult      = 0u;
    boolean                 localUseDma      = FALSE;
    IfxAdc_Dsadc_BufferType localBuffType    = IfxAdc_Dsadc_BufferType_linear;
    uint16                  localValidResult = 0u; //value read from handle

    if (hasAnalogMod)
    {
        channelHandle    = (IfxAdc_Dsadc_Channel *)channel;
        localUseDma      = channelHandle->queue.dma.useDma;
        localBuffType    = channelHandle->queue.bufferType;
        localValidResult = channelHandle->queue.validResult;
    }
    else
    {
        exmodHandle      = (IfxAdc_Dsadc_Exmod *)channel;
        localUseDma      = exmodHandle->queue.dma.useDma;
        localBuffType    = exmodHandle->queue.bufferType;
        localValidResult = exmodHandle->queue.validResult;
    }

    if (!localUseDma)
    {
        if (localBuffType == IfxAdc_Dsadc_BufferType_linearWithTimestamp)
        {
            // First value in buffer will be timestamp so subtracting valid results by 1
            validResult = (localValidResult - 1u);
        }
        else
        {
            validResult = localValidResult;
        }
    }
    else //DMA: Calculate valid results from DMA destination address
    {
        IfxAdc_Dsadc_updateHandleInfoFromDma(channel, hasAnalogMod);

        if (hasAnalogMod)
        {
            validResult = channelHandle->queue.validResult;
        }
        else
        {
            validResult = exmodHandle->queue.validResult;
        }
    }

    return validResult;
}


IFX_STATIC void IfxAdc_Dsadc_updateHandleInfoFromDma(void *channel, boolean hasAnalogMod)
{
    IfxAdc_Dsadc_Channel *channelHandle    = NULL_PTR;
    IfxAdc_Dsadc_Exmod   *exmodHandle      = NULL_PTR;
    uint16               *resultbufferPtr  = NULL_PTR;
    uint16                localReadIndex   = 0U;
    uint16                localWriteIndex  = 0U;
    uint16                localValidResult = 0U;
    uint16               *writePtr         = NULL_PTR;
    uint16                bufferSize       = 0U;
    boolean               bufferWrapStatus = FALSE;
    boolean               localBufferFull  = FALSE;
    Ifx_DMA              *dmaSfr           = NULL_PTR;
    IfxDma_ChannelId      dmaChannelId     = IfxDma_ChannelId_0;

    if (hasAnalogMod)
    {
        channelHandle    = (IfxAdc_Dsadc_Channel *)channel;
        localReadIndex   = channelHandle->queue.readIndex;
        resultbufferPtr  = (uint16 *)(channelHandle->queue.bufferPtr);
        writePtr         = (uint16 *)(channelHandle->queue.dma.channel.channel->DADR.U);
        bufferSize       = channelHandle->queue.size;
        bufferWrapStatus = channelHandle->queue.dma.channel.channel->CHCSR.B.WRPD;
        dmaSfr           = channelHandle->queue.dma.channel.dma;
        dmaChannelId     = channelHandle->queue.dma.channel.channelId;
    }
    else
    {
        exmodHandle      = (IfxAdc_Dsadc_Exmod *)channel;
        localReadIndex   = exmodHandle->queue.readIndex;
        resultbufferPtr  = (uint16 *)(exmodHandle->queue.bufferPtr);
        writePtr         = (uint16 *)(exmodHandle->queue.dma.channel.channel->DADR.U);
        bufferSize       = exmodHandle->queue.size;
        bufferWrapStatus = exmodHandle->queue.dma.channel.channel->CHCSR.B.WRPD;
        dmaSfr           = exmodHandle->queue.dma.channel.dma;
        dmaChannelId     = exmodHandle->queue.dma.channel.channelId;
    }

    localWriteIndex = (uint16)(writePtr - resultbufferPtr);

    /* Buffer empty : Read index same as write index and buffer not full*/
    if ((localReadIndex == localWriteIndex) && (!bufferWrapStatus))
    {
        localValidResult = 0u;
    }
    else if ((localReadIndex == localWriteIndex) && (bufferWrapStatus)) //Buffer full
    {
        localValidResult = bufferSize;                                  //buffer full
        localBufferFull  = TRUE;
    }
    else if ((localReadIndex < localWriteIndex) && (bufferWrapStatus))  //Buffer overflow. Update read Index
    {
        /* Buffer overflow. Updating the read index since the current read index will contain the new results */
        localValidResult = bufferSize;                                  //buffer full
        localBufferFull  = TRUE;
        localReadIndex   = localWriteIndex;
    }
    else if (localWriteIndex < localReadIndex)
    {
        localValidResult = (uint16)(bufferSize - localReadIndex + localWriteIndex);
    }
    else
    {
        localValidResult = (uint16)(localWriteIndex - localReadIndex);
    }

    /* Clear buffer warp status */
    if (bufferWrapStatus)
    {
        IfxDma_getAndClearChannelWrapDestinationBufferInterrupt(dmaSfr, dmaChannelId);
    }

    /*Update information in handle from DMA */
    if (hasAnalogMod)
    {
        channelHandle->queue.validResult = localValidResult;
        channelHandle->queue.writeIndex  = localWriteIndex;
        channelHandle->queue.readIndex   = localReadIndex;
        channelHandle->queue.bufferFull  = localBufferFull;
    }
    else
    {
        exmodHandle->queue.validResult = localValidResult;
        exmodHandle->queue.writeIndex  = localWriteIndex;
        exmodHandle->queue.readIndex   = localReadIndex;
        exmodHandle->queue.bufferFull  = localBufferFull;
    }
}
