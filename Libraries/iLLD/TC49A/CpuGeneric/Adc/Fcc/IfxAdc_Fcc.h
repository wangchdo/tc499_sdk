/**
 * \file IfxAdc_Fcc.h
 * \brief ADC FCC details
 * \ingroup IfxLld_Adc
 *
 * \version iLLD_2_0_1_2_19
 * \copyright Copyright (c) 2021 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 * Fast Compare channel interface for ADC
 *
 *  How to use (Brief expectation):
 *
 *  \defgroup IfxLld_Adc_Fcc_Usage How to use the FCC Interface driver?
 *  \ingroup IfxLld_Adc
 *
 *  Configuration of FCC module contains:
 *  1. modSfr        -->  Pointer to the SFR base address of FCC module.
 *  2. id            -->  FCC module id.
 *  3. mode          -->  FCC operating mode (normal/ramp)
 *  4. filterDepth   -->  Glitch filter Depth
 *  5. boundaryMode  -->  Boundary flag mode enable/disable
 *  6. initialTv     -->  Initial threshold value for DAC
 *  7. trigger       -->  Pointer to hardware trigger configuration
 *  8. boundaryConfig-->  Pointer to the boundary configuration
 *  9. rampConfig    -->  Pointer to the ramp configuration
 *  10. srvReqCfg    -->  Configuration structure for service request
 *
 *  Steps to use the driver:
 *
 *  \section IfxLld_Adc_Fcc_Preparation Preparation
 *  \subsection IfxLld_Adc_Fcc_Include Include Files
 *
 *  Include following header file into your C code:
 *  \code
 *   #include <Adc/Fcc/IfxAdc_Fcc.h>
 *  \endcode
 *
 *  \subsection IfxLld_Adc_Tmadc_Init Module Initialization
 *  \code
 *        // Declare a config structure of FCC configuration
 *        IfxAdc_Fcc_Config myConfig;
 *
 *        //Declare a handle structure of FCC channel.
 *        IfxAdc_Fcc fccHandle;
 *
 *        //Set the configuration to default values for the given fcc module id, using inbuilt default setting function.
 *        IfxAdc_FccModule moduelId0 = IfxAdc_FccModule_0;
 *        IfxAdc_Fcc_initModuleConfig(&myConfig, &MODULE_ADC);
 *
 *        //If you wish to use the generic optional functionalities (trigger, rampconfig), then declare objects of these types and initialize them.
 *        IfxAdc_Fcc_TriggerConfig myTrigger = {triggerSettings};
 *
 *        //Modify the configuration structure as per application need.
 *        myConfig.initialTv   = 0x200; //for illustration purpose only -- to set your own values.
 *        myConfig.filterDepth = 100;   //for illustration purpose only -- to set your own values.
 *
 *        //Now, initialize the FCC module with your configuration and handle structures.
 *        IfxAdc_Fcc_initModule(&fccHandle, &myConfig);
 *  \endcode
 *
 * \section IfxLld_Adc_Fcc_Result Comparison Result
 *  \code
 *
 *        //FCC DCR result can be read from standard layer APIs
 *        IfxAdc_getFccDcrResult(fccHandle->modSfr);
 * \endcode
 *
 * \section IfxLld_Adc_Fcc_Result Comparison Result
 *  \code
 *
 *        //In ramp mode , FCC ramp settings can be changed at runtime.
 *        IfxAdc_Fcc_RampModeConfig newrampConfig;
 *        //Configure new ramp values
 *        newrampConfig.rampDir   = IfxAdc_FccRampDirection_increment;
 *        IfxAdc_Fcc_configureRamp(&MODULE_ADC.FCC[moduelId0], &newrampConfig);
 *
 *       //Trigger FCC ramp
 *       IfxAdc_triggerFccRamp(&MODULE_ADC.FCC[moduelId0]);
 *
 * \endcode
 *
 * \defgroup IfxLld_Adc_Fcc FCC
 * \ingroup IfxLld_Adc
 * \defgroup IfxLld_Adc_Fcc_Enum Enumerations
 * \ingroup IfxLld_Adc_Fcc
 * \defgroup IfxLld_Adc_Fcc_DataStructures Data Structures
 * \ingroup IfxLld_Adc_Fcc
 * \defgroup IfxLld_Adc_Fcc_Fcc Fcc init and runtime functionality
 * \ingroup IfxLld_Adc_Fcc
 */

#ifndef IFXADC_FCC_H
#define IFXADC_FCC_H 1

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "Adc/Std/IfxAdc.h"

/******************************************************************************/
/*-----------------------------------Macros-----------------------------------*/
/******************************************************************************/

/** \brief MACRO to set the trigger configuration in the register
 */
#define IFXADC_FCC_WRITETRIGCFG(reg, delayCount, mode, trigSel)              \
    (reg.U = (uint32)((uint32)(delayCount << IFX_ADC_FCC_RMPTRCFG_TRD_OFF) | \
                      (uint32)(mode << IFX_ADC_FCC_RMPTRCFG_TRM_OFF) |       \
                      (uint32)(trigSel)))

/** \brief Maximum threshold value
 */
#define IFXADC_FCC_MAX_THRESHOLD_VALUE ((uint32)0x3FFu)

/** \brief Number of service request per FCC module
 */
#define IFXADC_FCC_MAX_SERV_REQ_NODE   (2u)

/******************************************************************************/
/*--------------------------------Enumerations--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Adc_Fcc_Enum
 * \{ */
/** \brief Enumeration describing various states of module
 */
typedef enum
{
    IfxAdc_Fcc_ModuleState_uninitialized = 0,  /**< \brief uninitialized state */
    IfxAdc_Fcc_ModuleState_initialized   = 1   /**< \brief initialized and enabled */
} IfxAdc_Fcc_ModuleState;

/** \} */

/******************************************************************************/
/*-----------------------------Data Structures--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Adc_Fcc_DataStructures
 * \{ */
/** \brief Hysteresis Configuration
 */
typedef struct
{
    uint16 deltaMinus;       /**< \brief Delta MInus */
    uint16 deltaPlus;        /**< \brief Delta Plus */
} IfxAdc_Fcc_HysteresisConfig;

/** \brief Data structure holding interrupt configuration
 */
typedef struct
{
    Ifx_Priority priority;            /**< \brief Interrupt priority */
    IfxSrc_Tos   typeOfService;       /**< \brief type of interrupt service */
    IfxSrc_VmId  vmId;                /**< \brief Virtual Machine Number */
} IfxAdc_Fcc_InterruptConfig;

/** \brief Hardware Trigger Configuration
 */
typedef struct
{
    IfxAdc_FccTriggerSel  trigSel;          /**< \brief Selection value for trigger */
    IfxAdc_FccTriggerMode edgeSel;          /**< \brief Edge selection for trigger */
    uint16                delayCount;       /**< \brief Trigger delay count */
} IfxAdc_Fcc_Trigger;

/** \} */

/** \addtogroup IfxLld_Adc_Fcc_DataStructures
 * \{ */
/** \brief Boundary Configuration
 */
typedef struct
{
    IfxAdc_Fcc_HysteresisConfig *hystconfig;                 /**< \brief Pointer to the hysteresis configuration */
    IfxAdc_FccGatePolarity       polarity;                   /**< \brief Gated boundary flag polarity */
    IfxAdc_FccBoundaryFlag       activateBoundaryFlag;       /**< \brief Boundary flag activation condition */
    boolean                      selectBoundaryFlag;         /**< \brief True --> Software BFL, False --> Hardware BFL */
    boolean                      swBoundaryFlagValue;        /**< \brief True --> Set BFL, False --> Clear BFL */
    boolean                      enableboundary;             /**< \brief True --> Boundary flag mode enable */
} IfxAdc_Fcc_BoundaryConfig;

/** \brief Pin configuration structure
 */
typedef struct
{
    IFX_CONST IfxAdc_Fcc_In  *fccPin;          /**< \brief Fcc analog input pin configuration */
    IfxPort_InputMode         fccinMode;       /**< \brief Fcc pin input mode which should be configured */
    IFX_CONST IfxAdc_Bfl_Out *bflPin;          /**< \brief Boundary flag output pin configuration */
    IfxPort_OutputMode        bflMode;         /**< \brief Bfl output pin mode configuration */
    IfxPort_PadDriver         padDriver;       /**< \brief Pad Driver Configuration */
} IfxAdc_Fcc_PinsConfig;

/** \brief Ramp mode Configuration
 */
typedef struct
{
    uint16                  stepWidth;       /**< \brief Step width for reference value */
    uint16                  stepSize;        /**< \brief Step size for reference value */
    uint16                  startTV;         /**< \brief Start Threshold value */
    uint16                  endTV;           /**< \brief End Threshold value */
    IfxAdc_FccRampDirection rampDir;         /**< \brief Ramp direction */
} IfxAdc_Fcc_RampModeConfig;

/** \brief Structure for Service Request configuration
 */
typedef struct
{
    IfxAdc_Fcc_InterruptConfig intCfg[IFXADC_FCC_MAX_SERV_REQ_NODE];       /**< \brief Interrupt configuration */
    IfxAdc_FccSr0EventSel      event0Sel;                                  /**< \brief Service request event 0 selection */
    IfxAdc_FccSr1EventSel      event1Sel;                                  /**< \brief Service request event 1 selection */
} IfxAdc_Fcc_ServiceReqConfig;

/** \brief Trigger Configuration
 */
typedef struct
{
    IfxAdc_Fcc_Trigger *rampTrigger;            /**< \brief Ramp trigger configuration */
    IfxAdc_Fcc_Trigger *gatedTrigger;           /**< \brief gated trigger configuration */
    IfxAdc_Fcc_Trigger *thresholdTrigger;       /**< \brief Threshold trigger configuration */
} IfxAdc_Fcc_TriggerConfig;

/** \} */

/** \addtogroup IfxLld_Adc_Fcc_DataStructures
 * \{ */
/** \brief Handle of FCC module
 */
typedef struct
{
    Ifx_ADC_FCC           *modSfr;       /**< \brief pointer to the module SFR set */
    IfxAdc_FccModule       id;           /**< \brief module ID */
    IfxAdc_Fcc_ModuleState state;        /**< \brief State of module */
} IfxAdc_Fcc;

/** \brief Data Structure holding the configuration of FCC module
 */
typedef struct
{
    Ifx_ADC                         *adcSfr;            /**< \brief pointer to the ADC module SFR set */
    IfxAdc_FccModule                 id;                /**< \brief module ID */
    IfxAdc_FccMode                   mode;              /**< \brief Fcc operating mode */
    uint8                            filterDepth;       /**< \brief Glitch filter depth value */
    uint16                           initialTv;         /**< \brief Fcc initial threshold value */
    IfxAdc_Fcc_TriggerConfig        *trigger;           /**< \brief Pointer to the trigger configuration */
    IfxAdc_Fcc_BoundaryConfig       *boundaryCfg;       /**< \brief Pointer to the Boundary configuration */
    IfxAdc_Fcc_RampModeConfig       *rampCfg;           /**< \brief Pointer to ramp mode Configuration */
    IFX_CONST IfxAdc_Fcc_PinsConfig *pins;              /**< \brief Pins Configuration structure */
    IfxAdc_Fcc_ServiceReqConfig      srvReqCfg;         /**< \brief Configuration structure for interrupt */
} IfxAdc_Fcc_Config;

/** \} */

/** \addtogroup IfxLld_Adc_Fcc_Fcc
 * \{ */

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Function to the initialize the Fcc module
 * \param fcc Fcc pointer to the module handle
 * \param config configuration of module
 * \return None
 */
IFX_EXTERN void IfxAdc_Fcc_initModule(IfxAdc_Fcc *fcc, const IfxAdc_Fcc_Config *config);

/** \brief Function to initialize module configuration to default
 * \param config configuration of module
 * \param adc Pointer to ADC module sfr
 * \return None
 */
IFX_EXTERN void IfxAdc_Fcc_initModuleConfig(IfxAdc_Fcc_Config *config, Ifx_ADC *adc);

/** \brief Function to update ramp configuration. (STV,ETV,STEPWD,STEPSZ,DIR)
 * \param fcc Pointer to Fcc module sfr
 * \param rampConfig Ramp configuration
 * \return None
 */
IFX_EXTERN void IfxAdc_Fcc_configureRamp(Ifx_ADC_FCC *fcc, IfxAdc_Fcc_RampModeConfig *rampConfig);

/** \} */

#endif /* IFXADC_FCC_H */
