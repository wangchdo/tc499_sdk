/**
 * \file IfxAdc.h
 * \brief ADC  basic functionality
 * \ingroup IfxLld_Adc
 *
 * \version iLLD_2_0_1_2_19
 * \copyright Copyright (c) 2023 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 * STD layer for ADC functionality
 *
 * PROT usage of ADC
 *
 *  Steps:
 *  Declare a global
 *  IfxAdc_ApConfig apConfig
 *
 *  Initialize the IfxAdc_ApConfig structure with default values
 *  IfxAdc_initApConfig(&apConfig)
 *  Modify the PROTE, PROTSE and APU configuration as per the need.
 *
 *  Initialize PROTSE
 *  IfxAdc_initProtSE(&MODULE_ADC, &apConfig.protseConfig)
 *
 *  Initialize the PROTE
 *  IfxAdc_initProtE(&MODULE_ADC, &apConfig.proteConfig, IfxAdc_ProtE_0)
 *
 *  Change the APU assignment for ADC resources if needed, by default it is
 *  assigned to APU0.
 *  Assign Global resources of ADC,DSADC,EXMOD and CDSP to APU0-15
 *  IfxAdc_initGlobalResource(&MODULE_ADC, IfxAdc_GlobalResource_adc, IfxAdc_Apu_1)
 *  IfxAdc_initTmadcResource(&MODULE_ADC, IfxAdc_TmadcModule_0, IfxAdc_Apu_1)
 *  IfxAdc_initFccResource(&MODULE_ADC, IfxAdc_FccModule_0, IfxAdc_Apu_1)
 *  IfxAdc_initDsadcResource(&MODULE_ADC, IfxAdc_DsadcChannel_0, IfxAdc_Apu_1)
 *  IfxAdc_initExmodResource(&MODULE_ADC, IfxAdc_Exmod_0, IfxAdc_Apu_1)
 *  IfxAdc_initCdspResource(&MODULE_ADC, IfxAdc_CdspCore_0, IfxAdc_Apu_1)
 *
 *  Initialize the APU to enable Read and write access for master tag id.
 *  IfxAdc_initApu(&MODULE_ADC, &apConfig.apuConfig , IfxAdc_Apu_0)
 *
 * \defgroup IfxLld_Adc_Std_Enum Enumerations
 * \ingroup IfxLld_Adc_Std
 * \defgroup IfxLld_Adc_Std_Dsadc_Enum Dsadc Enumerations
 * \ingroup IfxLld_Adc_Std
 * \defgroup IfxLld_Adc_Std_Tmadc_Enum Tmadc_Enumerations
 * \ingroup IfxLld_Adc_Std
 * \defgroup IfxLld_Adc_Std_Fcc_Enum Fcc Enumerations
 * \ingroup IfxLld_Adc_Std
 * \defgroup IfxLld_Adc_Std_Cdsp_Enum Cdsp Enumerations
 * \ingroup IfxLld_Adc_Std
 * \defgroup IfxLld_Adc_Std_Data_Structures Data Structures
 * \ingroup IfxLld_Adc_Std
 * \defgroup IfxLld_Adc_Std_Module_Adc Adc Functionality
 * \ingroup IfxLld_Adc_Std
 * \defgroup IfxLld_Adc_Std_Tmadc Tmadc Functions
 * \ingroup IfxLld_Adc_Std
 * \defgroup IfxLld_Adc_Std_Fcc Fcc functions
 * \ingroup IfxLld_Adc_Std
 * \defgroup IfxLld_Adc_Std_Dsadc Dsadc Functions
 * \ingroup IfxLld_Adc_Std
 * \defgroup IfxLld_Adc_Std_Prot_Apu Prot and Apu functions
 * \ingroup IfxLld_Adc_Std
 * \defgroup IfxLld_Adc_Std_Cdsp cdsp Functions
 * \ingroup IfxLld_Adc_Std
 */

#ifndef IFXADC_H
#define IFXADC_H 1

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "_Impl/IfxAdc_cfg.h"
#include "_PinMap/IfxAdc_PinMap.h"
#include "Cpu/Std/IfxCpu_Intrinsics.h"
#include "IfxAdc_reg.h"
#include "IfxAdc_bf.h"
#include "Src/Std/IfxSrc.h"
#include "Ap/Std/IfxApApu.h"
#include "Ap/Std/IfxApProt.h"
#include "_Utilities/Ifx_Assert.h"

/******************************************************************************/
/*-----------------------------------Macros-----------------------------------*/
/******************************************************************************/

/** \brief macro to determine if startup calibration for TMADC is required or not.
 */
#ifndef IFXADC_TMADC_ENABLE_STARTUPCAL
#define IFXADC_TMADC_ENABLE_STARTUPCAL (0)
#endif

/** \brief MACRO to set the trigger configuration in the register
 */
#define IFXADC_WRITETRIGCFG(reg, delayCount, mode, trigSel) \
    (reg.U = (uint32)((uint32)(delayCount << 16u) |         \
                      (uint32)(mode << 6u) |                \
                      (uint32)(trigSel)))

/** \brief MACRO to set the APU assignment in the resource allocation register
 */
#define IFXADC_SETRESALLOCCFG(reg, resourceId, apuId)                                    \
    (reg.U = (uint32)((reg.U & ~(IFX_ADC_RESALLOC_GLOB_GLOB_MSK << (resourceId * 4u))) | \
                      (uint32)(apuId << (resourceId * 4u))))

/** \brief Macro for monitor channel offset
 */
#define IFXADC_TMADC_MCH_OFFSET (16U)

/******************************************************************************/
/*--------------------------------Enumerations--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Adc_Std_Enum
 * \{ */
/** \brief Enumeration for Access Protection unit
 */
typedef enum
{
    IfxAdc_Apu_0,     /**< \brief APU  0  */
    IfxAdc_Apu_1,     /**< \brief APU  1  */
    IfxAdc_Apu_2,     /**< \brief APU  2  */
    IfxAdc_Apu_3,     /**< \brief APU  3  */
    IfxAdc_Apu_4,     /**< \brief APU  4  */
    IfxAdc_Apu_5,     /**< \brief APU  5  */
    IfxAdc_Apu_6,     /**< \brief APU  6  */
    IfxAdc_Apu_7,     /**< \brief APU  7  */
    IfxAdc_Apu_8,     /**< \brief APU  8  */
    IfxAdc_Apu_9,     /**< \brief APU  9  */
    IfxAdc_Apu_10,    /**< \brief APU  10  */
    IfxAdc_Apu_11,    /**< \brief APU  11  */
    IfxAdc_Apu_12,    /**< \brief APU  12  */
    IfxAdc_Apu_13,    /**< \brief APU  13  */
    IfxAdc_Apu_14,    /**< \brief APU  14  */
    IfxAdc_Apu_15     /**< \brief APU  15  */
} IfxAdc_Apu;

/** \brief Enumeration for Global resources of ADC, DSADC and CDSP
 */
typedef enum
{
    IfxAdc_GlobalResource_adc,    /**< \brief ADC Global */
    IfxAdc_GlobalResource_dsadc,  /**< \brief Global parts of Dsadc and Exmod */
    IfxAdc_GlobalResource_cdsp    /**< \brief Global parts of Cdsp */
} IfxAdc_GlobalResource;

/** \brief Enumeration for PROTE
 */
typedef enum
{
    IfxAdc_ProtE_0,     /**< \brief PROTE  0  */
    IfxAdc_ProtE_1,     /**< \brief PROTE  1  */
    IfxAdc_ProtE_2,     /**< \brief PROTE  2  */
    IfxAdc_ProtE_3,     /**< \brief PROTE  3  */
    IfxAdc_ProtE_4,     /**< \brief PROTE  4  */
    IfxAdc_ProtE_5,     /**< \brief PROTE  5  */
    IfxAdc_ProtE_6,     /**< \brief PROTE  6  */
    IfxAdc_ProtE_7,     /**< \brief PROTE  7  */
    IfxAdc_ProtE_8,     /**< \brief PROTE  8  */
    IfxAdc_ProtE_9,     /**< \brief PROTE  9  */
    IfxAdc_ProtE_10,    /**< \brief PROTE  10  */
    IfxAdc_ProtE_11,    /**< \brief PROTE  11  */
    IfxAdc_ProtE_12,    /**< \brief PROTE  12  */
    IfxAdc_ProtE_13,    /**< \brief PROTE  13  */
    IfxAdc_ProtE_14,    /**< \brief PROTE  14  */
    IfxAdc_ProtE_15     /**< \brief PROTE  15  */
} IfxAdc_ProtE;

/** \brief Enumeration describing the status of an operation
 */
typedef enum
{
    IfxAdc_Status_success = 0,  /**< \brief operation successful */
    IfxAdc_Status_failure = 1   /**< \brief operation failed */
} IfxAdc_Status;

/** \} */

/** \addtogroup IfxLld_Adc_Std_Dsadc_Enum
 * \{ */
/** \brief Auxiliary CIC filter decimation factor (DSADCx/EXMODx_CICCFG.CFADF)
 */
typedef enum
{
    IfxAdc_DsadcAuxCicDecFactor_16,     /**< \brief Oversampling rate 16  */
    IfxAdc_DsadcAuxCicDecFactor_32,     /**< \brief Oversampling rate 32  */
    IfxAdc_DsadcAuxCicDecFactor_64,     /**< \brief Oversampling rate 64  */
    IfxAdc_DsadcAuxCicDecFactor_128     /**< \brief Oversampling rate 128  */
} IfxAdc_DsadcAuxCicDecFactor;

/** \brief Enumeration describing the mode of comparison for boundary check of DSADC
 */
typedef enum
{
    IfxAdc_DsadcBoundaryCmpMode_disable    = 0,  /**< \brief Boundary mode disable */
    IfxAdc_DsadcBoundaryCmpMode_upperBound = 1,  /**< \brief Boundary Flag is high when result exceeds upper limit */
    IfxAdc_DsadcBoundaryCmpMode_lowerBound = 2,  /**< \brief Boundary Flag is high when result is lower than lower limit */
    IfxAdc_DsadcBoundaryCmpMode_bothBound  = 3   /**< \brief Boudary Flag is high when result is out of the band */
} IfxAdc_DsadcBoundaryCmpMode;

/** \brief Enumeration for Boundary service request (BNDCFG.SR2CFG)
 */
typedef enum
{
    IfxAdc_DsadcBoundaryServReq_insideBoundary  = 0, /**< \brief Generate service request when result inside boundary band */
    IfxAdc_DsadcBoundaryServReq_outsideBoundary = 1  /**< \brief Generate service request when result outside boundary band */
} IfxAdc_DsadcBoundaryServReq;

/** \brief Enumeration for Dsadc calibration status
 */
typedef enum
{
    IfxAdc_DsadcCalibrationState_uncalibrated          = 0, /**< \brief Uncalibrated initial state after reset */
    IfxAdc_DsadcCalibrationState_running               = 1, /**< \brief Calibration algorithm is currently running */
    IfxAdc_DsadcCalibrationState_calibrated            = 2, /**< \brief Calibrated, normal operation is possible */
    IfxAdc_DsadcCalibrationState_terminatedIncorrectly = 3  /**< \brief Calibration terminated incorrectly */
} IfxAdc_DsadcCalibrationState;

/** \brief Enumeration describing Division factor for PWM signal generator
 */
typedef enum
{
    IfxAdc_DsadcCarrierSignalDivFactor_cgp2,   /**< \brief Carrier signal generator freq fcg = fadc/2 */
    IfxAdc_DsadcCarrierSignalDivFactor_cgp4,   /**< \brief Carrier signal generator freq fcg = fadc/4  */
    IfxAdc_DsadcCarrierSignalDivFactor_cgp6,   /**< \brief Carrier signal generator freq fcg = fadc/6  */
    IfxAdc_DsadcCarrierSignalDivFactor_cgp8,   /**< \brief Carrier signal generator freq fcg = fadc/8  */
    IfxAdc_DsadcCarrierSignalDivFactor_cgp10,  /**< \brief Carrier signal generator freq fcg = fadc/10  */
    IfxAdc_DsadcCarrierSignalDivFactor_cgp12,  /**< \brief Carrier signal generator freq fcg = fadc/12  */
    IfxAdc_DsadcCarrierSignalDivFactor_cgp14,  /**< \brief Carrier signal generator freq fcg = fadc/14  */
    IfxAdc_DsadcCarrierSignalDivFactor_cgp16,  /**< \brief Carrier signal generator freq fcg = fadc/16  */
    IfxAdc_DsadcCarrierSignalDivFactor_cgp18,  /**< \brief Carrier signal generator freq fcg = fadc/18  */
    IfxAdc_DsadcCarrierSignalDivFactor_cgp20,  /**< \brief Carrier signal generator freq fcg = fadc/20  */
    IfxAdc_DsadcCarrierSignalDivFactor_cgp22,  /**< \brief Carrier signal generator freq fcg = fadc/22  */
    IfxAdc_DsadcCarrierSignalDivFactor_cgp24,  /**< \brief Carrier signal generator freq fcg = fadc/24  */
    IfxAdc_DsadcCarrierSignalDivFactor_cgp26,  /**< \brief Carrier signal generator freq fcg = fadc/26  */
    IfxAdc_DsadcCarrierSignalDivFactor_cgp28,  /**< \brief Carrier signal generator freq fcg = fadc/28  */
    IfxAdc_DsadcCarrierSignalDivFactor_cgp30,  /**< \brief Carrier signal generator freq fcg = fadc/30  */
    IfxAdc_DsadcCarrierSignalDivFactor_cgp32   /**< \brief Carrier signal generator freq fcg = fadc/32  */
} IfxAdc_DsadcCarrierSignalDivFactor;

/** \brief Enumeration describing Carrier Signal Polarity
 */
typedef enum
{
    IfxAdc_DsadcCarrierSignalPol_normal   = 0, /**< \brief Carrier signal begins with +1 */
    IfxAdc_DsadcCarrierSignalPol_inverted = 1  /**< \brief Carrier signal begins with -1 */
} IfxAdc_DsadcCarrierSignalPol;

/** \brief Enumeration describing Carrier generation mode (DSADC_CGCFG.CGMOD)
 */
typedef enum
{
    IfxAdc_DsadcCgOperatingMode_stopped      = 0,  /**< \brief Stop Carrier generator */
    IfxAdc_DsadcCgOperatingMode_squareWave   = 1,  /**< \brief Generate  square wave */
    IfxAdc_DsadcCgOperatingMode_triangleWave = 2,  /**< \brief Generate triangle wave */
    IfxAdc_DsadcCgOperatingMode_cosineWave   = 3   /**< \brief Generate cosine wave */
} IfxAdc_DsadcCgOperatingMode;

/** \brief Decimation Rate of the CIC Filter During Calibration
 */
typedef enum
{
    IfxAdc_DsadcCicDecimationRate_128,  /**< \brief CIC decimation of 128 during calibration */
    IfxAdc_DsadcCicDecimationRate_256   /**< \brief CIC decimation of 256 during calibration */
} IfxAdc_DsadcCicDecimationRate;

/** \brief Data shift window of CIC filter (DSADCx/EXMODx_GAINCORR.CICSHIFT)
 */
typedef enum
{
    IfxAdc_DsadcCicShift_0to16,     /**< \brief Use Bits 0 to 16  */
    IfxAdc_DsadcCicShift_1to17,     /**< \brief Use Bits 1 to 17  */
    IfxAdc_DsadcCicShift_2to18,     /**< \brief Use Bits 2 to 18  */
    IfxAdc_DsadcCicShift_3to19,     /**< \brief Use Bits 3 to 19  */
    IfxAdc_DsadcCicShift_4to20,     /**< \brief Use Bits 4 to 20  */
    IfxAdc_DsadcCicShift_5to21,     /**< \brief Use Bits 5 to 21  */
    IfxAdc_DsadcCicShift_6to22,     /**< \brief Use Bits 6 to 22  */
    IfxAdc_DsadcCicShift_7to23,     /**< \brief Use Bits 7 to 23  */
    IfxAdc_DsadcCicShift_8to24,     /**< \brief Use Bits 8 to 24  */
    IfxAdc_DsadcCicShift_9to25,     /**< \brief Use Bits 9 to 25  */
    IfxAdc_DsadcCicShift_10to26,    /**< \brief Use Bits 10 to 26  */
    IfxAdc_DsadcCicShift_11to27,    /**< \brief Use Bits 11 to 27  */
    IfxAdc_DsadcCicShift_12to28,    /**< \brief Use Bits 12 to 28  */
    IfxAdc_DsadcCicShift_13to29,    /**< \brief Use Bits 13 to 29  */
    IfxAdc_DsadcCicShift_14to30,    /**< \brief Use Bits 14 to 30  */
    IfxAdc_DsadcCicShift_15to31,    /**< \brief Use Bits 15 to 31  */
    IfxAdc_DsadcCicShift_16to32,    /**< \brief Use Bits 16 to 32  */
    IfxAdc_DsadcCicShift_17to33,    /**< \brief Use Bits 17 to 33  */
    IfxAdc_DsadcCicShift_18to34,    /**< \brief Use Bits 18 to 34  */
    IfxAdc_DsadcCicShift_19to35,    /**< \brief Use Bits 19 to 35  */
    IfxAdc_DsadcCicShift_20to36,    /**< \brief Use Bits 20 to 36  */
    IfxAdc_DsadcCicShift_21to37,    /**< \brief Use Bits 21 to 37  */
    IfxAdc_DsadcCicShift_22to38,    /**< \brief Use Bits 22 to 38  */
    IfxAdc_DsadcCicShift_23to39,    /**< \brief Use Bits 23 to 39  */
    IfxAdc_DsadcCicShift_24to40,    /**< \brief Use Bits 24 to 40  */
    IfxAdc_DsadcCicShift_25to41,    /**< \brief Use Bits 25 to 41  */
    IfxAdc_DsadcCicShift_26to42,    /**< \brief Use Bits 26 to 42  */
    IfxAdc_DsadcCicShift_27to43,    /**< \brief Use Bits 27 to 43  */
    IfxAdc_DsadcCicShift_28to44     /**< \brief Use Bits 28 to 44  */
} IfxAdc_DsadcCicShift;

/** \brief Configuration of Data Read width (DSADCx/EXMODx_CHCFG.DRM)
 */
typedef enum
{
    IfxAdc_DsadcDataReadWidth_16Bit = 0,  /**< \brief 16 BIt */
    IfxAdc_DsadcDataReadWidth_32Bit = 2   /**< \brief 32 Bit */
} IfxAdc_DsadcDataReadWidth;

/** \brief Dither Trim Level (DSADCx_CHCFG.DITRIM)
 */
typedef enum
{
    IfxAdc_DsadcDitherTrim_disabled = -1,  /**< \brief Dither is Disabled */
    IfxAdc_DsadcDitherTrim_level0,         /**< \brief Dither level0  */
    IfxAdc_DsadcDitherTrim_level1,         /**< \brief Dither level1  */
    IfxAdc_DsadcDitherTrim_level2,         /**< \brief Dither level2  */
    IfxAdc_DsadcDitherTrim_level3          /**< \brief Dither level3  */
} IfxAdc_DsadcDitherTrim;

/** \brief FIFO fill level for service request generation
 */
typedef enum
{
    IfxAdc_DsadcFifoSrLevel_1,     /**< \brief SRLVL 1  */
    IfxAdc_DsadcFifoSrLevel_2,     /**< \brief SRLVL 2  */
    IfxAdc_DsadcFifoSrLevel_3,     /**< \brief SRLVL 3  */
    IfxAdc_DsadcFifoSrLevel_4      /**< \brief SRLVL 4  */
} IfxAdc_DsadcFifoSrLevel;

/** \brief Input configuration of analog modulator pins (DSADCx_CHCFG.INCFGP,N)
 */
typedef enum
{
    IfxAdc_DsadcInCfg_inputPin = 0,  /**< \brief Input Pin */
    IfxAdc_DsadcInCfg_vref     = 1,  /**< \brief Reference voltage Varef */
    IfxAdc_DsadcInCfg_vddmBy2  = 2,  /**< \brief Vddm/2 */
    IfxAdc_DsadcInCfg_ground   = 3   /**< \brief Reference Ground Varef */
} IfxAdc_DsadcInCfg;

/** \brief Input MUX selection for DSADC channel
 */
typedef enum
{
    IfxAdc_DsadcInSel_a = 0,  /**< \brief Input pin position A */
    IfxAdc_DsadcInSel_b = 1,  /**< \brief Input pin position B */
    IfxAdc_DsadcInSel_c = 2,  /**< \brief Input pin position C */
    IfxAdc_DsadcInSel_d = 3   /**< \brief Input pin position D */
} IfxAdc_DsadcInSel;

/** \brief DSADCx_CHCFG.INMAC setting
 */
typedef enum
{
    IfxAdc_DsadcInputMuxActCtrl_preset     = 0, /**< \brief preset by SW, update by trigger */
    IfxAdc_DsadcInputMuxActCtrl_singleStep = 1  /**< \brief Decrement upon Trigger */
} IfxAdc_DsadcInputMuxActCtrl;

/** \brief Select the bits to be accumulated in Integrator [INTCFG.ISC]
 */
typedef enum
{
    IfxAdc_DsadcIntegratorShift_bits4To20,   /**< \brief Select bits 4 to 20  */
    IfxAdc_DsadcIntegratorShift_bits5To21,   /**< \brief Select bits 5 to 21  */
    IfxAdc_DsadcIntegratorShift_bits6To22,   /**< \brief Select bits 6 to 22  */
    IfxAdc_DsadcIntegratorShift_bits7To23,   /**< \brief Select bits 7 to 23  */
    IfxAdc_DsadcIntegratorShift_bits8To24,   /**< \brief Select bits 8 to 24  */
    IfxAdc_DsadcIntegratorShift_bits9To25,   /**< \brief Select bits 9 to 25  */
    IfxAdc_DsadcIntegratorShift_bits10To26   /**< \brief Select bits 10 to 26 */
} IfxAdc_DsadcIntegratorShift;

/** \brief Integration Window Size [INTCFG.IWS]
 */
typedef enum
{
    IfxAdc_DsadcIntegratorWindowCtrl_internal = 0,  /**< \brief Internal control: stop integrator after REPVAL+1 integration cycles */
    IfxAdc_DsadcIntegratorWindowCtrl_external = 1,  /**< \brief External control: stop integrator upon the inverse trigger event */
    IfxAdc_DsadcIntegratorWindowCtrl_software = 2   /**< \brief Software control: Stop integrator when INTEN = 0 or INTTRM = 00 */
} IfxAdc_DsadcIntegratorWindowCtrl;

/** \brief Enumeration holding possible values of DSADCx_CHCCFG.DIVM
 */
typedef enum
{
    IfxAdc_DsadcModulatorFreq_40MHz = 0,  /**< \brief 160/4 = 40MHz */
    IfxAdc_DsadcModulatorFreq_20MHz = 1,  /**< \brief 160/8 = 20MHz */
    IfxAdc_DsadcModulatorFreq_10MHz = 2   /**< \brief 160/16 = 10MHz */
} IfxAdc_DsadcModulatorFreq;

/** \brief Cutoff frequency Rate of High pass filter in Offset compensation block
 */
typedef enum
{
    IfxAdc_DsadcOffCompFilter_disabled,      /**< \brief High pass Filter disabled */
    IfxAdc_DsadcOffCompFilter_cutoffRate1,   /**< \brief High pass filter cutoff Freq Rate 1  */
    IfxAdc_DsadcOffCompFilter_cutoffRate2,   /**< \brief High pass filter cutoff Freq Rate 2  */
    IfxAdc_DsadcOffCompFilter_cutoffRate3,   /**< \brief High pass filter cutoff Freq Rate 3  */
    IfxAdc_DsadcOffCompFilter_cutoffRate4,   /**< \brief High pass filter cutoff Freq Rate 4  */
    IfxAdc_DsadcOffCompFilter_cutoffRate5,   /**< \brief High pass filter cutoff Freq Rate 5  */
    IfxAdc_DsadcOffCompFilter_cutoffRate6,   /**< \brief High pass filter cutoff Freq Rate 6  */
    IfxAdc_DsadcOffCompFilter_cutoffRate7    /**< \brief High pass filter cutoff Freq Rate 7  */
} IfxAdc_DsadcOffCompFilter;

/** \brief Enumeration describing PWM generation
 */
typedef enum
{
    IfxAdc_DsadcPwmGeneration_normal     = 0, /**< \brief PWM generation normal */
    IfxAdc_DsadcPwmGeneration_bitReverse = 1  /**< \brief PWM generation bit reverse mode */
} IfxAdc_DsadcPwmGeneration;

/** \brief Enumeration describing selection of sign signal
 */
typedef enum
{
    IfxAdc_DsadcRectifierSignSource_onchip          = 0,  /**< \brief On-chip carrier generator */
    IfxAdc_DsadcRectifierSignSource_selectedchannel = 1,  /**< \brief Channel selected by bitfield SSCH */
    IfxAdc_DsadcRectifierSignSource_extsignalA      = 2,  /**< \brief External sign signal A */
    IfxAdc_DsadcRectifierSignSource_extsignalB      = 3   /**< \brief External sign signal B */
} IfxAdc_DsadcRectifierSignSource;

/** \brief DSADC service request 0 configuration
 */
typedef enum
{
    IfxAdc_DsadcSrvReq0_never,     /**< \brief Never raise Service Request */
    IfxAdc_DsadcSrvReq0_gateHigh,  /**< \brief Raise when gate HIGH */
    IfxAdc_DsadcSrvReq0_gateLow,   /**< \brief raise when gate LOW */
    IfxAdc_DsadcSrvReq0_always     /**< \brief raise always */
} IfxAdc_DsadcSrvReq0;

/** \brief DSADC service request 3 configuration
 */
typedef enum
{
    IfxAdc_DsadcSrvReq3_never,     /**< \brief Never raise Service Request */
    IfxAdc_DsadcSrvReq3_cgSync,    /**< \brief Raise for CGSYNC event */
    IfxAdc_DsadcSrvReq3_timestamp  /**< \brief raise for timestamp event */
} IfxAdc_DsadcSrvReq3;

/** \brief Enumeration describing Dsadc module supply level
 */
typedef enum
{
    IfxAdc_DsadcSupplyLevel_between3_7V_And_5_5V = 0,  /**< \brief VDDM supply 3.7V <= VDDM < = 5.5V */
    IfxAdc_DsadcSupplyLevel_lessThan3_7          = 1   /**< \brief VDDM < 3.7V */
} IfxAdc_DsadcSupplyLevel;

/** \brief Enumeration describing selection of supervisor signal from channels
 */
typedef enum
{
    IfxAdc_DsadcSvSigSel_none              = 0,  /**< \brief No supervision signal */
    IfxAdc_DsadcSvSigSel_internalRegulator = 1,  /**< \brief Internal Regulator 2.4V/1.8V */
    IfxAdc_DsadcSvSigSel_analogGround      = 2,  /**< \brief Analog Ground */
    IfxAdc_DsadcSvSigSel_internalBias      = 3   /**< \brief Internal Bias of Integrator */
} IfxAdc_DsadcSvSigSel;

/** \brief Enumeration holding timestamp counter clock selection.(CHCFG.TSCLK)
 */
typedef enum
{
    IfxAdc_DsadcTimestampClock_fmod     = 0,  /**< \brief Counter clocked with modulator clock fmod */
    IfxAdc_DsadcTimestampClock_fmoddiv2 = 1,  /**< \brief Counter clocked with fmod/2 */
    IfxAdc_DsadcTimestampClock_fmoddiv4 = 2,  /**< \brief Counter clocked with fmod/4 */
    IfxAdc_DsadcTimestampClock_fmoddiv8 = 3   /**< \brief Counter clocked with fmod/8 */
} IfxAdc_DsadcTimestampClock;

/** \brief Trigger mode of DSADC /EXMOD Triggers
 */
typedef enum
{
    IfxAdc_DsadcTriggerMode_none,         /**< \brief No Trigger */
    IfxAdc_DsadcTriggerMode_risingEdge,   /**< \brief Rising Edge */
    IfxAdc_DsadcTriggerMode_fallingEdge,  /**< \brief Falling edge */
    IfxAdc_DsadcTriggerMode_bothEdge      /**< \brief Both Edge trigger */
} IfxAdc_DsadcTriggerMode;

/** \brief Enumeration holding Hardware Trigger mux selection
 */
typedef enum
{
    IfxAdc_DsadcTriggerSel_0 = 0,  /**< \brief trigger mux selection 0 */
    IfxAdc_DsadcTriggerSel_1,      /**< \brief trigger mux selection 1 */
    IfxAdc_DsadcTriggerSel_2,      /**< \brief trigger mux selection 2 */
    IfxAdc_DsadcTriggerSel_3,      /**< \brief trigger mux selection 3 */
    IfxAdc_DsadcTriggerSel_4,      /**< \brief trigger mux selection 4 */
    IfxAdc_DsadcTriggerSel_5,      /**< \brief trigger mux selection 5 */
    IfxAdc_DsadcTriggerSel_6,      /**< \brief trigger mux selection 6 */
    IfxAdc_DsadcTriggerSel_7,      /**< \brief trigger mux selection 7 */
    IfxAdc_DsadcTriggerSel_8,      /**< \brief trigger mux selection 8 */
    IfxAdc_DsadcTriggerSel_9,      /**< \brief trigger mux selection 9 */
    IfxAdc_DsadcTriggerSel_10,     /**< \brief trigger mux selection 10 */
    IfxAdc_DsadcTriggerSel_11,     /**< \brief trigger mux selection 11 */
    IfxAdc_DsadcTriggerSel_12,     /**< \brief trigger mux selection 12 */
    IfxAdc_DsadcTriggerSel_13,     /**< \brief trigger mux selection 13 */
    IfxAdc_DsadcTriggerSel_14,     /**< \brief trigger mux selection 14 */
    IfxAdc_DsadcTriggerSel_15,     /**< \brief trigger mux selection 15 */
    IfxAdc_DsadcTriggerSel_16,     /**< \brief trigger mux selection 16 */
    IfxAdc_DsadcTriggerSel_17,     /**< \brief trigger mux selection 17 */
    IfxAdc_DsadcTriggerSel_18,     /**< \brief trigger mux selection 18 */
    IfxAdc_DsadcTriggerSel_19,     /**< \brief trigger mux selection 19 */
    IfxAdc_DsadcTriggerSel_20,     /**< \brief trigger mux selection 20 */
    IfxAdc_DsadcTriggerSel_21,     /**< \brief trigger mux selection 21 */
    IfxAdc_DsadcTriggerSel_22,     /**< \brief trigger mux selection 22 */
    IfxAdc_DsadcTriggerSel_23,     /**< \brief trigger mux selection 23 */
    IfxAdc_DsadcTriggerSel_24,     /**< \brief trigger mux selection 24 */
    IfxAdc_DsadcTriggerSel_25,     /**< \brief trigger mux selection 25 */
    IfxAdc_DsadcTriggerSel_26,     /**< \brief trigger mux selection 26 */
    IfxAdc_DsadcTriggerSel_27,     /**< \brief trigger mux selection 27 */
    IfxAdc_DsadcTriggerSel_28,     /**< \brief trigger mux selection 28 */
    IfxAdc_DsadcTriggerSel_29,     /**< \brief trigger mux selection 29 */
    IfxAdc_DsadcTriggerSel_30,     /**< \brief trigger mux selection 30 */
    IfxAdc_DsadcTriggerSel_31,     /**< \brief trigger mux selection 31 */
    IfxAdc_DsadcTriggerSel_32,     /**< \brief trigger mux selection 32 */
    IfxAdc_DsadcTriggerSel_33,     /**< \brief trigger mux selection 33 */
    IfxAdc_DsadcTriggerSel_34,     /**< \brief trigger mux selection 34 */
    IfxAdc_DsadcTriggerSel_35,     /**< \brief trigger mux selection 35 */
    IfxAdc_DsadcTriggerSel_36,     /**< \brief trigger mux selection 36 */
    IfxAdc_DsadcTriggerSel_37,     /**< \brief trigger mux selection 37 */
    IfxAdc_DsadcTriggerSel_38,     /**< \brief trigger mux selection 38 */
    IfxAdc_DsadcTriggerSel_39,     /**< \brief trigger mux selection 39 */
    IfxAdc_DsadcTriggerSel_40,     /**< \brief trigger mux selection 40 */
    IfxAdc_DsadcTriggerSel_41,     /**< \brief trigger mux selection 41 */
    IfxAdc_DsadcTriggerSel_42,     /**< \brief trigger mux selection 42 */
    IfxAdc_DsadcTriggerSel_43,     /**< \brief trigger mux selection 43 */
    IfxAdc_DsadcTriggerSel_44,     /**< \brief trigger mux selection 44 */
    IfxAdc_DsadcTriggerSel_45,     /**< \brief trigger mux selection 45 */
    IfxAdc_DsadcTriggerSel_46,     /**< \brief trigger mux selection 46 */
    IfxAdc_DsadcTriggerSel_47,     /**< \brief trigger mux selection 47 */
    IfxAdc_DsadcTriggerSel_48,     /**< \brief trigger mux selection 48 */
    IfxAdc_DsadcTriggerSel_49,     /**< \brief trigger mux selection 49 */
    IfxAdc_DsadcTriggerSel_50,     /**< \brief trigger mux selection 50 */
    IfxAdc_DsadcTriggerSel_51,     /**< \brief trigger mux selection 51 */
    IfxAdc_DsadcTriggerSel_52,     /**< \brief trigger mux selection 52 */
    IfxAdc_DsadcTriggerSel_53,     /**< \brief trigger mux selection 53 */
    IfxAdc_DsadcTriggerSel_54,     /**< \brief trigger mux selection 54 */
    IfxAdc_DsadcTriggerSel_55,     /**< \brief trigger mux selection 55 */
    IfxAdc_DsadcTriggerSel_56,     /**< \brief trigger mux selection 56 */
    IfxAdc_DsadcTriggerSel_57,     /**< \brief trigger mux selection 57 */
    IfxAdc_DsadcTriggerSel_58,     /**< \brief trigger mux selection 58 */
    IfxAdc_DsadcTriggerSel_59,     /**< \brief trigger mux selection 59 */
    IfxAdc_DsadcTriggerSel_60,     /**< \brief trigger mux selection 60 */
    IfxAdc_DsadcTriggerSel_61,     /**< \brief trigger mux selection 61 */
    IfxAdc_DsadcTriggerSel_62,     /**< \brief trigger mux selection 62 */
    IfxAdc_DsadcTriggerSel_63      /**< \brief trigger mux selection 63 */
} IfxAdc_DsadcTriggerSel;

/** \brief Enumeration for ExMod clock frequency
 */
typedef enum
{
    IfxAdc_ExmodClockFreq_fadcdiv4  = 1, /**< \brief External modulator frequency fmod= fadc/4 */
    IfxAdc_ExmodClockFreq_fadcdiv8  = 2, /**< \brief External modulator frequency fmod= fadc/8 */
    IfxAdc_ExmodClockFreq_fadcdiv16 = 3  /**< \brief External modulator frequency fmod= fadc/16 */
} IfxAdc_ExmodClockFreq;

/** \brief Enumeration of Clock Source for External Modulator
 */
typedef enum
{
    IfxAdc_ExmodClockSource_inputA   = 0, /**< \brief Clock source from external input A */
    IfxAdc_ExmodClockSource_inputB   = 1, /**< \brief Clock source from external input B */
    IfxAdc_ExmodClockSource_inputC   = 2, /**< \brief Clock source from external input C */
    IfxAdc_ExmodClockSource_inputD   = 3, /**< \brief Clock source from external input D */
    IfxAdc_ExmodClockSource_inputE   = 4, /**< \brief Clock source from external input E */
    IfxAdc_ExmodClockSource_inputF   = 5, /**< \brief Clock source from external input F */
    IfxAdc_ExmodClockSource_inputG   = 6, /**< \brief Clock source from external input G */
    IfxAdc_ExmodClockSource_inputH   = 7, /**< \brief Clock source from external input H */
    IfxAdc_ExmodClockSource_internal = 8  /**< \brief Internal clock source */
} IfxAdc_ExmodClockSource;

/** \brief Enumeration of Data Source for External Modulator
 */
typedef enum
{
    IfxAdc_ExmodDataSource_inputA = 0,  /**< \brief Data source from external input A */
    IfxAdc_ExmodDataSource_inputB = 1,  /**< \brief Data source from external input B */
    IfxAdc_ExmodDataSource_inputC = 2,  /**< \brief Data source from external input C */
    IfxAdc_ExmodDataSource_inputD = 3,  /**< \brief Data source from external input D */
    IfxAdc_ExmodDataSource_inputE = 4,  /**< \brief Data source from external input E */
    IfxAdc_ExmodDataSource_inputF = 5,  /**< \brief Data source from external input F */
    IfxAdc_ExmodDataSource_inputG = 6,  /**< \brief Data source from external input G */
    IfxAdc_ExmodDataSource_inputH = 7   /**< \brief Data source from external input H */
} IfxAdc_ExmodDataSource;

/** \brief Enumeration for ExMod data stream select
 */
typedef enum
{
    IfxAdc_ExmodDataStream_fallingEdge = 0,  /**< \brief Data sampling on falling edge clock */
    IfxAdc_ExmodDataStream_risingEdge  = 1   /**< \brief Data sampling on rising edge clock */
} IfxAdc_ExmodDataStream;

/** \} */

/** \addtogroup IfxLld_Adc_Std_Tmadc_Enum
 * \{ */
/** \brief Enumeration describing the mode of comparision for boundary check of TMADC
 */
typedef enum
{
    IfxAdc_TmadcBoundaryCmpMode_disable    = 0,  /**< \brief boundary check is disabled */
    IfxAdc_TmadcBoundaryCmpMode_upperBound = 1,  /**< \brief upper bound is checked */
    IfxAdc_TmadcBoundaryCmpMode_lowerBound = 2,  /**< \brief lower Bound is checked */
    IfxAdc_TmadcBoundaryCmpMode_bothBound  = 3   /**< \brief both Bounds checked */
} IfxAdc_TmadcBoundaryCmpMode;

/** \brief Enmieration describing TMADC boundary registers available
 */
typedef enum
{
    IfxAdc_TmadcBoundaryReg_0 = 0,  /**< \brief boundary reg 0 */
    IfxAdc_TmadcBoundaryReg_1 = 1   /**< \brief boundary reg 1 */
} IfxAdc_TmadcBoundaryReg;

/** \brief Enumeration holding External multiplexer channel numbers
 */
typedef enum
{
    IfxAdc_TmadcEmuxChannel_0,     /**< \brief Emux channel 0  */
    IfxAdc_TmadcEmuxChannel_1,     /**< \brief Emux channel 1  */
    IfxAdc_TmadcEmuxChannel_2,     /**< \brief Emux channel 2  */
    IfxAdc_TmadcEmuxChannel_3,     /**< \brief Emux channel 3  */
    IfxAdc_TmadcEmuxChannel_4,     /**< \brief Emux channel 4  */
    IfxAdc_TmadcEmuxChannel_5,     /**< \brief Emux channel 5  */
    IfxAdc_TmadcEmuxChannel_6,     /**< \brief Emux channel 6  */
    IfxAdc_TmadcEmuxChannel_7      /**< \brief Emux channel 7  */
} IfxAdc_TmadcEmuxChannel;

/** \brief Enumeration describing the Tmadc Emux modes
 */
typedef enum
{
    IfxAdc_TmadcEmuxMode_normal   = 0, /**< \brief EMUX channel to be converted is given by the bitfield CHNR value */
    IfxAdc_TmadcEmuxMode_autoincr = 1  /**< \brief channels starting from EMUX channel-0 upto the value specified by bitfield CHCNT */
} IfxAdc_TmadcEmuxMode;

/** \brief Enumeration for TMADC event operation for service request
 */
typedef enum
{
    IfxAdc_TmadcEventOp_orLogicWithoutWfc = 0,  /**< \brief Service request generation on each event */
    IfxAdc_TmadcEventOp_orLogicWithWfc    = 1,  /**< \brief Service request generation on first event */
    IfxAdc_TmadcEventOp_andLogic          = 2   /**< \brief Service request generation on occurrence of all event */
} IfxAdc_TmadcEventOp;

/** \brief Enumeration for TMADC event selection for service request
 */
typedef enum
{
    IfxAdc_TmadcEventSel_disable  = 0, /**< \brief Disable service request */
    IfxAdc_TmadcEventSel_error    = 1, /**< \brief Service request on error event */
    IfxAdc_TmadcEventSel_result   = 2, /**< \brief Service request on result event */
    IfxAdc_TmadcEventSel_boundary = 3  /**< \brief Service request on boundary event */
} IfxAdc_TmadcEventSel;

/** \brief Enumeration for TMADC Global service request
 */
typedef enum
{
    IfxAdc_TmadcGlobalServReq_0,     /**< \brief Global service request0  */
    IfxAdc_TmadcGlobalServReq_1,     /**< \brief Global service request1  */
    IfxAdc_TmadcGlobalServReq_2,     /**< \brief Global service request2  */
    IfxAdc_TmadcGlobalServReq_3      /**< \brief Global service request3  */
} IfxAdc_TmadcGlobalServReq;

/** \brief Enumeration holding monitor channel numbers
 */
typedef enum
{
    IfxAdc_TmadcMonitorChannel_0 = 0,  /**< \brief Monitor channel 0 */
    IfxAdc_TmadcMonitorChannel_1 = 1   /**< \brief Monitor channel 1 */
} IfxAdc_TmadcMonitorChannel;

/** \brief Enumeration describing monitor channel input mux selection
 */
typedef enum
{
    IfxAdc_TmadcMonitorChannelInput_coreSupply   = 0,  /**< \brief Core (0,1) Supply voltage (VDDK0,VDDK1). (MCH1 --> Core0, MCH0 --> Core1) */
    IfxAdc_TmadcMonitorChannelInput_otherModules = 1,  /**< \brief Supply voltages from other modules (PMS,TMADC or DSADC) */
    IfxAdc_TmadcMonitorChannelInput_vssm         = 2,  /**< \brief VSSM */
    IfxAdc_TmadcMonitorChannelInput_csd          = 3   /**< \brief CSD monitor channel */
} IfxAdc_TmadcMonitorChannelInput;

/** \brief Enumeration describing operating modes of a TMADC channel
 */
typedef enum
{
    IfxAdc_TmadcOpMode_oneShot    = 0, /**< \brief one shot conversion */
    IfxAdc_TmadcOpMode_continuous = 1  /**< \brief continuous conversion with auto trigger */
} IfxAdc_TmadcOpMode;

/** \brief Enumeration describing output supervisor multiplexer selection
 */
typedef enum
{
    IfxAdc_TmadcOutputSupervisorMux_noConnection = 0,  /**< \brief No connection */
    IfxAdc_TmadcOutputSupervisorMux_vddk0        = 1,  /**< \brief Core-0 comparator supply voltage (VDDK0) */
    IfxAdc_TmadcOutputSupervisorMux_vddk1        = 2,  /**< \brief Core-1 comparator supply voltage (VDDK1) */
    IfxAdc_TmadcOutputSupervisorMux_vssm         = 3   /**< \brief Vssm */
} IfxAdc_TmadcOutputSupervisorMux;

/** \brief Enumeration holding TMADC result register numbers
 */
typedef enum
{
    IfxAdc_TmadcResultReg_0,     /**< \brief result register 0  */
    IfxAdc_TmadcResultReg_1,     /**< \brief result register 1  */
    IfxAdc_TmadcResultReg_2,     /**< \brief result register 2  */
    IfxAdc_TmadcResultReg_3,     /**< \brief result register 3  */
    IfxAdc_TmadcResultReg_4,     /**< \brief result register 4  */
    IfxAdc_TmadcResultReg_5,     /**< \brief result register 5  */
    IfxAdc_TmadcResultReg_6,     /**< \brief result register 6  */
    IfxAdc_TmadcResultReg_7,     /**< \brief result register 7  */
    IfxAdc_TmadcResultReg_8,     /**< \brief result register 8  */
    IfxAdc_TmadcResultReg_9,     /**< \brief result register 9  */
    IfxAdc_TmadcResultReg_10,    /**< \brief result register 10  */
    IfxAdc_TmadcResultReg_11,    /**< \brief result register 11  */
    IfxAdc_TmadcResultReg_12,    /**< \brief result register 12  */
    IfxAdc_TmadcResultReg_13,    /**< \brief result register 13  */
    IfxAdc_TmadcResultReg_14,    /**< \brief result register 14  */
    IfxAdc_TmadcResultReg_15,    /**< \brief result register 15  */
    IfxAdc_TmadcResultReg_count  /**< \brief Number of IfxAdc_TmadcResultReg of TMADC */
} IfxAdc_TmadcResultReg;

/** \brief Enumeration describing the Tmadc SAR Cores
 */
typedef enum
{
    IfxAdc_TmadcSarCore_0,     /**< \brief sar core0  */
    IfxAdc_TmadcSarCore_1      /**< \brief sar core1  */
} IfxAdc_TmadcSarCore;

/** \brief Enumeration for TMADC service request
 */
typedef enum
{
    IfxAdc_TmadcServReq_none = -1, /**< \brief Service request disable */
    IfxAdc_TmadcServReq_0,         /**< \brief Service request 0  */
    IfxAdc_TmadcServReq_1,         /**< \brief Service request 1  */
    IfxAdc_TmadcServReq_2,         /**< \brief Service request 2  */
    IfxAdc_TmadcServReq_3,         /**< \brief Service request 3  */
    IfxAdc_TmadcServReq_4,         /**< \brief Service request 4  */
    IfxAdc_TmadcServReq_5,         /**< \brief Service request 5  */
    IfxAdc_TmadcServReq_6          /**< \brief Service request 6  */
} IfxAdc_TmadcServReq;

/** \brief Enumeration for suspend modes of Tmadc
 */
typedef enum
{
    IfxAdc_TmadcSuspendMode_dsiable         = 0,  /**< \brief Suspend mode disable */
    IfxAdc_TmadcSuspendMode_hard            = 1,  /**< \brief Module immediately goes to suspend state */
    IfxAdc_TmadcSuspendMode_soft_activeConv = 2,  /**< \brief Module goes to suspend state after completing active conversions */
    IfxAdc_TmadcSuspendMode_soft_holdConv   = 3   /**< \brief Module goes to suspend state after completing conversions for all channels in hold state */
} IfxAdc_TmadcSuspendMode;

/** \brief Edge selection for TMADC hardware trigger
 */
typedef enum
{
    IfxAdc_TmadcTriggerMode_disable     = 0,  /**< \brief trigger is disabled */
    IfxAdc_TmadcTriggerMode_risingEdge  = 1,  /**< \brief rising edge of trigger selected */
    IfxAdc_TmadcTriggerMode_fallingEdge = 2,  /**< \brief Falling edge of trigger */
    IfxAdc_TmadcTriggerMode_bothEdge    = 3   /**< \brief both Edges selected */
} IfxAdc_TmadcTriggerMode;

/** \brief Enumeration holding Hardware Trigger mux selection
 */
typedef enum
{
    IfxAdc_TmadcTriggerMuxSel_0 = 0,      /**< \brief trigger mux selection 0  */
    IfxAdc_TmadcTriggerMuxSel_1,          /**< \brief trigger mux selection 1  */
    IfxAdc_TmadcTriggerMuxSel_2,          /**< \brief trigger mux selection 2  */
    IfxAdc_TmadcTriggerMuxSel_3,          /**< \brief trigger mux selection 3  */
    IfxAdc_TmadcTriggerMuxSel_4,          /**< \brief trigger mux selection 4  */
    IfxAdc_TmadcTriggerMuxSel_5,          /**< \brief trigger mux selection 5  */
    IfxAdc_TmadcTriggerMuxSel_6,          /**< \brief trigger mux selection 6  */
    IfxAdc_TmadcTriggerMuxSel_7,          /**< \brief trigger mux selection 7  */
    IfxAdc_TmadcTriggerMuxSel_8,          /**< \brief trigger mux selection 8  */
    IfxAdc_TmadcTriggerMuxSel_9,          /**< \brief trigger mux selection 9  */
    IfxAdc_TmadcTriggerMuxSel_10,         /**< \brief trigger mux selection 10  */
    IfxAdc_TmadcTriggerMuxSel_11,         /**< \brief trigger mux selection 11  */
    IfxAdc_TmadcTriggerMuxSel_12,         /**< \brief trigger mux selection 12  */
    IfxAdc_TmadcTriggerMuxSel_13,         /**< \brief trigger mux selection 13  */
    IfxAdc_TmadcTriggerMuxSel_14,         /**< \brief trigger mux selection 14  */
    IfxAdc_TmadcTriggerMuxSel_15,         /**< \brief trigger mux selection 15  */
    IfxAdc_TmadcTriggerMuxSel_16,         /**< \brief trigger mux selection 16  */
    IfxAdc_TmadcTriggerMuxSel_17,         /**< \brief trigger mux selection 17  */
    IfxAdc_TmadcTriggerMuxSel_18,         /**< \brief trigger mux selection 18  */
    IfxAdc_TmadcTriggerMuxSel_19,         /**< \brief trigger mux selection 19  */
    IfxAdc_TmadcTriggerMuxSel_20,         /**< \brief trigger mux selection 20  */
    IfxAdc_TmadcTriggerMuxSel_21,         /**< \brief trigger mux selection 21  */
    IfxAdc_TmadcTriggerMuxSel_22,         /**< \brief trigger mux selection 22  */
    IfxAdc_TmadcTriggerMuxSel_23,         /**< \brief trigger mux selection 23  */
    IfxAdc_TmadcTriggerMuxSel_24,         /**< \brief trigger mux selection 24  */
    IfxAdc_TmadcTriggerMuxSel_25,         /**< \brief trigger mux selection 25  */
    IfxAdc_TmadcTriggerMuxSel_26,         /**< \brief trigger mux selection 26  */
    IfxAdc_TmadcTriggerMuxSel_27,         /**< \brief trigger mux selection 27  */
    IfxAdc_TmadcTriggerMuxSel_28,         /**< \brief trigger mux selection 28  */
    IfxAdc_TmadcTriggerMuxSel_29,         /**< \brief trigger mux selection 29  */
    IfxAdc_TmadcTriggerMuxSel_30,         /**< \brief trigger mux selection 30  */
    IfxAdc_TmadcTriggerMuxSel_31,         /**< \brief trigger mux selection 31  */
    IfxAdc_TmadcTriggerMuxSel_32,         /**< \brief trigger mux selection 32  */
    IfxAdc_TmadcTriggerMuxSel_33,         /**< \brief trigger mux selection 33  */
    IfxAdc_TmadcTriggerMuxSel_34,         /**< \brief trigger mux selection 34  */
    IfxAdc_TmadcTriggerMuxSel_35,         /**< \brief trigger mux selection 35  */
    IfxAdc_TmadcTriggerMuxSel_36,         /**< \brief trigger mux selection 36  */
    IfxAdc_TmadcTriggerMuxSel_37,         /**< \brief trigger mux selection 37  */
    IfxAdc_TmadcTriggerMuxSel_38,         /**< \brief trigger mux selection 38  */
    IfxAdc_TmadcTriggerMuxSel_39,         /**< \brief trigger mux selection 39  */
    IfxAdc_TmadcTriggerMuxSel_40,         /**< \brief trigger mux selection 40  */
    IfxAdc_TmadcTriggerMuxSel_41,         /**< \brief trigger mux selection 41  */
    IfxAdc_TmadcTriggerMuxSel_42,         /**< \brief trigger mux selection 42  */
    IfxAdc_TmadcTriggerMuxSel_43,         /**< \brief trigger mux selection 43  */
    IfxAdc_TmadcTriggerMuxSel_44,         /**< \brief trigger mux selection 44  */
    IfxAdc_TmadcTriggerMuxSel_45,         /**< \brief trigger mux selection 45  */
    IfxAdc_TmadcTriggerMuxSel_46,         /**< \brief trigger mux selection 46  */
    IfxAdc_TmadcTriggerMuxSel_47,         /**< \brief trigger mux selection 47  */
    IfxAdc_TmadcTriggerMuxSel_48,         /**< \brief trigger mux selection 48  */
    IfxAdc_TmadcTriggerMuxSel_49,         /**< \brief trigger mux selection 49  */
    IfxAdc_TmadcTriggerMuxSel_50,         /**< \brief trigger mux selection 50  */
    IfxAdc_TmadcTriggerMuxSel_51,         /**< \brief trigger mux selection 51  */
    IfxAdc_TmadcTriggerMuxSel_52,         /**< \brief trigger mux selection 52  */
    IfxAdc_TmadcTriggerMuxSel_53,         /**< \brief trigger mux selection 53  */
    IfxAdc_TmadcTriggerMuxSel_54,         /**< \brief trigger mux selection 54  */
    IfxAdc_TmadcTriggerMuxSel_55,         /**< \brief trigger mux selection 55  */
    IfxAdc_TmadcTriggerMuxSel_56,         /**< \brief trigger mux selection 56  */
    IfxAdc_TmadcTriggerMuxSel_57,         /**< \brief trigger mux selection 57  */
    IfxAdc_TmadcTriggerMuxSel_58,         /**< \brief trigger mux selection 58  */
    IfxAdc_TmadcTriggerMuxSel_59,         /**< \brief trigger mux selection 59  */
    IfxAdc_TmadcTriggerMuxSel_60,         /**< \brief trigger mux selection 60  */
    IfxAdc_TmadcTriggerMuxSel_61,         /**< \brief trigger mux selection 61  */
    IfxAdc_TmadcTriggerMuxSel_62,         /**< \brief trigger mux selection 62  */
    IfxAdc_TmadcTriggerMuxSel_63,         /**< \brief trigger mux selection 63  */
    IfxAdc_TmadcTriggerMuxSel_count       /**< \brief Number of IfxAdc_TmadcTriggerMuxSel items */
} IfxAdc_TmadcTriggerMuxSel;

/** \} */

/** \addtogroup IfxLld_Adc_Std_Fcc_Enum
 * \{ */
/** \brief Enumeration describing Boundary flag activation
 */
typedef enum
{
    IfxAdc_FccBoundaryFlag_setonCrossingUpperThresh = 0,  /**< \brief Set BFL when the channel comparison result is greater than upper threshold */
    IfxAdc_FccBoundaryFlag_setonBelowLowerThresh    = 1   /**< \brief Set BFL when the channel comparison result is lower than lower threshold */
} IfxAdc_FccBoundaryFlag;

/** \brief Enumeration for boundary flag polarity.
 */
typedef enum
{
    IfxAdc_FccGatePolarity_low  = 0, /**< \brief Gated Boundary flag value is 0. */
    IfxAdc_FccGatePolarity_high = 1  /**< \brief Gated Boundary flag value is 1. */
} IfxAdc_FccGatePolarity;

/** \brief Enumeration describing Fcc modes
 */
typedef enum
{
    IfxAdc_FccMode_normal                          = 0,  /**< \brief Normal operation mode */
    IfxAdc_FccMode_hysteresis                      = 2,  /**< \brief Hysteresis operation mode */
    IfxAdc_FccMode_rampstartonSwtEndonTv           = 3,  /**< \brief Ramp Operation mode start on Software trigger and end ramp when end threshold value is reached */
    IfxAdc_FccMode_rampstartonSwtEndonHwt          = 4,  /**< \brief Ramp Operation mode start on Software trigger and end ramp on hardware trigger */
    IfxAdc_FccMode_rampstartonSwtEndonBoundaryFlag = 5,  /**< \brief Ramp Operation mode start on Software trigger and end ramp on first transition of boundary flag */
    IfxAdc_FccMode_rampstartonHwtEndonTv           = 6,  /**< \brief Ramp Operation mode start on Hardware trigger and end ramp when end threshold value is reached */
    IfxAdc_FccMode_rampstartonHwtEndonHwt          = 7   /**< \brief Ramp Operation mode start on Hardware trigger and end on Hardware trigger */
} IfxAdc_FccMode;

/** \brief Enumeration describing ramp direction
 */
typedef enum
{
    IfxAdc_FccRampDirection_increment = 0,  /**< \brief Ramp incremented when enabled */
    IfxAdc_FccRampDirection_decrement = 1   /**< \brief Ramp decremented when enabled */
} IfxAdc_FccRampDirection;

/** \brief Enumeration describing Service Request 0 event selection
 */
typedef enum
{
    IfxAdc_FccSr0EventSel_disable         = 0,  /**< \brief Service request line disabled. */
    IfxAdc_FccSr0EventSel_risingedgeofBfl = 1,  /**< \brief Service request on the rising edge of BFL */
    IfxAdc_FccSr0EventSel_fallingdgeofBfl = 2,  /**< \brief Service request on the falling edge of BFL */
    IfxAdc_FccSr0EventSel_bothedgeofBfl   = 3   /**< \brief Service request on both the rising and fallign edges of BFL */
} IfxAdc_FccSr0EventSel;

/** \brief Enumeration describing Service Request 1 event selection
 */
typedef enum
{
    IfxAdc_FccSr1EventSel_disable            = 0, /**< \brief Service request line disabled. */
    IfxAdc_FccSr1EventSel_tvUpdateOrRammpend = 1  /**< \brief Service request on new threshold update (MODE= 101).Service request on end of ramp (Mode != 101) */
} IfxAdc_FccSr1EventSel;

/** \brief Edge selection for hardware trigger
 */
typedef enum
{
    IfxAdc_FccTriggerMode_disable     = 0,  /**< \brief trigger is disabled */
    IfxAdc_FccTriggerMode_risingEdge  = 1,  /**< \brief rising edge of trigger selected */
    IfxAdc_FccTriggerMode_fallingEdge = 2,  /**< \brief Falling edge of trigger */
    IfxAdc_FccTriggerMode_bothEdge    = 3   /**< \brief both Edges selected */
} IfxAdc_FccTriggerMode;

/** \brief Enumeration holding Trigger selection
 */
typedef enum
{
    IfxAdc_FccTriggerSel_0,     /**< \brief trigger selection 0  */
    IfxAdc_FccTriggerSel_1,     /**< \brief trigger selection 1  */
    IfxAdc_FccTriggerSel_2,     /**< \brief trigger selection 2  */
    IfxAdc_FccTriggerSel_3,     /**< \brief trigger selection 3  */
    IfxAdc_FccTriggerSel_4,     /**< \brief trigger selection 4  */
    IfxAdc_FccTriggerSel_5,     /**< \brief trigger selection 5  */
    IfxAdc_FccTriggerSel_6,     /**< \brief trigger selection 6  */
    IfxAdc_FccTriggerSel_7,     /**< \brief trigger selection 7  */
    IfxAdc_FccTriggerSel_8,     /**< \brief trigger selection 8  */
    IfxAdc_FccTriggerSel_9,     /**< \brief trigger selection 9  */
    IfxAdc_FccTriggerSel_10,    /**< \brief trigger selection 10  */
    IfxAdc_FccTriggerSel_11,    /**< \brief trigger selection 11  */
    IfxAdc_FccTriggerSel_12,    /**< \brief trigger selection 12  */
    IfxAdc_FccTriggerSel_13,    /**< \brief trigger selection 13  */
    IfxAdc_FccTriggerSel_14,    /**< \brief trigger selection 14  */
    IfxAdc_FccTriggerSel_15,    /**< \brief trigger selection 15  */
    IfxAdc_FccTriggerSel_16,    /**< \brief trigger selection 16  */
    IfxAdc_FccTriggerSel_17,    /**< \brief trigger selection 17  */
    IfxAdc_FccTriggerSel_18,    /**< \brief trigger selection 18  */
    IfxAdc_FccTriggerSel_19,    /**< \brief trigger selection 19  */
    IfxAdc_FccTriggerSel_20,    /**< \brief trigger selection 20  */
    IfxAdc_FccTriggerSel_21,    /**< \brief trigger selection 21  */
    IfxAdc_FccTriggerSel_22,    /**< \brief trigger selection 22  */
    IfxAdc_FccTriggerSel_23,    /**< \brief trigger selection 23  */
    IfxAdc_FccTriggerSel_24,    /**< \brief trigger selection 24  */
    IfxAdc_FccTriggerSel_25,    /**< \brief trigger selection 25  */
    IfxAdc_FccTriggerSel_26,    /**< \brief trigger selection 26  */
    IfxAdc_FccTriggerSel_27,    /**< \brief trigger selection 27  */
    IfxAdc_FccTriggerSel_28,    /**< \brief trigger selection 28  */
    IfxAdc_FccTriggerSel_29,    /**< \brief trigger selection 29  */
    IfxAdc_FccTriggerSel_30,    /**< \brief trigger selection 30  */
    IfxAdc_FccTriggerSel_31,    /**< \brief trigger selection 31  */
    IfxAdc_FccTriggerSel_32,    /**< \brief trigger selection 32  */
    IfxAdc_FccTriggerSel_33,    /**< \brief trigger selection 33  */
    IfxAdc_FccTriggerSel_34,    /**< \brief trigger selection 34  */
    IfxAdc_FccTriggerSel_35,    /**< \brief trigger selection 35  */
    IfxAdc_FccTriggerSel_36,    /**< \brief trigger selection 36  */
    IfxAdc_FccTriggerSel_37,    /**< \brief trigger selection 37  */
    IfxAdc_FccTriggerSel_38,    /**< \brief trigger selection 38  */
    IfxAdc_FccTriggerSel_39,    /**< \brief trigger selection 39  */
    IfxAdc_FccTriggerSel_40,    /**< \brief trigger selection 40  */
    IfxAdc_FccTriggerSel_41,    /**< \brief trigger selection 41  */
    IfxAdc_FccTriggerSel_42,    /**< \brief trigger selection 42  */
    IfxAdc_FccTriggerSel_43,    /**< \brief trigger selection 43  */
    IfxAdc_FccTriggerSel_44,    /**< \brief trigger selection 44  */
    IfxAdc_FccTriggerSel_45,    /**< \brief trigger selection 45  */
    IfxAdc_FccTriggerSel_46,    /**< \brief trigger selection 46  */
    IfxAdc_FccTriggerSel_47,    /**< \brief trigger selection 47  */
    IfxAdc_FccTriggerSel_48,    /**< \brief trigger selection 48  */
    IfxAdc_FccTriggerSel_49,    /**< \brief trigger selection 49  */
    IfxAdc_FccTriggerSel_50,    /**< \brief trigger selection 50  */
    IfxAdc_FccTriggerSel_51,    /**< \brief trigger selection 51  */
    IfxAdc_FccTriggerSel_52,    /**< \brief trigger selection 52  */
    IfxAdc_FccTriggerSel_53,    /**< \brief trigger selection 53  */
    IfxAdc_FccTriggerSel_54,    /**< \brief trigger selection 54  */
    IfxAdc_FccTriggerSel_55,    /**< \brief trigger selection 55  */
    IfxAdc_FccTriggerSel_56,    /**< \brief trigger selection 56  */
    IfxAdc_FccTriggerSel_57,    /**< \brief trigger selection 57  */
    IfxAdc_FccTriggerSel_58,    /**< \brief trigger selection 58  */
    IfxAdc_FccTriggerSel_59,    /**< \brief trigger selection 59  */
    IfxAdc_FccTriggerSel_60,    /**< \brief trigger selection 60  */
    IfxAdc_FccTriggerSel_61,    /**< \brief trigger selection 61  */
    IfxAdc_FccTriggerSel_62,    /**< \brief trigger selection 62  */
    IfxAdc_FccTriggerSel_63,    /**< \brief trigger selection 63  */
    IfxAdc_FccTriggerSel_count  /**< \brief Number of IfxAdc_FccTriggerSel items */
} IfxAdc_FccTriggerSel;

/** \} */

/** \addtogroup IfxLld_Adc_Std_Cdsp_Enum
 * \{ */
/** \brief Enumeration describing the mode of comparision for boundary check of CDSP
 */
typedef enum
{
    IfxAdc_CdspBoundaryCmpMode_disable    = 0,  /**< \brief boundary check is disabled */
    IfxAdc_CdspBoundaryCmpMode_upperBound = 1,  /**< \brief upper bound is checked */
    IfxAdc_CdspBoundaryCmpMode_lowerBound = 2,  /**< \brief lower Bound is checked */
    IfxAdc_CdspBoundaryCmpMode_bothBound  = 3   /**< \brief both Bounds checked */
} IfxAdc_CdspBoundaryCmpMode;

/** \brief Enumeration for Boundary service request (CDSP_DSPa_BNDCFG.SR2CFG)
 */
typedef enum
{
    IfxAdc_CdspBoundaryServReq_insideBoundary  = 0, /**< \brief Generate service request when result inside boundary band */
    IfxAdc_CdspBoundaryServReq_outsideBoundary = 1  /**< \brief Generate service request when result outside boundary band */
} IfxAdc_CdspBoundaryServReq;

/** \brief Configuration of Data Read width (CDSP_DSPa_DSPCFG.DRM)
 */
typedef enum
{
    IfxAdc_CdspDataReadWidth_16Bit = 0,  /**< \brief 16 BIt */
    IfxAdc_CdspDataReadWidth_32Bit = 2   /**< \brief 32 Bit */
} IfxAdc_CdspDataReadWidth;

/** \brief Enumeration for CDSP error flag.
 */
typedef enum
{
    IfxAdc_CdspError_read             = 0,  /**< \brief Read error flag */
    IfxAdc_CdspError_write            = 1,  /**< \brief Write error flag */
    IfxAdc_CdspError_srvReqTrigger    = 2,  /**< \brief Service request trigger error flag */
    IfxAdc_CdspError_timestampTrigger = 4,  /**< \brief Time-stamp trigger error flag */
    IfxAdc_CdspError_boundaryTrigger  = 6   /**< \brief Boundary request trigger error */
} IfxAdc_CdspError;

/** \brief FIFO fill level for service request generation
 */
typedef enum
{
    IfxAdc_CdspFifoSrLevel_1,     /**< \brief SRLVL 1  */
    IfxAdc_CdspFifoSrLevel_2,     /**< \brief SRLVL 2  */
    IfxAdc_CdspFifoSrLevel_3,     /**< \brief SRLVL 3  */
    IfxAdc_CdspFifoSrLevel_4      /**< \brief SRLVL 4  */
} IfxAdc_CdspFifoSrLevel;

/** \brief Enumeration decribing CDSP input selection
 */
typedef enum
{
    IfxAdc_CdspInput_dsadc0,       /**< \brief Dsadc0  */
    IfxAdc_CdspInput_dsadc1,       /**< \brief Dsadc1  */
    IfxAdc_CdspInput_dsadc2,       /**< \brief Dsadc2  */
    IfxAdc_CdspInput_dsadc3,       /**< \brief Dsadc3  */
    IfxAdc_CdspInput_dsadc4,       /**< \brief Dsadc4  */
    IfxAdc_CdspInput_dsadc5,       /**< \brief Dsadc5  */
    IfxAdc_CdspInput_dsadc6,       /**< \brief Dsadc6  */
    IfxAdc_CdspInput_dsadc7,       /**< \brief Dsadc7  */
    IfxAdc_CdspInput_dsadc8,       /**< \brief Dsadc8  */
    IfxAdc_CdspInput_dsadc9,       /**< \brief Dsadc9  */
    IfxAdc_CdspInput_dsadc10,      /**< \brief Dsadc10  */
    IfxAdc_CdspInput_dsadc11,      /**< \brief Dsadc11  */
    IfxAdc_CdspInput_dsadc12,      /**< \brief Dsadc12  */
    IfxAdc_CdspInput_dsadc13,      /**< \brief Dsadc13  */
    IfxAdc_CdspInput_exmod0,       /**< \brief Exmod0  */
    IfxAdc_CdspInput_exmod1,       /**< \brief Exmod1  */
    IfxAdc_CdspInput_exmod2,       /**< \brief Exmod2  */
    IfxAdc_CdspInput_exmod3,       /**< \brief Exmod3  */
    IfxAdc_CdspInput_tmadc0Core0,  /**< \brief TMADC0 Core0 */
    IfxAdc_CdspInput_tmadc0Core1,  /**< \brief TMADC0 Core1 */
    IfxAdc_CdspInput_tmadc1Core0,  /**< \brief TMADC0 Core0 */
    IfxAdc_CdspInput_tmadc1Core1,  /**< \brief TMADC1 Core1 */
    IfxAdc_CdspInput_tmadc2Core0,  /**< \brief TMADC2 Core0 */
    IfxAdc_CdspInput_tmadc2Core1,  /**< \brief TMADC2 Core1 */
    IfxAdc_CdspInput_tmadc3Core0,  /**< \brief TMADC3 Core0 */
    IfxAdc_CdspInput_tmadc3Core1,  /**< \brief TMADC3 Core1 */
    IfxAdc_CdspInput_tmadc4Core0,  /**< \brief TMADC4 Core0 */
    IfxAdc_CdspInput_tmadc4Core1,  /**< \brief TMADC0 Core1 */
    IfxAdc_CdspInput_tmadc5Core0,  /**< \brief TMADC5 Core0 */
    IfxAdc_CdspInput_tmadc5Core1,  /**< \brief TMADC5 Core1 */
    IfxAdc_CdspInput_tmadc6Core0,  /**< \brief TMADC6 Core0 */
    IfxAdc_CdspInput_tmadc6Core1,  /**< \brief TMADC5 Core1 */
    IfxAdc_CdspInput_tmadc7Core0,  /**< \brief TMADC7 Core0 */
    IfxAdc_CdspInput_tmadc7Core1,  /**< \brief TMADC7 Core1 */
    IfxAdc_CdspInput_gp0,          /**< \brief General Purpose Register 0  */
    IfxAdc_CdspInput_gp1,          /**< \brief General Purpose Register 1  */
    IfxAdc_CdspInput_gp2,          /**< \brief General Purpose Register 2  */
    IfxAdc_CdspInput_gp3,          /**< \brief General Purpose Register 3  */
    IfxAdc_CdspInput_carmag        /**< \brief Carrier Signal of Dsadc */
} IfxAdc_CdspInput;

/** \brief Enumeration describing CDSP monitor selection.
 * CDSP_DSPa_DSPCFG.HSIMON
 */
typedef enum
{
    IfxAdc_CdspInputMonitor_dsadc0,       /**< \brief Dsadc0 */
    IfxAdc_CdspInputMonitor_dsadc1,       /**< \brief Dsadc1 */
    IfxAdc_CdspInputMonitor_dsadc2,       /**< \brief Dsadc2 */
    IfxAdc_CdspInputMonitor_dsadc3,       /**< \brief Dsadc3 */
    IfxAdc_CdspInputMonitor_dsadc4,       /**< \brief Dsadc4 */
    IfxAdc_CdspInputMonitor_dsadc5,       /**< \brief Dsadc5 */
    IfxAdc_CdspInputMonitor_dsadc6,       /**< \brief Dsadc6 */
    IfxAdc_CdspInputMonitor_dsadc7,       /**< \brief Dsadc7 */
    IfxAdc_CdspInputMonitor_dsadc8,       /**< \brief Dsadc8 */
    IfxAdc_CdspInputMonitor_dsadc9,       /**< \brief Dsadc9 */
    IfxAdc_CdspInputMonitor_dsadc10,      /**< \brief Dsadc10 */
    IfxAdc_CdspInputMonitor_dsadc11,      /**< \brief Dsadc11 */
    IfxAdc_CdspInputMonitor_dsadc12,      /**< \brief Dsadc12 */
    IfxAdc_CdspInputMonitor_dsadc13,      /**< \brief Dsadc13 */
    IfxAdc_CdspInputMonitor_exmod0,       /**< \brief Exmod0 */
    IfxAdc_CdspInputMonitor_exmod1,       /**< \brief Exmod1 */
    IfxAdc_CdspInputMonitor_exmod2,       /**< \brief Exmod2 */
    IfxAdc_CdspInputMonitor_exmod3,       /**< \brief Exmod3 */
    IfxAdc_CdspInputMonitor_tmadc0Core0,  /**< \brief TMADC0 Core0 */
    IfxAdc_CdspInputMonitor_tmadc0Core1,  /**< \brief TMADC0 Core1 */
    IfxAdc_CdspInputMonitor_tmadc1Core0,  /**< \brief TMADC0 Core0 */
    IfxAdc_CdspInputMonitor_tmadc1Core1,  /**< \brief TMADC1 Core1 */
    IfxAdc_CdspInputMonitor_tmadc2Core0,  /**< \brief TMADC2 Core0 */
    IfxAdc_CdspInputMonitor_tmadc2Core1,  /**< \brief TMADC2 Core1 */
    IfxAdc_CdspInputMonitor_tmadc3Core0,  /**< \brief TMADC3 Core0 */
    IfxAdc_CdspInputMonitor_tmadc3Core1,  /**< \brief TMADC3 Core1 */
    IfxAdc_CdspInputMonitor_tmadc4Core0,  /**< \brief TMADC4 Core0 */
    IfxAdc_CdspInputMonitor_tmadc4Core1,  /**< \brief TMADC0 Core1 */
    IfxAdc_CdspInputMonitor_tmadc5Core0,  /**< \brief TMADC5 Core0 */
    IfxAdc_CdspInputMonitor_tmadc5Core1,  /**< \brief TMADC5 Core1 */
    IfxAdc_CdspInputMonitor_tmadc6Core0,  /**< \brief TMADC6 Core0 */
    IfxAdc_CdspInputMonitor_tmadc6Core1,  /**< \brief TMADC5 Core1 */
    IfxAdc_CdspInputMonitor_tmadc7Core0,  /**< \brief TMADC7 Core0 */
    IfxAdc_CdspInputMonitor_tmadc7Core1,  /**< \brief TMADC7 Core1 */
    IfxAdc_CdspInputMonitor_gp0,          /**< \brief General Purpose Register 0 */
    IfxAdc_CdspInputMonitor_gp1,          /**< \brief General Purpose Register 1 */
    IfxAdc_CdspInputMonitor_gp2,          /**< \brief General Purpose Register 2 */
    IfxAdc_CdspInputMonitor_gp3,          /**< \brief General Purpose Register 3 */
    IfxAdc_CdspInputMonitor_carmag        /**< \brief Carrier Signal of Dsadc */
} IfxAdc_CdspInputMonitor;

/** \brief Select the bits to be accumulated in Integrator [INTCFG.ISC]
 */
typedef enum
{
    IfxAdc_CdspIntegratorShift_bits4To20,     /**< \brief Select bits 4 to 20  */
    IfxAdc_CdspIntegratorShift_bits5To21,     /**< \brief Select bits 5 to 21  */
    IfxAdc_CdspIntegratorShift_bits6To22,     /**< \brief Select bits 6 to 22  */
    IfxAdc_CdspIntegratorShift_bits7To23,     /**< \brief Select bits 7 to 23  */
    IfxAdc_CdspIntegratorShift_bits8To24,     /**< \brief Select bits 8 to 24  */
    IfxAdc_CdspIntegratorShift_bits9To25      /**< \brief Select bits 9 to 25  */
} IfxAdc_CdspIntegratorShift;

/** \brief Enumeration for CDSP Integrator window control
 */
typedef enum
{
    IfxAdc_CdspIntegratorWindowControl_internal = 0,  /**< \brief Integrator window control (start - edgeControl Stop - CDSP SW filter repetition parameter) */
    IfxAdc_CdspIntegratorWindowControl_external = 1   /**< \brief Integrator window controlled externally (Start - edgeControlled Stop - edgeControlled ) */
} IfxAdc_CdspIntegratorWindowControl;

/** \brief Enumeration for Cdsp Result register
 */
typedef enum
{
    IfxAdc_CdspResultReg_0,     /**< \brief CDSP Result register0  */
    IfxAdc_CdspResultReg_1,     /**< \brief CDSP Result register1  */
    IfxAdc_CdspResultReg_2      /**< \brief CDSP Result register2  */
} IfxAdc_CdspResultReg;

/** \brief Enumeration for Cdsp Service request
 */
typedef enum
{
    IfxAdc_CdspServiceReq_result = 0,  /**< \brief Service request for result */
    IfxAdc_CdspServiceReq_event  = 1,  /**< \brief Service request for timestamp/wakeup event */
    IfxAdc_CdspServiceReq_alarm  = 2   /**< \brief Service request for limit checking */
} IfxAdc_CdspServiceReq;

/** \brief CDSP service request 0 configuration
 */
typedef enum
{
    IfxAdc_CdspSrvReq0_never    = 0,  /**< \brief Never raise Service Request */
    IfxAdc_CdspSrvReq0_gateHigh = 1,  /**< \brief Raise when gate HIGH */
    IfxAdc_CdspSrvReq0_gateLow  = 2,  /**< \brief Raise when gate LOW */
    IfxAdc_CdspSrvReq0_always   = 3   /**< \brief Raise always */
} IfxAdc_CdspSrvReq0;

/** \brief Enumeration holding CDSP service request 1 selection
 */
typedef enum
{
    IfxAdc_CdspSrvReq1_never     = 0,  /**< \brief Never raise Service Request */
    IfxAdc_CdspSrvReq1_timestamp = 1,  /**< \brief SR1 occurs when timestamp is generated */
    IfxAdc_CdspSrvReq1_wakeupErr = 2,  /**< \brief SR1 occurs when a wakeup error occurs or core is in halt state */
    IfxAdc_CdspSrvReq1_always    = 3   /**< \brief SR1 is generated on timestamp generation, wakeup error or system halt */
} IfxAdc_CdspSrvReq1;

/** \brief Enumeration for suspend modes of Cdsp
 */
typedef enum
{
    IfxAdc_CdspSuspendMode_disable   = 0, /**< \brief Suspend mode disable */
    IfxAdc_CdspSuspendMode_hard      = 1, /**< \brief Module immediately goes to suspend state */
    IfxAdc_CdspSuspendMode_soft      = 2, /**< \brief Module goes to suspend state after processing the current sample */
    IfxAdc_CdspSuspendMode_soft_res0 = 3  /**< \brief Module goes to suspend state after after generating the final output in RES0 */
} IfxAdc_CdspSuspendMode;

/** \brief Enumeration for CDSP timestamp clock
 */
typedef enum
{
    IfxAdc_CdspTimestampClock_div4  = 0,  /**< \brief Timestamp clock fts = fadc/4 */
    IfxAdc_CdspTimestampClock_div8  = 1,  /**< \brief Timestamp clock fts = fadc/8 */
    IfxAdc_CdspTimestampClock_div16 = 2,  /**< \brief Timestamp clock fts = fadc/16 */
    IfxAdc_CdspTimestampClock_div32 = 3   /**< \brief Timestamp clock fts = fadc/32 */
} IfxAdc_CdspTimestampClock;

/** \brief Edge selection for CDSP trigger
 */
typedef enum
{
    IfxAdc_CdspTriggerMode_disable     = 0,  /**< \brief trigger is disabled */
    IfxAdc_CdspTriggerMode_risingEdge  = 1,  /**< \brief rising edge of trigger selected */
    IfxAdc_CdspTriggerMode_fallingEdge = 2,  /**< \brief Falling edge of trigger */
    IfxAdc_CdspTriggerMode_bothEdge    = 3   /**< \brief both Edges selected */
} IfxAdc_CdspTriggerMode;

/** \brief Enumeration Cdsp trigger selection
 */
typedef enum
{
    IfxAdc_CdspTriggerSel_0,     /**< \brief trigger selection 0  */
    IfxAdc_CdspTriggerSel_1,     /**< \brief trigger selection 1  */
    IfxAdc_CdspTriggerSel_2,     /**< \brief trigger selection 2  */
    IfxAdc_CdspTriggerSel_3,     /**< \brief trigger selection 3  */
    IfxAdc_CdspTriggerSel_4,     /**< \brief trigger selection 4  */
    IfxAdc_CdspTriggerSel_5,     /**< \brief trigger selection 5  */
    IfxAdc_CdspTriggerSel_6,     /**< \brief trigger selection 6  */
    IfxAdc_CdspTriggerSel_7,     /**< \brief trigger selection 7  */
    IfxAdc_CdspTriggerSel_8,     /**< \brief trigger selection 8  */
    IfxAdc_CdspTriggerSel_9,     /**< \brief trigger selection 9  */
    IfxAdc_CdspTriggerSel_10,    /**< \brief trigger selection 10  */
    IfxAdc_CdspTriggerSel_11,    /**< \brief trigger selection 11  */
    IfxAdc_CdspTriggerSel_12,    /**< \brief trigger selection 12  */
    IfxAdc_CdspTriggerSel_13,    /**< \brief trigger selection 13  */
    IfxAdc_CdspTriggerSel_14,    /**< \brief trigger selection 14  */
    IfxAdc_CdspTriggerSel_15,    /**< \brief trigger selection 15  */
    IfxAdc_CdspTriggerSel_16,    /**< \brief trigger selection 16  */
    IfxAdc_CdspTriggerSel_17,    /**< \brief trigger selection 17  */
    IfxAdc_CdspTriggerSel_18,    /**< \brief trigger selection 18  */
    IfxAdc_CdspTriggerSel_19,    /**< \brief trigger selection 19  */
    IfxAdc_CdspTriggerSel_20,    /**< \brief trigger selection 20  */
    IfxAdc_CdspTriggerSel_21,    /**< \brief trigger selection 21  */
    IfxAdc_CdspTriggerSel_22,    /**< \brief trigger selection 22  */
    IfxAdc_CdspTriggerSel_23,    /**< \brief trigger selection 23  */
    IfxAdc_CdspTriggerSel_24,    /**< \brief trigger selection 24  */
    IfxAdc_CdspTriggerSel_25,    /**< \brief trigger selection 25  */
    IfxAdc_CdspTriggerSel_26,    /**< \brief trigger selection 26  */
    IfxAdc_CdspTriggerSel_27,    /**< \brief trigger selection 27  */
    IfxAdc_CdspTriggerSel_28,    /**< \brief trigger selection 28  */
    IfxAdc_CdspTriggerSel_29,    /**< \brief trigger selection 29  */
    IfxAdc_CdspTriggerSel_30,    /**< \brief trigger selection 30  */
    IfxAdc_CdspTriggerSel_31,    /**< \brief trigger selection 31  */
    IfxAdc_CdspTriggerSel_32,    /**< \brief trigger selection 32  */
    IfxAdc_CdspTriggerSel_33,    /**< \brief trigger selection 33  */
    IfxAdc_CdspTriggerSel_34,    /**< \brief trigger selection 34  */
    IfxAdc_CdspTriggerSel_35,    /**< \brief trigger selection 35  */
    IfxAdc_CdspTriggerSel_36,    /**< \brief trigger selection 36  */
    IfxAdc_CdspTriggerSel_37,    /**< \brief trigger selection 37  */
    IfxAdc_CdspTriggerSel_38,    /**< \brief trigger selection 38  */
    IfxAdc_CdspTriggerSel_39,    /**< \brief trigger selection 39  */
    IfxAdc_CdspTriggerSel_40,    /**< \brief trigger selection 40  */
    IfxAdc_CdspTriggerSel_41,    /**< \brief trigger selection 41  */
    IfxAdc_CdspTriggerSel_42,    /**< \brief trigger selection 42  */
    IfxAdc_CdspTriggerSel_43,    /**< \brief trigger selection 43  */
    IfxAdc_CdspTriggerSel_44,    /**< \brief trigger selection 44  */
    IfxAdc_CdspTriggerSel_45,    /**< \brief trigger selection 45  */
    IfxAdc_CdspTriggerSel_46,    /**< \brief trigger selection 46  */
    IfxAdc_CdspTriggerSel_47,    /**< \brief trigger selection 47  */
    IfxAdc_CdspTriggerSel_48,    /**< \brief trigger selection 48  */
    IfxAdc_CdspTriggerSel_49,    /**< \brief trigger selection 49  */
    IfxAdc_CdspTriggerSel_50,    /**< \brief trigger selection 50  */
    IfxAdc_CdspTriggerSel_51,    /**< \brief trigger selection 51  */
    IfxAdc_CdspTriggerSel_52,    /**< \brief trigger selection 52  */
    IfxAdc_CdspTriggerSel_53,    /**< \brief trigger selection 53  */
    IfxAdc_CdspTriggerSel_54,    /**< \brief trigger selection 54  */
    IfxAdc_CdspTriggerSel_55,    /**< \brief trigger selection 55  */
    IfxAdc_CdspTriggerSel_56,    /**< \brief trigger selection 56  */
    IfxAdc_CdspTriggerSel_57,    /**< \brief trigger selection 57  */
    IfxAdc_CdspTriggerSel_58,    /**< \brief trigger selection 58  */
    IfxAdc_CdspTriggerSel_59,    /**< \brief trigger selection 59  */
    IfxAdc_CdspTriggerSel_60,    /**< \brief trigger selection 60  */
    IfxAdc_CdspTriggerSel_61,    /**< \brief trigger selection 61  */
    IfxAdc_CdspTriggerSel_62,    /**< \brief trigger selection 62  */
    IfxAdc_CdspTriggerSel_63,    /**< \brief trigger selection 63  */
    IfxAdc_CdspTriggerSel_count  /**< \brief Number of IfxAdc_CdspTriggerSel items */
} IfxAdc_CdspTriggerSel;

/** \} */

/******************************************************************************/
/*-----------------------------Data Structures--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Adc_Std_Data_Structures
 * \{ */
/** \brief PROT and APU Configuration
 */
typedef struct
{
    IfxApProt_ProtConfig proteConfig;        /**< \brief PROTE related configuration */
    IfxApProt_ProtConfig protseConfig;       /**< \brief PROTSE related configuration */
    IfxApApu_ApuConfig   apuConfig;          /**< \brief APU Configuration */
} IfxAdc_ApConfig;

/** \} */

/** \addtogroup IfxLld_Adc_Std_Module_Adc
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Enables the clock connection to ADC module
 * \param modSFR Pointer to the ADC SFR structure
 * \return None
 */
IFX_INLINE void IfxAdc_enableModule(Ifx_ADC *modSFR);

/** \} */

/** \addtogroup IfxLld_Adc_Std_Tmadc
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Trigger a channel for conversion
 * \param tmSFR Pointer to the module SFR
 * \param channelSet Set of channels to be triggered. (All channels corresponding to bit positions set to 1 shall be triggered)
 * \return None
 */
IFX_INLINE void IfxAdc_triggerTmadcChannelSet(Ifx_ADC_TMADC *tmSFR, uint16 channelSet);

/** \brief Trigger a channel for conversion
 * \param tmSFR Pointer to the module SFR
 * \param channelId Channel to be triggered
 * \return None
 */
IFX_INLINE void IfxAdc_triggerTmadcChannel(Ifx_ADC_TMADC *tmSFR, IfxAdc_TmadcChannel channelId);

/** \brief Function that accepts the Sampling Time in NS and returns the sampling time configuration value to be written into the CHSTC register.
 * \param sampleTimeNs Sampling time of channel in NS
 * \return Sampling Time (ST) value to be written into CHSTCy register
 */
IFX_INLINE uint16 IfxAdc_getTmadcSamplingTimeValue(const float32 sampleTimeNs);

/** \brief Checks if the result is available in the result register
 * \param tmadc Pointer to the module SFR
 * \param resultRegNum result Register number
 * \return TRUE: result available
 * FALSE: result unavailable
 */
IFX_INLINE boolean IfxAdc_isTmadcResultAvailable(Ifx_ADC_TMADC *tmadc, IfxAdc_TmadcResultReg resultRegNum);

/** \brief Clears the result flag of the requested result register
 * \param tmadc Pointer to the module SFR
 * \param resultRegNum result Register number
 * \return None
 */
IFX_INLINE void IfxAdc_clearTmadcResultFlag(Ifx_ADC_TMADC *tmadc, IfxAdc_TmadcResultReg resultRegNum);

/** \brief Function that accepts the delay Time in NS and returns the delay time configuration value to be written into the CHSTC register.
 * \param delayNS trigger delay of channel in NS
 * \return trigger delay (TD) value to be written into CHSTCy register
 */
IFX_INLINE uint16 IfxAdc_getTmadcTriggerDelayValue(const float32 delayNS);

/** \brief Function to set Tmadc module to run state
 * \param tmadc Pointer to tmadc module sfr
 * \return None
 */
IFX_INLINE void IfxAdc_runTmadcModule(Ifx_ADC_TMADC *tmadc);

/** \brief Function to set Tmadc module to config state
 * \param tmadc Pointer to tmadc module sfr
 * \return None
 */
IFX_INLINE void IfxAdc_stopTmadcModule(Ifx_ADC_TMADC *tmadc);

/** \brief Function to configure a tmadc analog input pin
 * \param tmadcpin tmadc analog input Pin which should be configured
 * \param pinMode the pin input mode which should be configured
 * \param padDriver pad driver mode which should be configured
 * \return None
 */
IFX_INLINE void IfxAdc_initTmadcPin(const IfxAdc_TmadcCh_In *tmadcpin, IfxPort_InputMode pinMode, IfxPort_PadDriver padDriver);

/** \brief Function to configure external multiplexer pin
 * \param emuxPin the external multiplexer Pin which should be configured
 * \param pinMode pin output mode which should be configured
 * \param padDriver pad driver mode which should be configured
 * \return None
 */
IFX_INLINE void IfxAdc_initTmadcEmuxCtrlPin(const IfxAdc_Emuxctrl_Out *emuxPin, IfxPort_OutputMode pinMode, IfxPort_PadDriver padDriver);

/** \brief Enables the clock connection to Tmadc module
 * \param moduleId Module Id for Tmadc
 * \return None
 */
IFX_INLINE void IfxAdc_enableTmadcModule(IfxAdc_TmadcModule moduleId);

/** \brief Disables the clock connection to Tmadc module
 * \param moduleId Module Id for Tmadc
 * \return None
 */
IFX_INLINE void IfxAdc_disableTmadcModule(IfxAdc_TmadcModule moduleId);

/** \brief Read Tmadc result
 * \param moduleId Module Id for Tmadc
 * \param resultReg Result register of TMADC
 * \return Returns result
 */
IFX_INLINE sint16 IfxAdc_readTmadcResult(IfxAdc_TmadcModule moduleId, IfxAdc_TmadcResultReg resultReg);

/** \brief Read timestamp value.
 * \param moduleId Module Id for Tmadc
 * \param resultReg Result register of TMADC
 * \return Returns timestamp
 */
IFX_INLINE uint16 IfxAdc_readTmadcTimestamp(IfxAdc_TmadcModule moduleId, IfxAdc_TmadcResultReg resultReg);

/** \brief Checks if the result is available for the monitor channel in the result register
 * \param tmadc Pointer to the tmadc module SFR
 * \param channel monitor channel number
 * \return TRUE: result available
 * FALSE: result unavailable
 */
IFX_INLINE boolean IfxAdc_isTmadcMonitorChannelResultAvailable(Ifx_ADC_TMADC *tmadc, IfxAdc_TmadcMonitorChannel channel);

/** \brief Clears the result flag of the monitor channel result
 * \param tmadc Pointer to the module SFR
 * \param channel monitor channel number
 * \return None
 */
IFX_INLINE void IfxAdc_clearTmadcMonitorChannelResultFlag(Ifx_ADC_TMADC *tmadc, IfxAdc_TmadcMonitorChannel channel);

/** \brief API to get trigger error number
 * \param tmadc Pointer to the module SFR
 * \param channel channel number
 * \return Trigger error number
 */
IFX_INLINE uint8 IfxAdc_getTmadcTriggerErrorNumber(Ifx_ADC_TMADC *tmadc, IfxAdc_TmadcChannel channel);

/** \brief Checks if the hardware trigger is ignored.
 * \param tmadc Pointer to tmadc module sfr
 * \param channel channel id
 * \return TRUE: Hardware trigger is ignored
 * FALSE: No error
 */
IFX_INLINE boolean IfxAdc_isTmadcHwTriggerIgnored(Ifx_ADC_TMADC *tmadc, IfxAdc_TmadcChannel channel);

/** \brief Checks if the software trigger is ignored.
 * \param tmadc Pointer to tmadc module sfr
 * \param channel channel id
 * \return TRUE: Software trigger is ignored
 * FALSE: No error
 */
IFX_INLINE boolean IfxAdc_isTmadcSwTriggerIgnored(Ifx_ADC_TMADC *tmadc, IfxAdc_TmadcChannel channel);

/** \brief Get boundary flag output
 * \param tmadc Pointer to tmadc module sfr
 * \param boundaryReg Boundary register selection
 * \return TRUE: Boundary flag high
 * FALSE: Boundary flag low
 */
IFX_INLINE boolean IfxAdc_getTmadcBoundaryFlag(Ifx_ADC_TMADC *tmadc, IfxAdc_TmadcBoundaryReg boundaryReg);

/** \brief Check if error event occured on the channel.
 * \param tmadc Pointer to tmadc module sfr
 * \param channel channel id
 * \return TRUE: Error event occured on this channel
 * FALSE: No error event on the channel
 */
IFX_INLINE boolean IfxAdc_isTmadcErrorEventOccured(Ifx_ADC_TMADC *tmadc, IfxAdc_TmadcChannel channel);

/** \brief Check if boundary event occured on the channel.
 * \param tmadc Pointer to tmadc module sfr
 * \param resultReg Result register
 * \return TRUE: Boundary check successful
 * FALSE: Boundary check failure
 */
IFX_INLINE boolean IfxAdc_isTmadcBoundaryEventOccured(Ifx_ADC_TMADC *tmadc, IfxAdc_TmadcResultReg resultReg);

/** \brief Clear result event flag
 * \param tmadc Pointer to tmadc module sfr
 * \param channel Channel id
 * \return None
 */
IFX_INLINE void IfxAdc_clearTmadcErrorFlag(Ifx_ADC_TMADC *tmadc, IfxAdc_TmadcChannel channel);

/** \brief Clear boundary event flag
 * \param tmadc Pointer to tmadc module sfr
 * \param resultReg Result register
 * \return None
 */
IFX_INLINE void IfxAdc_clearTmadcBoundaryFlag(Ifx_ADC_TMADC *tmadc, IfxAdc_TmadcResultReg resultReg);

/** \brief Trigger a monitor channel for conversion
 * \param tmSFR Pointer to the module SFR
 * \param channelId Monitor Channel to be triggered
 * \return None
 */
IFX_INLINE void IfxAdc_triggerTmadcMonitorChannel(Ifx_ADC_TMADC *tmSFR, IfxAdc_TmadcMonitorChannel channelId);

/** \brief Function to configure TMADC event for service request node
 * \param tmSFR Pointer to the module SFR
 * \param srvNode Service request node selection
 * \param event Event selection for node
 * \return None
 */
IFX_INLINE void IfxAdc_configureTmadcEvent(Ifx_ADC_TMADC *tmSFR, IfxAdc_TmadcServReq srvNode, IfxAdc_TmadcEventSel event);

/** \brief Function to enable event for the TMADC channel or result register.
 *  If service request node is configured for result/boundary event then channel id
 *  corresponds to the result register enum. If node is configured for result/boundary event
 *  then each bit in the bit field corresponds to the result register.
 * \param tmSFR Pointer to the module SFR
 * \param srvNode Service request node selection
 * \param channelId Channel id
 * \return None
 */
IFX_INLINE void IfxAdc_enableTmadcChannelEvent(Ifx_ADC_TMADC *tmSFR, IfxAdc_TmadcServReq srvNode, IfxAdc_TmadcChannel channelId);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Function to suspend instances of Tmadc
 * \param moduleId Tmadc module id
 * \param mode Tmadc suspend mode
 * \return None
 */
IFX_EXTERN void IfxAdc_suspendTmadcModule(IfxAdc_TmadcModule moduleId, IfxAdc_TmadcSuspendMode mode);

/** \brief Returns the SRC pointer for TMADC event
 * \param moduleId Tmadc module id
 * \param node Tmadc service request node
 * \return Returens SRC pointer for give node.
 */
IFX_EXTERN volatile Ifx_SRC_SRCR *IfxAdc_getTmadcSrcPointer(IfxAdc_TmadcModule moduleId, IfxAdc_TmadcServReq node);

/** \} */

/** \addtogroup IfxLld_Adc_Std_Fcc
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Function returns the compare result DCR.
 * \param fcc Pointer to FCC module
 * \return Returns DCR value
 */
IFX_INLINE boolean IfxAdc_getFccDcrResult(Ifx_ADC_FCC *fcc);

/** \brief Function returns the current threshold vlaue(CTV) for given FCC modue
 * \param fcc Pointer to FCC module
 * \return Returns CTV value from MODSTAT register
 */
IFX_INLINE uint16 IfxAdc_getFccCurrentThresholdValue(Ifx_ADC_FCC *fcc);

/** \brief Function to set FCC module to run state
 * \param fcc Pointer to FCC module
 * \return None
 */
IFX_INLINE void IfxAdc_runFccModule(Ifx_ADC_FCC *fcc);

/** \brief Function to set Fcc module to config state
 * \param fcc Pointer to FCC module
 * \return None
 */
IFX_INLINE void IfxAdc_stopFccModule(Ifx_ADC_FCC *fcc);

/** \brief Function returns the comparison result for boundary activation check
 * \param fcc Pointer to FCC module sfr
 * \return Returns BFL (FCCx_MODSTAT.BFL) value
 */
IFX_INLINE boolean IfxAdc_getFccBoundaryFlagValue(Ifx_ADC_FCC *fcc);

/** \brief Function to update DAC with new value on Software Trigger
 * \param fcc Pointer to FCC module sfr
 * \return None
 */
IFX_INLINE void IfxAdc_triggerFccDacUpdate(Ifx_ADC_FCC *fcc);

/** \brief Function to set threshold value
 * \param fcc Pointer to FCC module sfr
 * \param thresholdValue Threshold Value for DAC update MODCFG.TV
 * \return None
 */
IFX_INLINE void IfxAdc_setFccThresholdValue(Ifx_ADC_FCC *fcc, uint16 thresholdValue);

/** \brief Function to set ramp start threshold value
 * \param fcc Pointer to FCC module sfr
 * \param thresholdValue Start threshold Value for ramp configuration
 * \return None
 */
IFX_INLINE void IfxAdc_setFccRampStartThresholdValue(Ifx_ADC_FCC *fcc, uint16 thresholdValue);

/** \brief Function to set ramp end threshold value
 * \param fcc Pointer to FCC module sfr
 * \param thresholdValue End threshold Value for ramp configuration
 * \return None
 */
IFX_INLINE void IfxAdc_setFccRampEndThresholdValue(Ifx_ADC_FCC *fcc, uint16 thresholdValue);

/** \brief Function to set step width of each ramp step
 * \param fcc Pointer to FCC module sfr
 * \param stepWidth Step width of each ramp step
 * \return None
 */
IFX_INLINE void IfxAdc_setFccRampStepWidth(Ifx_ADC_FCC *fcc, uint16 stepWidth);

/** \brief Function to set step size of each ramp step
 * \param fcc Pointer to FCC module sfr
 * \param stepSize Step size of each ramp step
 * \return None
 */
IFX_INLINE void IfxAdc_setFccRampStepSize(Ifx_ADC_FCC *fcc, uint16 stepSize);

/** \brief Function to set ramp direction
 * \param fcc Pointer to FCC module sfr
 * \param dir Direction of ramp
 * \return None
 */
IFX_INLINE void IfxAdc_setFccRampDirection(Ifx_ADC_FCC *fcc, IfxAdc_FccRampDirection dir);

/** \brief Function to start ramp software trigger
 * \param fcc Pointer to fcc module sfr
 * \return None
 */
IFX_INLINE void IfxAdc_triggerFccRamp(Ifx_ADC_FCC *fcc);

/** \brief Function to set SR0 Event selection
 * \param fcc Pointer to FCC module sfr
 * \param event Event selection for SR0
 * \return None
 */
IFX_INLINE void IfxAdc_setFccSr0EventSel(Ifx_ADC_FCC *fcc, IfxAdc_FccSr0EventSel event);

/** \brief Function to set SR1 Event selection
 * \param fcc Pointer to FCC module sfr
 * \param event Event selection for SR1
 * \return None
 */
IFX_INLINE void IfxAdc_setFccSr1EventSel(Ifx_ADC_FCC *fcc, IfxAdc_FccSr1EventSel event);

/** \brief Returns the SRC pointer for Boundary flag event
 * \param fcc Pointer to FCC module sfr
 * \param id Fcc module number
 * \return SRC pointer for FCC module
 */
IFX_INLINE volatile Ifx_SRC_SRCR *IfxAdc_getFccSr0SrcPointer(Ifx_ADC_FCC *fcc, IfxAdc_FccModule id);

/** \brief Returns the SRC pointer for normal mode or ramp mode event
 *  Normal mode --> Threshold value update
 *  Ramp mode --> End of ramp
 * \param fcc Pointer to FCC module sfr
 * \param id Fcc module number
 * \return SRC pointer for FCC module
 */
IFX_INLINE volatile Ifx_SRC_SRCR *IfxAdc_getFccSr1SrcPointer(Ifx_ADC_FCC *fcc, IfxAdc_FccModule id);

/** \brief Initializes a BFL output
 * \param bflPin BFL Pin which should be configured
 * \param pinMode pin output mode which should be configured
 * \param padDriver pad driver mode which should be configured
 * \return None
 */
IFX_INLINE void IfxAdc_initBflPin(const IfxAdc_Bfl_Out *bflPin, IfxPort_OutputMode pinMode, IfxPort_PadDriver padDriver);

/** \brief Initializes a BFL output
 * \param fccPin Fcc Pin which should be configured
 * \param pinMode pin output mode which should be configured
 * \param padDriver pad driver mode which should be configured
 * \return None
 */
IFX_INLINE void IfxAdc_initFccPin(const IfxAdc_Fcc_In *fccPin, IfxPort_InputMode pinMode, IfxPort_PadDriver padDriver);

/** \brief Enables the clock connection to Fcc module
 * \param moduleId module Id for Fcc
 * \return None
 */
IFX_INLINE void IfxAdc_enableFccModule(IfxAdc_FccModule moduleId);

/** \brief Disables the clock connection to Fcc module
 * \param moduleId module Id for Fcc
 * \return None
 */
IFX_INLINE void IfxAdc_disableFccModule(IfxAdc_FccModule moduleId);

/** \brief Set Software Boundary flag.(BFLCFG.SBFV)
 * \param fcc Pointer to FCC module sfr
 * \return None
 */
IFX_INLINE void IfxAdc_setFccBoundaryFlag(Ifx_ADC_FCC *fcc);

/** \brief Clear Software Boundary flag.(BFLCFG.SBFV)
 * \param fcc Pointer to FCC module sfr
 * \return None
 */
IFX_INLINE void IfxAdc_clearFccBoundaryFlag(Ifx_ADC_FCC *fcc);

/** \} */

/** \addtogroup IfxLld_Adc_Std_Dsadc
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Enable the filter chain of DSADC channels
 * \param channelId DSADC Channel number
 * \return None
 */
IFX_INLINE void IfxAdc_enableDsadcFilterChain(IfxAdc_DsadcChannel channelId);

/** \brief Enable the EXMOD filter chain
 * \param channelId EXMOD Channel number
 * \return None
 */
IFX_INLINE void IfxAdc_enableExmodFilterChain(IfxAdc_Exmod channelId);

/** \brief Enable DSADC channel(analog modulator)
 * \param channelId DSADC Channel number
 * \return None
 */
IFX_INLINE void IfxAdc_enableDsadcChannel(IfxAdc_DsadcChannel channelId);

/** \brief Read Auxiliary filtered result for DSADC channel
 * \param channelId DSADC Channel number
 * \return AUX result (may be a signed value)
 */
IFX_INLINE uint16 IfxAdc_getDsadcAuxResult(IfxAdc_DsadcChannel channelId);

/** \brief Read Auxiliary filtered result for EXMOD channel
 * \param channelId EXMOD Channel number
 * \return AUX result (may be a signed value)
 */
IFX_INLINE uint16 IfxAdc_getExmodAuxResult(IfxAdc_Exmod channelId);

/** \brief Get the result flag (main) of DSADC channel
 * \param channelId DSADC Channel number
 * \return TRUE: result event occurred
 */
IFX_INLINE boolean IfxAdc_getDsadcResultEvent(IfxAdc_DsadcChannel channelId);

/** \brief Get Result even (main) of EXMOD channel
 * \param channelId EXMOD Channel number
 * \return TRUE: result event occurred
 */
IFX_INLINE boolean IfxAdc_getExmodResultEvent(IfxAdc_Exmod channelId);

/** \brief Clear the result event of DSADC channel
 * \param channelId DSADC Channel number
 * \return None
 */
IFX_INLINE void IfxAdc_clearDsadcResultEvent(IfxAdc_DsadcChannel channelId);

/** \brief Clear the result event of EXMOD channel
 * \param channelId DSADC Channel number
 * \return None
 */
IFX_INLINE void IfxAdc_clearExmodResultEvent(IfxAdc_Exmod channelId);

/** \brief Get the result flag (auxiliary) of DSADC channel
 * \param channelId DSADC Channel number
 * \return TRUE: result event occurred
 */
IFX_INLINE boolean IfxAdc_getDsadcAuxResultEvent(IfxAdc_DsadcChannel channelId);

/** \brief Get Result even (auxiliary) of EXMOD channel
 * \param channelId EXMOD Channel number
 * \return TRUE: result event occurred
 */
IFX_INLINE boolean IfxAdc_getExmodAuxResultEvent(IfxAdc_Exmod channelId);

/** \brief Clear the result event of DSADC channel
 * \param channelId DSADC Channel number
 * \return None
 */
IFX_INLINE void IfxAdc_clearDsadcAuxResultEvent(IfxAdc_DsadcChannel channelId);

/** \brief Clear the result event (auxiliary) of EXMOD channel
 * \param channelId DSADC Channel number
 * \return None
 */
IFX_INLINE void IfxAdc_clearExmodAuxResultEvent(IfxAdc_Exmod channelId);

/** \brief get FIFO fill level of DSADC channel
 * \param channelId DSADC Channel number
 * \return FIFO fill level
 */
IFX_INLINE uint8 IfxAdc_getDsadcFifoFillLevel(IfxAdc_DsadcChannel channelId);

/** \brief get FIFO fill level of EXMOD channel
 * \param channelId DSADC Channel number
 * \return FIFO fill level
 */
IFX_INLINE uint8 IfxAdc_getExmodFifoFillLevel(IfxAdc_Exmod channelId);

/** \brief Disable DSADC channel
 * \param channelId DSADC Channel number
 * \return None
 */
IFX_INLINE void IfxAdc_disableDsadcChannel(IfxAdc_DsadcChannel channelId);

/** \brief Disable the EXMOD channel
 * \param channelId EXMOD Channel number
 * \return None
 */
IFX_INLINE void IfxAdc_disableExmodChannel(IfxAdc_Exmod channelId);

/** \brief Function to start the Integrator window by SW
 * \param channelId DSADC Channel number
 * \return None
 */
IFX_INLINE void IfxAdc_startDsadcIntegratorWindow(IfxAdc_DsadcChannel channelId);

/** \brief Function to stop the DSADC Integrator Window by SW
 * \param channelId DSADC Channel number
 * \return None
 */
IFX_INLINE void IfxAdc_stopDsadcIntegratorWindow(IfxAdc_DsadcChannel channelId);

/** \brief Initializes a Dsadc negative analog input channel
 * \param dsadcnegpin Dsadc Pin which should be configured
 * \param pinMode pin output mode which should be configured
 * \param padDriver pad driver mode which should be configured
 * \return None
 */
IFX_INLINE void IfxAdc_initDsadcnPin(const IfxAdc_Dsadcn_In *dsadcnegpin, IfxPort_InputMode pinMode, IfxPort_PadDriver padDriver);

/** \brief Initializes a Dsadc negative analog input channel
 * \param dsadcpospin Dsadc Pin which should be configured
 * \param pinMode the pin input mode which should be configured
 * \param padDriver pad driver mode which should be configured
 * \return None
 */
IFX_INLINE void IfxAdc_initDsadcpPin(const IfxAdc_Dsadcp_In *dsadcpospin, IfxPort_InputMode pinMode, IfxPort_PadDriver padDriver);

/** \brief Function to configure  DSadc trigger input
 * \param trigpin Dsadc Pin which should be configured
 * \param pinMode the pin input mode which should be configured
 * \param padDriver pad driver mode which should be configured
 * \return None
 */
IFX_INLINE void IfxAdc_initDsadcTrigPin(const IfxAdc_Trig_In *trigpin, IfxPort_InputMode pinMode, IfxPort_PadDriver padDriver);

/** \brief Function to configure  Exmod clock input
 * \param clkpin clock Pin which should be configured
 * \param pinMode the pin input mode which should be configured
 * \param padDriver pad driver mode which should be configured
 * \return None
 */
IFX_INLINE void IfxAdc_initExmodClockPin(const IfxAdc_Clkin_In *clkpin, IfxPort_InputMode pinMode, IfxPort_PadDriver padDriver);

/** \brief Function to configure  Exmod data input source
 * \param datapin data source Pin which should be configured
 * \param pinMode the pin input mode which should be configured
 * \param padDriver pad driver mode which should be configured
 * \return None
 */
IFX_INLINE void IfxAdc_initExmodDataPin(const IfxAdc_Data_In *datapin, IfxPort_InputMode pinMode, IfxPort_PadDriver padDriver);

/** \brief Function to configure  Exmod data input source
 * \param signpin the Sign signal input Pin which should be configured
 * \param pinMode the pin input mode which should be configured
 * \param padDriver pad driver mode which should be configured
 * \return None
 */
IFX_INLINE void IfxAdc_initSignSignalPin(const IfxAdc_Sign_In *signpin, IfxPort_InputMode pinMode, IfxPort_PadDriver padDriver);

/** \brief Function to configure a PWM output pin
 * \param cgPwm the Sign signal input Pin which should be configured
 * \param pinMode the pin input mode which should be configured
 * \param padDriver pad driver mode which should be configured
 * \return None
 */
IFX_INLINE void IfxAdc_initCgPwmPin(const IfxAdc_Pwm_Out *cgPwm, IfxPort_OutputMode pinMode, IfxPort_PadDriver padDriver);

/** \brief Enables the clock connection to Dsadc channel
 * \param channelId Channel Id for Dsadc
 * \return None
 */
IFX_INLINE void IfxAdc_enableDsadcClock(IfxAdc_DsadcChannel channelId);

/** \brief Enables the clock connection to Exmod channel
 * \param channelId Channel Id for Exmod
 * \return None
 */
IFX_INLINE void IfxAdc_enableExmodClock(IfxAdc_Exmod channelId);

/** \brief Enable global part of Dsadc and Exmod
 * \return None
 */
IFX_INLINE void IfxAdc_enableDsadcGlobal(void);

/** \brief Starts Dsadc calibration algorithm
 * \param channelId Dsadc channel id
 * \return None
 */
IFX_INLINE void IfxAdc_triggerDsadcCalibration(IfxAdc_DsadcChannel channelId);

/** \brief Get Dsadc calibration status
 * \param channelId Dsadc channel Id
 * \return Calibration status for Dsadc channel
 */
IFX_INLINE IfxAdc_DsadcCalibrationState IfxAdc_getDsadcCalibrationStatus(IfxAdc_DsadcChannel channelId);

/** \brief Get Dsadc boundary event flag
 * \param channelId Dsadc channel Id
 * \return Returns boundary event status for the channel
 * TRUE --> Boundary Event occurred
 * FALSE --> Boundary event not occurred
 */
IFX_INLINE boolean IfxAdc_isDsadcBoundaryEventOccurred(IfxAdc_DsadcChannel channelId);

/** \brief Api to clear Dsadc boundary event flag
 * \param channelId Dsadc channel Id
 * \return None
 */
IFX_INLINE void IfxAdc_clearDsadcBoundaryFlag(IfxAdc_DsadcChannel channelId);

/** \brief Get Exmod boundary event flag
 * \param channelId Exmod channel Id
 * \return Returns boundary event status for the channel
 * TRUE --> Boundary Event occurred
 * FALSE --> Boundary event not occurred
 */
IFX_INLINE boolean IfxAdc_isExmodBoundaryEventOccurred(IfxAdc_Exmod channelId);

/** \brief Api to clear Exmod boundary event flag
 * \param channelId Exmod channel Id
 * \return None
 */
IFX_INLINE void IfxAdc_clearExmodBoundaryFlag(IfxAdc_Exmod channelId);

/** \brief Function to configure  Exmod clock output
 * \param clkpin clock Pin which should be configured
 * \param pinMode the pin input mode which should be configured
 * \param padDriver pad driver mode which should be configured
 * \return None
 */
IFX_INLINE void IfxAdc_initExmodClockOutPin(const IfxAdc_Clkout_Out *clkpin, IfxPort_OutputMode pinMode, IfxPort_PadDriver padDriver);

/** \brief Function to set dsadc input pin
 * \param channelId Dsadc channel Id
 * \param inputSelect Input pin selection
 * \return None
 */
IFX_INLINE void IfxAdc_setDsadcInputPin(IfxAdc_DsadcChannel channelId, IfxAdc_DsadcInSel inputSelect);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Returns the SRC pointer for DSADC event.
 * \param channelId Dsadc channel id
 * \param node Dsadc Service request node
 * \return Returns SRC pointer for service request node of Dsadc channel.
 */
IFX_EXTERN volatile Ifx_SRC_SRCR *IfxAdc_getDsadcSrcPointer(IfxAdc_DsadcChannel channelId, uint8 node);

/** \brief Returns the SRC pointer for Exmod event
 * \param channelId Exmod channel id
 * \param node Exmod Service request node
 * \return Returns SRC pointer for Exmod Service request node.
 */
IFX_EXTERN volatile Ifx_SRC_SRCR *IfxAdc_getExmodSrcPointer(IfxAdc_Exmod channelId, uint8 node);

/** \} */

/** \addtogroup IfxLld_Adc_Std_Prot_Apu
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Initializes the PROTs and APU with default value
 * \param config PROT and APU Config
 * \return None
 */
IFX_INLINE void IfxAdc_initApConfig(IfxAdc_ApConfig *config);

/** \brief Initialize the APU
 * \param adc ADC module pointer
 * \param config APU config pointer
 * \param id Access Protection Unit id
 * \return None
 */
IFX_INLINE void IfxAdc_initApu(Ifx_ADC *adc, IfxApApu_ApuConfig *config, IfxAdc_Apu id);

/** \brief Function to initialize PROTE
 * \param adc ADC module pointer
 * \param config PROT configuration
 * \param id PROTE register
 * \return status of the PROT initialization
 */
IFX_INLINE IfxApProt_Status IfxAdc_initProtE(Ifx_ADC *adc, IfxApProt_ProtConfig *config, IfxAdc_ProtE id);

/** \brief Function to initialize PROTSE
 * \param adc ADC module pointer
 * \param config PROT configuration
 * \return status of the PROT initialization
 */
IFX_INLINE IfxApProt_Status IfxAdc_initProtSE(Ifx_ADC *adc, IfxApProt_ProtConfig *config);

/** \brief Function to set APU assignment for Tmadc resource
 * \param adc ADC module pointer
 * \param moduleId Tmadc module id
 * \param apuId APU id
 * \return None
 */
IFX_INLINE void IfxAdc_initTmadcResource(Ifx_ADC *adc, IfxAdc_TmadcModule moduleId, IfxAdc_Apu apuId);

/** \brief Function to set APU assignment for Global resource
 * \param adc ADC module pointer
 * \param resourceId Options for Global adc, dsadc and cdsp
 * \param apuId APU id
 * \return None
 */
IFX_INLINE void IfxAdc_initGlobalResource(Ifx_ADC *adc, IfxAdc_GlobalResource resourceId, IfxAdc_Apu apuId);

/** \brief Function to set APU assignment for Fcc resource
 * \param adc ADC module pointer
 * \param moduleId Fcc module id
 * \param apuId APU id
 * \return None
 */
IFX_INLINE void IfxAdc_initFccResource(Ifx_ADC *adc, IfxAdc_FccModule moduleId, IfxAdc_Apu apuId);

/** \brief Function to set APU assignment for Dsadc resource
 * \param adc ADC module pointer
 * \param channelId Dsadc channel id
 * \param apuId APU id
 * \return None
 */
IFX_INLINE void IfxAdc_initDsadcResource(Ifx_ADC *adc, IfxAdc_DsadcChannel channelId, IfxAdc_Apu apuId);

/** \brief Function to set APU assignment for Exmod resource
 * \param adc ADC module pointer
 * \param exmodId Exmodl id
 * \param apuId APU id
 * \return None
 */
IFX_INLINE void IfxAdc_initExmodResource(Ifx_ADC *adc, IfxAdc_Exmod exmodId, IfxAdc_Apu apuId);

/** \brief Function to set APU assignment for CDSP resource
 * \param adc ADC module pointer
 * \param cdspId Cdsp core id
 * \param apuId APU id
 * \return None
 */
IFX_INLINE void IfxAdc_initCdspResource(Ifx_ADC *adc, IfxAdc_CdspCore cdspId, IfxAdc_Apu apuId);

/** \} */

/** \addtogroup IfxLld_Adc_Std_Cdsp
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Function to enable DSP clock
 * \param coreId Dsp core
 * \return None
 */
IFX_INLINE void IfxAdc_enableCdspClock(IfxAdc_CdspCore coreId);

/** \brief Function to get the sleep status of DSP core
 * \param cdsp Pointer to cdsp module sfr
 * \param coreId Dsp core
 * \return TRUE --> DSP core is in sleep mode
 */
IFX_INLINE boolean IfxAdc_getCdspCoreSleepStatus(Ifx_ADC_CDSP *cdsp, IfxAdc_CdspCore coreId);

/** \brief Function to clear wakeup error.
 * \param cdsp Pointer to cdsp module sfr
 * \param coreId Dsp core
 * \return None
 */
IFX_INLINE void IfxAdc_clearCdspWakeupError(Ifx_ADC_CDSP *cdsp, IfxAdc_CdspCore coreId);

/** \brief Function to get the wakeup error event
 * \param cdsp Pointer to cdsp module sfr
 * \param coreId Dsp Core
 * \return Returns Cdsp wakeup error event status for Cdsp core
 */
IFX_INLINE boolean IfxAdc_getCdspWakeupErrorStatus(Ifx_ADC_CDSP *cdsp, IfxAdc_CdspCore coreId);

/** \brief Function to run DSP core
 * \param cdsp Pointer to cdsp module sfr
 * \param coreId Dsp Core
 * \return None
 */
IFX_INLINE void IfxAdc_runCdspCore(Ifx_ADC_CDSP *cdsp, IfxAdc_CdspCore coreId);

/** \brief Get the result flag of DSP core
 * \param cdsp Pointer to cdsp module sfr
 * \param coreId DSP core
 * \param reg DSP core result register
 * \return TRUE: result event occurred
 */
IFX_INLINE boolean IfxAdc_getCdspResultEvent(Ifx_ADC_CDSP *cdsp, IfxAdc_CdspCore coreId, IfxAdc_CdspResultReg reg);

/** \brief Get FIFO fill level of DSP core
 * \param cdsp Pointer to cdsp module sfr
 * \param coreId Dsp core
 * \return Returns FIFO fill level
 */
IFX_INLINE uint8 IfxAdc_getCdspFifoFillLevel(Ifx_ADC_CDSP *cdsp, IfxAdc_CdspCore coreId);

/** \brief Enable clock for global part of CDSP
 * \return None
 */
IFX_INLINE void IfxAdc_enableCdspGlobal(void);

/** \brief Function to reset Cdsp core. (Module Reset)
 * \param cdsp Pointer to cdsp module sfr
 * \param coreId Dsp core
 * \return None
 */
IFX_INLINE void IfxAdc_resetCdspCore(Ifx_ADC_CDSP *cdsp, IfxAdc_CdspCore coreId);

/** \brief Function to halt Cdsp core.
 * \param cdsp Pointer to cdsp module sfr
 * \param coreId Dsp core
 * \return None
 */
IFX_INLINE void IfxAdc_haltCdspCore(Ifx_ADC_CDSP *cdsp, IfxAdc_CdspCore coreId);

/** \brief Function to copy data from source address to destination address
 * \param srcAddr source address
 * \param destAddr Destination address
 * \param size Data size to be transfered.
 * \return None
 */
IFX_INLINE void IfxAdc_loadCdspMemory(void *srcAddr, void *destAddr, uint16 size);

/** \brief Clear the result event flag of DSP core
 * \param cdsp Pointer to cdsp module sfr
 * \param coreId Dsp core
 * \param reg DSP core result register
 * \return None
 */
IFX_INLINE void IfxAdc_clearCdspResultEvent(Ifx_ADC_CDSP *cdsp, IfxAdc_CdspCore coreId, IfxAdc_CdspResultReg reg);

/** \brief Function to get the halt status of DSP core
 * \param cdsp Pointer to cdsp module sfr
 * \param coreId Dsp core
 * \return TRUE --> DSP core is in halt state
 */
IFX_INLINE boolean IfxAdc_getCdspCoreHaltStatus(Ifx_ADC_CDSP *cdsp, IfxAdc_CdspCore coreId);

/** \brief Function to start the Integrator window by SW
 * \param cdsp Pointer to cdsp module sfr
 * \param coreId Dsp core
 * \return None
 */
IFX_INLINE void IfxAdc_startCdspIntegratorWindow(Ifx_ADC_CDSP *cdsp, IfxAdc_CdspCore coreId);

/** \brief Function to stop the CDSP Integrator Window by SW
 * \param cdsp Pointer to cdsp module sfr
 * \param coreId Dsp core
 * \return None
 */
IFX_INLINE void IfxAdc_stopCdspIntegratorWindow(Ifx_ADC_CDSP *cdsp, IfxAdc_CdspCore coreId);

/** \brief Function to get boundary event flag
 * \param cdsp Pointer to cdsp module sfr
 * \param coreId Dsp core
 * \return TRUE --> Boundary Event occured
 */
IFX_INLINE boolean IfxAdc_getCdspBoundaryEvent(Ifx_ADC_CDSP *cdsp, IfxAdc_CdspCore coreId);

/** \brief Clear the boundary event flag of DSP core
 * \param cdsp Pointer to cdsp module sfr
 * \param coreId Dsp core
 * \return None
 */
IFX_INLINE void IfxAdc_clearCdspBoundaryEvent(Ifx_ADC_CDSP *cdsp, IfxAdc_CdspCore coreId);

/** \brief Clear the boundary event flag of DSP core
 * \param cdsp Pointer to cdsp module sfr
 * \param coreId Dsp core
 * \param error Error selection
 * \return None
 */
IFX_INLINE void IfxAdc_clearCdspError(Ifx_ADC_CDSP *cdsp, IfxAdc_CdspCore coreId, IfxAdc_CdspError error);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Function to suspend Cdsp core
 * \param coreId Dsp core
 * \param mode Cdsp suspend mode
 * \return None
 */
IFX_EXTERN void IfxAdc_suspendCdspCore(IfxAdc_CdspCore coreId, IfxAdc_CdspSuspendMode mode);

/** \brief Returns the SRC pointer for CDSP event
 * \param coreId Dsp core
 * \param node CDSP Service request node
 * \return Returns SRC pointer for service request node of DSP core
 */
IFX_EXTERN volatile Ifx_SRC_SRCR *IfxAdc_getCdspSrcPointer(IfxAdc_CdspCore coreId, uint8 node);

/** \} */

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Configures access to all masters to all the ADC in the device
 * \param apConfig pointer to configuration structure
 * \return None
 */
IFX_EXTERN void IfxAdc_configureAccessToAdc(IfxApApu_ApuConfig *apConfig);

/******************************************************************************/
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE void IfxAdc_enableModule(Ifx_ADC *modSFR)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_ADC.PROTE[0], IfxApProt_State_config);
#endif
    modSFR->CLC.B.DISR = 0U;
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_ADC.PROTE[0], IfxApProt_State_run);
#endif

    while (modSFR->CLC.B.DISS == 1U)
    {
        /* wait until module is enabled */
    }
}


IFX_INLINE void IfxAdc_enableDsadcFilterChain(IfxAdc_DsadcChannel channelId)
{
#if !defined(IFX_ILLD_PPU_USAGE)
    __dsync(); /* TC49xA Errata : Dsync required before each RMW operation*/
#endif
    Ifx__imaskldmst(&MODULE_ADC.DSADC.GLOBRCF.U, 1u, channelId, 1u);
}


IFX_INLINE void IfxAdc_enableExmodFilterChain(IfxAdc_Exmod channelId)
{
    uint32 shift = channelId + 16u;
#if !defined(IFX_ILLD_PPU_USAGE)
    __dsync(); /* TC49xA Errata : Dsync required before each RMW operation*/
#endif
    Ifx__imaskldmst(&MODULE_ADC.DSADC.GLOBRCF.U, 1u, shift, 1u);
}


IFX_INLINE void IfxAdc_enableDsadcChannel(IfxAdc_DsadcChannel channelId)
{
#if !defined(IFX_ILLD_PPU_USAGE)
    __dsync(); /* TC49xA Errata : Dsync required before each RMW operation*/
#endif
    Ifx__imaskldmst(&MODULE_ADC.DSADC.GLOBRCM.U, 1u, channelId, 1u);
}


IFX_INLINE uint16 IfxAdc_getDsadcAuxResult(IfxAdc_DsadcChannel channelId)
{
    return MODULE_ADC.DSADC.IN[channelId].RESA.B.RESULT;
}


IFX_INLINE uint16 IfxAdc_getExmodAuxResult(IfxAdc_Exmod channelId)
{
    return MODULE_ADC.DSADC.EX[channelId].RESA.B.RESULT;
}


IFX_INLINE boolean IfxAdc_getDsadcResultEvent(IfxAdc_DsadcChannel channelId)
{
    boolean event = FALSE;

    if ((MODULE_ADC.DSADC.RESMF.U & (1u << channelId)) != 0u)
    {
        event = TRUE;
    }

    return event;
}


IFX_INLINE boolean IfxAdc_getExmodResultEvent(IfxAdc_Exmod channelId)
{
    boolean event = FALSE;
    uint32  shift = channelId + 16u;

    if ((MODULE_ADC.DSADC.RESMF.U & (1u << shift)) != 0u)
    {
        event = TRUE;
    }

    return event;
}


IFX_INLINE void IfxAdc_clearDsadcResultEvent(IfxAdc_DsadcChannel channelId)
{
#if !defined(IFX_ILLD_PPU_USAGE)
    __dsync(); /* TC49xA Errata : Dsync required before each RMW operation*/
#endif
    Ifx__imaskldmst(&MODULE_ADC.DSADC.RESMFCL.U, 1u, channelId, 1u);
}


IFX_INLINE void IfxAdc_clearExmodResultEvent(IfxAdc_Exmod channelId)
{
    uint32 shift = channelId + 16u;
#if !defined(IFX_ILLD_PPU_USAGE)
    __dsync(); /* TC49xA Errata : Dsync required before each RMW operation*/
#endif
    Ifx__imaskldmst(&MODULE_ADC.DSADC.RESMFCL.U, 1u, shift, 1u);
}


IFX_INLINE boolean IfxAdc_getDsadcAuxResultEvent(IfxAdc_DsadcChannel channelId)
{
    boolean event = FALSE;

    if ((MODULE_ADC.DSADC.RESAF.U & (1u << channelId)) != 0u)
    {
        event = TRUE;
    }

    return event;
}


IFX_INLINE boolean IfxAdc_getExmodAuxResultEvent(IfxAdc_Exmod channelId)
{
    boolean event = FALSE;
    uint32  shift = channelId + 16u;

    if ((MODULE_ADC.DSADC.RESAF.U & (1u << shift)) != 0u)
    {
        event = TRUE;
    }

    return event;
}


IFX_INLINE void IfxAdc_clearDsadcAuxResultEvent(IfxAdc_DsadcChannel channelId)
{
#if !defined(IFX_ILLD_PPU_USAGE)
    __dsync(); /* TC49xA Errata : Dsync required before each RMW operation*/
#endif
    Ifx__imaskldmst(&MODULE_ADC.DSADC.RESAFCL.U, 1u, channelId, 1u);
}


IFX_INLINE void IfxAdc_clearExmodAuxResultEvent(IfxAdc_Exmod channelId)
{
    uint32 shift = channelId + 16u;
#if !defined(IFX_ILLD_PPU_USAGE)
    __dsync(); /* TC49xA Errata : Dsync required before each RMW operation*/
#endif
    Ifx__imaskldmst(&MODULE_ADC.DSADC.RESAFCL.U, 1u, shift, 1u);
}


IFX_INLINE uint8 IfxAdc_getDsadcFifoFillLevel(IfxAdc_DsadcChannel channelId)
{
    return (uint8)(MODULE_ADC.DSADC.IN[channelId].CHST.B.FILL);
}


IFX_INLINE uint8 IfxAdc_getExmodFifoFillLevel(IfxAdc_Exmod channelId)
{
    return (uint8)(MODULE_ADC.DSADC.EX[channelId].CHST.B.FILL);
}


IFX_INLINE void IfxAdc_disableDsadcChannel(IfxAdc_DsadcChannel channelId)
{
#if !defined(IFX_ILLD_PPU_USAGE)
    __dsync(); /* TC49xA Errata : Dsync required before each RMW operation*/
#endif
    Ifx__imaskldmst(&MODULE_ADC.DSADC.GLOBRCF.U, 0u, channelId, 1u);
#if !defined(IFX_ILLD_PPU_USAGE)
    __dsync(); /* TC49xA Errata : Dsync required before each RMW operation*/
#endif
    Ifx__imaskldmst(&MODULE_ADC.DSADC.GLOBRCM.U, 0u, channelId, 1u);
}


IFX_INLINE void IfxAdc_disableExmodChannel(IfxAdc_Exmod channelId)
{
    uint32 shift = channelId + 16u;
#if !defined(IFX_ILLD_PPU_USAGE)
    __dsync(); /* TC49xA Errata : Dsync required before each RMW operation*/
#endif
    Ifx__imaskldmst(&MODULE_ADC.DSADC.GLOBRCF.U, 0u, shift, 1u);
}


IFX_INLINE void IfxAdc_startDsadcIntegratorWindow(IfxAdc_DsadcChannel channelId)
{
    MODULE_ADC.DSADC.IN[channelId].INTCFG.B.INTEN = 1u;
}


IFX_INLINE void IfxAdc_stopDsadcIntegratorWindow(IfxAdc_DsadcChannel channelId)
{
    MODULE_ADC.DSADC.IN[channelId].INTTRCFG.B.INTTRM = 0u;
}


IFX_INLINE boolean IfxAdc_getFccDcrResult(Ifx_ADC_FCC *fcc)
{
    return (fcc->MODSTAT.B.DCR);
}


IFX_INLINE uint16 IfxAdc_getFccCurrentThresholdValue(Ifx_ADC_FCC *fcc)
{
    return (fcc->MODSTAT.B.CTV);
}


IFX_INLINE void IfxAdc_runFccModule(Ifx_ADC_FCC *fcc)
{
    fcc->MODEN.B.RUN = 1;
}


IFX_INLINE void IfxAdc_stopFccModule(Ifx_ADC_FCC *fcc)
{
    fcc->MODEN.B.RUN = 0;
}


IFX_INLINE boolean IfxAdc_getFccBoundaryFlagValue(Ifx_ADC_FCC *fcc)
{
    return fcc->MODSTAT.B.BFL;
}


IFX_INLINE void IfxAdc_triggerFccDacUpdate(Ifx_ADC_FCC *fcc)
{
    fcc->MODCFG.B.SWTR = 1;
}


IFX_INLINE void IfxAdc_setFccThresholdValue(Ifx_ADC_FCC *fcc, uint16 thresholdValue)
{
    fcc->MODCFG.B.TV = thresholdValue;
}


IFX_INLINE void IfxAdc_setFccRampStartThresholdValue(Ifx_ADC_FCC *fcc, uint16 thresholdValue)
{
    fcc->RMPT.B.STV = thresholdValue;
}


IFX_INLINE void IfxAdc_setFccRampEndThresholdValue(Ifx_ADC_FCC *fcc, uint16 thresholdValue)
{
    fcc->RMPT.B.ETV = thresholdValue;
}


IFX_INLINE void IfxAdc_setFccRampStepWidth(Ifx_ADC_FCC *fcc, uint16 stepWidth)
{
    fcc->RMPCFG.B.STEPWD = stepWidth;
}


IFX_INLINE void IfxAdc_setFccRampStepSize(Ifx_ADC_FCC *fcc, uint16 stepSize)
{
    fcc->RMPCFG.B.STEPSZ = stepSize;
}


IFX_INLINE void IfxAdc_setFccRampDirection(Ifx_ADC_FCC *fcc, IfxAdc_FccRampDirection dir)
{
    fcc->RMPCFG.B.DIR = dir;
}


IFX_INLINE void IfxAdc_triggerFccRamp(Ifx_ADC_FCC *fcc)
{
    fcc->RMPCFG.B.RSWTR = 1u;
}


IFX_INLINE void IfxAdc_setFccSr0EventSel(Ifx_ADC_FCC *fcc, IfxAdc_FccSr0EventSel event)
{
    fcc->SRCFG.B.SR0EVSEL = event;
}


IFX_INLINE void IfxAdc_setFccSr1EventSel(Ifx_ADC_FCC *fcc, IfxAdc_FccSr1EventSel event)
{
    fcc->SRCFG.B.SR1EVSEL = event;
}


IFX_INLINE volatile Ifx_SRC_SRCR *IfxAdc_getFccSr0SrcPointer(Ifx_ADC_FCC *fcc, IfxAdc_FccModule id)
{
    return (volatile Ifx_SRC_SRCR *)(&MODULE_SRC.FCC[id].SR[0]);
}


IFX_INLINE volatile Ifx_SRC_SRCR *IfxAdc_getFccSr1SrcPointer(Ifx_ADC_FCC *fcc, IfxAdc_FccModule id)
{
    return (volatile Ifx_SRC_SRCR *)(&MODULE_SRC.FCC[id].SR[1]);
}


IFX_INLINE void IfxAdc_triggerTmadcChannelSet(Ifx_ADC_TMADC *tmSFR, uint16 channelSet)
{
    tmSFR->SWTRCFG.B.SCHSEL = channelSet;
}


IFX_INLINE void IfxAdc_triggerTmadcChannel(Ifx_ADC_TMADC *tmSFR, IfxAdc_TmadcChannel channelId)
{
    tmSFR->SWTRCFG.B.SCHSEL = (uint16)(1 << channelId);
}


IFX_INLINE uint16 IfxAdc_getTmadcSamplingTimeValue(const float32 sampleTimeNs)
{
    uint16 stVal;
    uint32 reqSampleTime = (uint32)(sampleTimeNs * 10U);

    for (stVal = 0; stVal < 0xFFFF; stVal++)
    {
        if ((uint32)(125 * (stVal + 1)) >= reqSampleTime)
        {
            break; /* break out. stVal value has matched sampling time */
        }
    }

    if (stVal < 3U)
    {
        stVal = 3U;
    }

    return stVal;
}


IFX_INLINE boolean IfxAdc_isTmadcResultAvailable(Ifx_ADC_TMADC *tmadc, IfxAdc_TmadcResultReg resultRegNum)
{
    uint32 resultEvent = tmadc->RESF.B.RESEV;

    return (resultEvent & ((uint32)1 << resultRegNum)) != (uint32)0;
}


IFX_INLINE void IfxAdc_clearTmadcResultFlag(Ifx_ADC_TMADC *tmadc, IfxAdc_TmadcResultReg resultRegNum)
{
    tmadc->RESFCLR.B.RESEVCLR = ((uint32)1 << resultRegNum);
}


IFX_INLINE uint16 IfxAdc_getTmadcTriggerDelayValue(const float32 delayNS)
{
    uint16 delayVal;
    uint32 reqDelay = (uint32)(delayNS * 10U);

    for (delayVal = 0; delayVal < 0xFFFF; delayVal++)
    {
        if ((uint32)(125 * (delayVal + 1)) >= reqDelay)
        {
            break; /* break out. stVal value has matched sampling time */
        }
    }

    return delayVal;
}


IFX_INLINE void IfxAdc_runTmadcModule(Ifx_ADC_TMADC *tmadc)
{
    tmadc->MODCFG.B.RUN = 1u;
}


IFX_INLINE void IfxAdc_stopTmadcModule(Ifx_ADC_TMADC *tmadc)
{
    tmadc->MODCFG.B.RUN = 0u;
}


IFX_INLINE void IfxAdc_enableCdspClock(IfxAdc_CdspCore coreId)
{
    uint32 offset = coreId + IFX_ADC_CLKEN_CDSP_CDSPEN_OFF;
#if !defined(IFX_ILLD_PPU_USAGE)
    __dsync(); /* TC49xA Errata : Dsync required before each RMW operation*/
#endif
    Ifx__imaskldmst(&MODULE_ADC.CLKEN.CDSP.U, 1u, offset, 1u);
}


IFX_INLINE boolean IfxAdc_getCdspCoreSleepStatus(Ifx_ADC_CDSP *cdsp, IfxAdc_CdspCore coreId)
{
    boolean event = FALSE;

    if ((cdsp->SLPST.U & (1u << coreId)) != 0u)
    {
        event = TRUE;
    }

    return event;
}


IFX_INLINE void IfxAdc_clearCdspWakeupError(Ifx_ADC_CDSP *cdsp, IfxAdc_CdspCore coreId)
{
#if !defined(IFX_ILLD_PPU_USAGE)
    __dsync(); /* TC49xA Errata : Dsync required before each RMW operation*/
#endif
    Ifx__imaskldmst(&cdsp->WUERRCL.U, 1u, coreId, 1u);
}


IFX_INLINE boolean IfxAdc_getCdspWakeupErrorStatus(Ifx_ADC_CDSP *cdsp, IfxAdc_CdspCore coreId)
{
    boolean event = FALSE;

    if ((cdsp->WUERREV.U & (1u << coreId)) != 0u)
    {
        event = TRUE;
    }

    return event;
}


IFX_INLINE void IfxAdc_runCdspCore(Ifx_ADC_CDSP *cdsp, IfxAdc_CdspCore coreId)
{
#if !defined(IFX_ILLD_PPU_USAGE)
    __dsync(); /* TC49xA Errata : Dsync required before each RMW operation*/
#endif
    Ifx__imaskldmst(&cdsp->GLOBRCD.U, 1u, coreId, 1u);

    while (((cdsp->GLOBRSD.U >> coreId) & 0x1u) != 1u)
    {
        /* Wait for core to run */
    }
}


IFX_INLINE boolean IfxAdc_getCdspResultEvent(Ifx_ADC_CDSP *cdsp, IfxAdc_CdspCore coreId, IfxAdc_CdspResultReg reg)
{
    boolean event = FALSE;

    if ((cdsp->RESEV[reg].U & (1u << coreId)) != 0u)
    {
        event = TRUE;
    }

    return event;
}


IFX_INLINE uint8 IfxAdc_getCdspFifoFillLevel(Ifx_ADC_CDSP *cdsp, IfxAdc_CdspCore coreId)
{
    return (uint8)(cdsp->DSP[coreId].DSPST.B.FILL);
}


IFX_INLINE void IfxAdc_initBflPin(const IfxAdc_Bfl_Out *bflPin, IfxPort_OutputMode pinMode, IfxPort_PadDriver padDriver)
{
    if ((bflPin != NULL_PTR) && (bflPin->pin.port != NULL_PTR))
    {
        IfxPort_setPinModeOutput(bflPin->pin.port, bflPin->pin.pinIndex, pinMode, bflPin->select);
        IfxPort_setPinPadDriver(bflPin->pin.port, bflPin->pin.pinIndex, padDriver);
    }
}


IFX_INLINE void IfxAdc_initFccPin(const IfxAdc_Fcc_In *fccPin, IfxPort_InputMode pinMode, IfxPort_PadDriver padDriver)
{
    if ((fccPin != NULL_PTR) && (fccPin->pin.port != NULL_PTR))
    {
        IfxPort_setPinModeInput(fccPin->pin.port, fccPin->pin.pinIndex, pinMode);
        IfxPort_setPinPadDriver(fccPin->pin.port, fccPin->pin.pinIndex, padDriver);
        IfxPort_setPinFunctionMode(fccPin->pin.port, fccPin->pin.pinIndex, IfxPort_PinFunctionMode_analog);
    }
}


IFX_INLINE void IfxAdc_initDsadcnPin(const IfxAdc_Dsadcn_In *dsadcnegpin, IfxPort_InputMode pinMode, IfxPort_PadDriver padDriver)
{
    if (dsadcnegpin->pin.port != NULL_PTR)
    {
        IfxPort_setPinModeInput(dsadcnegpin->pin.port, dsadcnegpin->pin.pinIndex, pinMode);
        IfxPort_setPinPadDriver(dsadcnegpin->pin.port, dsadcnegpin->pin.pinIndex, padDriver);
        IfxPort_setPinFunctionMode(dsadcnegpin->pin.port, dsadcnegpin->pin.pinIndex, IfxPort_PinFunctionMode_analog);
    }
}


IFX_INLINE void IfxAdc_initDsadcpPin(const IfxAdc_Dsadcp_In *dsadcpospin, IfxPort_InputMode pinMode, IfxPort_PadDriver padDriver)
{
    if (dsadcpospin->pin.port != NULL_PTR)
    {
        IfxPort_setPinModeInput(dsadcpospin->pin.port, dsadcpospin->pin.pinIndex, pinMode);
        IfxPort_setPinPadDriver(dsadcpospin->pin.port, dsadcpospin->pin.pinIndex, padDriver);
        IfxPort_setPinFunctionMode(dsadcpospin->pin.port, dsadcpospin->pin.pinIndex, IfxPort_PinFunctionMode_analog);
    }
}


IFX_INLINE void IfxAdc_initDsadcTrigPin(const IfxAdc_Trig_In *trigpin, IfxPort_InputMode pinMode, IfxPort_PadDriver padDriver)
{
    if (trigpin->pin.port != NULL_PTR)
    {
        IfxPort_setPinModeInput(trigpin->pin.port, trigpin->pin.pinIndex, pinMode);
        IfxPort_setPinPadDriver(trigpin->pin.port, trigpin->pin.pinIndex, padDriver);
    }
}


IFX_INLINE void IfxAdc_initExmodClockPin(const IfxAdc_Clkin_In *clkpin, IfxPort_InputMode pinMode, IfxPort_PadDriver padDriver)
{
    if (clkpin->pin.port != NULL_PTR)
    {
        IfxPort_setPinModeInput(clkpin->pin.port, clkpin->pin.pinIndex, pinMode);
        IfxPort_setPinPadDriver(clkpin->pin.port, clkpin->pin.pinIndex, padDriver);
    }
}


IFX_INLINE void IfxAdc_initExmodDataPin(const IfxAdc_Data_In *datapin, IfxPort_InputMode pinMode, IfxPort_PadDriver padDriver)
{
    if (datapin->pin.port != NULL_PTR)
    {
        IfxPort_setPinModeInput(datapin->pin.port, datapin->pin.pinIndex, pinMode);
        IfxPort_setPinPadDriver(datapin->pin.port, datapin->pin.pinIndex, padDriver);
    }
}


IFX_INLINE void IfxAdc_initSignSignalPin(const IfxAdc_Sign_In *signpin, IfxPort_InputMode pinMode, IfxPort_PadDriver padDriver)
{
    if (signpin->pin.port != NULL_PTR)
    {
        IfxPort_setPinModeInput(signpin->pin.port, signpin->pin.pinIndex, pinMode);
        IfxPort_setPinPadDriver(signpin->pin.port, signpin->pin.pinIndex, padDriver);
    }
}


IFX_INLINE void IfxAdc_initCgPwmPin(const IfxAdc_Pwm_Out *cgPwm, IfxPort_OutputMode pinMode, IfxPort_PadDriver padDriver)
{
    if ((cgPwm != NULL_PTR) && (cgPwm->pin.port != NULL_PTR))
    {
        IfxPort_setPinModeOutput(cgPwm->pin.port, cgPwm->pin.pinIndex, pinMode, cgPwm->select);
        IfxPort_setPinPadDriver(cgPwm->pin.port, cgPwm->pin.pinIndex, padDriver);
    }
}


IFX_INLINE void IfxAdc_initTmadcPin(const IfxAdc_TmadcCh_In *tmadcpin, IfxPort_InputMode pinMode, IfxPort_PadDriver padDriver)
{
    if ((tmadcpin != NULL_PTR) && (tmadcpin->pin.port != NULL_PTR))
    {
        IfxPort_setPinModeInput(tmadcpin->pin.port, tmadcpin->pin.pinIndex, pinMode);
        IfxPort_setPinPadDriver(tmadcpin->pin.port, tmadcpin->pin.pinIndex, padDriver);
        IfxPort_setPinFunctionMode(tmadcpin->pin.port, tmadcpin->pin.pinIndex, IfxPort_PinFunctionMode_analog);
    }
}


IFX_INLINE void IfxAdc_initTmadcEmuxCtrlPin(const IfxAdc_Emuxctrl_Out *emuxPin, IfxPort_OutputMode pinMode, IfxPort_PadDriver padDriver)
{
    if ((emuxPin != NULL_PTR) && (emuxPin->pin.port != NULL_PTR))
    {
        IfxPort_setPinModeOutput(emuxPin->pin.port, emuxPin->pin.pinIndex, pinMode, emuxPin->select);
        IfxPort_setPinPadDriver(emuxPin->pin.port, emuxPin->pin.pinIndex, padDriver);
    }
}


IFX_INLINE void IfxAdc_initApConfig(IfxAdc_ApConfig *config)
{
    IfxApProt_initConfig(&config->proteConfig);
    IfxApProt_initConfig(&config->protseConfig);
    IfxApApu_initConfig(&config->apuConfig);
}


IFX_INLINE void IfxAdc_initApu(Ifx_ADC *adc, IfxApApu_ApuConfig *config, IfxAdc_Apu id)
{
    /* Change the state to CONFIG, Configure APU and set PROT state back to RUN */
    /* Initialize the APU */
    IfxApProt_setState((Ifx_PROT_PROT *)&adc->PROTE[id], IfxApProt_State_config);
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&adc->ACCEN[id], config);
    IfxApProt_setState((Ifx_PROT_PROT *)&adc->PROTE[id], IfxApProt_State_run);
}


IFX_INLINE IfxApProt_Status IfxAdc_initProtE(Ifx_ADC *adc, IfxApProt_ProtConfig *config, IfxAdc_ProtE id)
{
    return IfxApProt_init((Ifx_PROT_PROT *)&adc->PROTE[id], config);
}


IFX_INLINE IfxApProt_Status IfxAdc_initProtSE(Ifx_ADC *adc, IfxApProt_ProtConfig *config)
{
    return IfxApProt_init((Ifx_PROT_PROT *)&adc->PROTSE, config);
}


IFX_INLINE void IfxAdc_initTmadcResource(Ifx_ADC *adc, IfxAdc_TmadcModule moduleId, IfxAdc_Apu apuId)
{
    IfxApProt_setState((Ifx_PROT_PROT *)&adc->PROTSE, IfxApProt_State_config);
    IFXADC_SETRESALLOCCFG(adc->RESALLOC.TMADC, moduleId, apuId);
    IfxApProt_setState((Ifx_PROT_PROT *)&adc->PROTSE, IfxApProt_State_run);
}


IFX_INLINE void IfxAdc_initGlobalResource(Ifx_ADC *adc, IfxAdc_GlobalResource resourceId, IfxAdc_Apu apuId)
{
    IfxApProt_setState((Ifx_PROT_PROT *)&adc->PROTSE, IfxApProt_State_config);
    IFXADC_SETRESALLOCCFG(adc->RESALLOC.GLOB, resourceId, apuId);
    IfxApProt_setState((Ifx_PROT_PROT *)&adc->PROTSE, IfxApProt_State_run);
}


IFX_INLINE void IfxAdc_initFccResource(Ifx_ADC *adc, IfxAdc_FccModule moduleId, IfxAdc_Apu apuId)
{
    IfxApProt_setState((Ifx_PROT_PROT *)&adc->PROTSE, IfxApProt_State_config);

    if (moduleId < IfxAdc_FccModule_8)
    {
        IFXADC_SETRESALLOCCFG(adc->RESALLOC.FCCA, moduleId, apuId);
    }
    else
    {
        moduleId = (IfxAdc_FccModule)(moduleId - IfxAdc_FccModule_8);
        IFXADC_SETRESALLOCCFG(adc->RESALLOC.FCCB, moduleId, apuId);
    }

    IfxApProt_setState((Ifx_PROT_PROT *)&adc->PROTSE, IfxApProt_State_run);
}


IFX_INLINE void IfxAdc_initDsadcResource(Ifx_ADC *adc, IfxAdc_DsadcChannel channelId, IfxAdc_Apu apuId)
{
    IfxApProt_setState((Ifx_PROT_PROT *)&adc->PROTSE, IfxApProt_State_config);

    if (channelId < IfxAdc_DsadcChannel_8)
    {
        IFXADC_SETRESALLOCCFG(adc->RESALLOC.DSADCA, channelId, apuId);
    }
    else
    {
        channelId = (IfxAdc_DsadcChannel)(channelId - IfxAdc_DsadcChannel_8);
        IFXADC_SETRESALLOCCFG(adc->RESALLOC.DSADCB, channelId, apuId);
    }

    IfxApProt_setState((Ifx_PROT_PROT *)&adc->PROTSE, IfxApProt_State_run);
}


IFX_INLINE void IfxAdc_initExmodResource(Ifx_ADC *adc, IfxAdc_Exmod exmodId, IfxAdc_Apu apuId)
{
    IfxApProt_setState((Ifx_PROT_PROT *)&adc->PROTSE, IfxApProt_State_config);
    IFXADC_SETRESALLOCCFG(adc->RESALLOC.EXMOD, exmodId, apuId);
    IfxApProt_setState((Ifx_PROT_PROT *)&adc->PROTSE, IfxApProt_State_run);
}


IFX_INLINE void IfxAdc_initCdspResource(Ifx_ADC *adc, IfxAdc_CdspCore cdspId, IfxAdc_Apu apuId)
{
    IfxApProt_setState((Ifx_PROT_PROT *)&adc->PROTSE, IfxApProt_State_config);
#if IFXADC_NUM_CDSP_CORES > 8U

    if (cdspId < IfxAdc_CdspCore_8)
#endif
    {
        IFXADC_SETRESALLOCCFG(adc->RESALLOC.CDSPA, cdspId, apuId);
    }

#if IFXADC_NUM_CDSP_CORES > 16U
    else if (cdspId < IfxAdc_CdspCore_16)
    {
        cdspId = (IfxAdc_CdspCore)(cdspId - IfxAdc_CdspCore_8);
        IFXADC_SETRESALLOCCFG(adc->RESALLOC.CDSPB, cdspId, apuId);
    }
#elif IFXADC_NUM_CDSP_CORES == 12U
    else
    {
        cdspId = (IfxAdc_CdspCore)(cdspId - IfxAdc_CdspCore_8);
        IFXADC_SETRESALLOCCFG(adc->RESALLOC.CDSPB, cdspId, apuId);
    }
#endif
#if IFXADC_NUM_CDSP_CORES > 16U
    else
    {
        cdspId = (IfxAdc_CdspCore)(cdspId - IfxAdc_CdspCore_16);
        IFXADC_SETRESALLOCCFG(adc->RESALLOC.CDSPC, cdspId, apuId);
    }
#endif
    IfxApProt_setState((Ifx_PROT_PROT *)&adc->PROTSE, IfxApProt_State_run);
}


IFX_INLINE void IfxAdc_enableTmadcModule(IfxAdc_TmadcModule moduleId)
{
#if !defined(IFX_ILLD_PPU_USAGE)
    __dsync(); /* TC49xA Errata : Dsync required before each RMW operation*/
#endif
    Ifx__imaskldmst(&MODULE_ADC.CLKEN.TMADC.U, 1u, moduleId, 1u);
}


IFX_INLINE void IfxAdc_disableTmadcModule(IfxAdc_TmadcModule moduleId)
{
#if !defined(IFX_ILLD_PPU_USAGE)
    __dsync(); /* TC49xA Errata : Dsync required before each RMW operation*/
#endif
    Ifx__imaskldmst(&MODULE_ADC.CLKEN.TMADC.U, 0u, moduleId, 1u);
}


IFX_INLINE void IfxAdc_enableDsadcClock(IfxAdc_DsadcChannel channelId)
{
#if !defined(IFX_ILLD_PPU_USAGE)
    __dsync(); /* TC49xA Errata : Dsync required before each RMW operation*/
#endif
    Ifx__imaskldmst(&MODULE_ADC.CLKEN.DSINEX.U, 1u, channelId, 1u);
}


IFX_INLINE void IfxAdc_enableExmodClock(IfxAdc_Exmod channelId)
{
    uint32 shift = channelId + 16u;
#if !defined(IFX_ILLD_PPU_USAGE)
    __dsync(); /* TC49xA Errata : Dsync required before each RMW operation*/
#endif
    Ifx__imaskldmst(&MODULE_ADC.CLKEN.DSINEX.U, 1u, shift, 1u);
}


IFX_INLINE void IfxAdc_enableDsadcGlobal(void)
{
#if !defined(IFX_ILLD_PPU_USAGE)
    __dsync(); /* TC49xA Errata : Dsync required before each RMW operation*/
#endif
    Ifx__imaskldmst(&MODULE_ADC.CLKEN.DSINEX.U, 1u, IFX_ADC_CLKEN_DSINEX_DSADCEN_OFF, 1u);
}


IFX_INLINE void IfxAdc_enableFccModule(IfxAdc_FccModule moduleId)
{
#if !defined(IFX_ILLD_PPU_USAGE)
    __dsync(); /* TC49xA Errata : Dsync required before each RMW operation*/
#endif
    Ifx__imaskldmst(&MODULE_ADC.CLKEN.FCC.U, 1u, moduleId, 1u);
}


IFX_INLINE void IfxAdc_disableFccModule(IfxAdc_FccModule moduleId)
{
#if !defined(IFX_ILLD_PPU_USAGE)
    __dsync(); /* TC49xA Errata : Dsync required before each RMW operation*/
#endif
    Ifx__imaskldmst(&MODULE_ADC.CLKEN.FCC.U, 0u, moduleId, 1u);
}


IFX_INLINE void IfxAdc_enableCdspGlobal(void)
{
#if !defined(IFX_ILLD_PPU_USAGE)
    __dsync(); /* TC49xA Errata : Dsync required before each RMW operation*/
#endif
    Ifx__imaskldmst(&MODULE_ADC.CLKEN.CDSP.U, 1u, IFX_ADC_CLKEN_CDSP_CDSPGL_OFF, 1u);
}


IFX_INLINE void IfxAdc_resetCdspCore(Ifx_ADC_CDSP *cdsp, IfxAdc_CdspCore coreId)
{
#if !defined(IFX_ILLD_PPU_USAGE)
    __dsync(); /* TC49xA Errata : Dsync required before each RMW operation*/
#endif
    Ifx__imaskldmst(&cdsp->GLOBRD.U, 1u, coreId, 1u);
}


IFX_INLINE void IfxAdc_haltCdspCore(Ifx_ADC_CDSP *cdsp, IfxAdc_CdspCore coreId)
{
#if !defined(IFX_ILLD_PPU_USAGE)
    __dsync(); /* TC49xA Errata : Dsync required before each RMW operation*/
#endif
    Ifx__imaskldmst(&cdsp->GLOBHCD.U, 1u, coreId, 1u);

    /* Wait for core to go in halt state */
    while (!(cdsp->GLOBHSTD.U & (1u << coreId)))
    {}
}


IFX_INLINE void IfxAdc_loadCdspMemory(void *srcAddr, void *destAddr, uint16 size)
{
    if ((srcAddr != NULL_PTR) && (destAddr != NULL_PTR))
    {
        uint32 *src_long  = (uint32 *)srcAddr;
        uint32 *dest_long = (uint32 *)destAddr;

        /* To check if address is 4 byte aligned */
        if (!((uint32)src_long & 0x03U) && !((uint32)dest_long & 0x03U))
        {
            /* Transfer 4 bytes */
            while (size >= 4u)
            {
                *dest_long++ = *src_long++;
                size        -= 4u;
            }

            uint8 *src  = (uint8 *)src_long;
            uint8 *dest = (uint8 *)dest_long;

            /* Transfer remaining data byte by byte*/
            while (size--)
            {
                *dest++ = *src++;
            }
        }
    }
}


IFX_INLINE void IfxAdc_clearCdspResultEvent(Ifx_ADC_CDSP *cdsp, IfxAdc_CdspCore coreId, IfxAdc_CdspResultReg reg)
{
    cdsp->RESEVCLR[reg].B.RESEVCLR = (1u << coreId);
}


IFX_INLINE boolean IfxAdc_getCdspCoreHaltStatus(Ifx_ADC_CDSP *cdsp, IfxAdc_CdspCore coreId)
{
    boolean event = FALSE;

    if ((cdsp->GLOBHSTD.U & (1u << coreId)) != 0u)
    {
        event = TRUE;
    }

    return event;
}


IFX_INLINE void IfxAdc_startCdspIntegratorWindow(Ifx_ADC_CDSP *cdsp, IfxAdc_CdspCore coreId)
{
    cdsp->DSP[coreId].INTCFG.B.INTEN = 1u;
}


IFX_INLINE void IfxAdc_stopCdspIntegratorWindow(Ifx_ADC_CDSP *cdsp, IfxAdc_CdspCore coreId)
{
    cdsp->DSP[coreId].INTTRCFG.B.INTRM = 0u;
}


IFX_INLINE void IfxAdc_setFccBoundaryFlag(Ifx_ADC_FCC *fcc)
{
    fcc->BFLCFG.B.SBFV = 1u;
}


IFX_INLINE void IfxAdc_clearFccBoundaryFlag(Ifx_ADC_FCC *fcc)
{
    fcc->BFLCFG.B.SBFV = 0u;
}


IFX_INLINE sint16 IfxAdc_readTmadcResult(IfxAdc_TmadcModule moduleId, IfxAdc_TmadcResultReg resultReg)
{
#if defined(IFX_ILLD_PPU_USAGE)            //PPU
    return (sint16)(MODULE_ADC_AXI.TMADCRES[moduleId].RESAXI[resultReg].B.RESULT);
#else //Tricore
    return (sint16)(MODULE_ADC.TMADC[moduleId].AW0.RES[resultReg].B.RESULT);
#endif
}


IFX_INLINE uint16 IfxAdc_readTmadcTimestamp(IfxAdc_TmadcModule moduleId, IfxAdc_TmadcResultReg resultReg)
{
#if defined(IFX_ILLD_PPU_USAGE) //PPU
    return (uint16)(MODULE_ADC_AXI.TMADCRES[moduleId].TSAXI[resultReg].B.TIMESTAMP);
#else                           //Tricore
    return (uint16)(MODULE_ADC.TMADC[moduleId].AW0.TS[resultReg].B.TIMESTAMP);
#endif
}


IFX_INLINE void IfxAdc_triggerDsadcCalibration(IfxAdc_DsadcChannel channelId)
{
    MODULE_ADC.DSADC.IN[channelId].CHCFG.B.CALIB = 1u;
}


IFX_INLINE IfxAdc_DsadcCalibrationState IfxAdc_getDsadcCalibrationStatus(IfxAdc_DsadcChannel channelId)
{
    return (IfxAdc_DsadcCalibrationState)(MODULE_ADC.DSADC.IN[channelId].CHST.B.CAL);
}


IFX_INLINE boolean IfxAdc_isTmadcMonitorChannelResultAvailable(Ifx_ADC_TMADC *tmadc, IfxAdc_TmadcMonitorChannel channel)
{
    uint32 resultEvent = tmadc->RESF.B.RESEV;
    uint8  shift       = channel + IFXADC_TMADC_MCH_OFFSET;
    return (resultEvent & ((uint32)1 << shift)) != (uint32)0;
}


IFX_INLINE void IfxAdc_clearTmadcMonitorChannelResultFlag(Ifx_ADC_TMADC *tmadc, IfxAdc_TmadcMonitorChannel channel)
{
    tmadc->RESFCLR.B.RESEVCLR = ((uint32)1 << (channel + IFXADC_TMADC_MCH_OFFSET));
}


IFX_INLINE uint8 IfxAdc_getTmadcTriggerErrorNumber(Ifx_ADC_TMADC *tmadc, IfxAdc_TmadcChannel channel)
{
    return tmadc->CH[channel].STAT.B.TRENR;
}


IFX_INLINE boolean IfxAdc_isTmadcHwTriggerIgnored(Ifx_ADC_TMADC *tmadc, IfxAdc_TmadcChannel channel)
{
    return tmadc->CH[channel].STAT.B.HWTRE;
}


IFX_INLINE boolean IfxAdc_isTmadcSwTriggerIgnored(Ifx_ADC_TMADC *tmadc, IfxAdc_TmadcChannel channel)
{
    return tmadc->CH[channel].STAT.B.SWTRE;
}


IFX_INLINE boolean IfxAdc_getTmadcBoundaryFlag(Ifx_ADC_TMADC *tmadc, IfxAdc_TmadcBoundaryReg boundaryReg)
{
    return tmadc->BFL[boundaryReg].STAT.B.BFL;
}


IFX_INLINE boolean IfxAdc_isTmadcErrorEventOccured(Ifx_ADC_TMADC *tmadc, IfxAdc_TmadcChannel channel)
{
    return (tmadc->ERRF.U & (1u << channel)) != 0u;
}


IFX_INLINE boolean IfxAdc_isTmadcBoundaryEventOccured(Ifx_ADC_TMADC *tmadc, IfxAdc_TmadcResultReg resultReg)
{
    return (tmadc->BNDF.U & (1u << resultReg)) != 0u;
}


IFX_INLINE void IfxAdc_clearTmadcErrorFlag(Ifx_ADC_TMADC *tmadc, IfxAdc_TmadcChannel channel)
{
    tmadc->ERRFCLR.U = (1u << channel);
}


IFX_INLINE void IfxAdc_clearTmadcBoundaryFlag(Ifx_ADC_TMADC *tmadc, IfxAdc_TmadcResultReg resultReg)
{
    tmadc->BNDFCLR.U = (1u << resultReg);
}


IFX_INLINE void IfxAdc_triggerTmadcMonitorChannel(Ifx_ADC_TMADC *tmSFR, IfxAdc_TmadcMonitorChannel channelId)
{
    uint8 shift = (channelId + IFXADC_TMADC_MCH_OFFSET);
    tmSFR->SWTRCFG.B.SCHSEL = (1u << shift);
}


IFX_INLINE void IfxAdc_configureTmadcEvent(Ifx_ADC_TMADC *tmSFR, IfxAdc_TmadcServReq srvNode, IfxAdc_TmadcEventSel event)
{
    if (srvNode != IfxAdc_TmadcServReq_none)
    {
        tmSFR->SR[srvNode].CFG.B.EVSEL = event;
    }
}


IFX_INLINE void IfxAdc_enableTmadcChannelEvent(Ifx_ADC_TMADC *tmSFR, IfxAdc_TmadcServReq srvNode, IfxAdc_TmadcChannel channelId)
{
    if (srvNode != IfxAdc_TmadcServReq_none)
    {
        tmSFR->SR[srvNode].CFG.B.EVEN |= (1u << channelId);
    }
}


IFX_INLINE boolean IfxAdc_getCdspBoundaryEvent(Ifx_ADC_CDSP *cdsp, IfxAdc_CdspCore coreId)
{
    boolean event = FALSE;

    if (((cdsp->BNDCF.U >> coreId) & 1u) != 0u)
    {
        event = TRUE;
    }

    return event;
}


IFX_INLINE void IfxAdc_clearCdspBoundaryEvent(Ifx_ADC_CDSP *cdsp, IfxAdc_CdspCore coreId)
{
    Ifx__imaskldmst(&cdsp->BNDCFCL.U, 1u, coreId, 1u);
}


IFX_INLINE void IfxAdc_clearCdspError(Ifx_ADC_CDSP *cdsp, IfxAdc_CdspCore coreId, IfxAdc_CdspError error)
{
    cdsp->DSP[coreId].CHERRCL.U = (1u << error);
}


IFX_INLINE boolean IfxAdc_isDsadcBoundaryEventOccurred(IfxAdc_DsadcChannel channelId)
{
    return (boolean)((MODULE_ADC.DSADC.BOUNDF.B.BNDEVIN & (1u << channelId)) != 0u);
}


IFX_INLINE void IfxAdc_clearDsadcBoundaryFlag(IfxAdc_DsadcChannel channelId)
{
    MODULE_ADC.DSADC.BOUNDFCL.B.BNDINCL = 1u << channelId;
}


IFX_INLINE boolean IfxAdc_isExmodBoundaryEventOccurred(IfxAdc_Exmod channelId)
{
    return (boolean)((MODULE_ADC.DSADC.BOUNDF.B.BNDEVEX & (1u << channelId)) != 0u);
}


IFX_INLINE void IfxAdc_clearExmodBoundaryFlag(IfxAdc_Exmod channelId)
{
    MODULE_ADC.DSADC.BOUNDFCL.B.BNDEXCL = 1u << channelId;
}


IFX_INLINE void IfxAdc_initExmodClockOutPin(const IfxAdc_Clkout_Out *clkpin, IfxPort_OutputMode pinMode, IfxPort_PadDriver padDriver)
{
    if (clkpin->pin.port != NULL_PTR)
    {
        IfxPort_setPinModeOutput(clkpin->pin.port, clkpin->pin.pinIndex, pinMode, clkpin->select);
        IfxPort_setPinPadDriver(clkpin->pin.port, clkpin->pin.pinIndex, padDriver);
    }
}


IFX_INLINE void IfxAdc_setDsadcInputPin(IfxAdc_DsadcChannel channelId, IfxAdc_DsadcInSel inputSelect)
{
    MODULE_ADC.DSADC.IN[channelId].CHCFG.B.INSEL = inputSelect;
}


#endif /* IFXADC_H */
