/**
 * \file IfxGtm_Pwm.h
 * \brief GTM PWM details
 * \ingroup IfxLld_Gtm
 *
 * \version iLLD_2_0_1_2_19
 * \copyright Copyright (c) 2023 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 *
 * \defgroup IfxLld_Gtm_Pwm_Usage How to use the PWM Interface layer?
 * \ingroup IfxLld_Gtm
 * \section IfxLld_Gtm_Pwm_Overview Overview
 * This documentation describes the usage of PWM driver interface layer of GTM/eGTM module present in Aurix TC4xx devices.\n
 * This interface can be used to generate upto 16 PWM signals (8 of them can be complementary pairs).\n\n
 * Users can pass an array of channel configurations. The first channel acts as "Base" channel and subsequent channels are "Synchronous".
 * The base channel is responsible for controlling the frequency of all channels. It does so by generating a trigger at CM0 match.\n
 * The synchronous channels receive and forward this trigger to subsequent channels. The trigger notifies the synchronous channel counters to reset to 0 or change direction depending on PWM alignment.
 * <b>Note:</b>
 *     -# This documentation will use the term "GTM" to mean both "GTM" and "EGTM" module unless specified otheriwse.
 *     -# Enabling of Gtm module and configuration of clock is not supported by this driver.
 *     -# PWM driver can configure only one cluster and one submodule (Tom/Atom) at a time
 *     -# Atom has only 8 channels so at max 8 complementary PWM signal pairs can be generated when using Atom
 *     -# If channels span across two TGCs in Tom, then driver uses TBU channel 0 to start the channels. Ensure that this channel is not being used elsewhere
 * \subsection IfxLld_Gtm_Pwm_Overview_Func Functionalities Provided
 * The PWM interface layer provides the following functionalities:
 *     -# Usage of TOM/ATOM submodule for PWM generation
 *     -# Generation of edge and center aligned PWM signals
 *     -# Usage of upto 16 channels (1 base + 15 synchronous channels with contiguous channel numbers)
 *     -# Generation of upto 2 PWM output signals from each channel (depending on DTM Availability)
 *     -# Static and run time APIs for configuring PWM frequency, duty, phase (edge aligned), and dead time
 *         -# Synchronous update of one channel
 *         -# Immediate update of one channel
 *         -# Synchronous update of all channels
 *         -# Immediate update of all channels
 * \subsection IfxLld_Gtm_Pwm_Init Interface Initialization
 * Initialization can be done by calling IfxGtm_Pwm_init() function.\n
 * The function performs the following steps:
 *     -# Retrieves clock information for Atom/Tom and DTM
 *     -# Initializes base and sync channels:
 *         -# Saves pointers to registers for faster access later
 *         -# Configures Atom/Tom global control and channel registers
 *         -# Configures Pwm alignment of each channel
 *         -# Configures Base channel with Pwm frequency and to generate trigger at end of period
 *         -# Configures Sync channels to receive trigger from last channel and forward it
 *         -# If sync channel and Pwm is edge aligned, configures Phase shift
 *         -# Configures Duty of each channel
 *         -# Configures Dead time for each channel if pointer provided
 *         -# Connects output pins if pointer provided
 *         -# Configures interrupt if pointer provided else disables interrupt of channel
 *     -# Starts channels after init done if configured
 * \section IfxLld_Gtm_Pwm_Code Coding Example
 * \subsection IfxLld_Gtm_Pwm_Step1 STEP 1: Including interface and declaring variables
 *     \code
 *     //=====================================
 *     // 1. Include PWM Interface
 *     //=====================================
 *     #include "Gtm/Pwm/IfxGtm_Pwm.h"
 *     //=====================================
 *     // 2. Variable Instantiation
 *     //=====================================
 *     #define IFXGTM_PWM_NUM_CHANNELS 8
 *     IfxGtm_Pwm_Config           config;                                     // Main PWM config structure
 *     IfxGtm_Pwm_ChannelConfig    channelConfig[IFXGTM_PWM_NUM_CHANNELS];     // Array containing configuration for each channel
 *     IfxGtm_Pwm_DtmConfig        dtmConfig[IFXGTM_PWM_NUM_CHANNELS];         // Only needed if using DTM module
 *     IfxGtm_Pwm_InterruptConfig  interruptConfig;                            // Only needed if using interrupt. Can also be an array
 *     IfxGtm_Pwm_OutputConfig     output[IFXGTM_PWM_NUM_CHANNELS];            // Only needed if connected to pin
 *     IfxGtm_Pwm                  pwm;                                        // Driver handle
 *     IfxGtm_Pwm_Channel          channels[IFXGTM_PWM_NUM_CHANNELS];          // Array containing channel data after configuration
 *     Ifx_GTM                     *gtmSFR = &MODULE_GTM;                      // GTM SFR
 *     IfxGtm_Dtm_ClockSource      dtmClockSource = IfxGtm_Dtm_ClockSource_cmuClock0;
 *     IfxGtm_Pwm_SubModule_Ch     channelIndex;
 *     //=====================================
 *     // 3. [OPTIONAL Step for using interrupt]
 *     //=====================================
 *     // Create callback function
 *     void IfxGtm_periodEventFunction(void *data)
 *     {
 *         // Do something
 *     }
 *     // Define interrupt function
 *     volatile unsigned ch0ccu0InterruptCount = 0;
 *     IFX_INTERRUPT(ch0ccu0GtmCall, 0, IFXGTM_CH0CCU0_INTR_PRIO)
 *     {
 *         ch0ccu0InterruptCount++;
 *         // Call event function
 *     }
 *     // Install interrupt handler
 *     IfxCpu_Irq_installInterruptHandler(&ch0ccu0GtmCall, IFXGTM_CH0CCU0_INTR_PRIO);
 *     IfxCpu_enableInterrupts();
 *     \endcode
 * After completing the above, the following steps should be performed by the user as driver doesn't do them:
 *     -# Enable GTM module.
 *     -# Configure and enable clocks to be used by the driver.
 * \subsection IfxLld_Gtm_Pwm_Step2 STEP 2: Configure the structures
 * In this step we will, configure PWM driver to generate PWM using all channels of Atom submodule.\n
 * Note that the ATOM.CH[0] will be used as base channel by the driver.
 *     \code
 *     //=====================================
 *     // 1. Config structure initialization
 *     //=====================================
 *     IfxGtm_Pwm_initConfig(&config, &MODULE_GTM);
 *     //=====================================
 *     // 2. [Optional] Output configuration
 *     //=====================================
 *     // Example configuration of output connection from base channel. Similarly configure for other channels.
 *     output[0].pin                   = (IfxGtm_Pwm_ToutMap*)&IfxGtm_ATOM0_0_TOUT0_P02_0_OUT;     // Output pin configuration (typecast to this type)
 *     output[0].complementaryPin      = (IfxGtm_Pwm_ToutMap*)&IfxGtm_ATOM0_0N_TOUT1_P02_1_OUT;    // Complementary output pin configuration (_N)
 *     output[0].polarity              = Ifx_ActiveState_high;                                     // Active low/high of pin
 *     output[0].complementaryPolarity = Ifx_ActiveState_low;                                      // Active low/high of pin
 *     output[0].outputMode            = IfxPort_OutputMode_pushPull;                              // Output mode
 *     output[0].padDriver             = IfxPort_PadDriver_cmosAutomotiveSpeed1;                   // Pad driver
 *     //=====================================
 *     // 3. [Optional] Dtm configuration
 *     //=====================================
 *     // Example configuration of dtm for base channel. Similarly configure for other channels.
 *     dtmConfig[0].deadTime.rising        = 0.0f;             // Rising Dead time in seconds
 *     dtmConfig[0].deadTime.falling       = 1e-7f;            // Falling Dead time in seconds
 *     dtmConfig[0].deadTime.fastShutOff   = NULL_PTR;         // Fast shut off configuration
 *     //=====================================
 *     // 4. [Optional] Interrupt configuration
 *     //=====================================
 *     // Example configuration of interrupt for base channel
 *     interruptConfig.mode          = IfxGtm_IrqMode_pulseNotify;     // IRQ mode of interrupt
 *     interruptConfig.isrProvider   = IfxSrc_Tos_cpu0;                // Type of Service
 *     interruptConfig.priority      = IFXGTM_CH0CCU0_INTR_PRIO;       // Interrupt priority
 *     interruptConfig.vmId          = IfxSrc_VmId_0;                  // VM ID
 *     interruptConfig.periodEvent   = IfxGtm_periodEventFunction;     // Connect callback function for period event interrupt
 *     interruptConfig.dutyEvent     = NULL_PTR;                       // Don't duty event interrupt
 *     //=====================================
 *     // 5. Channel configuration
 *     //=====================================
 *     // Base channel configuration
 *     IfxGtm_Pwm_initChannelConfig(&channelConfig[0]);                // Init to default values
 *     channelConfig[0].timerCh        = IfxGtm_Pwm_SubModule_Ch_0;    // Atom channel index to be used for base channel
 *     channelConfig[0].phase          = 0.000f;                       // Phase shift in radians (range: 0.0 .. 2pi; only for edge aligned sync channels)
 *     channelConfig[0].duty           = 75.0f;                        // PWM duty in % (range: 0.0 .. 100.0)
 *     channelConfig[0].dtm            = &dtmConfig[0];                // Attach Dead time configuration for this channel
 *     channelConfig[0].output         = &output[0];                   // Attach Pin connections and polarities for this channel
 *     channelConfig[0].mscOut         = NULL_PTR;                     // MSC configuration for this channel (currently doesn't do anything)
 *     channelConfig[0].interrupt      = &interruptConfig;             // Attach Interrupt configuration for this channel
 *     // Sync channel 0 configuration. Similarly configure other sync channels
 *     IfxGtm_Pwm_initChannelConfig(&channelConfig[1]);                // Init to default values
 *     channelConfig[0].timerCh        = IfxGtm_Pwm_SubModule_Ch_1;    // Atom channel index to be used for sync channel
 *     channelConfig[0].phase          = 1.150f;                       // Phase shift in radians (range: 0.0 .. 2pi; only for edge aligned sync channels)
 *     channelConfig[0].duty           = 75.0f;                        // PWM duty in % (range: 0.0 .. 100.0)
 *     channelConfig[0].dtm            = &dtmConfig[1];                // Dead time configuration for this channel
 *     channelConfig[0].output         = &output[2];                   // Pin connections and polarities for this channel
 *     channelConfig[0].mscOut         = NULL_PTR;                     // MSC configuration for this channel
 *     channelConfig[0].interrupt      = NULL_PTR;                     // Interrupt configuration for this channel
 *     //=====================================
 *     // 5. Other configurations
 *     //=====================================
 *     config.cluster              = IfxGtm_Cluster_0;                         // Cluster
 *     config.subModule            = IfxGtm_Pwm_SubModule_atom;                // Sub module
 *     config.alignment            = IfxGtm_Pwm_Alignment_edge;                // Alignment
 *     config.syncStart            = TRUE;                                     // Start all channels after init
 *     config.numChannels          = IFXGTM_PWM_NUM_CHANNELS;                  // Number of channels configured
 *     config.channels             = &channelConfig[0];                        // Attach Channel configuration
 *     config.frequency            = 500000.0f;                                // PWM frequency
 *     config.clockSource.atom     = IfxGtm_Cmu_Clk_0;                         // Clock source for atom
 *     config.dtmClockSource       = IfxGtm_Dtm_ClockSource_cmuClock0;         // Clock source for dtm
 *     config.syncUpdateEnabled    = TRUE;                                     // TRUE: Update compare registers from shadow at the end of period
 *     \endcode
 * Before proceeding please ensure:
 *     -# Atom/Tom is present in cluster specified
 *     -# Atom/Tom and Dtm (if enabled) clock are properly configured (clock frequency > 0) and enabled
 *     -# Channel number specifed in channel configuration is present in submodule (Atom contains only 8 channels)
 *     -# Synchronous channel must always be next to last configured base or sync channel (last channel number + 1) E.g. If base channel is channel 5 then next channel numbers must be 6, 7, ... and so on.
 *     -# If DTM config is attached, then DTM is present for that channel
 *     -# Pin
 *         - Channel number specified in the pin configuration is same as the channel number specified in the channel config structure
 *         - Cluster specified in the pin configuration is same as the cluster specified in Pwm config
 *     -# Frequency is in valid range (always less than clock frequency)
 *     -# High res
 *         - High res should only be activated when using Atom
 *         - High res only works with up counting mode (UDMODE = 0 / edge aligned) and with clock frequency <= 200 Mhz clock
 * \subsection IfxLld_Gtm_Pwm_Step3 STEP 3: Initialize PWM
 *     \code
 *     //=====================================
 *     // 1. Call the init function
 *     //=====================================
 *     IfxGtm_Pwm_init(&pwm, &channels[0], &config);
 *     \endcode
 * After completing this step, the PWM signal will start getting generated and will be available at pins if connected/configured
 * \subsection IfxLld_Gtm_Pwm_Step4 STEP 4: Run time APIs
 *     \code
 *     // Dummy variable to store phase data of all channels
 *     float32 reqPhase[IFXGTM_PWM_NUM_CHANNELS] = {..};
 *     float32 reqDuty[IFXGTM_PWM_NUM_CHANNELS] = {..};
 *     //=====================================
 *     // 1. Update frequency of PWM group (all channels)
 *     //=====================================
 *     IfxGtm_Pwm_updateFrequency(&pwm, 400000.0f);
 *     //=====================================
 *     // 2. Update phase of single channel
 *     // Use this only for edge aligned PWM and sync channels
 *     //=====================================
 *     // Call this API to synchronously update phase of a certain channel
 *     // Note: The second argument is the array index of the channel which you want to configure
 *     IfxGtm_Pwm_updateChannelPhase(&pwm, IfxGtm_Pwm_SyncChannelIndex_1, reqPhase[IfxGtm_Pwm_SyncChannelIndex_1]);
 *     // Call this API to asynchronously update phase of a certain channel
 *     IfxGtm_Pwm_updateChannelPhaseImmediate(&pwm, IfxGtm_Pwm_SyncChannelIndex_1, reqPhase[IfxGtm_Pwm_SyncChannelIndex_1]);
 *     //=====================================
 *     // 3. Update phase of all channels
 *     // Use this only for edge aligned PWM
 *     //=====================================
 *     // Call this API to synchronously update phase of all sync channels (index 0 is ignored)
 *     IfxGtm_Pwm_updateChannelsPhase(&pwm, &reqPhase[0]);
 *     // Call this API to immediately update phase of all sync channels asynchronously (index 0 is ignored)
 *     IfxGtm_Pwm_updateChannelsPhaseImmediate(&pwm, &reqPhase[0]);
 *     //=====================================
 *     // 4. Update duty of single channel
 *     //=====================================
 *     // Call this API to synchronously update duty of a certain channel
 *     // Note: The second argument is the array index of the channel which you want to configure
 *     IfxGtm_Pwm_updateChannelDuty(&pwm, IfxGtm_Pwm_SyncChannelIndex_1, reqDuty[IfxGtm_Pwm_SyncChannelIndex_1]);
 *     // Call this API to asynchronously(immediately) update duty of a certain channel
 *     IfxGtm_Pwm_updateChannelDutyImmediate(&pwm, IfxGtm_Pwm_SyncChannelIndex_1, reqDuty[IfxGtm_Pwm_SyncChannelIndex_1]);
 *     //=====================================
 *     // 5. Update duty of all channels
 *     //=====================================
 *     // Call this API to synchronously update duty of all sync channels
 *     IfxGtm_Pwm_updateChannelsDuty(&pwm, &reqDuty[0]);
 *     // Call this API to immediately update duty of all sync channels asynchronously
 *     IfxGtm_Pwm_updateChannelsDutyImmediate(&pwm, &reqDuty[0]);
 *     \endcode
 * \subsection IfxLld_Gtm_Pwm_Sync Synchronised Groups
 * There is a possibility of having two PWM groups synchronised to each other. E.g. One may be used as drive channels and the other for trigger channels.\n
 * The procedure to configure PWM remians same apart from one difference. User shall disable the boolean "syncStart" of both PWM groups so that counters/output do not start at the end of init.
 *     \code
 *     config.syncStart = FALSE;    // Don't Start all channels after init
 *     \endcode
 * Then, follow the Step 3 for both PWM groups.\n
 * Now, the two groups are ready to be started. They will be started by calling a special API which will internally use TBU module of GTM to start two groups at once.
 *     \code
 *     // Pass two PWM handles
 *     IfxGtm_Pwm_startSyncedGroups(&pwm1, &pwm2);
 *     \endcode
 * Now, the PWM is being generated correspoding to both groups.\n\n
 * One more special API exists for updating frequency of two synchronised groups at once since there is a possibility that if frequency of each group is updated separately, the counters may get out of sync.
 *     \code
 *     // Pass two handles and requested frequency
 *     IfxGtm_Pwm_updateSyncedGroupsFrequency(&pwm1, &pwm2, 50000.0f);
 *     \endcode
 * For updating phase and duty, there is no special API and user can use the earlier discussed APIs.
 * \subsection IfxLld_Gtm_Pwm_Trigger Trigger ADC from PWM channels
 * The PWM driver doesn't provide any way to configure a PWM channel to trigger ADC. Instead, users are requested to initialize and start a PWM group as normal and then do the following:
 *     \code
 *     //=====================================
 *     // 1. Include the Trigger interface
 *     //=====================================
 *     #include "Gtm/Trigger/IfxGtm_Trigger.h"
 *     //=====================================
 *     // 2. Initialize and start PWM as normal
 *     //=====================================
 *     //=====================================
 *     // 3. Connect to ADC
 *     //=====================================
 *     // Pass the cluster, submodule, trigger channel (Atom/Tom channel number) to be used and trigger sel(each cluster has max 4 sel) to be used
 *     result = IfxGtm_Trigger_trigToAdc(IfxGtm_Cluster_0, IfxGtm_TrigSource_atom, IfxGtm_TrigChannel_0, IfxGtm_Cfg_AdcTriggerSignal_0);
 *     \endcode
 * For more information, users are requested to refer to UM and Trigger driver interface.
 * \subsection IfxLld_Gtm_Pwm_HighRes High Res capability in eGTM
 * This section will describe how to use High Res capability (capability exists exclusively for eGTM).\n
 * While doing step 2, do the following:
 *     \code
 *     // Attach hrpwm pin instead of atom pin
 *     output[0].pin = (IfxGtm_Pwm_ToutMap*)&IfxEgtm_HRPWM0_CH0_F_P02_0_OUT;     // Output pin configuration (typecast to this type)
 *     // Either enable atom high res or dtm high res or disable both
 *     config.highResEnable        = TRUE;         // Enable Atom high res mode
 *     config.dtmHighResEnable;    = FALSE;        // Disable high res in DTM module
 *     \endcode
 * Rest everything remains same as discussed earlier.
 *
 * \defgroup IfxLld_Gtm_Pwm PWM
 * \ingroup IfxLld_Gtm
 */

#ifndef IFXGTM_PWM_H
#define IFXGTM_PWM_H 1

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "Gtm/Std/IfxGtm_Atom.h"
#include "Gtm/Std/IfxGtm_Cmu.h"
#include "Gtm/Std/IfxGtm_Dtm.h"
#include "Gtm/Std/IfxGtm_Tom.h"
#include "Gtm/Std/IfxGtm.h"
#include "_PinMap/IfxGtm_PinMap.h"

/******************************************************************************/
/*-----------------------------------Macros-----------------------------------*/
/******************************************************************************/

/** \brief Get TOM global control unit index with help of channel index
 */
#define IFXGTM_PWM_GET_TGC_INDEX(channelIndex) ((uint8)(((uint8)(channelIndex)) >> 3))

/** \brief Default PWM frequency in Hz
 */
#ifndef IFXGTM_PWM_DEFAULT_FREQUENCY
#define IFXGTM_PWM_DEFAULT_FREQUENCY ((float32)(10000.0f))
#endif

/** \brief Check if submodule is present in cluster
 */
#define IFXGTM_PWM_IS_SUBMODULE_PRESENT(cluster, subModule) \
    ((uint32)((subModule == IfxGtm_Pwm_SubModule_atom) ||   \
              ((subModule == IfxGtm_Pwm_SubModule_tom) &&   \
               ((uint8)cluster < IFXGTM_NUM_TOM_OBJECTS))))

/** \brief Check if channel is present in submodule
 */
#define IFXGTM_PWM_IS_CHANNEL_PRESENT(subModule, channel)  \
    ((uint32)((subModule == IfxGtm_Pwm_SubModule_tom) ||   \
              ((subModule == IfxGtm_Pwm_SubModule_atom) && \
               ((uint8)channel < IFXGTM_NUM_ATOM_CHANNELS))))

/** \brief Mask for range of channel bitfields in Global control
 */
#define IFXGTM_PWM_CHANNELS_MASK(firstChannel, lastChannel) ((uint32)(((uint32)1u << ((uint32)((uint32)lastChannel - (uint32)firstChannel + 1u) << 1u)) - 1u) << (((uint32)firstChannel & 0x7u) << 1u))

/** \brief Value to enable UPEN of all channels in global control register
 */
#define IFXGTM_PWM_UPEN_ENABLE_VALUE                                                          \
    (((uint32)IfxGtm_FeatureControl_enable << IFX_GTM_CLS_ATOM_AGC_GLB_CTRL_UPEN_CTRL0_OFF) | \
     ((uint32)IfxGtm_FeatureControl_enable << IFX_GTM_CLS_ATOM_AGC_GLB_CTRL_UPEN_CTRL1_OFF) | \
     ((uint32)IfxGtm_FeatureControl_enable << IFX_GTM_CLS_ATOM_AGC_GLB_CTRL_UPEN_CTRL2_OFF) | \
     ((uint32)IfxGtm_FeatureControl_enable << IFX_GTM_CLS_ATOM_AGC_GLB_CTRL_UPEN_CTRL3_OFF) | \
     ((uint32)IfxGtm_FeatureControl_enable << IFX_GTM_CLS_ATOM_AGC_GLB_CTRL_UPEN_CTRL4_OFF) | \
     ((uint32)IfxGtm_FeatureControl_enable << IFX_GTM_CLS_ATOM_AGC_GLB_CTRL_UPEN_CTRL5_OFF) | \
     ((uint32)IfxGtm_FeatureControl_enable << IFX_GTM_CLS_ATOM_AGC_GLB_CTRL_UPEN_CTRL6_OFF) | \
     ((uint32)IfxGtm_FeatureControl_enable << IFX_GTM_CLS_ATOM_AGC_GLB_CTRL_UPEN_CTRL7_OFF))

/** \brief Value to disable UPEN of all channels in global control register
 */
#define IFXGTM_PWM_UPEN_DISABLE_VALUE                                                          \
    (((uint32)IfxGtm_FeatureControl_disable << IFX_GTM_CLS_ATOM_AGC_GLB_CTRL_UPEN_CTRL0_OFF) | \
     ((uint32)IfxGtm_FeatureControl_disable << IFX_GTM_CLS_ATOM_AGC_GLB_CTRL_UPEN_CTRL1_OFF) | \
     ((uint32)IfxGtm_FeatureControl_disable << IFX_GTM_CLS_ATOM_AGC_GLB_CTRL_UPEN_CTRL2_OFF) | \
     ((uint32)IfxGtm_FeatureControl_disable << IFX_GTM_CLS_ATOM_AGC_GLB_CTRL_UPEN_CTRL3_OFF) | \
     ((uint32)IfxGtm_FeatureControl_disable << IFX_GTM_CLS_ATOM_AGC_GLB_CTRL_UPEN_CTRL4_OFF) | \
     ((uint32)IfxGtm_FeatureControl_disable << IFX_GTM_CLS_ATOM_AGC_GLB_CTRL_UPEN_CTRL5_OFF) | \
     ((uint32)IfxGtm_FeatureControl_disable << IFX_GTM_CLS_ATOM_AGC_GLB_CTRL_UPEN_CTRL6_OFF) | \
     ((uint32)IfxGtm_FeatureControl_disable << IFX_GTM_CLS_ATOM_AGC_GLB_CTRL_UPEN_CTRL7_OFF))

/** \brief Number of TBU ticks after at which Atom/Tom channel received trigger to start counters
 */
#define IFXGTM_PWM_TBU_TIMEOUT_TICKS ((uint32)0x50u)

/******************************************************************************/
/*------------------------------Type Definitions------------------------------*/
/******************************************************************************/

/** \brief Interrupt callback function type definition
 */
typedef void (*IfxGtm_Pwm_callBack)(void *data);

/******************************************************************************/
/*-------------------------------Enumerations---------------------------------*/
/******************************************************************************/

/** \brief PWM Alignment
 */
typedef enum
{
    IfxGtm_Pwm_Alignment_edge   = 0, /**< \brief Edge aligned PWM */
    IfxGtm_Pwm_Alignment_center = 1  /**< \brief Symmetric center aligned PWM */
} IfxGtm_Pwm_Alignment;

/** \brief PWM Channel state
 */
typedef enum
{
    IfxGtm_Pwm_ChannelState_running = 0,  /**< \brief Channel counters are running and output is enabled */
    IfxGtm_Pwm_ChannelState_stopped       /**< \brief Either channel or it's output is disabled */
} IfxGtm_Pwm_ChannelState;

/** \brief Reset event for channel counter CN0
 */
typedef enum
{
    IfxGtm_Pwm_ResetEvent_onCm0     = 0, /**< \brief Reset counter when CN0 = CM0 */
    IfxGtm_Pwm_ResetEvent_onTrigger = 1  /**< \brief Reset counter when trigger is received */
} IfxGtm_Pwm_ResetEvent;

/** \brief Module state
 */
typedef enum
{
    IfxGtm_Pwm_State_unknown = -1,  /**< \brief Unknown state */
    IfxGtm_Pwm_State_init    = 0,   /**< \brief Module is being initialized */
    IfxGtm_Pwm_State_run     = 1,   /**< \brief Run state */
    IfxGtm_Pwm_State_stopped = 2,   /**< \brief Stopped state */
    IfxGtm_Pwm_State_error   = 3    /**< \brief Error state */
} IfxGtm_Pwm_State;

/** \brief GTM Submodules
 */
typedef enum
{
    IfxGtm_Pwm_SubModule_atom = 0,  /**< \brief GTM submodule ATOM */
    IfxGtm_Pwm_SubModule_tom  = 1   /**< \brief GTM submodule TOM */
} IfxGtm_Pwm_SubModule;

/** \brief PWM Channels
 */
typedef enum
{
    IfxGtm_Pwm_SubModule_Ch_0  = 0,   /**< \brief ATOM / TOM channel 0 */
    IfxGtm_Pwm_SubModule_Ch_1  = 1,   /**< \brief ATOM / TOM channel 1 */
    IfxGtm_Pwm_SubModule_Ch_2  = 2,   /**< \brief ATOM / TOM channel 2 */
    IfxGtm_Pwm_SubModule_Ch_3  = 3,   /**< \brief ATOM / TOM channel 3 */
    IfxGtm_Pwm_SubModule_Ch_4  = 4,   /**< \brief ATOM / TOM channel 4 */
    IfxGtm_Pwm_SubModule_Ch_5  = 5,   /**< \brief ATOM / TOM channel 5 */
    IfxGtm_Pwm_SubModule_Ch_6  = 6,   /**< \brief ATOM / TOM channel 6 */
    IfxGtm_Pwm_SubModule_Ch_7  = 7,   /**< \brief ATOM / TOM channel 7 */
    IfxGtm_Pwm_SubModule_Ch_8  = 8,   /**< \brief TOM channel 8 */
    IfxGtm_Pwm_SubModule_Ch_9  = 9,   /**< \brief TOM channel 9 */
    IfxGtm_Pwm_SubModule_Ch_10 = 10,  /**< \brief TOM channel 10 */
    IfxGtm_Pwm_SubModule_Ch_11 = 11,  /**< \brief TOM channel 11 */
    IfxGtm_Pwm_SubModule_Ch_12 = 12,  /**< \brief TOM channel 12 */
    IfxGtm_Pwm_SubModule_Ch_13 = 13,  /**< \brief TOM channel 13 */
    IfxGtm_Pwm_SubModule_Ch_14 = 14,  /**< \brief TOM channel 14 */
    IfxGtm_Pwm_SubModule_Ch_15 = 15   /**< \brief TOM channel 15 */
} IfxGtm_Pwm_SubModule_Ch;

/** \brief Index to access individual channel information from array of channels
 */
typedef enum
{
    IfxGtm_Pwm_SyncChannelIndex_0 = 0,  /**< \brief Base Channel */
    IfxGtm_Pwm_SyncChannelIndex_1,      /**< \brief Sync Channel 0 */
    IfxGtm_Pwm_SyncChannelIndex_2,      /**< \brief Sync Channel 1 */
    IfxGtm_Pwm_SyncChannelIndex_3,      /**< \brief Sync Channel 2 */
    IfxGtm_Pwm_SyncChannelIndex_4,      /**< \brief Sync Channel 3 */
    IfxGtm_Pwm_SyncChannelIndex_5,      /**< \brief Sync Channel 4 */
    IfxGtm_Pwm_SyncChannelIndex_6,      /**< \brief Sync Channel 5 */
    IfxGtm_Pwm_SyncChannelIndex_7,      /**< \brief Sync Channel 6 */
    IfxGtm_Pwm_SyncChannelIndex_8,      /**< \brief Sync Channel 7 */
    IfxGtm_Pwm_SyncChannelIndex_9,      /**< \brief Sync Channel 8 */
    IfxGtm_Pwm_SyncChannelIndex_10,     /**< \brief Sync Channel 9 */
    IfxGtm_Pwm_SyncChannelIndex_11,     /**< \brief Sync Channel 10 */
    IfxGtm_Pwm_SyncChannelIndex_12,     /**< \brief Sync Channel 11 */
    IfxGtm_Pwm_SyncChannelIndex_13,     /**< \brief Sync Channel 12 */
    IfxGtm_Pwm_SyncChannelIndex_14,     /**< \brief Sync Channel 13 */
    IfxGtm_Pwm_SyncChannelIndex_15      /**< \brief Sync Channel 14 */
} IfxGtm_Pwm_SyncChannelIndex;

/******************************************************************************/
/*-----------------------------Data Structures--------------------------------*/
/******************************************************************************/

/** \brief Dead time structure
 */
typedef struct
{
    float32 rising;        /**< \brief Relative rise time */
    float32 falling;       /**< \brief Relative fall time */
} IfxGtm_Pwm_DeadTime;

typedef struct
{
    IfxGtm_Dtm_ShutoffInput inputSignal;                 /**< \brief Select input signal to be used as shut off signal */
    boolean                 invertInputSignal;           /**< \brief TRUE: Input signal is inverted */
    IfxGtm_Dtm_SignalLevel  offState;                    /**< \brief Desired state(High or low) of output 0 when shut-off is active */
    IfxGtm_Dtm_SignalLevel  complementaryOffState;       /**< \brief Desired state(High or low) of output 1 (*_N) when shut-off is active */
} IfxGtm_Pwm_FastShutoffConfig;

/** \brief Union of Atom and Tom Tout map
 */
typedef union
{
    IfxGtm_Atom_ToutMap atom;       /**< \brief ATOM map */
    IfxGtm_Tom_ToutMap  tom;        /**< \brief TOM map */
} IfxGtm_Pwm_ToutMap;

/** \brief Structure to store address of frequently used registers
 */
typedef struct
{
    volatile Ifx_UReg_32Bit *SR0;              /**< \brief Pointer to ATOM/TOM SR0 */
    volatile Ifx_UReg_32Bit *SR1;              /**< \brief Pointer to ATOM/TOM SR1 */
    volatile Ifx_UReg_32Bit *CM0;              /**< \brief Pointer to ATOM/TOM CM0 */
    volatile Ifx_UReg_32Bit *CM1;              /**< \brief Pointer to ATOM/TOM CM1 */
    volatile Ifx_UReg_32Bit *CN0;              /**< \brief Pointer to ATOM/TOM CN0 */
    volatile Ifx_UReg_32Bit *CTRL;             /**< \brief Pointer to ATOM/TOM CTRL */
    volatile Ifx_UReg_32Bit *GLB_CTRL;         /**< \brief Pointer to ATOM/TOM GLB_CTRL for disabling/enabling UPEN */
    volatile Ifx_UReg_32Bit *IRQ_NOTIFY;       /**< \brief Pointer to ATOM/TOM IRQ_NOTIFY for reading/clearing interrupts */
    volatile Ifx_UReg_32Bit *DTV;              /**< \brief Pointer to DTM dead time value register */
    volatile Ifx_UReg_32Bit *DTV_SR;           /**< \brief Pointer to DTM dead time shadow value register */
} IfxGtm_Pwm_ChannelRegisters;

typedef struct
{
    IfxGtm_Pwm_DeadTime           deadTime;          /**< \brief Dead time in seconds */
    IfxGtm_Pwm_FastShutoffConfig *fastShutOff;       /**< \brief Enable individual fast shut off by passing a pointer */
} IfxGtm_Pwm_DtmConfig;

/** \brief Interrupt Configuration structure
 */
typedef struct
{
    IfxGtm_IrqMode      mode;              /**< \brief IRQ mode of interrupt. Note: Use IfxGtm_IrqMode_pulseNotify as default */
    IfxSrc_Tos          isrProvider;       /**< \brief Type of Service for Ccu0/1 interrupt */
    Ifx_Priority        priority;          /**< \brief Priority for Ccu0/1 interrupt */
    IfxSrc_VmId         vmId;              /**< \brief Virtual machine interrupt service provider */
    IfxGtm_Pwm_callBack periodEvent;       /**< \brief Period interrupt callback function pointer */
    IfxGtm_Pwm_callBack dutyEvent;         /**< \brief Duty interrupt callback function pointer */
} IfxGtm_Pwm_InterruptConfig;

/** \brief PWM Pin output configuration structure
 */
typedef struct
{
    IfxGtm_Pwm_ToutMap *pin;                        /**< \brief Output pin configuration */
    IfxGtm_Pwm_ToutMap *complementaryPin;           /**< \brief Complementary output pin configuration (_N) */
    Ifx_ActiveState     polarity;                   /**< \brief Active low/high of pin */
    Ifx_ActiveState     complementaryPolarity;      /**< \brief Active low/high of complementary pin */
    IfxPort_OutputMode  outputMode;                 /**< \brief Output mode */
    IfxPort_PadDriver   padDriver;                  /**< \brief Pad driver */
} IfxGtm_Pwm_OutputConfig;

/** \brief Channel run time structure
 */
typedef struct
{
    IfxGtm_Pwm_ChannelRegisters registers;         /**< \brief Contains pointers to frequenctly accessed channel specific registers */
    uint32                      upenMask;          /**< \brief Update enable mask of this channel */
    IfxGtm_Pwm_callBack         periodEvent;       /**< \brief CCU0 interrupt callback function pointer */
    IfxGtm_Pwm_callBack         dutyEvent;         /**< \brief CCU1 interrupt callback function pointer */
    IfxGtm_Pwm_SubModule_Ch     timerCh;           /**< \brief Channel Index */
    uint32                      phaseTicks;        /**< \brief Current phase ticks */
    uint32                      dutyTicks;         /**< \brief Current duty ticks */
} IfxGtm_Pwm_Channel;

/** \brief PWM Channel Configuration structure
 */
typedef struct
{
    IfxGtm_Pwm_SubModule_Ch     timerCh;         /**< \brief Channel Index */
    float32                     phase;           /**< \brief Initial phase in radians (range: 0.0 .. 2pi; only for edge aligned sync channels) */
    float32                     duty;            /**< \brief PWM duty in % (range: 0.0 .. 100.0) */
    IfxGtm_Pwm_DtmConfig       *dtm;             /**< \brief Dead time configuration for this channel */
    IfxGtm_Pwm_OutputConfig    *output;          /**< \brief Pin connections and polarities for this channel */
    IfxGtm_MscOut              *mscOut;          /**< \brief MSC configuration for this channel */
    IfxGtm_Pwm_InterruptConfig *interrupt;       /**< \brief Interrupt configuration for this channel */
} IfxGtm_Pwm_ChannelConfig;

/** \brief Clock source
 */
typedef union
{
    IfxGtm_Cmu_Clk   atom;       /**< \brief Clock source for ATOM channels */
    IfxGtm_Cmu_Fxclk tom;        /**< \brief Clock source for TOM channels */
} IfxGtm_Pwm_ClockSource;

/** \brief Structure to hold pointers to [TGC[0/1]/AGC]_GLB_CTRL and mask value for fast access
 */
typedef struct
{
    volatile Ifx_UReg_32Bit *reg0;                /**< \brief ATOM: points to AGC_GLB_CTRL.
                                                   * TOM: If channels span 2 TGCs then points to TGC0_GLB_CTRL else to the TGC being used TGCx_GLB_CTRL */
    volatile Ifx_UReg_32Bit *reg1;                /**< \brief ATOM: Not used. TOM: Points to TGC1_GLB_CTRL if channels span across 2 TGCs. */
    uint32                   upenMask0;           /**< \brief UPEN Mask for reg0 [AGC/TGC[0/1]]_GLB_CTRL */
    uint32                   upenMask1;           /**< \brief UPEN Mask for reg1 [AGC/TGC[0/1]]_GLB_CTRL */
    volatile Ifx_UReg_32Bit *endisCtrlReg0;       /**< \brief ATOM: points to AGC_ENDIS_CTRL.
                                                   * TOM: If channels span 2 TGCs then points to TGC0_ENDIS_CTRL else to the TGC being used TGCx_GLB_CTRL */
    volatile Ifx_UReg_32Bit *endisCtrlReg1;       /**< \brief ATOM: Not used. TOM: Points to TGC1_ENDIS_CTRL if channels span across 2 TGCs. */
} IfxGtm_Pwm_GlobalControl;

/** \brief PWM Handle
 */
typedef struct
{
    Ifx_GTM                 *gtmSFR;                  /**< \brief Pointer to GTM module */
    Ifx_GTM_CLS             *clusterSFR;              /**< \brief Pointer to cluster SFR */
    IfxGtm_Cluster           cluster;                 /**< \brief Index of the CLS object used */
    IfxGtm_Pwm_SubModule     subModule;               /**< \brief Sub module to be used for PWM */
    IfxGtm_Pwm_Alignment     alignment;               /**< \brief PWM alignment */
    uint8                    numChannels;             /**< \brief Number of channels configured (base + sync) */
    IfxGtm_Pwm_Channel      *channels;                /**< \brief Stores state of PWM channels (base + sync) */
    IfxGtm_Pwm_GlobalControl globalControl;           /**< \brief Pointer and mask for GLB_CTRL */
    float32                  sourceFrequency;         /**< \brief Source clock frequency in Hz */
    float32                  dtmFrequency;            /**< \brief DTM clock frequency in Hz */
    float32                  frequency;               /**< \brief Current PWM frequency in Hz */
    uint32                   periodTicks;             /**< \brief Current PWM Period in ticks */
    IfxGtm_Pwm_ClockSource   clockSource;             /**< \brief Clock source for Atom/Tom channels */
    IfxGtm_Dtm_ClockSource   dtmClockSource;          /**< \brief Clock source for DTM channels */
    boolean                  syncUpdateEnabled;       /**< \brief TRUE: Update compare registers from shadow at the end of period */
    IfxGtm_Pwm_State         state;                   /**< \brief Module state */
} IfxGtm_Pwm;

/** \brief PWM Configuration structure
 */
typedef struct
{
    Ifx_GTM                  *gtmSFR;                 /**< \brief Pointer to GTM module */
    IfxGtm_Cluster            cluster;                /**< \brief Index of the CLS object used */
    IfxGtm_Pwm_SubModule      subModule;              /**< \brief Sub module to be used for PWM */
    IfxGtm_Pwm_Alignment      alignment;              /**< \brief PWM alignment */
    uint8                     numChannels;            /**< \brief Number of channels (base + sync) to be configured */
    IfxGtm_Pwm_ChannelConfig *channels;               /**< \brief Pointer to channel configuration */
    float32                   frequency;              /**< \brief Initial PWM frequency */
    IfxGtm_Pwm_ClockSource    clockSource;            /**< \brief Clock source for Atom/Tom channels */
    IfxGtm_Dtm_ClockSource    dtmClockSource;         /**< \brief Clock source for DTM channels */
    boolean                   syncUpdateEnabled;      /**< \brief TRUE: Update compare registers from shadow at the end of period */
    boolean                   syncStart;              /**< \brief TRUE: Synchronously start all channels PWM by starting the counters at the end of init */
} IfxGtm_Pwm_Config;

/** \brief Configuration structure for output pin
 */
typedef struct
{
    IfxGtm_Pwm_ToutMap *outputPin;        /**< \brief Output pin */
    IfxPort_OutputMode  outputMode;       /**< \brief Output mode */
    IfxPort_PadDriver   padDriver;        /**< \brief Pad driver */
} IfxGtm_Pwm_Pin;

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Sets the Signal level during duty cycle for specified channel
 * \param clusterSFR Pointer to the Cluster object
 * \param subModule ATOM/TOM
 * \param channel Channel index
 * \param polarity Active high/low
 * \return None
 */
IFX_INLINE void IfxGtm_Pwm_setChannelPolarity(Ifx_GTM_CLS *clusterSFR, IfxGtm_Pwm_SubModule subModule, IfxGtm_Pwm_SubModule_Ch channel, Ifx_ActiveState polarity);

/** \brief Update sync channel phase with requested value at the end of period (synchronously)
 * Note: Use this API only for sync channels and not for base channel. API doesn't check this condition.
 * \param pwm PWM handle
 * \param configIndex Index of channel in the array of configured PWM channels
 * \param requestPhase Requested phase in radians (0.0 .. 2 * pi)
 * \return None
 */
IFX_INLINE void IfxGtm_Pwm_updateChannelPhase(IfxGtm_Pwm *pwm, IfxGtm_Pwm_SyncChannelIndex configIndex, float32 requestPhase);

/** \brief Update sync channel phase with requested value immediately (asynchronously)
 * Note: Use this API only for sync channels and not for base channel. API doesn't check this condition.
 * \param pwm PWM handle
 * \param configIndex Index of channel in the array of configured PWM channels
 * \param requestPhase Requested phase in radians (0.0 .. 2 * pi)
 * \return None
 */
IFX_INLINE void IfxGtm_Pwm_updateChannelPhaseImmediate(IfxGtm_Pwm *pwm, IfxGtm_Pwm_SyncChannelIndex configIndex, float32 requestPhase);

/** \brief Update channel duty with requested value at the end of period (synchronously)
 * \param pwm PWM handle
 * \param configIndex Index of channel in the array of configured PWM channels
 * \param requestDuty Requested duty in % (0.0 .. 100.0)
 * \return None
 */
IFX_INLINE void IfxGtm_Pwm_updateChannelDuty(IfxGtm_Pwm *pwm, IfxGtm_Pwm_SyncChannelIndex configIndex, float32 requestDuty);

/** \brief Update channel duty with requested value immediately (asynchronously)
 * \param pwm PWM handle
 * \param configIndex Index of channel in the array of configured PWM channels
 * \param requestDuty Requested duty in % (0.0 .. 100.0)
 * \return None
 */
IFX_INLINE void IfxGtm_Pwm_updateChannelDutyImmediate(IfxGtm_Pwm *pwm, IfxGtm_Pwm_SyncChannelIndex configIndex, float32 requestDuty);

/** \brief Update channel dead time (leading and trailing) with requested value (synchronously)
 * \param pwm PWM handle
 * \param configIndex Index of channel in the array of configured PWM channels
 * \param requestDeadTime Requested dead time in seconds
 * \return None
 */
IFX_INLINE void IfxGtm_Pwm_updateChannelDeadTime(IfxGtm_Pwm *pwm, IfxGtm_Pwm_SyncChannelIndex configIndex, IfxGtm_Pwm_DeadTime requestDeadTime);

/** \brief Update channel dead time (leading and trailing) with requested value (asynchronously)
 * \param pwm PWM handle
 * \param configIndex Index of channel in the array of configured PWM channels
 * \param requestDeadTime Requested dead time in seconds
 * \return None
 */
IFX_INLINE void IfxGtm_Pwm_updateChannelDeadTimeImmediate(IfxGtm_Pwm *pwm, IfxGtm_Pwm_SyncChannelIndex configIndex, IfxGtm_Pwm_DeadTime requestDeadTime);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Initializes the configuration structure to default values
 * \param config Configuration structure
 * \param gtmSFR Pointer to GTM module
 * \return None
 */
IFX_EXTERN void IfxGtm_Pwm_initConfig(IfxGtm_Pwm_Config *config, Ifx_GTM *gtmSFR);

/** \brief Initializes the channel configuration structure to default values
 * \param channelConfig Configuration structure
 * \return None
 */
IFX_EXTERN void IfxGtm_Pwm_initChannelConfig(IfxGtm_Pwm_ChannelConfig *channelConfig);

/** \brief Initializes the GTM module for PWM
 * \param pwm PWM handle
 * \param channels Pointer to array to store channel data
 * Length of array is specified in config parameter
 * \param config Configuration structure
 * \return None
 */
IFX_EXTERN void IfxGtm_Pwm_init(IfxGtm_Pwm *pwm, IfxGtm_Pwm_Channel *channels, IfxGtm_Pwm_Config *config);

/** \brief Synchronously start all the configured channels
 * \param pwm PWM handle
 * \return None
 */
IFX_EXTERN void IfxGtm_Pwm_startSyncedChannels(IfxGtm_Pwm *pwm);

/** \brief Synchronously stops all the configured channels
 * \param pwm PWM handle
 * \return None
 */
IFX_EXTERN void IfxGtm_Pwm_stopSyncedChannels(IfxGtm_Pwm *pwm);

/** \brief Synchronously start two synced groups using TBU submodule of GTM
 * \param pwm1 First PWM handle
 * \param pwm2 Second PWM handle
 * \return None
 */
IFX_EXTERN void IfxGtm_Pwm_startSyncedGroups(IfxGtm_Pwm *pwm1, IfxGtm_Pwm *pwm2);

/** \brief Synchronously stops two synced groups using TBU submodule of GTM
 * \param pwm1 First PWM handle
 * \param pwm2 Second PWM handle
 * \return None
 */
IFX_EXTERN void IfxGtm_Pwm_stopSyncedGroups(IfxGtm_Pwm *pwm1, IfxGtm_Pwm *pwm2);

/** \brief Change the frequency of all channels to requested frequency at the end of period (synchronously)
 * \param pwm PWM handle
 * \param requestFrequency Requested frequency in Hz
 * \return None
 */
IFX_EXTERN void IfxGtm_Pwm_updateFrequency(IfxGtm_Pwm *pwm, float32 requestFrequency);

/** \brief Change the frequency of two synced groups' channels to requested frequency at the end of period (synchronously)
 * \param pwm1 PWM handle 1
 * \param pwm2 PWM handle 2
 * \param requestFrequency Requested frequency in Hz
 * \return None
 */
IFX_EXTERN void IfxGtm_Pwm_updateSyncedGroupsFrequency(IfxGtm_Pwm *pwm1, IfxGtm_Pwm *pwm2, float32 requestFrequency);

/** \brief Change the frequency of all channels to requested frequency immediately (asynchronously)
 * \param pwm PWM handle
 * \param requestFrequency Requested frequency in Hz
 * \return None
 */
IFX_EXTERN void IfxGtm_Pwm_updateFrequencyImmediate(IfxGtm_Pwm *pwm, float32 requestFrequency);

/** \brief Update phase and duty of any configured channel to requested values at the end of period (synchronously)
 * It is recommeded to use this API only for edge aligned PWM
 * \param pwm PWM handle
 * \param configIndex Enum to choose channel type (base/sync) and index
 * \param requestPhase New phase value (applicable for edge aligned sync channel)
 * \param requestDuty New duty value
 * \return None
 */
IFX_EXTERN void IfxGtm_Pwm_updateChannelPulse(IfxGtm_Pwm *pwm, IfxGtm_Pwm_SyncChannelIndex configIndex, float32 requestPhase, float32 requestDuty);

/** \brief Update phase and duty of any configured channel to requested values immediately (asynchronously)
 * It is recommeded to use this API only for edge aligned PWM
 * \param pwm PWM handle
 * \param configIndex Enum to choose channel type (base/sync) and index
 * \param requestPhase New phase value(applicable for edge aligned sync channel)
 * \param requestDuty New duty value
 * \return None
 */
IFX_EXTERN void IfxGtm_Pwm_updateChannelPulseImmediate(IfxGtm_Pwm *pwm, IfxGtm_Pwm_SyncChannelIndex configIndex, float32 requestPhase, float32 requestDuty);

/** \brief Update phase of all configured channels to requested values at the end of period (synchronously)
 * \param pwm PWM handle
 * \param requestPhase New phase values
 * Note: First index element is ignored
 * \return None
 */
IFX_EXTERN void IfxGtm_Pwm_updateChannelsPhase(IfxGtm_Pwm *pwm, float32 *requestPhase);

/** \brief Update duty of all configured channels to requested values at the end of period (synchronously)
 * \param pwm PWM handle
 * \param requestDuty New duty value
 * \return None
 */
IFX_EXTERN void IfxGtm_Pwm_updateChannelsDuty(IfxGtm_Pwm *pwm, float32 *requestDuty);

/** \brief Update phase and duty of all configured channels to requested values at the end of period (synchronously)
 * It is recommeded to use this API only for edge aligned PWM
 * \param pwm PWM handle
 * \param requestPhase New phase value(applicable for edge aligned sync channel)
 * \param requestDuty New duty value
 * \return None
 */
IFX_EXTERN void IfxGtm_Pwm_updateChannelsPulse(IfxGtm_Pwm *pwm, float32 *requestPhase, float32 *requestDuty);

/** \brief Update dead time of all configured channels to requested values
 * \param pwm PWM handle
 * \param requestDeadTime New dead time value
 * \return None
 */
IFX_EXTERN void IfxGtm_Pwm_updateChannelsDeadTime(IfxGtm_Pwm *pwm, IfxGtm_Pwm_DeadTime *requestDeadTime);

/** \brief Update phase of all configured channels to requested values immediately (asynchronously)
 * \param pwm PWM handle
 * \param requestPhase New phase values
 * Note: First index element is ignored
 * \return None
 */
IFX_EXTERN void IfxGtm_Pwm_updateChannelsPhaseImmediate(IfxGtm_Pwm *pwm, float32 *requestPhase);

/** \brief Update duty of all configured channels to requested values immediately (asynchronously)
 * \param pwm PWM handle
 * \param requestDuty New duty value
 * \return None
 */
IFX_EXTERN void IfxGtm_Pwm_updateChannelsDutyImmediate(IfxGtm_Pwm *pwm, float32 *requestDuty);

/** \brief Update phase and duty of all configured channels to requested values immediately (asynchronously)
 * It is recommeded to use this API only for edge aligned PWM
 * \param pwm PWM handle
 * \param requestPhase New phase value(applicable for edge aligned sync channel)
 * \param requestDuty New duty value
 * \return None
 */
IFX_EXTERN void IfxGtm_Pwm_updateChannelsPulseImmediate(IfxGtm_Pwm *pwm, float32 *requestPhase, float32 *requestDuty);

/** \brief Function that handles interrupt generated by channel by calling ccu0/ccu1 callback functions
 * \param channel Channel handle
 * \param data Data to pass to callback functions
 * \return None
 */
IFX_EXTERN void IfxGtm_Pwm_interruptHandler(IfxGtm_Pwm_Channel *channel, void *data);

/** \brief Gets channel state: running or stopped
 * \param pwm PWM handle
 * \param channel Channel index
 * \return Channel state
 */
IFX_EXTERN IfxGtm_Pwm_ChannelState IfxGtm_Pwm_getChannelState(IfxGtm_Pwm *pwm, IfxGtm_Pwm_SubModule_Ch channel);

/******************************************************************************/
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE void IfxGtm_Pwm_setChannelPolarity(Ifx_GTM_CLS *clusterSFR, IfxGtm_Pwm_SubModule subModule, IfxGtm_Pwm_SubModule_Ch channel, Ifx_ActiveState polarity)
{
    if (subModule == IfxGtm_Pwm_SubModule_atom)
    {
        clusterSFR->ATOM.CH[channel].CTRL.B.SL       = (uint8)(polarity); /* Write to channel control register */
        clusterSFR->ATOM.CH[channel].CTRL_SR.B.SL_SR = (uint8)(polarity); /* Wrute to channel control shadow register */
    }
    else                                                                  /* TOM */
    {
        clusterSFR->TOM.CH[channel].CTRL.B.SL       = (uint8)(polarity);  /* Write to channel control register */
        clusterSFR->TOM.CH[channel].CTRL_SR.B.SL_SR = (uint8)(polarity);  /* Wrute to channel control shadow register */
    }
}


IFX_INLINE void IfxGtm_Pwm_updateChannelPhase(IfxGtm_Pwm *pwm, IfxGtm_Pwm_SyncChannelIndex configIndex, float32 requestPhase)
{
    IfxGtm_Pwm_Channel *channel = &pwm->channels[configIndex];

    /* Phase in ticks = period * (phase in radian / (2 * pi)) */
    uint32              phaseTicks = (uint32)((float32)(((float32)pwm->periodTicks * requestPhase * IFX_ONE_OVER_TWO_PI) + (float32)0.5f));

    /* Subtract old phase value and add new vale */
    uint32              dutyTicks = (channel->dutyTicks - channel->phaseTicks) + phaseTicks;

    /* Copy to handle */
    channel->phaseTicks = phaseTicks;
    channel->dutyTicks  = dutyTicks;

    /* Update shadow register */
    *channel->registers.SR0 = phaseTicks;
    *channel->registers.SR1 = (dutyTicks <= pwm->periodTicks) ? dutyTicks : dutyTicks - pwm->periodTicks;
}


IFX_INLINE void IfxGtm_Pwm_updateChannelPhaseImmediate(IfxGtm_Pwm *pwm, IfxGtm_Pwm_SyncChannelIndex configIndex, float32 requestPhase)
{
    IfxGtm_Pwm_Channel *channel = &pwm->channels[configIndex];

    /* Phase in ticks = period * (phase in radian / (2 * pi)) */
    uint32              phaseTicks = (uint32)((float32)(((float32)pwm->periodTicks * requestPhase * IFX_ONE_OVER_TWO_PI) + (float32)0.5f));

    /* Subtract old phase value and add new value */
    uint32              dutyTicks = (channel->dutyTicks - channel->phaseTicks) + phaseTicks;

    /* Copy to handle */
    channel->phaseTicks = phaseTicks;
    channel->dutyTicks  = dutyTicks;

    dutyTicks           = (dutyTicks <= pwm->periodTicks) ? dutyTicks : dutyTicks - pwm->periodTicks;

    /* Update compare register */
    *channel->registers.SR0 = phaseTicks;
    *channel->registers.SR1 = dutyTicks;
    *channel->registers.CM0 = phaseTicks;
    *channel->registers.CM1 = dutyTicks;
}


IFX_INLINE void IfxGtm_Pwm_updateChannelDuty(IfxGtm_Pwm *pwm, IfxGtm_Pwm_SyncChannelIndex configIndex, float32 requestDuty)
{
    IfxGtm_Pwm_Channel *channel = &pwm->channels[configIndex];

    /* Duty in ticks = period * (duty in percent / 100%) */
    uint32              dutyTicks = (uint32)((float32)(((float32)pwm->periodTicks * requestDuty * 0.01f) + (float32)0.5f));

    /* Subtract from period for center aligned */
    if (pwm->alignment != IfxGtm_Pwm_Alignment_edge)
    {
        dutyTicks          = pwm->periodTicks - dutyTicks;
        channel->dutyTicks = dutyTicks;
    }
    /* Offset by phase to account for phase shift in sync channel edge aligned (phaseticks = 0 for base channel) */
    else
    {
        dutyTicks         += channel->phaseTicks;
        channel->dutyTicks = dutyTicks;
        dutyTicks          = (dutyTicks <= pwm->periodTicks) ? dutyTicks : dutyTicks - pwm->periodTicks;
    }

    /* Update shadow register */
    *channel->registers.SR1 = dutyTicks;
}


IFX_INLINE void IfxGtm_Pwm_updateChannelDutyImmediate(IfxGtm_Pwm *pwm, IfxGtm_Pwm_SyncChannelIndex configIndex, float32 requestDuty)
{
    IfxGtm_Pwm_Channel *channel = &pwm->channels[configIndex];

    /* Duty in ticks = period * (duty in percent / 100%) */
    uint32              dutyTicks = (uint32)((float32)(((float32)pwm->periodTicks * requestDuty * 0.01f) + (float32)0.5f));

    /* Subtract from period for center aligned */
    if (pwm->alignment != IfxGtm_Pwm_Alignment_edge)
    {
        dutyTicks          = pwm->periodTicks - dutyTicks;
        channel->dutyTicks = dutyTicks;
    }
    /* Offset by phase to account for phase shift in sync channel edge aligned (phaseticks = 0 for base channel) */
    else
    {
        dutyTicks         += channel->phaseTicks;
        channel->dutyTicks = dutyTicks;
        dutyTicks          = (dutyTicks <= pwm->periodTicks) ? dutyTicks : dutyTicks - pwm->periodTicks;
    }

    /* Update compare register */
    *channel->registers.SR1 = dutyTicks;
    *channel->registers.CM1 = dutyTicks;
}


IFX_INLINE void IfxGtm_Pwm_updateChannelDeadTime(IfxGtm_Pwm *pwm, IfxGtm_Pwm_SyncChannelIndex configIndex, IfxGtm_Pwm_DeadTime requestDeadTime)
{
    IfxGtm_Pwm_Channel *channel = &pwm->channels[configIndex];

    /* Only update if channel is connected to DTM */
    if (channel->registers.DTV_SR != NULL_PTR)
    {
        Ifx_GTM_CLS_CDTM_DTM_CH_DTV_SR dtvSrReg;

        /* Read current register state */
        dtvSrReg.U = *channel->registers.DTV_SR;

        /* Get dead time ticks */
        dtvSrReg.B.RELRISE_SR = (uint16)((float32)((requestDeadTime.rising * pwm->dtmFrequency) + (float32)0.5f));
        dtvSrReg.B.RELFALL_SR = (uint16)((float32)((requestDeadTime.falling * pwm->dtmFrequency) + (float32)0.5f));

        /* Configure registers */
        *channel->registers.DTV_SR = dtvSrReg.U;
    }
}


IFX_INLINE void IfxGtm_Pwm_updateChannelDeadTimeImmediate(IfxGtm_Pwm *pwm, IfxGtm_Pwm_SyncChannelIndex configIndex, IfxGtm_Pwm_DeadTime requestDeadTime)
{
    IfxGtm_Pwm_Channel *channel = &pwm->channels[configIndex];

    /* Only update if channel is connected to DTM */
    if (channel->registers.DTV != NULL_PTR)
    {
        Ifx_GTM_CLS_CDTM_DTM_CH_DTV    dtvReg;
        Ifx_GTM_CLS_CDTM_DTM_CH_DTV_SR dtvSrReg;

        /* Calculate values */
        uint32                         risingTicks  = (uint32)((float32)((requestDeadTime.rising * pwm->dtmFrequency) + (float32)0.5f));
        uint32                         fallingTicks = (uint32)((float32)((requestDeadTime.falling * pwm->dtmFrequency) + (float32)0.5f));

        /* Read current register state */
        dtvSrReg.U = *channel->registers.DTV_SR;

        /* Save dead time ticks */
        dtvReg.B.RELRISE      = (uint16)risingTicks;
        dtvReg.B.RELFALL      = (uint16)fallingTicks;
        dtvSrReg.B.RELRISE_SR = (uint16)risingTicks;
        dtvSrReg.B.RELFALL_SR = (uint16)fallingTicks;

        /* Configure registers */
        *channel->registers.DTV_SR = dtvSrReg.U;
        *channel->registers.DTV    = dtvReg.U;
    }
}


#endif /* IFXGTM_PWM_H */
