/**
 * \file IfxGtm_Atom_Timer.h
 * \brief GTM TIMER details
 * \ingroup IfxLld_Gtm
 *
 * \version iLLD_2_0_1_2_19
 * \copyright Copyright (c) 2023 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 * \defgroup IfxLld_Gtm_Atom_Timer_Usage How to use the GTM ATOM Timer Driver
 * \ingroup IfxLld_Gtm_Atom_Timer
 *
 *   This driver implements the timer functionalities.
 *
 * \section specific Specific Implementation
 *   The timer functionality is implemented using either a single or 2 ATOM channels. The decision to use 1 or 2 channels is done
 *   depending on the following requirements:
 *   - relative position of the timer channel to the other channels used if any
 *   - need to trigger another module, for example ADC triggering.
 *
 *   Single ATOM channel is used for the timer and trigger functionalities.
 *   The internal trigger signal is generated when the counter CN0 reach the CM0 compare register. The value of CM0 act as the period value. This internal
 *   trigger is used to reset the CN0 counter and simultaneously transfer the shadow values for the period value (SR0->CM0)
 *   and trigger edge (SR1->CM1). The internal trigger is used as a trigger input to the next ATOM channel.
 *   The trigger signal (output trigger) is generated by the CM0 and CM1 compare values. Depending on the trigger signal active
 *   edge \ref IfxGtm_Atom_Timer_Config "configuration", the CM0 will reset, and the CM1 will set the trigger signal, or vice versa.
 *
 *   In case 2 ATOM channels are used for the timer and trigger functionalities,
 *   the 1st channel (CHz) is used for the generation of the period,  and the 2nd channel (CHz+n) is used for the trigger generation.
 *
 *   The CHz ATOM channel generates the internal trigger signal when the counter CN0 reach the CM0 compare register.
 *   The value of CM0 of CHz act as the period value. This internal trigger is used to reset the  CN0 counter and simultaneously
 *   transfer the shadow period value (SR0->CM0). The internal trigger is used as an input for the next ATOM channel.
 *
 *   The CHz+n ATOM channel, uses the internal trigger signal to simultaneously resets the
 *   counter CN0, and transfer the shadow values used for the generation of the trigger falling and rising edges (SR0->CM0 and SR1->CM1).
 *   The internal trigger is used as a trigger input to the next ATOM channel.
 *   Depending on the trigger signal active edge \ref IfxGtm_Atom_Timer_Config "configuration", the CM0 will reset, and the CM1 will set the trigger signal, or vice versa.
 *   In orter to have a similar behaviour to the single channel implementation,
 *   the CM0 is set to the same value as CHz CM0, and CM1 is used for the trigger edge.
 *
 *   In order to ensure a coherent update of all registers, the internal trigger must be disable before updating
 *   the timer and trigger shadow values, and enabled once the update is done. The transfer will occurs at the next timer reset.
 *
 *   - Resources used:
 *       - if the trigger channel is identical to the timer channel, only one ATOM channels is used.
 *       - if the trigger channel is different from the timer channel, 2 ATOM channels are used.
 *       - All channels used must be of the same ATOM and ATOM TGC.
 *   - The timer counting direction is limited to \ref IfxGtm_Atom_Timer_CountDir_up.
 *   - If the ATOM trigger channel is not the same as the ATOM timer channels.
 *       - The ATOM channel used for the trigger must have a lower index than the ATOM channels.
 *         used for the timer.
 *       - the ATOM channels must be contiguous, unless specified by the driver using the timer driver.
 *
 *  Note: the timer and trigger must be part of the same TGC, but PWM channels can be of different TGC of the same ATOM as the timer.
 *
 *   For a detailed configuration of the microcontroller, see \ref IfxGtm_Atom_Timer_init().
 *
 *
 * \section Preparation Preparation
 * \subsection Include Include Files
 *
 * Include following header file into your C code:
 * \code
 *     #include <Gtm/Atom/Timer/IfxGtm_Atom_Timer.h>
 * \endcode
 *
 * \subsection Variables Variables
 * define global variables if necessary
 *
 * \code
 * Ifx_GTM *gtm = &MODULE_GTM;
 * #define ATOM0_CH0_PRIO 10
 * \endcode
 *
 * \subsection Interrupts Interrupts
 * define Interrupts if needed
 *
 * \code
 * IFX_INTERRUPT(ATOM0Ch0_ISR, 0, ATOM0_CH0_PRIO)
 * {}
 * \endcode
 *
 * \subsection Initialization Initialization
 *
 * \code
 * // install interrupt handlers
 * IfxCpu_Irq_installInterruptHandler (ATOM0Ch0_ISR, ATOM0_CH0_PRIO);
 *
 * // enable GTM clock
 * {
 *     float32 frequency = IfxGtm_Cmu_getModuleFrequency(gtm);
 *     // Enables the GTM
 *     IfxGtm_enable(gtm);
 *     // Set the global clock frequency to the max
 *     IfxGtm_Cmu_setGclkFrequency(gtm, frequency);
 *     // Set the CMU CLK0
 *     IfxGtm_Cmu_setClkFrequency(gtm, IfxGtm_Cmu_Clk_0, frequency);
 *     // FXCLK: used by TOM and CLK0: used by ATOM
 *     IfxGtm_Cmu_enableClocks(gtm, IFXGTM_CMU_CLKEN_FXCLK | IFXGTM_CMU_CLKEN_CLK0);
 * }
 *
 * // initialize ATOM
 * \code
 * IfxGtm_Atom_Timer_Config atomConfig;      \\configuration structure
 * IfxGtm_Atom_Timer atomHandle;      \\ handle
 *
 * IfxGtm_Atom_Pwm_initConfig(&atomConfig, gtm);
 *
 *     //configuration
 *     atomConfig.gtm                               = gtm;
 *     atomConfig.cluster                           = IfxGtm_Cluster_0;
 *     atomConfig.timerChannel                      = IfxGtm_Atom_Ch_0;
 *     atomConfig.clock                             = IfxGtm_Atom_Ch_ClkSrc_cmuFxclk0;
 *     atomConfig.countDir                          = IfxGtm_Atom_Timer_CountDir_up;
 *     atomConfig.initPins                          = FALSE;
 *     atomConfig.frequency                      = 200000; \\frequency in Hz
 *     atomConfig.startOffset		     = 0;
 *     atomConfig.minResolution               = 0;
 *     atomConfig.interrupt.isrPriority       = INTERRUPT_TIMER;
 *
 * IfxGtm_Atom_Timer_init (&atomHandle, &atomConfig);
 *
 * \endcode
 *
 * During run-time
 * \code
 *  IfxGtm_Atom_Timer_run(&atomHandle);
 *  IfxGtm_Atom_Timer_disableUpdate(&atomHandle);
 *  IfxGtm_Atom_Timer_setPeriod(&atomHandle);
 *  IfxGtm_Atom_Timer_applyUpdate(&atomHandle);
 *
 * \endcode
 *
 * \defgroup IfxLld_Gtm_Atom_Timer ATOM Timer Interface Driver
 * \ingroup IfxLld_Gtm_Atom
 * \defgroup IfxLld_Gtm_Atom_Timer_Timer_StdIf_Functions Timer StdIf Functions
 * \ingroup IfxLld_Gtm_Atom_Timer
 * \defgroup IfxLld_Gtm_Atom_Timer_Timer_Functions Timer Functions
 * \ingroup IfxLld_Gtm_Atom_Timer
 * \defgroup IfxLld_Gtm_Atom_Timer_Data_Structures Data Structures
 * \ingroup IfxLld_Gtm_Atom_Timer
 * \defgroup IfxLld_Gtm_Atom_Timer_Enumerations Enumerations
 * \ingroup IfxLld_Gtm_Atom_Timer
 */

#ifndef IFXGTM_ATOM_TIMER_H
#define IFXGTM_ATOM_TIMER_H 1

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "_PinMap/IfxGtm_PinMap.h"
#include "Gtm/Std/IfxGtm_Atom.h"
#include "Gtm/Std/IfxGtm_Cmu.h"
#include "Gtm/Std/IfxGtm_Dtm.h"
#include "_Utilities/Ifx_Assert.h"

/******************************************************************************/
/*--------------------------------Enumerations--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Gtm_Atom_Timer_Enumerations
 * \{ */
/** \brief Timer increment direction
 */
typedef enum
{
    IfxGtm_Atom_Timer_CountDir_up,         /**< \brief Timer is counting up */
    IfxGtm_Atom_Timer_CountDir_upAndDown,  /**< \brief Timer is counting up and down */
    IfxGtm_Atom_Timer_CountDir_down        /**< \brief Timer is counting down */
} IfxGtm_Atom_Timer_CountDir;

/** \} */

/******************************************************************************/
/*-----------------------------Data Structures--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Gtm_Atom_Timer_Data_Structures
 * \{ */
/** \brief Interrupt configuration
 */
typedef struct
{
    Ifx_Priority   isrPriority;       /**< \brief Interrupt Priority, if 0 the interrupt is disable */
    IfxSrc_Tos     isrProvider;       /**< \brief Interrupt service provider */
    IfxGtm_IrqMode irqMode;           /**< \brief Interrupt mode */
    IfxSrc_VmId    vmId;              /**< \brief Virtual machine interrupt service provider */
} IfxGtm_Atom_Timer_Interrupt;

/** \} */

/** \addtogroup IfxLld_Gtm_Atom_Timer_Data_Structures
 * \{ */
/** \brief Trigger configuration
 */
typedef struct
{
    boolean                     enabled;                  /**< \brief If TRUE, the trigger functionality is initialized, else ignored */
    uint32                      triggerPoint;             /**< \brief Trigger point in timer ticks */
    IfxPort_OutputMode          outputMode;               /**< \brief Output mode */
    IfxPort_PadDriver           outputDriver;             /**< \brief Output pad driver */
    boolean                     risingEdgeAtPeriod;       /**< \brief Set the clock signal polarity, if TRUE, the rising edge is at the period, else at the trigger offset. When the timer is stopped, the output is set to high */
    boolean                     outputEnabled;            /**< \brief If TRUE, the output pin is enabled, else disabled. In case the output is disabled, the output pin is not initialized. */
    IfxGtm_Atom_Timer_Interrupt interrupt;                /**< \brief Interrupt configuration */
} IfxGtm_Atom_Timer_Trigger;

/** \} */

/** \addtogroup IfxLld_Gtm_Atom_Timer_Data_Structures
 * \{ */
/** \brief TOM Timer interface
 */
typedef struct
{
    Ifx_GTM                   *gtm;                    /**< \brief GTM module used for the timer functionality */
    Ifx_GTM_CLS_ATOM          *atom;                   /**< \brief ATOM used for the timer functionality */
    Ifx_GTM_CLS_ATOM_AGC      *agc;                    /**< \brief Pointer to the AGC object */
    IfxGtm_Cluster             clsIndex;               /**< \brief Enum for CLS objects */
    IfxGtm_Atom_Ch             timerChannel;           /**< \brief ATOM channel used for the timer */
    IfxGtm_Atom_Ch             triggerChannel;         /**< \brief ATOM channel used for the trigger, if identical to the timerChannel, the trigger interrupt is having the same interrupt level as  the timer interrupt */
    uint16                     channelsMask;           /**< \brief Mask for channels to be modified together */
    uint32                     offset;                 /**< \brief Timer initial offset in ticks */
    Ifx_GTM_CLS_CDTM_DTM      *dtm;                    /**< \brief Pointer to DTM object used by ATOM */
    IfxGtm_Dtm_Ch              dtmChannel;             /**< \brief DTM channel */
    uint32                     agcDisableUpdate;       /**< \brief AGC value for disable update */
    uint32                     agcApplyUpdate;         /**< \brief AGC value for apply update */
    uint32                     period;                 /**< \brief Timer period in ticks (cached value) */
    boolean                    triggerEnabled;         /**< \brief If TRUE, the trigger functionality is initialized */
    float32                    clockFreq;              /**< \brief Timer input clock frequency (cached value) */
    IfxGtm_Atom_Timer_CountDir countDir;               /**< \brief Timer counting mode */
} IfxGtm_Atom_Timer;

/** \brief Configuration structure for TOM Timer
 */
typedef struct
{
    Ifx_GTM                    *gtm;                  /**< \brief GTM used for the timer functionality */
    IfxGtm_Cluster              cluster;              /**< \brief CLS used for the timer functionality */
    IfxGtm_Atom_Ch              timerChannel;         /**< \brief ATOM channel used for the timer */
    IfxGtm_Atom_ToutMap        *triggerOut;           /**< \brief ATOM channel used for the trigger output, can be identical to the timer channe */
    IfxGtm_Atom_Ch_ClkSrc       clock;                /**< \brief Timer input clock */
    IfxGtm_Dtm_ClockSource      dtmClockSource;       /**< \brief DTM clock source */
    float32                     frequency;            /**< \brief PWM frequency in Hz. This parameter is only used to initialize the timer structure. An additional cell is required to build the timer. */
    float32                     minResolution;        /**< \brief Minimum resolution of the timer in seconds. if 0, this parameter is ignored. If the configuration does not enable this setting a warning is given */
    float32                     startOffset;          /**< \brief FIXME make startOffset as Ifx_TimerValue. Timer initial offset in % of the period */
    IfxGtm_Atom_Timer_CountDir  countDir;             /**< \brief Timer counting mode */
    IfxGtm_Atom_Timer_Interrupt interrupt;            /**< \brief Interrupt configuration */
    IfxGtm_Atom_Timer_Trigger   trigger;              /**< \brief trigger configuration */
    boolean                     initPins;             /**< \brief TRUE: Initialize pins in driver
                                                       * FALSE: Don't initialize pins in driver : user handles separately */
} IfxGtm_Atom_Timer_Config;

/** \} */

/** \addtogroup IfxLld_Gtm_Atom_Timer_Timer_StdIf_Functions
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Add a channel to the channel mask
 * Channels present in the mask are started, stopped, updated at the same time as the timer:
 * IfxGtm_Atom_Timer_applyUpdate, IfxGtm_Atom_Timer_disableUpdate, IfxGtm_Atom_Timer_stop, IfxGtm_Atom_Timer_run
 * \param driver ATOM Timer interface Handle
 * \param channel Channel to ba added to the mask
 * \return None
 */
IFX_INLINE void IfxGtm_Atom_Timer_addToChannelMask(IfxGtm_Atom_Timer *driver, IfxGtm_Atom_Ch channel);

/** \brief Enables the transfer of the shadow registers
 * \see IfxStdIf_Timer_ApplyUpdate
 * \param driver ATOM Timer interface Handle
 * \return None
 */
IFX_INLINE void IfxGtm_Atom_Timer_applyUpdate(IfxGtm_Atom_Timer *driver);

/** \brief Disables the update
 * \see IfxStdIf_Timer_DisableUpdate
 * \param driver ATOM Timer interface Handle
 * \return None
 */
IFX_INLINE void IfxGtm_Atom_Timer_disableUpdate(IfxGtm_Atom_Timer *driver);

/** \brief Returns the frequency
 * \see IfxStdIf_Timer_GetFrequency
 * \param driver ATOM Timer interface Handle
 * \return Frequency
 */
IFX_INLINE float32 IfxGtm_Atom_Timer_getFrequency(IfxGtm_Atom_Timer *driver);

/** \brief Returns the Input frequency
 * \see IfxStdIf_Timer_GetInputFrequency
 * \param driver ATOM Timer interface Handle
 * \return Frequency
 */
IFX_INLINE float32 IfxGtm_Atom_Timer_getInputFrequency(IfxGtm_Atom_Timer *driver);

/** \brief Returns the period of the timer
 * \see IfxStdIf_Timer_GetPeriod
 * \param driver ATOM Timer interface Handle
 * \return Period
 */
IFX_INLINE uint32 IfxGtm_Atom_Timer_getPeriod(IfxGtm_Atom_Timer *driver);

/** \brief Returns the resolution
 * \see IfxStdIf_Timer_GetResolution
 * \param driver ATOM Timer interface Handle
 * \return Resolution
 */
IFX_INLINE float32 IfxGtm_Atom_Timer_getResolution(IfxGtm_Atom_Timer *driver);

/** \brief Returns the trigger point
 * \param driver ATOM Timer interface Handle
 * \return Trigger point
 */
IFX_INLINE uint32 IfxGtm_Atom_Timer_getTrigger(IfxGtm_Atom_Timer *driver);

/** \brief Sets the frequency
 * \see IfxStdIf_Timer_SetFrequency
 * \param driver ATOM Timer interface Handle
 * \param frequency Frequency
 * \return TRUE on success else FALSE
 */
IFX_INLINE boolean IfxGtm_Atom_Timer_setFrequency(IfxGtm_Atom_Timer *driver, float32 frequency);

/** \brief Sets the period for the timer
 * \see IfxStdIf_Timer_SetPeriod
 * \param driver ATOM Timer interface Handle
 * \param period Period value
 * \return TRUE on success else FALSE
 */
IFX_INLINE boolean IfxGtm_Atom_Timer_setPeriod(IfxGtm_Atom_Timer *driver, uint32 period);

/** \brief Sets the single shot mode of the timer
 * \see IfxStdIf_Timer_SetSingleMode
 * \param driver ATOM Timer interface Handle
 * \param enabled If TRUE, sets the single shot mode
 * \return None
 */
IFX_INLINE void IfxGtm_Atom_Timer_setSingleMode(IfxGtm_Atom_Timer *driver, boolean enabled);

/** \brief Sets the trigger
 * \see IfxStdIf_Timer_SetTrigger
 * \param driver ATOM Timer interface Handle
 * \param triggerPoint Trigger point value
 * \return None
 */
IFX_INLINE void IfxGtm_Atom_Timer_setTrigger(IfxGtm_Atom_Timer *driver, uint32 triggerPoint);

/** \brief Updates the input frequency
 * \see IfxStdIf_Timer_UpdateInputFrequency
 * \param driver ATOM Timer interface Handle
 * \return None
 */
IFX_INLINE void IfxGtm_Atom_Timer_updateInputFrequency(IfxGtm_Atom_Timer *driver);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Returns the timer event
 * \see IfxStdIf_Timer_AckTimerIrq
 * \param driver ATOM Timer interface Handle
 * \return Timer event
 */
IFX_EXTERN boolean IfxGtm_Atom_Timer_acknowledgeTimerIrq(IfxGtm_Atom_Timer *driver);

/** \brief Returns the trigger event
 * \see IfxStdIf_Timer_AckTriggerIrq
 * \param driver ATOM Timer interface Handle
 * \return Trigger event
 */
IFX_EXTERN boolean IfxGtm_Atom_Timer_acknowledgeTriggerIrq(IfxGtm_Atom_Timer *driver);

/** \brief Runs the timer
 * \see IfxStdIf_Timer_Run
 * \param driver ATOM Timer interface Handle
 * \return None
 */
IFX_EXTERN void IfxGtm_Atom_Timer_run(IfxGtm_Atom_Timer *driver);

/** \brief Stops the timer
 * \see IfxStdIf_Timer_Stop
 * \param driver ATOM Timer interface Handle
 * \return None
 */
IFX_EXTERN void IfxGtm_Atom_Timer_stop(IfxGtm_Atom_Timer *driver);

/** \} */

/** \addtogroup IfxLld_Gtm_Atom_Timer_Timer_Functions
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Returns the initial timer offset in ticks
 * \see IfxStdIf_Timer_GetOffset
 * \param driver ATOM Timer interface Handle
 * \return Returns the initial timer offset in ticks
 */
IFX_INLINE uint32 IfxGtm_Atom_Timer_getOffset(IfxGtm_Atom_Timer *driver);

/** \brief Returns the pointer to timer channel
 * \param driver ATOM Timer interface Handle
 * \return Pointer
 */
IFX_INLINE volatile uint32 *IfxGtm_Atom_Timer_getPointer(IfxGtm_Atom_Timer *driver);

/** \brief Returns the pointer to trigger channel
 * \param driver ATOM Timer interface Handle
 * \return Pointer
 */
IFX_INLINE volatile uint32 *IfxGtm_Atom_Timer_getTriggerPointer(IfxGtm_Atom_Timer *driver);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief initializes the timer object
 * \param driver ATOM Timer interface Handle
 * \param config Configuration structure for ATOM Timer
 * \return TRUE on success else FALSE
 */
IFX_EXTERN boolean IfxGtm_Atom_Timer_init(IfxGtm_Atom_Timer *driver, const IfxGtm_Atom_Timer_Config *config);

/** \brief Initializes the configuration structure to default
 * \param config Configuration structure for ATOM Timer
 * \param gtm Pointer to GTM module
 * \return None
 */
IFX_EXTERN void IfxGtm_Atom_Timer_initConfig(IfxGtm_Atom_Timer_Config *config, Ifx_GTM *gtm);

/** \} */

/******************************************************************************/
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE void IfxGtm_Atom_Timer_addToChannelMask(IfxGtm_Atom_Timer *driver, IfxGtm_Atom_Ch channel)
{
    driver->channelsMask    |= (uint16)((uint16)1u << (uint8)channel);
    driver->agcDisableUpdate = IfxGtm_Atom_Agc_buildFeature(0, driver->channelsMask, IFX_GTM_CLS_ATOM_AGC_GLB_CTRL_UPEN_CTRL0_OFF);
    driver->agcApplyUpdate   = IfxGtm_Atom_Agc_buildFeature(driver->channelsMask, 0, IFX_GTM_CLS_ATOM_AGC_GLB_CTRL_UPEN_CTRL0_OFF);
}


IFX_INLINE void IfxGtm_Atom_Timer_applyUpdate(IfxGtm_Atom_Timer *driver)
{
    IfxGtm_Atom_Agc_setChannelsUpdate(driver->agc, driver->agcApplyUpdate);
}


IFX_INLINE void IfxGtm_Atom_Timer_disableUpdate(IfxGtm_Atom_Timer *driver)
{
    IfxGtm_Atom_Agc_setChannelsUpdate(driver->agc, driver->agcDisableUpdate);
}


IFX_INLINE float32 IfxGtm_Atom_Timer_getFrequency(IfxGtm_Atom_Timer *driver)
{
    float32 tickTOS = IfxGtm_tickToS(driver->clockFreq, driver->period);
    return (float32)1.0f / tickTOS;
}


IFX_INLINE float32 IfxGtm_Atom_Timer_getInputFrequency(IfxGtm_Atom_Timer *driver)
{
    return driver->clockFreq;
}


IFX_INLINE uint32 IfxGtm_Atom_Timer_getOffset(IfxGtm_Atom_Timer *driver)
{
    return driver->offset;
}


IFX_INLINE uint32 IfxGtm_Atom_Timer_getPeriod(IfxGtm_Atom_Timer *driver)
{
    return driver->period;
}


IFX_INLINE volatile uint32 *IfxGtm_Atom_Timer_getPointer(IfxGtm_Atom_Timer *driver)
{
    return IfxGtm_Atom_Ch_getTimerPointer(driver->atom, driver->timerChannel);
}


IFX_INLINE float32 IfxGtm_Atom_Timer_getResolution(IfxGtm_Atom_Timer *driver)
{
    return (float32)1.0f / driver->clockFreq;
}


IFX_INLINE uint32 IfxGtm_Atom_Timer_getTrigger(IfxGtm_Atom_Timer *driver)
{
    return IfxGtm_Atom_Ch_getCompareOne(driver->atom, driver->triggerChannel) - 1;
}


IFX_INLINE volatile uint32 *IfxGtm_Atom_Timer_getTriggerPointer(IfxGtm_Atom_Timer *driver)
{
    return IfxGtm_Atom_Ch_getCompareOnePointer(driver->atom, driver->triggerChannel);
}


IFX_INLINE boolean IfxGtm_Atom_Timer_setFrequency(IfxGtm_Atom_Timer *driver, float32 frequency)
{
    uint32 period = IfxGtm_sToTick(driver->clockFreq, (float32)1.0f / frequency);

    return IfxGtm_Atom_Timer_setPeriod(driver, period);
}


IFX_INLINE boolean IfxGtm_Atom_Timer_setPeriod(IfxGtm_Atom_Timer *driver, uint32 period)
{
    driver->period = period;
    IfxGtm_Atom_Ch_setCompareZeroShadow(driver->atom, driver->timerChannel, period);

    if (driver->triggerChannel != driver->timerChannel)
    {
        IfxGtm_Atom_Ch_setCompareZeroShadow(driver->atom, driver->triggerChannel, period);
    }

    return TRUE;
}


IFX_INLINE void IfxGtm_Atom_Timer_setSingleMode(IfxGtm_Atom_Timer *driver, boolean enabled)
{
    IfxGtm_Atom_Ch_setOneShotMode(driver->atom, driver->timerChannel, enabled);
}


IFX_INLINE void IfxGtm_Atom_Timer_setTrigger(IfxGtm_Atom_Timer *driver, uint32 triggerPoint)
{
    IfxGtm_Atom_Ch_setCompareOneShadow(driver->atom, driver->triggerChannel, triggerPoint + 1);
}


IFX_INLINE void IfxGtm_Atom_Timer_updateInputFrequency(IfxGtm_Atom_Timer *driver)
{
    driver->clockFreq = IfxGtm_Atom_Ch_getClockFrequency(driver->gtm, driver->atom, driver->timerChannel);
}


#endif /* IFXGTM_ATOM_TIMER_H */
