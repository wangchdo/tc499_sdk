/**
 * \file IfxGtm_Dtm.h
 * \brief GTM  basic functionality
 * \ingroup IfxLld_Gtm
 *
 * \version iLLD_2_0_1_2_19
 * \copyright Copyright (c) 2023 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 * \defgroup IfxLld_Gtm_Std_Dtm Dtm Basic Functionality
 * \ingroup IfxLld_Gtm_Std
 * \defgroup IfxLld_Gtm_Std_Dtm_Enumerations DTM Enumerations
 * \ingroup IfxLld_Gtm_Std_Dtm
 * \defgroup IfxLld_Gtm_Std_Dtm_Functions DTM Functions
 * \ingroup IfxLld_Gtm_Std_Dtm
 */

#ifndef IFXGTM_DTM_H
#define IFXGTM_DTM_H 1

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "_Impl/IfxGtm_cfg.h"
#include "Cpu/Std/IfxCpu_Intrinsics.h"
#include "IfxGtm_bf.h"

/******************************************************************************/
/*--------------------------------Enumerations--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Gtm_Std_Dtm_Enumerations
 * \{ */
/** \brief Enumeration for CLSi_CDTM_DTMd_CH_CTRL2.OCx_y and CLSi_CDTM_DTMd_CH_CTRL2_SR.OCx_y_SR
 * This is used for controlling the output of DTM channel
 */
typedef enum
{
    IfxGtm_Dtm_ChannelControl_functionalOutput = 0,  /**< \brief Functional output generated by DTM (E.g. normal DTM output) */
    IfxGtm_Dtm_ChannelControl_constantOutput         /**< \brief Constant output defined by CLSi_CDTM_DTMd_CH_CTRL2.SLx_y */
} IfxGtm_Dtm_ChannelControl;

/** \brief Clock source for DTM object\n
 * Definition in IfxGTM.DTM[i].CTRL.B.CLKSEL ( i = 0 to 35)
 */
typedef enum
{
    IfxGtm_Dtm_ClockSource_systemClock,  /**< \brief SYS_CLK as clock source */
    IfxGtm_Dtm_ClockSource_cmuClock0,    /**< \brief CMU_CLK0 as clock source */
    IfxGtm_Dtm_ClockSource_cmuClock1,    /**< \brief CMU_CLK1 (if DTM is connected to ATOM) or CMU_FXCLK0 (if DTM is connected to TOM) as clock source */
    IfxGtm_Dtm_ClockSource_cmuClock2     /**< \brief CMU_CLK2 (if DTM is connected to ATOM) or CMU_FXCLK1 (if DTM is connected to TOM) as clock source */
} IfxGtm_Dtm_ClockSource;

/** \brief Dead Time Path on output x of channel y\n
 * Definition in IfxGTM.DTM[i].CH.CTRL2.B.DTxy ( i = 0 to 35; x = 0 , 1; and y = 0 to 4)
 */
typedef enum
{
    IfxGtm_Dtm_DeadTimePath_feedThrough,  /**< \brief Feed through from DTM input to output (DTM[i]_INx to DTM[i]_OUTx (i = 0 to 35 and x = 0 to 4) */
    IfxGtm_Dtm_DeadTimePath_enable        /**< \brief Dead Time Path enabled */
} IfxGtm_Dtm_DeadTimePath;

/** \brief Output x function of channel y \n
 * Definition in IfxGTM.DTM[i].CH.CTRL1.B.O1Fx ( i = 0 to 35 and x = 0 to 3)
 */
typedef enum
{
    IfxGtm_Dtm_Output1Function_signalEdgeTrigger,            /**< \brief Signal Edge Trigger */
    IfxGtm_Dtm_Output1Function_xorOfDtmInputandShiftSignal,  /**< \brief XOR Of Dtm Input and Shift Signal */
    IfxGtm_Dtm_Output1Function_andOfDtmInputandShiftSignal,  /**< \brief AND Of Dtm Input and Shift Signal */
    IfxGtm_Dtm_Output1Function_dtmInputSignal                /**< \brief DTM Input Signal DTM[i]_INx_T (i = 0 to 35 and x = 0 to 3) */
} IfxGtm_Dtm_Output1Function;

/** \brief Output 1 selection of channel x (x = 0 to 3)\n
 * Definition in IfxGTM.DTM[i].CH.CTRL1.B.O1SELx ( i = 0 to 35 and x = 0 to 3)
 */
typedef enum
{
    IfxGtm_Dtm_Output1Select_inverseDeadTime,  /**< \brief Inverse Dead Time */
    IfxGtm_Dtm_Output1Select_specialFunction   /**< \brief Special Function as selected by O1Fx (x = 0 to 3) */
} IfxGtm_Dtm_Output1Select;

/** \brief Polarity on output
 */
typedef enum
{
    IfxGtm_Dtm_OutputPolarity_notInverted = 0,  /**< \brief Output signal not inverted */
    IfxGtm_Dtm_OutputPolarity_inverted          /**< \brief Output signal inverted */
} IfxGtm_Dtm_OutputPolarity;

/** \brief Select input signal to be used as shut off signal
 */
typedef enum
{
    IfxGtm_Dtm_ShutoffInput_timChIn0 = 0,       /**< \brief TIM_CH_IN0 */
    IfxGtm_Dtm_ShutoffInput_timChIn1,           /**< \brief TIM_CH_IN1 */
    IfxGtm_Dtm_ShutoffInput_previousDtmAuxIn0,  /**< \brief DTM[d-1]_AUX_IN0 */
    IfxGtm_Dtm_ShutoffInput_previousDtmAuxIn1,  /**< \brief DTM[d-1]_AUX_IN1 */
    IfxGtm_Dtm_ShutoffInput_dtmAuxIn0,          /**< \brief DTM[d]_AUX_IN0 */
    IfxGtm_Dtm_ShutoffInput_dtmAuxIn1           /**< \brief DTM[d]_AUX_IN1 */
} IfxGtm_Dtm_ShutoffInput;

/** \brief Select Signal level
 */
typedef enum
{
    IfxGtm_Dtm_SignalLevel_low  = 0,
    IfxGtm_Dtm_SignalLevel_high = 1
} IfxGtm_Dtm_SignalLevel;

/** \} */

/** \addtogroup IfxLld_Gtm_Std_Dtm_Functions
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief returns the base address of selected DTM instance
 * \param gtm pointer to GTM register base
 * \param cdtmIndex CDTM index
 * \param dtmIndex DTM index
 * \return Base address of DTM
 */
IFX_INLINE Ifx_GTM_CLS_CDTM_DTM *IfxGtm_Dtm_getDtmPointer(Ifx_GTM *gtm, IfxGtm_Cdtm cdtmIndex, IfxGtm_Dtm dtmIndex);

/** \brief Sets the clock source for DTM object
 * \param dtm Pointer to the DTM object
 * \param clockSource Clock source for DTM object
 * \return None
 */
IFX_INLINE void IfxGtm_Dtm_setClockSource(Ifx_GTM_CLS_CDTM_DTM *dtm, IfxGtm_Dtm_ClockSource clockSource);

/** \brief Sets the Output 0 Dead Time Path for DTM channel
 * \param dtm Pointer to the DTM object
 * \param channel Channel index
 * \param deadTimePath Dead Time Path for Dtm chhannel output
 * \return None
 */
IFX_INLINE void IfxGtm_Dtm_setOutput0DeadTimePath(Ifx_GTM_CLS_CDTM_DTM *dtm, IfxGtm_Dtm_Ch channel, IfxGtm_Dtm_DeadTimePath deadTimePath);

/** \brief Sets the Output 1 Dead Time Path for DTM channel
 * \param dtm Pointer to the DTM object
 * \param channel Channel index
 * \param deadTimePath Dead Time Path for Dtm chhannel output
 * \return None
 */
IFX_INLINE void IfxGtm_Dtm_setOutput1DeadTimePath(Ifx_GTM_CLS_CDTM_DTM *dtm, IfxGtm_Dtm_Ch channel, IfxGtm_Dtm_DeadTimePath deadTimePath);

/** \brief Sets the Output Function for DTM channel
 * \param dtm Pointer to the DTM object
 * \param channel Channel index
 * \param output1Function Output 1 function
 * \return None
 */
IFX_INLINE void IfxGtm_Dtm_setOutput1Function(Ifx_GTM_CLS_CDTM_DTM *dtm, IfxGtm_Dtm_Ch channel, IfxGtm_Dtm_Output1Function output1Function);

/** \brief Sets the Output Selection for DTM channel
 * \param dtm Pointer to the DTM object
 * \param channel Channel index
 * \param output1Select Output 1 selection
 * \return None
 */
IFX_INLINE void IfxGtm_Dtm_setOutput1Select(Ifx_GTM_CLS_CDTM_DTM *dtm, IfxGtm_Dtm_Ch channel, IfxGtm_Dtm_Output1Select output1Select);

/** \brief Sets the relative rise time
 * \param dtm Pointer to the DTM object
 * \param channel DTM Channel
 * \param relrise Relative rise value in ticks
 * \return None
 */
IFX_INLINE void IfxGtm_Dtm_setRelrise(Ifx_GTM_CLS_CDTM_DTM *dtm, IfxGtm_Dtm_Ch channel, uint16 relrise);

/** \brief Sets the relative fall time
 * \param dtm Pointer to the DTM object
 * \param channel DTM Channel
 * \param relfall Relative fall value in ticks
 * \return None
 */
IFX_INLINE void IfxGtm_Dtm_setRelfall(Ifx_GTM_CLS_CDTM_DTM *dtm, IfxGtm_Dtm_Ch channel, uint16 relfall);

/** \brief Set signal polarity at output 1
 * \param dtm Pointer to the DTM object
 * \param channel DTM Channel
 * \param polarity Polarity on Output 1 Channel x
 * \return None
 */
IFX_INLINE void IfxGtm_Dtm_setOutput1Polarity(Ifx_GTM_CLS_CDTM_DTM *dtm, IfxGtm_Dtm_Ch channel, IfxGtm_Dtm_OutputPolarity polarity);

/** \brief Enable individual channel fast shutoff
 * \param dtm Pointer to the DTM object
 * \return None
 */
IFX_INLINE void IfxGtm_Dtm_enableIndividualShutoff(Ifx_GTM_CLS_CDTM_DTM *dtm);

/** \brief Set shutoff input source for the channel
 * \param dtm Pointer to the DTM object
 * \param channel DTM Channel
 * \param input Input source
 * \return None
 */
IFX_INLINE void IfxGtm_Dtm_setShutoffInput(Ifx_GTM_CLS_CDTM_DTM *dtm, IfxGtm_Dtm_Ch channel, IfxGtm_Dtm_ShutoffInput input);

/** \brief Invert shutoff signal for the channel
 * \param dtm Pointer to the DTM object
 * \param channel DTM Channel
 * \param enabled TRUE: invert the signal
 * \return None
 */
IFX_INLINE void IfxGtm_Dtm_setShutoffInputInverter(Ifx_GTM_CLS_CDTM_DTM *dtm, IfxGtm_Dtm_Ch channel, boolean enabled);

/** \brief Set shutoff update mode
 * \param dtm Pointer to the DTM object
 * \param channel DTM Channel
 * \param mode Shutoff mode
 * \return None
 */
IFX_INLINE void IfxGtm_Dtm_setShutoffUpdateMode(Ifx_GTM_CLS_CDTM_DTM *dtm, IfxGtm_Dtm_Ch channel, uint8 mode);

/** \brief Reset the shutoff signal so as to resume normal DTM output
 * Writing to this register clears internal signal SHUTOFF_SYNC_0
 * \param dtm Pointer to the DTM object
 * \param channel DTM Channel
 * \return None
 */
IFX_INLINE void IfxGtm_Dtm_resetShutoffSignal(Ifx_GTM_CLS_CDTM_DTM *dtm, IfxGtm_Dtm_Ch channel);

/** \brief Set output 0 shadow signal level for the channel
 * \param dtm Pointer to the DTM object
 * \param channel DTM Channel
 * \param level signal level
 * \return None
 */
IFX_INLINE void IfxGtm_Dtm_setOutput0ShadowSignalLevel(Ifx_GTM_CLS_CDTM_DTM *dtm, IfxGtm_Dtm_Ch channel, IfxGtm_Dtm_SignalLevel level);

/** \brief Set output 1 shadow signal level for the channel
 * \param dtm Pointer to the DTM object
 * \param channel DTM Channel
 * \param level signal level
 * \return None
 */
IFX_INLINE void IfxGtm_Dtm_setOutput1ShadowSignalLevel(Ifx_GTM_CLS_CDTM_DTM *dtm, IfxGtm_Dtm_Ch channel, IfxGtm_Dtm_SignalLevel level);

/** \brief Set output 0 shadow channel control for the DTM channel
 * \param dtm Pointer to the DTM object
 * \param channel DTM Channel
 * \param control Channel control
 * \return None
 */
IFX_INLINE void IfxGtm_Dtm_setOutput0ShadowChannelControl(Ifx_GTM_CLS_CDTM_DTM *dtm, IfxGtm_Dtm_Ch channel, IfxGtm_Dtm_ChannelControl control);

/** \brief Set output 1 shadow channel control for the DTM channel
 * \param dtm Pointer to the DTM object
 * \param channel DTM Channel
 * \param control Channel control
 * \return None
 */
IFX_INLINE void IfxGtm_Dtm_setOutput1ShadowChannelControl(Ifx_GTM_CLS_CDTM_DTM *dtm, IfxGtm_Dtm_Ch channel, IfxGtm_Dtm_ChannelControl control);

/** \} */

/******************************************************************************/
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE Ifx_GTM_CLS_CDTM_DTM *IfxGtm_Dtm_getDtmPointer(Ifx_GTM *gtm, IfxGtm_Cdtm cdtmIndex, IfxGtm_Dtm dtmIndex)
{
    Ifx_GTM_CLS_CDTM_DTM *dtmSFR;

    if (cdtmIndex > IfxGtm_Cdtm_none)
    {
        dtmSFR = &(gtm->CLS[cdtmIndex].CDTM.DTM[dtmIndex]);
    }
    else
    {
        dtmSFR = NULL_PTR;
    }

    return dtmSFR;
}


IFX_INLINE void IfxGtm_Dtm_setClockSource(Ifx_GTM_CLS_CDTM_DTM *dtm, IfxGtm_Dtm_ClockSource clockSource)
{
    dtm->CTRL.B.CLK_SEL = (uint8)clockSource;
}


IFX_INLINE void IfxGtm_Dtm_setOutput0DeadTimePath(Ifx_GTM_CLS_CDTM_DTM *dtm, IfxGtm_Dtm_Ch channel, IfxGtm_Dtm_DeadTimePath deadTimePath)
{
    uint32 shift = (8u * (uint32)channel) + 3u;
    uint32 mask  = (uint32)1U << shift;

    dtm->CH_CTRL2.U = (dtm->CH_CTRL2.U & ~mask) | ((uint32)deadTimePath << shift);
}


IFX_INLINE void IfxGtm_Dtm_setOutput1DeadTimePath(Ifx_GTM_CLS_CDTM_DTM *dtm, IfxGtm_Dtm_Ch channel, IfxGtm_Dtm_DeadTimePath deadTimePath)
{
    uint32 shift = (8u * (uint32)channel) + 7u;
    uint32 mask  = (uint32)1U << shift;

    dtm->CH_CTRL2.U = (dtm->CH_CTRL2.U & ~mask) | ((uint32)deadTimePath << shift);
}


IFX_INLINE void IfxGtm_Dtm_setOutput1Function(Ifx_GTM_CLS_CDTM_DTM *dtm, IfxGtm_Dtm_Ch channel, IfxGtm_Dtm_Output1Function output1Function)
{
    uint32 shift = (8u * (uint32)channel) + 4u;
    uint32 mask  = (uint32)3U << shift;

    dtm->CH_CTRL1.U = (dtm->CH_CTRL1.U & ~mask) | ((uint32)output1Function << shift);
}


IFX_INLINE void IfxGtm_Dtm_setOutput1Select(Ifx_GTM_CLS_CDTM_DTM *dtm, IfxGtm_Dtm_Ch channel, IfxGtm_Dtm_Output1Select output1Select)
{
    uint32 shift = 8u * (uint32)channel;
    uint32 mask  = (uint32)1U << shift;

    dtm->CH_CTRL1.U = (dtm->CH_CTRL1.U & ~mask) | ((uint32)output1Select << shift);
}


IFX_INLINE void IfxGtm_Dtm_setRelrise(Ifx_GTM_CLS_CDTM_DTM *dtm, IfxGtm_Dtm_Ch channel, uint16 relrise)
{
    dtm->CH_DTV[channel].B.RELRISE = relrise;
}


IFX_INLINE void IfxGtm_Dtm_setRelfall(Ifx_GTM_CLS_CDTM_DTM *dtm, IfxGtm_Dtm_Ch channel, uint16 relfall)
{
    dtm->CH_DTV[channel].B.RELFALL = relfall;
}


IFX_INLINE void IfxGtm_Dtm_setOutput1Polarity(Ifx_GTM_CLS_CDTM_DTM *dtm, IfxGtm_Dtm_Ch channel, IfxGtm_Dtm_OutputPolarity polarity)
{
    uint32 shift = ((uint32)channel << 3u) + IFX_GTM_CLS_CDTM_DTM_CH_CTRL2_POL1_0_OFF;
    uint32 mask  = (uint32)IFX_GTM_CLS_CDTM_DTM_CH_CTRL2_POL1_0_MSK << shift;
    uint32 value = (uint32)polarity << shift;

    Ifx__ldmst(&(dtm->CH_CTRL2), mask, value);
}


IFX_INLINE void IfxGtm_Dtm_enableIndividualShutoff(Ifx_GTM_CLS_CDTM_DTM *dtm)
{
    dtm->CTRL.B.CH_SHUTOFF_EN = 1u;
}


IFX_INLINE void IfxGtm_Dtm_setShutoffInput(Ifx_GTM_CLS_CDTM_DTM *dtm, IfxGtm_Dtm_Ch channel, IfxGtm_Dtm_ShutoffInput input)
{
    Ifx_GTM_CLS_CDTM_DTM_CTRL2 ctrl2Reg;
    uint32                     mask, shift, value;

    /* Read register */
    ctrl2Reg.U = dtm->CTRL2.U;

    /* The bitfield we want to modify is write protected by WR_EN_x. Change bit to 1 */
    shift       = ((uint32)channel << 3u) + IFX_GTM_CLS_CDTM_DTM_CTRL2_WR_EN_0_OFF;
    ctrl2Reg.U |= (uint32)IFX_GTM_CLS_CDTM_DTM_CTRL2_WR_EN_0_MSK << shift;

    /* Calculate value of bitfield */
    shift       = ((uint32)channel << 3u) + IFX_GTM_CLS_CDTM_DTM_CTRL2_SHUTOFF_SEL_0_OFF;
    mask        = (uint32)IFX_GTM_CLS_CDTM_DTM_CTRL2_SHUTOFF_SEL_0_MSK << shift;
    value       = (uint32)input << shift;

    ctrl2Reg.U |= (ctrl2Reg.U & mask) | value;

    /* Write back to register */
    dtm->CTRL2.U = ctrl2Reg.U;
}


IFX_INLINE void IfxGtm_Dtm_setShutoffInputInverter(Ifx_GTM_CLS_CDTM_DTM *dtm, IfxGtm_Dtm_Ch channel, boolean enabled)
{
    Ifx_GTM_CLS_CDTM_DTM_CTRL2 ctrl2Reg;
    uint32                     mask, shift, value;

    /* Read register */
    ctrl2Reg.U = dtm->CTRL2.U;

    /* The bitfield we want to modify is write protected by WR_EN_x. Change bit to 1 */
    shift       = ((uint32)channel << 3u) + IFX_GTM_CLS_CDTM_DTM_CTRL2_WR_EN_0_OFF;
    ctrl2Reg.U |= (uint32)IFX_GTM_CLS_CDTM_DTM_CTRL2_WR_EN_0_MSK << shift;

    /* Calculate value of bitfield */
    shift       = ((uint32)channel << 3u) + IFX_GTM_CLS_CDTM_DTM_CTRL2_SHUTOFF_POL_0_OFF;
    mask        = (uint32)IFX_GTM_CLS_CDTM_DTM_CTRL2_SHUTOFF_POL_0_MSK << shift;
    value       = (uint32)enabled << shift;

    ctrl2Reg.U |= (ctrl2Reg.U & mask) | value;

    /* Write back to register */
    dtm->CTRL2.U = ctrl2Reg.U;
}


IFX_INLINE void IfxGtm_Dtm_setShutoffUpdateMode(Ifx_GTM_CLS_CDTM_DTM *dtm, IfxGtm_Dtm_Ch channel, uint8 mode)
{
    Ifx_GTM_CLS_CDTM_DTM_CTRL2 ctrl2Reg;
    uint32                     mask, shift, value;

    /* Read register */
    ctrl2Reg.U = dtm->CTRL2.U;

    /* The bitfield we want to modify is write protected by WR_EN_x. Change bit to 1 */
    shift       = ((uint32)channel << 3u) + IFX_GTM_CLS_CDTM_DTM_CTRL2_WR_EN_0_OFF;
    ctrl2Reg.U |= (uint32)IFX_GTM_CLS_CDTM_DTM_CTRL2_WR_EN_0_MSK << shift;

    /* Calculate value of bitfield */
    shift       = ((uint32)channel << 3u) + IFX_GTM_CLS_CDTM_DTM_CTRL2_UPD_MODE_0_OFF;
    mask        = (uint32)IFX_GTM_CLS_CDTM_DTM_CTRL2_UPD_MODE_0_MSK << shift;
    value       = (uint32)mode << shift;

    ctrl2Reg.U |= (ctrl2Reg.U & mask) | value;

    /* Write back to register */
    dtm->CTRL2.U = ctrl2Reg.U;
}


IFX_INLINE void IfxGtm_Dtm_resetShutoffSignal(Ifx_GTM_CLS_CDTM_DTM *dtm, IfxGtm_Dtm_Ch channel)
{
    Ifx_GTM_CLS_CDTM_DTM_CTRL2 ctrl2Reg;
    uint32                     mask, shift, value;

    /* Read register */
    ctrl2Reg.U = dtm->CTRL2.U;

    /* The bitfield we want to modify is write protected by WR_EN_x. Change bit to 1 */
    shift       = ((uint32)channel << 3u) + IFX_GTM_CLS_CDTM_DTM_CTRL2_WR_EN_0_OFF;
    ctrl2Reg.U |= (uint32)IFX_GTM_CLS_CDTM_DTM_CTRL2_WR_EN_0_MSK << shift;

    /* Calculate value of bitfield */
    shift       = ((uint32)channel << 3u) + IFX_GTM_CLS_CDTM_DTM_CTRL2_SHUT_OFF_RST_0_OFF;
    mask        = (uint32)IFX_GTM_CLS_CDTM_DTM_CTRL2_SHUT_OFF_RST_0_MSK << shift;
    value       = (uint32)1u << shift;

    ctrl2Reg.U |= (ctrl2Reg.U & mask) | value;

    /* Write back to register */
    dtm->CTRL2.U = ctrl2Reg.U;
}


IFX_INLINE void IfxGtm_Dtm_setOutput0ShadowSignalLevel(Ifx_GTM_CLS_CDTM_DTM *dtm, IfxGtm_Dtm_Ch channel, IfxGtm_Dtm_SignalLevel level)
{
    uint32 shift = ((uint32)channel << 3u) + IFX_GTM_CLS_CDTM_DTM_CH_CTRL2_SR_SL0_0_SR_OFF;
    uint32 mask  = (uint32)IFX_GTM_CLS_CDTM_DTM_CH_CTRL2_SR_SL0_0_SR_MSK << shift;
    uint32 value = (uint32)level << shift;

    Ifx__ldmst(&(dtm->CH_CTRL2_SR), mask, value);
}


IFX_INLINE void IfxGtm_Dtm_setOutput1ShadowSignalLevel(Ifx_GTM_CLS_CDTM_DTM *dtm, IfxGtm_Dtm_Ch channel, IfxGtm_Dtm_SignalLevel level)
{
    uint32 shift = ((uint32)channel << 3u) + IFX_GTM_CLS_CDTM_DTM_CH_CTRL2_SR_SL1_0_SR_OFF;
    uint32 mask  = (uint32)IFX_GTM_CLS_CDTM_DTM_CH_CTRL2_SR_SL1_0_SR_MSK << shift;
    uint32 value = (uint32)level << shift;

    Ifx__ldmst(&(dtm->CH_CTRL2_SR), mask, value);
}


IFX_INLINE void IfxGtm_Dtm_setOutput0ShadowChannelControl(Ifx_GTM_CLS_CDTM_DTM *dtm, IfxGtm_Dtm_Ch channel, IfxGtm_Dtm_ChannelControl control)
{
    uint32 shift = ((uint32)channel << 3u) + IFX_GTM_CLS_CDTM_DTM_CH_CTRL2_SR_OC0_0_SR_OFF;
    uint32 mask  = (uint32)IFX_GTM_CLS_CDTM_DTM_CH_CTRL2_SR_OC0_0_SR_MSK << shift;
    uint32 value = (uint32)control << shift;

    Ifx__ldmst(&(dtm->CH_CTRL2_SR), mask, value);
}


IFX_INLINE void IfxGtm_Dtm_setOutput1ShadowChannelControl(Ifx_GTM_CLS_CDTM_DTM *dtm, IfxGtm_Dtm_Ch channel, IfxGtm_Dtm_ChannelControl control)
{
    uint32 shift = ((uint32)channel << 3u) + IFX_GTM_CLS_CDTM_DTM_CH_CTRL2_SR_OC1_0_SR_OFF;
    uint32 mask  = (uint32)IFX_GTM_CLS_CDTM_DTM_CH_CTRL2_SR_OC1_0_SR_MSK << shift;
    uint32 value = (uint32)control << shift;

    Ifx__ldmst(&(dtm->CH_CTRL2_SR), mask, value);
}


#endif /* IFXGTM_DTM_H */
